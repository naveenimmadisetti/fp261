
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 ff ee    	cmp    $0xeeffe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 03 09 00 00       	call   800934 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <_ZL10put_bufferPv>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
	buse[i] = 0;
  80004b:	c6 80 60 90 81 00 00 	movb   $0x0,0x819060(%eax)
}
  800052:	5d                   	pop    %ebp
  800053:	c3                   	ret    

00800054 <_ZL12serve_threadj>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  800054:	55                   	push   %ebp
  800055:	89 e5                	mov    %esp,%ebp
  800057:	81 ec 98 00 00 00    	sub    $0x98,%esp
  80005d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  800060:	89 75 f8             	mov    %esi,-0x8(%ebp)
  800063:	89 7d fc             	mov    %edi,-0x4(%ebp)
  800066:	8b 5d 08             	mov    0x8(%ebp),%ebx
	struct st_args *args = (struct st_args *)a;
	union Nsipc *req = args->req;
  800069:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;
   
	switch (args->reqno) {
  80006c:	83 3b 0a             	cmpl   $0xa,(%ebx)
  80006f:	0f 87 34 01 00 00    	ja     8001a9 <_ZL12serve_threadj+0x155>
  800075:	8b 03                	mov    (%ebx),%eax
  800077:	ff 24 85 60 44 81 00 	jmp    *0x814460(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
				&ret.ret_addrlen);
  80007e:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800081:	89 44 24 08          	mov    %eax,0x8(%esp)
  800085:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800088:	89 44 24 04          	mov    %eax,0x4(%esp)
  80008c:	8b 06                	mov    (%esi),%eax
  80008e:	89 04 24             	mov    %eax,(%esp)
  800091:	e8 fc 52 00 00       	call   805392 <lwip_accept>
  800096:	89 c7                	mov    %eax,%edi
		memmove(req, &ret, sizeof ret);
  800098:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80009f:	00 
  8000a0:	8d 45 84             	lea    -0x7c(%ebp),%eax
  8000a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000a7:	89 34 24             	mov    %esi,(%esp)
  8000aa:	e8 dd 11 00 00       	call   80128c <memmove>
		break;
  8000af:	e9 13 01 00 00       	jmp    8001c7 <_ZL12serve_threadj+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
			      req->bind.req_namelen);
  8000b4:	8b 46 14             	mov    0x14(%esi),%eax
  8000b7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8000bb:	8d 46 04             	lea    0x4(%esi),%eax
  8000be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000c2:	8b 06                	mov    (%esi),%eax
  8000c4:	89 04 24             	mov    %eax,(%esp)
  8000c7:	e8 71 54 00 00       	call   80553d <lwip_bind>
  8000cc:	89 c7                	mov    %eax,%edi
		break;
  8000ce:	e9 f4 00 00 00       	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  8000d3:	8b 46 04             	mov    0x4(%esi),%eax
  8000d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8000da:	8b 06                	mov    (%esi),%eax
  8000dc:	89 04 24             	mov    %eax,(%esp)
  8000df:	e8 53 60 00 00       	call   806137 <lwip_shutdown>
  8000e4:	89 c7                	mov    %eax,%edi
		break;
  8000e6:	e9 dc 00 00 00       	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  8000eb:	8b 06                	mov    (%esi),%eax
  8000ed:	89 04 24             	mov    %eax,(%esp)
  8000f0:	e8 05 55 00 00       	call   8055fa <lwip_close>
  8000f5:	89 c7                	mov    %eax,%edi
		break;
  8000f7:	e9 cb 00 00 00       	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
				 req->connect.req_namelen);
  8000fc:	8b 46 14             	mov    0x14(%esi),%eax
  8000ff:	89 44 24 08          	mov    %eax,0x8(%esp)
  800103:	8d 46 04             	lea    0x4(%esi),%eax
  800106:	89 44 24 04          	mov    %eax,0x4(%esp)
  80010a:	8b 06                	mov    (%esi),%eax
  80010c:	89 04 24             	mov    %eax,(%esp)
  80010f:	e8 62 55 00 00       	call   805676 <lwip_connect>
  800114:	89 c7                	mov    %eax,%edi
		break;
  800116:	e9 ac 00 00 00       	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  80011b:	8b 46 04             	mov    0x4(%esi),%eax
  80011e:	89 44 24 04          	mov    %eax,0x4(%esp)
  800122:	8b 06                	mov    (%esi),%eax
  800124:	89 04 24             	mov    %eax,(%esp)
  800127:	e8 07 56 00 00       	call   805733 <lwip_listen>
  80012c:	89 c7                	mov    %eax,%edi
		break;
  80012e:	e9 94 00 00 00       	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
			      req->recv.req_len, req->recv.req_flags);
  800133:	8b 46 08             	mov    0x8(%esi),%eax
  800136:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80013a:	8b 46 04             	mov    0x4(%esi),%eax
  80013d:	89 44 24 08          	mov    %eax,0x8(%esp)
  800141:	89 74 24 04          	mov    %esi,0x4(%esp)
  800145:	8b 06                	mov    (%esi),%eax
  800147:	89 04 24             	mov    %eax,(%esp)
  80014a:	e8 e5 58 00 00       	call   805a34 <lwip_recv>
  80014f:	89 c7                	mov    %eax,%edi
		break;
  800151:	eb 74                	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
			      req->send.req_size, req->send.req_flags);
  800153:	8b 46 08             	mov    0x8(%esi),%eax
  800156:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80015a:	8b 46 04             	mov    0x4(%esi),%eax
  80015d:	89 44 24 08          	mov    %eax,0x8(%esp)
  800161:	8d 46 0c             	lea    0xc(%esi),%eax
  800164:	89 44 24 04          	mov    %eax,0x4(%esp)
  800168:	8b 06                	mov    (%esi),%eax
  80016a:	89 04 24             	mov    %eax,(%esp)
  80016d:	e8 5e 5a 00 00       	call   805bd0 <lwip_send>
  800172:	89 c7                	mov    %eax,%edi
		break;
  800174:	eb 51                	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
				req->socket.req_protocol);
  800176:	8b 46 08             	mov    0x8(%esi),%eax
  800179:	89 44 24 08          	mov    %eax,0x8(%esp)
  80017d:	8b 46 04             	mov    0x4(%esi),%eax
  800180:	89 44 24 04          	mov    %eax,0x4(%esp)
  800184:	8b 06                	mov    (%esi),%eax
  800186:	89 04 24             	mov    %eax,(%esp)
  800189:	e8 04 5b 00 00       	call   805c92 <lwip_socket>
  80018e:	89 c7                	mov    %eax,%edi
		break;
  800190:	eb 35                	jmp    8001c7 <_ZL12serve_threadj+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800192:	89 74 24 04          	mov    %esi,0x4(%esp)
  800196:	c7 04 24 20 90 81 00 	movl   $0x819020,(%esp)
  80019d:	e8 cd 00 01 00       	call   81026f <_Z9jif_inputP5netifPv>
		r = 0;
  8001a2:	bf 00 00 00 00       	mov    $0x0,%edi
		break;
  8001a7:	eb 4c                	jmp    8001f5 <_ZL12serve_threadj+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  8001a9:	89 74 24 08          	mov    %esi,0x8(%esp)
  8001ad:	8b 43 04             	mov    0x4(%ebx),%eax
  8001b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8001b4:	c7 04 24 80 42 81 00 	movl   $0x814280,(%esp)
  8001bb:	e8 16 09 00 00       	call   800ad6 <_Z7cprintfPKcz>
		r = -E_INVAL;
  8001c0:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  8001c5:	eb 2e                	jmp    8001f5 <_ZL12serve_threadj+0x1a1>
		break;
	}

	if (r == -1) {
  8001c7:	83 ff ff             	cmp    $0xffffffff,%edi
  8001ca:	75 29                	jne    8001f5 <_ZL12serve_threadj+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  8001cc:	8b 03                	mov    (%ebx),%eax
  8001ce:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8001d2:	c7 44 24 08 b5 43 81 	movl   $0x8143b5,0x8(%esp)
  8001d9:	00 
  8001da:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  8001e1:	00 
  8001e2:	8d 75 84             	lea    -0x7c(%ebp),%esi
  8001e5:	89 34 24             	mov    %esi,(%esp)
  8001e8:	e8 94 0e 00 00       	call   801081 <_Z8snprintfPciPKcz>
		perror(buf);
  8001ed:	89 34 24             	mov    %esi,(%esp)
  8001f0:	e8 04 ff 00 00       	call   8100f9 <_Z6perrorPKc>
	}

	if (args->reqno != NSREQ_INPUT)
  8001f5:	83 3b 0a             	cmpl   $0xa,(%ebx)
  8001f8:	74 1f                	je     800219 <_ZL12serve_threadj+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  8001fa:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800201:	00 
  800202:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800209:	00 
  80020a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80020e:	8b 43 04             	mov    0x4(%ebx),%eax
  800211:	89 04 24             	mov    %eax,(%esp)
  800214:	e8 76 1d 00 00       	call   801f8f <_Z8ipc_sendijPvi>

	put_buffer(args->req);
  800219:	8b 43 08             	mov    0x8(%ebx),%eax
  80021c:	e8 1f fe ff ff       	call   800040 <_ZL10put_bufferPv>
	sys_page_unmap(0, (void*) args->req);
  800221:	8b 43 08             	mov    0x8(%ebx),%eax
  800224:	89 44 24 04          	mov    %eax,0x4(%esp)
  800228:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80022f:	e8 59 14 00 00       	call   80168d <_Z14sys_page_unmapiPv>
	free(args);
  800234:	89 1c 24             	mov    %ebx,(%esp)
  800237:	e8 74 44 00 00       	call   8046b0 <_Z4freePv>
}
  80023c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80023f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  800242:	8b 7d fc             	mov    -0x4(%ebp),%edi
  800245:	89 ec                	mov    %ebp,%esp
  800247:	5d                   	pop    %ebp
  800248:	c3                   	ret    

00800249 <_ZL9net_timerj>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  800249:	55                   	push   %ebp
  80024a:	89 e5                	mov    %esp,%ebp
  80024c:	56                   	push   %esi
  80024d:	53                   	push   %ebx
  80024e:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  800251:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  800254:	e8 d5 16 00 00       	call   80192e <_Z13sys_time_msecv>
  800259:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  80025b:	e8 11 f5 00 00       	call   80f771 <lwip_core_lock>
		t->func();
  800260:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800263:	e8 0e f5 00 00       	call   80f776 <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  800268:	03 33                	add    (%ebx),%esi
  80026a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80026e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800275:	00 
  800276:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80027d:	e8 1c f8 00 00       	call   80fa9e <_Z11thread_waitPVjjj>
  800282:	eb d0                	jmp    800254 <_ZL9net_timerj+0xb>

00800284 <_ZL11start_timerP12timer_threadPFvvEPKci>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800284:	55                   	push   %ebp
  800285:	89 e5                	mov    %esp,%ebp
  800287:	53                   	push   %ebx
  800288:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80028b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80028e:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800290:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800293:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800296:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80029a:	c7 44 24 08 49 02 80 	movl   $0x800249,0x8(%esp)
  8002a1:	00 
  8002a2:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8002a6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002ad:	e8 6d f5 00 00       	call   80f81f <_Z13thread_createPjPKcPFvjEj>
	if (r < 0)
  8002b2:	85 c0                	test   %eax,%eax
  8002b4:	79 28                	jns    8002de <_ZL11start_timerP12timer_threadPFvvEPKci+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  8002b6:	89 04 24             	mov    %eax,(%esp)
  8002b9:	e8 aa f8 00 00       	call   80fb68 <_Z3e2si>
  8002be:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002c2:	c7 44 24 08 a4 42 81 	movl   $0x8142a4,0x8(%esp)
  8002c9:	00 
  8002ca:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  8002d1:	00 
  8002d2:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  8002d9:	e8 da 06 00 00       	call   8009b8 <_Z6_panicPKciS0_z>
}
  8002de:	83 c4 14             	add    $0x14,%esp
  8002e1:	5b                   	pop    %ebx
  8002e2:	5d                   	pop    %ebp
  8002e3:	c3                   	ret    

008002e4 <_ZL15tcpip_init_donePv>:

static void
tcpip_init_done(void *arg)
{
  8002e4:	55                   	push   %ebp
  8002e5:	89 e5                	mov    %esp,%ebp
  8002e7:	83 ec 18             	sub    $0x18,%esp
  8002ea:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = (uint32_t*)arg;
	*done = 1;
  8002ed:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  8002f3:	89 04 24             	mov    %eax,(%esp)
  8002f6:	e8 b4 f4 00 00       	call   80f7af <_Z13thread_wakeupPVj>
}
  8002fb:	c9                   	leave  
  8002fc:	c3                   	ret    

008002fd <_Z10serve_initjjj>:

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  8002fd:	55                   	push   %ebp
  8002fe:	89 e5                	mov    %esp,%ebp
  800300:	56                   	push   %esi
  800301:	53                   	push   %ebx
  800302:	83 ec 30             	sub    $0x30,%esp
  800305:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800308:	e8 64 f4 00 00       	call   80f771 <lwip_core_lock>

	uint32_t done = 0;
  80030d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  800314:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  800317:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80031b:	c7 04 24 e4 02 80 00 	movl   $0x8002e4,(%esp)
  800322:	e8 01 67 00 00       	call   806a28 <tcpip_init>
	lwip_core_unlock();
  800327:	e8 4a f4 00 00       	call   80f776 <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  80032c:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  800333:	ff 
  800334:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80033b:	00 
  80033c:	89 1c 24             	mov    %ebx,(%esp)
  80033f:	e8 5a f7 00 00       	call   80fa9e <_Z11thread_waitPVjjj>
	lwip_core_lock();
  800344:	e8 28 f4 00 00       	call   80f771 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  800349:	89 75 f0             	mov    %esi,-0x10(%ebp)
	netmask.addr = init_mask;
  80034c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80034f:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  800352:	8b 45 10             	mov    0x10(%ebp),%eax
  800355:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
			   if_state,
			   jif_init,
			   ip_input))
  800358:	c7 44 24 18 79 b0 80 	movl   $0x80b079,0x18(%esp)
  80035f:	00 
  800360:	c7 44 24 14 7a 03 81 	movl   $0x81037a,0x14(%esp)
  800367:	00 
  800368:	c7 44 24 10 5c 90 81 	movl   $0x81905c,0x10(%esp)
  80036f:	00 
  800370:	8d 45 e8             	lea    -0x18(%ebp),%eax
  800373:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800377:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80037a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80037e:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800381:	89 44 24 04          	mov    %eax,0x4(%esp)
  800385:	c7 04 24 20 90 81 00 	movl   $0x819020,(%esp)
  80038c:	e8 2b 8c 00 00       	call   808fbc <netif_add>
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
	netmask.addr = init_mask;
	gateway.addr = init_gw;

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  800391:	85 c0                	test   %eax,%eax
  800393:	75 1c                	jne    8003b1 <_Z10serve_initjjj+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  800395:	c7 44 24 08 c4 42 81 	movl   $0x8142c4,0x8(%esp)
  80039c:	00 
  80039d:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  8003a4:	00 
  8003a5:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  8003ac:	e8 07 06 00 00       	call   8009b8 <_Z6_panicPKciS0_z>

	netif_set_default(nif);
  8003b1:	c7 04 24 20 90 81 00 	movl   $0x819020,(%esp)
  8003b8:	e8 8a 8c 00 00       	call   809047 <netif_set_default>
	netif_set_up(nif);
  8003bd:	c7 04 24 20 90 81 00 	movl   $0x819020,(%esp)
  8003c4:	e8 e3 8c 00 00       	call   8090ac <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  8003c9:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8003d0:	b9 cf 43 81 00       	mov    $0x8143cf,%ecx
  8003d5:	ba 9b e3 80 00       	mov    $0x80e39b,%edx
  8003da:	b8 74 90 81 00       	mov    $0x819074,%eax
  8003df:	e8 a0 fe ff ff       	call   800284 <_ZL11start_timerP12timer_threadPFvvEPKci>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  8003e4:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  8003eb:	b9 d9 43 81 00       	mov    $0x8143d9,%ecx
  8003f0:	ba 50 a2 80 00       	mov    $0x80a250,%edx
  8003f5:	b8 80 90 81 00       	mov    $0x819080,%eax
  8003fa:	e8 85 fe ff ff       	call   800284 <_ZL11start_timerP12timer_threadPFvvEPKci>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  8003ff:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  800406:	b9 e5 43 81 00       	mov    $0x8143e5,%ecx
  80040b:	ba 7e a6 80 00       	mov    $0x80a67e,%edx
  800410:	b8 8c 90 81 00       	mov    $0x81908c,%eax
  800415:	e8 6a fe ff ff       	call   800284 <_ZL11start_timerP12timer_threadPFvvEPKci>
	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x"
		" bound to static IP %s\n",
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));
  80041a:	89 34 24             	mov    %esi,(%esp)
  80041d:	e8 ee be 00 00       	call   80c310 <inet_ntoa>
  800422:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  800426:	0f b6 05 4a 90 81 00 	movzbl 0x81904a,%eax
  80042d:	89 44 24 18          	mov    %eax,0x18(%esp)
  800431:	0f b6 05 49 90 81 00 	movzbl 0x819049,%eax
  800438:	89 44 24 14          	mov    %eax,0x14(%esp)
  80043c:	0f b6 05 48 90 81 00 	movzbl 0x819048,%eax
  800443:	89 44 24 10          	mov    %eax,0x10(%esp)
  800447:	0f b6 05 47 90 81 00 	movzbl 0x819047,%eax
  80044e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800452:	0f b6 05 46 90 81 00 	movzbl 0x819046,%eax
  800459:	89 44 24 08          	mov    %eax,0x8(%esp)
  80045d:	0f b6 05 45 90 81 00 	movzbl 0x819045,%eax
  800464:	89 44 24 04          	mov    %eax,0x4(%esp)
  800468:	c7 04 24 e4 42 81 00 	movl   $0x8142e4,(%esp)
  80046f:	e8 62 06 00 00       	call   800ad6 <_Z7cprintfPKcz>

	lwip_core_unlock();
  800474:	e8 fd f2 00 00       	call   80f776 <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  800479:	c7 04 24 f1 43 81 00 	movl   $0x8143f1,(%esp)
  800480:	e8 51 06 00 00       	call   800ad6 <_Z7cprintfPKcz>
}
  800485:	83 c4 30             	add    $0x30,%esp
  800488:	5b                   	pop    %ebx
  800489:	5e                   	pop    %esi
  80048a:	5d                   	pop    %ebp
  80048b:	c3                   	ret    

0080048c <_Z5servev>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80048c:	55                   	push   %ebp
  80048d:	89 e5                	mov    %esp,%ebp
  80048f:	57                   	push   %edi
  800490:	56                   	push   %esi
  800491:	53                   	push   %ebx
  800492:	83 ec 3c             	sub    $0x3c,%esp

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800495:	bb 00 00 00 00       	mov    $0x0,%ebx
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80049a:	8d 7d e0             	lea    -0x20(%ebp),%edi

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80049d:	e8 2e f3 00 00       	call   80f7d0 <_Z22thread_wakeups_pendingv>
  8004a2:	85 c0                	test   %eax,%eax
  8004a4:	0f 84 66 01 00 00    	je     800610 <_Z5servev+0x184>
  8004aa:	83 fb 1f             	cmp    $0x1f,%ebx
  8004ad:	0f 8f 5d 01 00 00    	jg     800610 <_Z5servev+0x184>
			thread_yield();
  8004b3:	e8 b1 f4 00 00       	call   80f969 <_Z12thread_yieldv>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8004b8:	83 c3 01             	add    $0x1,%ebx
  8004bb:	eb e0                	jmp    80049d <_Z5servev+0x11>
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  8004bd:	80 b8 60 90 81 00 00 	cmpb   $0x0,0x819060(%eax)
  8004c4:	74 0a                	je     8004d0 <_Z5servev+0x44>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004c6:	83 c0 01             	add    $0x1,%eax
  8004c9:	83 f8 14             	cmp    $0x14,%eax
  8004cc:	75 ef                	jne    8004bd <_Z5servev+0x31>
  8004ce:	eb 05                	jmp    8004d5 <_Z5servev+0x49>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8004d0:	83 f8 14             	cmp    $0x14,%eax
  8004d3:	75 21                	jne    8004f6 <_Z5servev+0x6a>
		panic("NS: buffer overflow");
  8004d5:	c7 44 24 08 0a 44 81 	movl   $0x81440a,0x8(%esp)
  8004dc:	00 
  8004dd:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8004e4:	00 
  8004e5:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  8004ec:	e8 c7 04 00 00       	call   8009b8 <_Z6_panicPKciS0_z>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8004f1:	b8 00 00 00 00       	mov    $0x0,%eax
	if (i == QUEUE_SIZE) {
		panic("NS: buffer overflow");
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8004f6:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8004fc:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8004ff:	c6 80 60 90 81 00 01 	movb   $0x1,0x819060(%eax)
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  800506:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80050a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80050e:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  800511:	89 04 24             	mov    %eax,(%esp)
  800514:	e8 e7 19 00 00       	call   801f00 <_Z8ipc_recvPiPvS_>
  800519:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  80051b:	83 f8 0c             	cmp    $0xc,%eax
  80051e:	75 67                	jne    800587 <_Z5servev+0xfb>
			process_timer(whom);
  800520:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800523:	3b 35 54 90 81 00    	cmp    0x819054,%esi
  800529:	74 12                	je     80053d <_Z5servev+0xb1>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80052b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80052f:	c7 04 24 20 43 81 00 	movl   $0x814320,(%esp)
  800536:	e8 9b 05 00 00       	call   800ad6 <_Z7cprintfPKcz>
  80053b:	eb 39                	jmp    800576 <_Z5servev+0xea>
		return;
	}

	start = sys_time_msec();
  80053d:	e8 ec 13 00 00       	call   80192e <_Z13sys_time_msecv>
  800542:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800545:	e8 1f f4 00 00       	call   80f969 <_Z12thread_yieldv>
	now = sys_time_msec();
  80054a:	e8 df 13 00 00       	call   80192e <_Z13sys_time_msecv>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  80054f:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800556:	00 
  800557:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80055e:	00 

	start = sys_time_msec();
	thread_yield();
	now = sys_time_msec();

	to = TIMER_INTERVAL - (now - start);
  80055f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800562:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  800568:	29 c2                	sub    %eax,%edx
	ipc_send(envid, to, 0, 0);
  80056a:	89 54 24 04          	mov    %edx,0x4(%esp)
  80056e:	89 34 24             	mov    %esi,(%esp)
  800571:	e8 19 1a 00 00       	call   801f8f <_Z8ipc_sendijPvi>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800576:	89 d8                	mov    %ebx,%eax
  800578:	e8 c3 fa ff ff       	call   800040 <_ZL10put_bufferPv>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  80057d:	bb 00 00 00 00       	mov    $0x0,%ebx

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
			continue;
  800582:	e9 16 ff ff ff       	jmp    80049d <_Z5servev+0x11>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  800587:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80058b:	75 1d                	jne    8005aa <_Z5servev+0x11e>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  80058d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800590:	89 44 24 04          	mov    %eax,0x4(%esp)
  800594:	c7 04 24 5c 43 81 00 	movl   $0x81435c,(%esp)
  80059b:	e8 36 05 00 00       	call   800ad6 <_Z7cprintfPKcz>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  8005a0:	bb 00 00 00 00       	mov    $0x0,%ebx
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
			cprintf("Invalid request from %08x: no argument page\n", whom);
			continue; // just leave it hanging...
  8005a5:	e9 f3 fe ff ff       	jmp    80049d <_Z5servev+0x11>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = (struct st_args *)malloc(sizeof(struct st_args));
  8005aa:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8005b1:	e8 cc 41 00 00       	call   804782 <_Z6mallocj>
		if (!args)
  8005b6:	85 c0                	test   %eax,%eax
  8005b8:	75 1c                	jne    8005d6 <_Z5servev+0x14a>
			panic("could not allocate thread args structure");
  8005ba:	c7 44 24 08 8c 43 81 	movl   $0x81438c,0x8(%esp)
  8005c1:	00 
  8005c2:	c7 44 24 04 26 01 00 	movl   $0x126,0x4(%esp)
  8005c9:	00 
  8005ca:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  8005d1:	e8 e2 03 00 00       	call   8009b8 <_Z6_panicPKciS0_z>

		args->reqno = reqno;
  8005d6:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8005d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8005db:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = (union Nsipc *)va;
  8005de:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8005e1:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005e5:	c7 44 24 08 54 00 80 	movl   $0x800054,0x8(%esp)
  8005ec:	00 
  8005ed:	c7 44 24 04 1e 44 81 	movl   $0x81441e,0x4(%esp)
  8005f4:	00 
  8005f5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8005fc:	e8 1e f2 00 00       	call   80f81f <_Z13thread_createPjPKcPFvjEj>
		thread_yield(); // let the thread created run
  800601:	e8 63 f3 00 00       	call   80f969 <_Z12thread_yieldv>

	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800606:	bb 00 00 00 00       	mov    $0x0,%ebx
  80060b:	e9 8d fe ff ff       	jmp    80049d <_Z5servev+0x11>
			thread_yield();

		perm = 0;
  800610:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  800617:	b8 01 00 00 00       	mov    $0x1,%eax
		if (!buse[i]) break;
  80061c:	80 3d 60 90 81 00 00 	cmpb   $0x0,0x819060
  800623:	0f 85 94 fe ff ff    	jne    8004bd <_Z5servev+0x31>
  800629:	e9 c3 fe ff ff       	jmp    8004f1 <_Z5servev+0x65>

0080062e <_ZL5tmainj>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  80062e:	55                   	push   %ebp
  80062f:	89 e5                	mov    %esp,%ebp
  800631:	83 ec 18             	sub    $0x18,%esp
  800634:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  800637:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
  80063a:	c7 04 24 2b 44 81 00 	movl   $0x81442b,(%esp)
  800641:	e8 ce bf 00 00       	call   80c614 <inet_addr>
  800646:	89 c3                	mov    %eax,%ebx
  800648:	c7 04 24 34 44 81 00 	movl   $0x814434,(%esp)
  80064f:	e8 c0 bf 00 00       	call   80c614 <inet_addr>
  800654:	89 c6                	mov    %eax,%esi
  800656:	c7 04 24 42 44 81 00 	movl   $0x814442,(%esp)
  80065d:	e8 b2 bf 00 00       	call   80c614 <inet_addr>
  800662:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800666:	89 74 24 04          	mov    %esi,0x4(%esp)
  80066a:	89 04 24             	mov    %eax,(%esp)
  80066d:	e8 8b fc ff ff       	call   8002fd <_Z10serve_initjjj>
	serve();
  800672:	e8 15 fe ff ff       	call   80048c <_Z5servev>
}
  800677:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80067a:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80067d:	89 ec                	mov    %ebp,%esp
  80067f:	5d                   	pop    %ebp
  800680:	c3                   	ret    

00800681 <_Z5umainiPPc>:

void
umain(int argc, char **argv)
{
  800681:	55                   	push   %ebp
  800682:	89 e5                	mov    %esp,%ebp
  800684:	53                   	push   %ebx
  800685:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  800688:	e8 db 0e 00 00       	call   801568 <_Z12sys_getenvidv>
  80068d:	89 c3                	mov    %eax,%ebx
	binaryname = "ns";
  80068f:	c7 05 00 80 81 00 a8 	movl   $0x8150a8,0x818000
  800696:	50 81 00 
	
    // fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800699:	e8 6f 15 00 00       	call   801c0d <_Z4forkv>
  80069e:	a3 54 90 81 00       	mov    %eax,0x819054
	if (timer_envid < 0)
  8006a3:	85 c0                	test   %eax,%eax
  8006a5:	79 1c                	jns    8006c3 <_Z5umainiPPc+0x42>
		panic("error forking");
  8006a7:	c7 44 24 08 4c 44 81 	movl   $0x81444c,0x8(%esp)
  8006ae:	00 
  8006af:	c7 44 24 04 42 01 00 	movl   $0x142,0x4(%esp)
  8006b6:	00 
  8006b7:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  8006be:	e8 f5 02 00 00       	call   8009b8 <_Z6_panicPKciS0_z>
	else if (timer_envid == 0) {
  8006c3:	85 c0                	test   %eax,%eax
  8006c5:	75 15                	jne    8006dc <_Z5umainiPPc+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  8006c7:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8006ce:	00 
  8006cf:	89 1c 24             	mov    %ebx,(%esp)
  8006d2:	e8 b9 00 00 00       	call   800790 <_Z5timerij>
		return;
  8006d7:	e9 a2 00 00 00       	jmp    80077e <_Z5umainiPPc+0xfd>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8006dc:	e8 2c 15 00 00       	call   801c0d <_Z4forkv>
  8006e1:	a3 58 90 81 00       	mov    %eax,0x819058
	if (input_envid < 0)
  8006e6:	85 c0                	test   %eax,%eax
  8006e8:	79 1c                	jns    800706 <_Z5umainiPPc+0x85>
		panic("error forking");
  8006ea:	c7 44 24 08 4c 44 81 	movl   $0x81444c,0x8(%esp)
  8006f1:	00 
  8006f2:	c7 44 24 04 4c 01 00 	movl   $0x14c,0x4(%esp)
  8006f9:	00 
  8006fa:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  800701:	e8 b2 02 00 00       	call   8009b8 <_Z6_panicPKciS0_z>
	else if (input_envid == 0) {
  800706:	85 c0                	test   %eax,%eax
  800708:	75 0a                	jne    800714 <_Z5umainiPPc+0x93>
		input(ns_envid);
  80070a:	89 1c 24             	mov    %ebx,(%esp)
  80070d:	e8 46 01 00 00       	call   800858 <_Z5inputi>
		return;
  800712:	eb 6a                	jmp    80077e <_Z5umainiPPc+0xfd>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  800714:	e8 f4 14 00 00       	call   801c0d <_Z4forkv>
  800719:	a3 5c 90 81 00       	mov    %eax,0x81905c
	if (output_envid < 0)
  80071e:	85 c0                	test   %eax,%eax
  800720:	79 1c                	jns    80073e <_Z5umainiPPc+0xbd>
		panic("error forking");
  800722:	c7 44 24 08 4c 44 81 	movl   $0x81444c,0x8(%esp)
  800729:	00 
  80072a:	c7 44 24 04 56 01 00 	movl   $0x156,0x4(%esp)
  800731:	00 
  800732:	c7 04 24 c4 43 81 00 	movl   $0x8143c4,(%esp)
  800739:	e8 7a 02 00 00       	call   8009b8 <_Z6_panicPKciS0_z>
	else if (output_envid == 0) {
  80073e:	85 c0                	test   %eax,%eax
  800740:	75 0a                	jne    80074c <_Z5umainiPPc+0xcb>
		output(ns_envid);
  800742:	89 1c 24             	mov    %ebx,(%esp)
  800745:	e8 9a 01 00 00       	call   8008e4 <_Z6outputi>
		return;
  80074a:	eb 32                	jmp    80077e <_Z5umainiPPc+0xfd>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization.
	thread_init();
  80074c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  800750:	e8 2b f0 00 00       	call   80f780 <_Z11thread_initv>
	thread_create(0, "main", tmain, 0);
  800755:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80075c:	00 
  80075d:	c7 44 24 08 2e 06 80 	movl   $0x80062e,0x8(%esp)
  800764:	00 
  800765:	c7 44 24 04 5a 44 81 	movl   $0x81445a,0x4(%esp)
  80076c:	00 
  80076d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800774:	e8 a6 f0 00 00       	call   80f81f <_Z13thread_createPjPKcPFvjEj>
	thread_yield();
  800779:	e8 eb f1 00 00       	call   80f969 <_Z12thread_yieldv>
	// never coming here!
}
  80077e:	83 c4 14             	add    $0x14,%esp
  800781:	5b                   	pop    %ebx
  800782:	5d                   	pop    %ebp
  800783:	c3                   	ret    
	...

00800790 <_Z5timerij>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800790:	55                   	push   %ebp
  800791:	89 e5                	mov    %esp,%ebp
  800793:	57                   	push   %edi
  800794:	56                   	push   %esi
  800795:	53                   	push   %ebx
  800796:	83 ec 2c             	sub    $0x2c,%esp
  800799:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	uint32_t stop = sys_time_msec() + initial_to;
  80079c:	e8 8d 11 00 00       	call   80192e <_Z13sys_time_msecv>
  8007a1:	89 c3                	mov    %eax,%ebx
  8007a3:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  8007a6:	c7 05 00 80 81 00 8c 	movl   $0x81448c,0x818000
  8007ad:	44 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007b0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
  8007b3:	e8 76 11 00 00       	call   80192e <_Z13sys_time_msecv>
  8007b8:	39 c3                	cmp    %eax,%ebx
  8007ba:	0f 86 8b 00 00 00    	jbe    80084b <_Z5timerij+0xbb>
  8007c0:	85 c0                	test   %eax,%eax
  8007c2:	78 07                	js     8007cb <_Z5timerij+0x3b>
			sys_yield();
  8007c4:	e8 d3 0d 00 00       	call   80159c <_Z9sys_yieldv>
  8007c9:	eb e8                	jmp    8007b3 <_Z5timerij+0x23>
		}
		if (r < 0)
			panic("sys_time_msec: %e", r);
  8007cb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8007cf:	c7 44 24 08 95 44 81 	movl   $0x814495,0x8(%esp)
  8007d6:	00 
  8007d7:	c7 44 24 04 0f 00 00 	movl   $0xf,0x4(%esp)
  8007de:	00 
  8007df:	c7 04 24 a7 44 81 00 	movl   $0x8144a7,(%esp)
  8007e6:	e8 cd 01 00 00       	call   8009b8 <_Z6_panicPKciS0_z>

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007eb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007f2:	00 
  8007f3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007fa:	00 
  8007fb:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  800802:	00 
  800803:	89 34 24             	mov    %esi,(%esp)
  800806:	e8 84 17 00 00       	call   801f8f <_Z8ipc_sendijPvi>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  80080b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800812:	00 
  800813:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80081a:	00 
  80081b:	89 3c 24             	mov    %edi,(%esp)
  80081e:	e8 dd 16 00 00       	call   801f00 <_Z8ipc_recvPiPvS_>
  800823:	89 c3                	mov    %eax,%ebx

			if (whom != (uint32_t)ns_envid) {
  800825:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800828:	39 c6                	cmp    %eax,%esi
  80082a:	74 12                	je     80083e <_Z5timerij+0xae>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  80082c:	89 44 24 04          	mov    %eax,0x4(%esp)
  800830:	c7 04 24 b4 44 81 00 	movl   $0x8144b4,(%esp)
  800837:	e8 9a 02 00 00       	call   800ad6 <_Z7cprintfPKcz>
		if (r < 0)
			panic("sys_time_msec: %e", r);

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
  80083c:	eb cd                	jmp    80080b <_Z5timerij+0x7b>
			if (whom != (uint32_t)ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  80083e:	e8 eb 10 00 00       	call   80192e <_Z13sys_time_msecv>
  800843:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
  800846:	e9 68 ff ff ff       	jmp    8007b3 <_Z5timerij+0x23>

	while (1) {
		while((r = sys_time_msec()) < stop && r >= 0) {
			sys_yield();
		}
		if (r < 0)
  80084b:	85 c0                	test   %eax,%eax
  80084d:	8d 76 00             	lea    0x0(%esi),%esi
  800850:	79 99                	jns    8007eb <_Z5timerij+0x5b>
  800852:	e9 74 ff ff ff       	jmp    8007cb <_Z5timerij+0x3b>
	...

00800858 <_Z5inputi>:
#include <inc/mmu.h>
extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800858:	55                   	push   %ebp
  800859:	89 e5                	mov    %esp,%ebp
  80085b:	53                   	push   %ebx
  80085c:	83 ec 14             	sub    $0x14,%esp
  80085f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    binaryname = "ns_input";
  800862:	c7 05 00 80 81 00 ef 	movl   $0x8144ef,0x818000
  800869:	44 81 00 
	// reading from it for a while, so don't immediately receive
	// another packet in to the same physical page.
    int len, r;
    while(1)
    {
        if((r = sys_page_alloc(0, &nsipcbuf, PTE_P|PTE_U|PTE_W)) < 0)
  80086c:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  800873:	00 
  800874:	c7 44 24 04 00 a0 81 	movl   $0x81a000,0x4(%esp)
  80087b:	00 
  80087c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  800883:	e8 48 0d 00 00       	call   8015d0 <_Z14sys_page_allociPvi>
  800888:	85 c0                	test   %eax,%eax
  80088a:	79 20                	jns    8008ac <_Z5inputi+0x54>
            panic("sys_page_alloc: %e\n", r);
  80088c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800890:	c7 44 24 08 f8 44 81 	movl   $0x8144f8,0x8(%esp)
  800897:	00 
  800898:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80089f:	00 
  8008a0:	c7 04 24 0c 45 81 00 	movl   $0x81450c,(%esp)
  8008a7:	e8 0c 01 00 00       	call   8009b8 <_Z6_panicPKciS0_z>
        len = sys_e1000_receive(&nsipcbuf.pkt.jp_data);
  8008ac:	c7 04 24 04 a0 81 00 	movl   $0x81a004,(%esp)
  8008b3:	e8 e0 10 00 00       	call   801998 <_Z17sys_e1000_receivePv>
        if (len >= 0)
  8008b8:	85 c0                	test   %eax,%eax
  8008ba:	78 b0                	js     80086c <_Z5inputi+0x14>
        {
            nsipcbuf.pkt.jp_len = len;
  8008bc:	a3 00 a0 81 00       	mov    %eax,0x81a000
            ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P|PTE_U|PTE_W);
  8008c1:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8008c8:	00 
  8008c9:	c7 44 24 08 00 a0 81 	movl   $0x81a000,0x8(%esp)
  8008d0:	00 
  8008d1:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008d8:	00 
  8008d9:	89 1c 24             	mov    %ebx,(%esp)
  8008dc:	e8 ae 16 00 00       	call   801f8f <_Z8ipc_sendijPvi>
  8008e1:	eb 89                	jmp    80086c <_Z5inputi+0x14>
	...

008008e4 <_Z6outputi>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8008e4:	55                   	push   %ebp
  8008e5:	89 e5                	mov    %esp,%ebp
  8008e7:	56                   	push   %esi
  8008e8:	53                   	push   %ebx
  8008e9:	83 ec 20             	sub    $0x20,%esp
  8008ec:	8b 75 08             	mov    0x8(%ebp),%esi
	binaryname = "ns_output";
  8008ef:	c7 05 00 80 81 00 18 	movl   $0x814518,0x818000
  8008f6:	45 81 00 
    // LAB 6: Your code here:
	// 	- read a packet from the network server
	//	- send the packet to the device driver
    while(1)
    {
        ipc_recv(&envid, &nsipcbuf, 0);
  8008f9:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8008fc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800903:	00 
  800904:	c7 44 24 04 00 a0 81 	movl   $0x81a000,0x4(%esp)
  80090b:	00 
  80090c:	89 1c 24             	mov    %ebx,(%esp)
  80090f:	e8 ec 15 00 00       	call   801f00 <_Z8ipc_recvPiPvS_>
        if (envid != ns_envid)
  800914:	39 75 f4             	cmp    %esi,-0xc(%ebp)
  800917:	75 e3                	jne    8008fc <_Z6outputi+0x18>
            continue;
        while(sys_e1000_transmit(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len));
  800919:	a1 00 a0 81 00       	mov    0x81a000,%eax
  80091e:	89 44 24 04          	mov    %eax,0x4(%esp)
  800922:	c7 04 24 04 a0 81 00 	movl   $0x81a004,(%esp)
  800929:	e8 34 10 00 00       	call   801962 <_Z18sys_e1000_transmitPvj>
  80092e:	85 c0                	test   %eax,%eax
  800930:	75 e7                	jne    800919 <_Z6outputi+0x35>
  800932:	eb c8                	jmp    8008fc <_Z6outputi+0x18>

00800934 <libmain>:
const volatile struct Env *thisenv;
const char *binaryname = "<unknown>";

asmlinkage void
libmain(int argc, char **argv)
{
  800934:	55                   	push   %ebp
  800935:	89 e5                	mov    %esp,%ebp
  800937:	57                   	push   %edi
  800938:	56                   	push   %esi
  800939:	53                   	push   %ebx
  80093a:	83 ec 1c             	sub    $0x1c,%esp
  80093d:	8b 7d 08             	mov    0x8(%ebp),%edi
  800940:	8b 75 0c             	mov    0xc(%ebp),%esi
	extern uintptr_t sctors[], ectors[];
	uintptr_t *ctorva;

	// set thisenv to point at our Env structure in envs[]
	thisenv = &envs[ENVX(sys_getenvid())]; /* Really? */
  800943:	e8 20 0c 00 00       	call   801568 <_Z12sys_getenvidv>
  800948:	25 ff 03 00 00       	and    $0x3ff,%eax
  80094d:	6b c0 78             	imul   $0x78,%eax,%eax
  800950:	05 00 00 00 ef       	add    $0xef000000,%eax
  800955:	a3 98 90 81 00       	mov    %eax,0x819098
	// save the name of the program so that panic() can use it
	if (argc > 0)
  80095a:	85 ff                	test   %edi,%edi
  80095c:	7e 07                	jle    800965 <libmain+0x31>
		binaryname = argv[0];
  80095e:	8b 06                	mov    (%esi),%eax
  800960:	a3 00 80 81 00       	mov    %eax,0x818000

	// Call any global constructors (e.g., defined by C++).
	// This relies on linker script magic to define the 'sctors' and
	// 'ectors' symbols; see user/user.ld.
	for (ctorva = ectors; ctorva > sctors; )
  800965:	b8 2a 75 81 00       	mov    $0x81752a,%eax
  80096a:	3d 2a 75 81 00       	cmp    $0x81752a,%eax
  80096f:	76 0f                	jbe    800980 <libmain+0x4c>
  800971:	89 c3                	mov    %eax,%ebx
		((void(*)()) *--ctorva)();
  800973:	83 eb 04             	sub    $0x4,%ebx
  800976:	ff 13                	call   *(%ebx)
		binaryname = argv[0];

	// Call any global constructors (e.g., defined by C++).
	// This relies on linker script magic to define the 'sctors' and
	// 'ectors' symbols; see user/user.ld.
	for (ctorva = ectors; ctorva > sctors; )
  800978:	81 fb 2a 75 81 00    	cmp    $0x81752a,%ebx
  80097e:	77 f3                	ja     800973 <libmain+0x3f>
		((void(*)()) *--ctorva)();

	// call user main routine
	umain(argc, argv);
  800980:	89 74 24 04          	mov    %esi,0x4(%esp)
  800984:	89 3c 24             	mov    %edi,(%esp)
  800987:	e8 f5 fc ff ff       	call   800681 <_Z5umainiPPc>

	// exit gracefully
	exit();
  80098c:	e8 0b 00 00 00       	call   80099c <_Z4exitv>
}
  800991:	83 c4 1c             	add    $0x1c,%esp
  800994:	5b                   	pop    %ebx
  800995:	5e                   	pop    %esi
  800996:	5f                   	pop    %edi
  800997:	5d                   	pop    %ebp
  800998:	c3                   	ret    
  800999:	00 00                	add    %al,(%eax)
	...

0080099c <_Z4exitv>:

#include <inc/lib.h>

void
exit(void)
{
  80099c:	55                   	push   %ebp
  80099d:	89 e5                	mov    %esp,%ebp
  80099f:	83 ec 18             	sub    $0x18,%esp
	close_all();
  8009a2:	e8 17 19 00 00       	call   8022be <_Z9close_allv>
	sys_env_destroy(0);
  8009a7:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8009ae:	e8 58 0b 00 00       	call   80150b <_Z15sys_env_destroyi>
}
  8009b3:	c9                   	leave  
  8009b4:	c3                   	ret    
  8009b5:	00 00                	add    %al,(%eax)
	...

008009b8 <_Z6_panicPKciS0_z>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt, ...)
{
  8009b8:	55                   	push   %ebp
  8009b9:	89 e5                	mov    %esp,%ebp
  8009bb:	56                   	push   %esi
  8009bc:	53                   	push   %ebx
  8009bd:	83 ec 20             	sub    $0x20,%esp
	va_list ap;

	va_start(ap, fmt);
  8009c0:	8d 75 14             	lea    0x14(%ebp),%esi

	// Print the panic message
	if (argv0)
  8009c3:	a1 9c 90 81 00       	mov    0x81909c,%eax
  8009c8:	85 c0                	test   %eax,%eax
  8009ca:	74 10                	je     8009dc <_Z6_panicPKciS0_z+0x24>
		cprintf("%s: ", argv0);
  8009cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009d0:	c7 04 24 2c 45 81 00 	movl   $0x81452c,(%esp)
  8009d7:	e8 fa 00 00 00       	call   800ad6 <_Z7cprintfPKcz>
	cprintf("[%08x] user panic in %s at %s:%d: ",
		sys_getenvid(), binaryname, file, line);
  8009dc:	8b 1d 00 80 81 00    	mov    0x818000,%ebx
  8009e2:	e8 81 0b 00 00       	call   801568 <_Z12sys_getenvidv>
  8009e7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8009ea:	89 54 24 10          	mov    %edx,0x10(%esp)
  8009ee:	8b 55 08             	mov    0x8(%ebp),%edx
  8009f1:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8009f5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8009f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009fd:	c7 04 24 34 45 81 00 	movl   $0x814534,(%esp)
  800a04:	e8 cd 00 00 00       	call   800ad6 <_Z7cprintfPKcz>
	vcprintf(fmt, ap);
  800a09:	89 74 24 04          	mov    %esi,0x4(%esp)
  800a0d:	8b 45 10             	mov    0x10(%ebp),%eax
  800a10:	89 04 24             	mov    %eax,(%esp)
  800a13:	e8 5d 00 00 00       	call   800a75 <_Z8vcprintfPKcPc>
	cprintf("\n");
  800a18:	c7 04 24 08 44 81 00 	movl   $0x814408,(%esp)
  800a1f:	e8 b2 00 00 00       	call   800ad6 <_Z7cprintfPKcz>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  800a24:	cc                   	int3   
  800a25:	eb fd                	jmp    800a24 <_Z6_panicPKciS0_z+0x6c>
	...

00800a28 <_ZL5putchiPv>:
};


static void
putch(int ch, void *ptr)
{
  800a28:	55                   	push   %ebp
  800a29:	89 e5                	mov    %esp,%ebp
  800a2b:	83 ec 18             	sub    $0x18,%esp
  800a2e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  800a31:	89 75 fc             	mov    %esi,-0x4(%ebp)
  800a34:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	struct printbuf *b = (struct printbuf *) ptr;
  800a37:	89 de                	mov    %ebx,%esi
	b->buf[b->idx++] = ch;
  800a39:	8b 03                	mov    (%ebx),%eax
  800a3b:	8b 55 08             	mov    0x8(%ebp),%edx
  800a3e:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  800a42:	83 c0 01             	add    $0x1,%eax
  800a45:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  800a47:	3d ff 00 00 00       	cmp    $0xff,%eax
  800a4c:	75 19                	jne    800a67 <_ZL5putchiPv+0x3f>
		sys_cputs(b->buf, b->idx);
  800a4e:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  800a55:	00 
  800a56:	8d 43 08             	lea    0x8(%ebx),%eax
  800a59:	89 04 24             	mov    %eax,(%esp)
  800a5c:	e8 43 0a 00 00       	call   8014a4 <_Z9sys_cputsPKcj>
		b->idx = 0;
  800a61:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  800a67:	83 46 04 01          	addl   $0x1,0x4(%esi)
}
  800a6b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800a6e:	8b 75 fc             	mov    -0x4(%ebp),%esi
  800a71:	89 ec                	mov    %ebp,%esp
  800a73:	5d                   	pop    %ebp
  800a74:	c3                   	ret    

00800a75 <_Z8vcprintfPKcPc>:

int
vcprintf(const char *fmt, va_list ap)
{
  800a75:	55                   	push   %ebp
  800a76:	89 e5                	mov    %esp,%ebp
  800a78:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  800a7e:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  800a85:	00 00 00 
	b.cnt = 0;
  800a88:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  800a8f:	00 00 00 
	vprintfmt(putch, &b, fmt, ap);
  800a92:	8b 45 0c             	mov    0xc(%ebp),%eax
  800a95:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800a99:	8b 45 08             	mov    0x8(%ebp),%eax
  800a9c:	89 44 24 08          	mov    %eax,0x8(%esp)
  800aa0:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  800aa6:	89 44 24 04          	mov    %eax,0x4(%esp)
  800aaa:	c7 04 24 28 0a 80 00 	movl   $0x800a28,(%esp)
  800ab1:	e8 a1 01 00 00       	call   800c57 <_Z9vprintfmtPFviPvES_PKcPc>
	sys_cputs(b.buf, b.idx);
  800ab6:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  800abc:	89 44 24 04          	mov    %eax,0x4(%esp)
  800ac0:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  800ac6:	89 04 24             	mov    %eax,(%esp)
  800ac9:	e8 d6 09 00 00       	call   8014a4 <_Z9sys_cputsPKcj>

	return b.cnt;
}
  800ace:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  800ad4:	c9                   	leave  
  800ad5:	c3                   	ret    

00800ad6 <_Z7cprintfPKcz>:

int
cprintf(const char *fmt, ...)
{
  800ad6:	55                   	push   %ebp
  800ad7:	89 e5                	mov    %esp,%ebp
  800ad9:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int cnt;

	va_start(ap, fmt);
  800adc:	8d 45 0c             	lea    0xc(%ebp),%eax
	cnt = vcprintf(fmt, ap);
  800adf:	89 44 24 04          	mov    %eax,0x4(%esp)
  800ae3:	8b 45 08             	mov    0x8(%ebp),%eax
  800ae6:	89 04 24             	mov    %eax,(%esp)
  800ae9:	e8 87 ff ff ff       	call   800a75 <_Z8vcprintfPKcPc>
	va_end(ap);

	return cnt;
}
  800aee:	c9                   	leave  
  800aef:	c3                   	ret    

00800af0 <_ZL8printnumPFviPvES_yjii>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800af0:	55                   	push   %ebp
  800af1:	89 e5                	mov    %esp,%ebp
  800af3:	57                   	push   %edi
  800af4:	56                   	push   %esi
  800af5:	53                   	push   %ebx
  800af6:	83 ec 4c             	sub    $0x4c,%esp
  800af9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800afc:	89 d6                	mov    %edx,%esi
  800afe:	8b 45 08             	mov    0x8(%ebp),%eax
  800b01:	89 45 dc             	mov    %eax,-0x24(%ebp)
  800b04:	8b 55 0c             	mov    0xc(%ebp),%edx
  800b07:	89 55 e0             	mov    %edx,-0x20(%ebp)
  800b0a:	8b 5d 14             	mov    0x14(%ebp),%ebx
  800b0d:	8b 7d 18             	mov    0x18(%ebp),%edi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800b10:	b8 00 00 00 00       	mov    $0x0,%eax
  800b15:	39 d0                	cmp    %edx,%eax
  800b17:	72 11                	jb     800b2a <_ZL8printnumPFviPvES_yjii+0x3a>
  800b19:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  800b1c:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  800b1f:	76 09                	jbe    800b2a <_ZL8printnumPFviPvES_yjii+0x3a>
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800b21:	83 eb 01             	sub    $0x1,%ebx
  800b24:	85 db                	test   %ebx,%ebx
  800b26:	7f 5d                	jg     800b85 <_ZL8printnumPFviPvES_yjii+0x95>
  800b28:	eb 6c                	jmp    800b96 <_ZL8printnumPFviPvES_yjii+0xa6>
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800b2a:	89 7c 24 10          	mov    %edi,0x10(%esp)
  800b2e:	83 eb 01             	sub    $0x1,%ebx
  800b31:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800b35:	8b 5d 10             	mov    0x10(%ebp),%ebx
  800b38:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800b3c:	8b 44 24 08          	mov    0x8(%esp),%eax
  800b40:	8b 54 24 0c          	mov    0xc(%esp),%edx
  800b44:	89 45 d0             	mov    %eax,-0x30(%ebp)
  800b47:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  800b4a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800b51:	00 
  800b52:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800b55:	89 14 24             	mov    %edx,(%esp)
  800b58:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800b5b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800b5f:	e8 bc 34 01 00       	call   814020 <__udivdi3>
  800b64:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800b67:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800b6a:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  800b6e:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800b72:	89 04 24             	mov    %eax,(%esp)
  800b75:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b79:	89 f2                	mov    %esi,%edx
  800b7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b7e:	e8 6d ff ff ff       	call   800af0 <_ZL8printnumPFviPvES_yjii>
  800b83:	eb 11                	jmp    800b96 <_ZL8printnumPFviPvES_yjii+0xa6>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800b85:	89 74 24 04          	mov    %esi,0x4(%esp)
  800b89:	89 3c 24             	mov    %edi,(%esp)
  800b8c:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800b8f:	83 eb 01             	sub    $0x1,%ebx
  800b92:	85 db                	test   %ebx,%ebx
  800b94:	7f ef                	jg     800b85 <_ZL8printnumPFviPvES_yjii+0x95>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800b96:	89 74 24 04          	mov    %esi,0x4(%esp)
  800b9a:	8b 74 24 04          	mov    0x4(%esp),%esi
  800b9e:	8b 45 10             	mov    0x10(%ebp),%eax
  800ba1:	89 44 24 08          	mov    %eax,0x8(%esp)
  800ba5:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800bac:	00 
  800bad:	8b 55 dc             	mov    -0x24(%ebp),%edx
  800bb0:	89 14 24             	mov    %edx,(%esp)
  800bb3:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800bb6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800bba:	e8 71 35 01 00       	call   814130 <__umoddi3>
  800bbf:	89 74 24 04          	mov    %esi,0x4(%esp)
  800bc3:	0f be 80 57 45 81 00 	movsbl 0x814557(%eax),%eax
  800bca:	89 04 24             	mov    %eax,(%esp)
  800bcd:	ff 55 e4             	call   *-0x1c(%ebp)
}
  800bd0:	83 c4 4c             	add    $0x4c,%esp
  800bd3:	5b                   	pop    %ebx
  800bd4:	5e                   	pop    %esi
  800bd5:	5f                   	pop    %edi
  800bd6:	5d                   	pop    %ebp
  800bd7:	c3                   	ret    

00800bd8 <_ZL7getuintPPci>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800bd8:	55                   	push   %ebp
  800bd9:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  800bdb:	83 fa 01             	cmp    $0x1,%edx
  800bde:	7e 0e                	jle    800bee <_ZL7getuintPPci+0x16>
		return va_arg(*ap, unsigned long long);
  800be0:	8b 10                	mov    (%eax),%edx
  800be2:	8d 4a 08             	lea    0x8(%edx),%ecx
  800be5:	89 08                	mov    %ecx,(%eax)
  800be7:	8b 02                	mov    (%edx),%eax
  800be9:	8b 52 04             	mov    0x4(%edx),%edx
  800bec:	eb 22                	jmp    800c10 <_ZL7getuintPPci+0x38>
	else if (lflag)
  800bee:	85 d2                	test   %edx,%edx
  800bf0:	74 10                	je     800c02 <_ZL7getuintPPci+0x2a>
		return va_arg(*ap, unsigned long);
  800bf2:	8b 10                	mov    (%eax),%edx
  800bf4:	8d 4a 04             	lea    0x4(%edx),%ecx
  800bf7:	89 08                	mov    %ecx,(%eax)
  800bf9:	8b 02                	mov    (%edx),%eax
  800bfb:	ba 00 00 00 00       	mov    $0x0,%edx
  800c00:	eb 0e                	jmp    800c10 <_ZL7getuintPPci+0x38>
	else
		return va_arg(*ap, unsigned int);
  800c02:	8b 10                	mov    (%eax),%edx
  800c04:	8d 4a 04             	lea    0x4(%edx),%ecx
  800c07:	89 08                	mov    %ecx,(%eax)
  800c09:	8b 02                	mov    (%edx),%eax
  800c0b:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800c10:	5d                   	pop    %ebp
  800c11:	c3                   	ret    

00800c12 <_ZL11sprintputchiPv>:
	int cnt;
};

static void
sprintputch(int ch, void *ptr)
{
  800c12:	55                   	push   %ebp
  800c13:	89 e5                	mov    %esp,%ebp
  800c15:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct sprintbuf *b = (struct sprintbuf *) ptr;
	b->cnt++;
  800c18:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  800c1c:	8b 10                	mov    (%eax),%edx
  800c1e:	3b 50 04             	cmp    0x4(%eax),%edx
  800c21:	73 0a                	jae    800c2d <_ZL11sprintputchiPv+0x1b>
		*b->buf++ = ch;
  800c23:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800c26:	88 0a                	mov    %cl,(%edx)
  800c28:	83 c2 01             	add    $0x1,%edx
  800c2b:	89 10                	mov    %edx,(%eax)
}
  800c2d:	5d                   	pop    %ebp
  800c2e:	c3                   	ret    

00800c2f <_Z8printfmtPFviPvES_PKcz>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  800c2f:	55                   	push   %ebp
  800c30:	89 e5                	mov    %esp,%ebp
  800c32:	83 ec 18             	sub    $0x18,%esp
	va_list ap;

	va_start(ap, fmt);
  800c35:	8d 45 14             	lea    0x14(%ebp),%eax
	vprintfmt(putch, putdat, fmt, ap);
  800c38:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800c3c:	8b 45 10             	mov    0x10(%ebp),%eax
  800c3f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800c43:	8b 45 0c             	mov    0xc(%ebp),%eax
  800c46:	89 44 24 04          	mov    %eax,0x4(%esp)
  800c4a:	8b 45 08             	mov    0x8(%ebp),%eax
  800c4d:	89 04 24             	mov    %eax,(%esp)
  800c50:	e8 02 00 00 00       	call   800c57 <_Z9vprintfmtPFviPvES_PKcPc>
	va_end(ap);
}
  800c55:	c9                   	leave  
  800c56:	c3                   	ret    

00800c57 <_Z9vprintfmtPFviPvES_PKcPc>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800c57:	55                   	push   %ebp
  800c58:	89 e5                	mov    %esp,%ebp
  800c5a:	57                   	push   %edi
  800c5b:	56                   	push   %esi
  800c5c:	53                   	push   %ebx
  800c5d:	83 ec 3c             	sub    $0x3c,%esp
  800c60:	8b 7d 0c             	mov    0xc(%ebp),%edi
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800c63:	8b 55 10             	mov    0x10(%ebp),%edx
  800c66:	0f b6 02             	movzbl (%edx),%eax
  800c69:	89 d3                	mov    %edx,%ebx
  800c6b:	83 c3 01             	add    $0x1,%ebx
  800c6e:	83 f8 25             	cmp    $0x25,%eax
  800c71:	74 2b                	je     800c9e <_Z9vprintfmtPFviPvES_PKcPc+0x47>
			if (ch == '\0')
  800c73:	85 c0                	test   %eax,%eax
  800c75:	75 10                	jne    800c87 <_Z9vprintfmtPFviPvES_PKcPc+0x30>
  800c77:	e9 a5 03 00 00       	jmp    801021 <_Z9vprintfmtPFviPvES_PKcPc+0x3ca>
  800c7c:	85 c0                	test   %eax,%eax
  800c7e:	66 90                	xchg   %ax,%ax
  800c80:	75 08                	jne    800c8a <_Z9vprintfmtPFviPvES_PKcPc+0x33>
  800c82:	e9 9a 03 00 00       	jmp    801021 <_Z9vprintfmtPFviPvES_PKcPc+0x3ca>
  800c87:	8b 75 08             	mov    0x8(%ebp),%esi
				return;
			putch(ch, putdat);
  800c8a:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800c8e:	89 04 24             	mov    %eax,(%esp)
  800c91:	ff d6                	call   *%esi
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800c93:	0f b6 03             	movzbl (%ebx),%eax
  800c96:	83 c3 01             	add    $0x1,%ebx
  800c99:	83 f8 25             	cmp    $0x25,%eax
  800c9c:	75 de                	jne    800c7c <_Z9vprintfmtPFviPvES_PKcPc+0x25>
			precision = va_arg(ap, int);
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
  800c9e:	c6 45 e0 20          	movb   $0x20,-0x20(%ebp)
  800ca2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  800ca9:	be ff ff ff ff       	mov    $0xffffffff,%esi
  800cae:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
  800cb5:	b9 00 00 00 00       	mov    $0x0,%ecx
  800cba:	89 75 d8             	mov    %esi,-0x28(%ebp)
  800cbd:	eb 2b                	jmp    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800cbf:	8b 5d 10             	mov    0x10(%ebp),%ebx

		// flag to pad on the right
		case '-':
			padc = '-';
  800cc2:	c6 45 e0 2d          	movb   $0x2d,-0x20(%ebp)
  800cc6:	eb 22                	jmp    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800cc8:	8b 5d 10             	mov    0x10(%ebp),%ebx
			padc = '-';
			goto reswitch;

		// flag to pad with 0's instead of spaces
		case '0':
			padc = '0';
  800ccb:	c6 45 e0 30          	movb   $0x30,-0x20(%ebp)
  800ccf:	eb 19                	jmp    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800cd1:	8b 5d 10             	mov    0x10(%ebp),%ebx
			precision = va_arg(ap, int);
			goto process_precision;

		case '.':
			if (width < 0)
				width = 0;
  800cd4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  800cdb:	eb 0d                	jmp    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
				width = precision, precision = -1;
  800cdd:	8b 75 d8             	mov    -0x28(%ebp),%esi
  800ce0:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  800ce3:	c7 45 d8 ff ff ff ff 	movl   $0xffffffff,-0x28(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800cea:	0f b6 03             	movzbl (%ebx),%eax
  800ced:	0f b6 d0             	movzbl %al,%edx
  800cf0:	8d 73 01             	lea    0x1(%ebx),%esi
  800cf3:	89 75 10             	mov    %esi,0x10(%ebp)
  800cf6:	83 e8 23             	sub    $0x23,%eax
  800cf9:	3c 55                	cmp    $0x55,%al
  800cfb:	0f 87 d8 02 00 00    	ja     800fd9 <_Z9vprintfmtPFviPvES_PKcPc+0x382>
  800d01:	0f b6 c0             	movzbl %al,%eax
  800d04:	ff 24 85 00 47 81 00 	jmp    *0x814700(,%eax,4)
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  800d0b:	83 ea 30             	sub    $0x30,%edx
  800d0e:	89 55 d8             	mov    %edx,-0x28(%ebp)
				ch = *fmt;
  800d11:	8b 55 10             	mov    0x10(%ebp),%edx
  800d14:	0f be 02             	movsbl (%edx),%eax
				if (ch < '0' || ch > '9')
  800d17:	8d 50 d0             	lea    -0x30(%eax),%edx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800d1a:	8b 5d 10             	mov    0x10(%ebp),%ebx
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
				ch = *fmt;
				if (ch < '0' || ch > '9')
  800d1d:	83 fa 09             	cmp    $0x9,%edx
  800d20:	77 4e                	ja     800d70 <_Z9vprintfmtPFviPvES_PKcPc+0x119>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800d22:	8b 75 d8             	mov    -0x28(%ebp),%esi
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800d25:	83 c3 01             	add    $0x1,%ebx
				precision = precision * 10 + ch - '0';
  800d28:	8d 14 b6             	lea    (%esi,%esi,4),%edx
  800d2b:	8d 74 50 d0          	lea    -0x30(%eax,%edx,2),%esi
				ch = *fmt;
  800d2f:	0f be 03             	movsbl (%ebx),%eax
				if (ch < '0' || ch > '9')
  800d32:	8d 50 d0             	lea    -0x30(%eax),%edx
  800d35:	83 fa 09             	cmp    $0x9,%edx
  800d38:	76 eb                	jbe    800d25 <_Z9vprintfmtPFviPvES_PKcPc+0xce>
  800d3a:	89 75 d8             	mov    %esi,-0x28(%ebp)
  800d3d:	eb 31                	jmp    800d70 <_Z9vprintfmtPFviPvES_PKcPc+0x119>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800d3f:	8b 45 14             	mov    0x14(%ebp),%eax
  800d42:	8d 50 04             	lea    0x4(%eax),%edx
  800d45:	89 55 14             	mov    %edx,0x14(%ebp)
  800d48:	8b 00                	mov    (%eax),%eax
  800d4a:	89 45 d8             	mov    %eax,-0x28(%ebp)
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800d4d:	8b 5d 10             	mov    0x10(%ebp),%ebx
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
			goto process_precision;
  800d50:	eb 1e                	jmp    800d70 <_Z9vprintfmtPFviPvES_PKcPc+0x119>

		case '.':
			if (width < 0)
  800d52:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  800d56:	0f 88 75 ff ff ff    	js     800cd1 <_Z9vprintfmtPFviPvES_PKcPc+0x7a>
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800d5c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  800d5f:	eb 89                	jmp    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>
  800d61:	8b 5d 10             	mov    0x10(%ebp),%ebx
			if (width < 0)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
  800d64:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
			goto reswitch;
  800d6b:	e9 7a ff ff ff       	jmp    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>

		process_precision:
			if (width < 0)
  800d70:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  800d74:	0f 89 70 ff ff ff    	jns    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>
  800d7a:	e9 5e ff ff ff       	jmp    800cdd <_Z9vprintfmtPFviPvES_PKcPc+0x86>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800d7f:	83 c1 01             	add    $0x1,%ecx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800d82:	8b 5d 10             	mov    0x10(%ebp),%ebx
  800d85:	e9 60 ff ff ff       	jmp    800cea <_Z9vprintfmtPFviPvES_PKcPc+0x93>
			lflag++;
			goto reswitch;

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800d8a:	8b 45 14             	mov    0x14(%ebp),%eax
  800d8d:	8d 50 04             	lea    0x4(%eax),%edx
  800d90:	89 55 14             	mov    %edx,0x14(%ebp)
  800d93:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800d97:	8b 00                	mov    (%eax),%eax
  800d99:	89 04 24             	mov    %eax,(%esp)
  800d9c:	ff 55 08             	call   *0x8(%ebp)
			break;
  800d9f:	e9 bf fe ff ff       	jmp    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>

		// error message
		case 'e':
			err = va_arg(ap, int);
  800da4:	8b 45 14             	mov    0x14(%ebp),%eax
  800da7:	8d 50 04             	lea    0x4(%eax),%edx
  800daa:	89 55 14             	mov    %edx,0x14(%ebp)
  800dad:	8b 00                	mov    (%eax),%eax
  800daf:	89 c2                	mov    %eax,%edx
  800db1:	c1 fa 1f             	sar    $0x1f,%edx
  800db4:	31 d0                	xor    %edx,%eax
  800db6:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
  800db8:	83 f8 14             	cmp    $0x14,%eax
  800dbb:	7f 0f                	jg     800dcc <_Z9vprintfmtPFviPvES_PKcPc+0x175>
  800dbd:	8b 14 85 60 48 81 00 	mov    0x814860(,%eax,4),%edx
  800dc4:	85 d2                	test   %edx,%edx
  800dc6:	0f 85 35 02 00 00    	jne    801001 <_Z9vprintfmtPFviPvES_PKcPc+0x3aa>
				printfmt(putch, putdat, "error %d", err);
  800dcc:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800dd0:	c7 44 24 08 6f 45 81 	movl   $0x81456f,0x8(%esp)
  800dd7:	00 
  800dd8:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800ddc:	8b 75 08             	mov    0x8(%ebp),%esi
  800ddf:	89 34 24             	mov    %esi,(%esp)
  800de2:	e8 48 fe ff ff       	call   800c2f <_Z8printfmtPFviPvES_PKcz>
  800de7:	e9 77 fe ff ff       	jmp    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>
  800dec:	8b 75 d8             	mov    -0x28(%ebp),%esi
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800def:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800df2:	89 45 d8             	mov    %eax,-0x28(%ebp)
				printfmt(putch, putdat, "%s", p);
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800df5:	8b 45 14             	mov    0x14(%ebp),%eax
  800df8:	8d 50 04             	lea    0x4(%eax),%edx
  800dfb:	89 55 14             	mov    %edx,0x14(%ebp)
  800dfe:	8b 18                	mov    (%eax),%ebx
				p = "(null)";
  800e00:	85 db                	test   %ebx,%ebx
  800e02:	ba 68 45 81 00       	mov    $0x814568,%edx
  800e07:	0f 44 da             	cmove  %edx,%ebx
			if (width > 0 && padc != '-')
  800e0a:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  800e0e:	7e 72                	jle    800e82 <_Z9vprintfmtPFviPvES_PKcPc+0x22b>
  800e10:	80 7d e0 2d          	cmpb   $0x2d,-0x20(%ebp)
  800e14:	74 6c                	je     800e82 <_Z9vprintfmtPFviPvES_PKcPc+0x22b>
				for (width -= strnlen(p, precision); width > 0; width--)
  800e16:	89 74 24 04          	mov    %esi,0x4(%esp)
  800e1a:	89 1c 24             	mov    %ebx,(%esp)
  800e1d:	e8 a9 02 00 00       	call   8010cb <_Z7strnlenPKcj>
  800e22:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800e25:	29 c2                	sub    %eax,%edx
  800e27:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  800e2a:	85 d2                	test   %edx,%edx
  800e2c:	7e 54                	jle    800e82 <_Z9vprintfmtPFviPvES_PKcPc+0x22b>
					putch(padc, putdat);
  800e2e:	0f be 45 e0          	movsbl -0x20(%ebp),%eax
  800e32:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  800e35:	89 d3                	mov    %edx,%ebx
  800e37:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  800e3a:	89 c6                	mov    %eax,%esi
  800e3c:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e40:	89 34 24             	mov    %esi,(%esp)
  800e43:	ff 55 08             	call   *0x8(%ebp)
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800e46:	83 eb 01             	sub    $0x1,%ebx
  800e49:	85 db                	test   %ebx,%ebx
  800e4b:	7f ef                	jg     800e3c <_Z9vprintfmtPFviPvES_PKcPc+0x1e5>
  800e4d:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  800e50:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  800e53:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  800e5a:	eb 26                	jmp    800e82 <_Z9vprintfmtPFviPvES_PKcPc+0x22b>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800e5c:	8d 50 e0             	lea    -0x20(%eax),%edx
  800e5f:	83 fa 5e             	cmp    $0x5e,%edx
  800e62:	76 10                	jbe    800e74 <_Z9vprintfmtPFviPvES_PKcPc+0x21d>
					putch('?', putdat);
  800e64:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e68:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  800e6f:	ff 55 08             	call   *0x8(%ebp)
  800e72:	eb 0a                	jmp    800e7e <_Z9vprintfmtPFviPvES_PKcPc+0x227>
				else
					putch(ch, putdat);
  800e74:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e78:	89 04 24             	mov    %eax,(%esp)
  800e7b:	ff 55 08             	call   *0x8(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e7e:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
  800e82:	0f be 03             	movsbl (%ebx),%eax
  800e85:	83 c3 01             	add    $0x1,%ebx
  800e88:	85 c0                	test   %eax,%eax
  800e8a:	74 11                	je     800e9d <_Z9vprintfmtPFviPvES_PKcPc+0x246>
  800e8c:	85 f6                	test   %esi,%esi
  800e8e:	78 05                	js     800e95 <_Z9vprintfmtPFviPvES_PKcPc+0x23e>
  800e90:	83 ee 01             	sub    $0x1,%esi
  800e93:	78 0d                	js     800ea2 <_Z9vprintfmtPFviPvES_PKcPc+0x24b>
				if (altflag && (ch < ' ' || ch > '~'))
  800e95:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  800e99:	75 c1                	jne    800e5c <_Z9vprintfmtPFviPvES_PKcPc+0x205>
  800e9b:	eb d7                	jmp    800e74 <_Z9vprintfmtPFviPvES_PKcPc+0x21d>
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e9d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800ea0:	eb 03                	jmp    800ea5 <_Z9vprintfmtPFviPvES_PKcPc+0x24e>
  800ea2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800ea5:	85 c0                	test   %eax,%eax
  800ea7:	0f 8e b6 fd ff ff    	jle    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>
  800ead:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  800eb0:	8b 75 08             	mov    0x8(%ebp),%esi
				putch(' ', putdat);
  800eb3:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800eb7:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  800ebe:	ff d6                	call   *%esi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800ec0:	83 eb 01             	sub    $0x1,%ebx
  800ec3:	85 db                	test   %ebx,%ebx
  800ec5:	7f ec                	jg     800eb3 <_Z9vprintfmtPFviPvES_PKcPc+0x25c>
  800ec7:	e9 97 fd ff ff       	jmp    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  800ecc:	83 f9 01             	cmp    $0x1,%ecx
  800ecf:	90                   	nop
  800ed0:	7e 10                	jle    800ee2 <_Z9vprintfmtPFviPvES_PKcPc+0x28b>
		return va_arg(*ap, long long);
  800ed2:	8b 45 14             	mov    0x14(%ebp),%eax
  800ed5:	8d 50 08             	lea    0x8(%eax),%edx
  800ed8:	89 55 14             	mov    %edx,0x14(%ebp)
  800edb:	8b 18                	mov    (%eax),%ebx
  800edd:	8b 70 04             	mov    0x4(%eax),%esi
  800ee0:	eb 26                	jmp    800f08 <_Z9vprintfmtPFviPvES_PKcPc+0x2b1>
	else if (lflag)
  800ee2:	85 c9                	test   %ecx,%ecx
  800ee4:	74 12                	je     800ef8 <_Z9vprintfmtPFviPvES_PKcPc+0x2a1>
		return va_arg(*ap, long);
  800ee6:	8b 45 14             	mov    0x14(%ebp),%eax
  800ee9:	8d 50 04             	lea    0x4(%eax),%edx
  800eec:	89 55 14             	mov    %edx,0x14(%ebp)
  800eef:	8b 18                	mov    (%eax),%ebx
  800ef1:	89 de                	mov    %ebx,%esi
  800ef3:	c1 fe 1f             	sar    $0x1f,%esi
  800ef6:	eb 10                	jmp    800f08 <_Z9vprintfmtPFviPvES_PKcPc+0x2b1>
	else
		return va_arg(*ap, int);
  800ef8:	8b 45 14             	mov    0x14(%ebp),%eax
  800efb:	8d 50 04             	lea    0x4(%eax),%edx
  800efe:	89 55 14             	mov    %edx,0x14(%ebp)
  800f01:	8b 18                	mov    (%eax),%ebx
  800f03:	89 de                	mov    %ebx,%esi
  800f05:	c1 fe 1f             	sar    $0x1f,%esi
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
				putch('-', putdat);
				num = -(long long) num;
			}
			base = 10;
  800f08:	b8 0a 00 00 00       	mov    $0xa,%eax
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
			if ((long long) num < 0) {
  800f0d:	85 f6                	test   %esi,%esi
  800f0f:	0f 89 8c 00 00 00    	jns    800fa1 <_Z9vprintfmtPFviPvES_PKcPc+0x34a>
				putch('-', putdat);
  800f15:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800f19:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  800f20:	ff 55 08             	call   *0x8(%ebp)
				num = -(long long) num;
  800f23:	f7 db                	neg    %ebx
  800f25:	83 d6 00             	adc    $0x0,%esi
  800f28:	f7 de                	neg    %esi
			}
			base = 10;
  800f2a:	b8 0a 00 00 00       	mov    $0xa,%eax
  800f2f:	eb 70                	jmp    800fa1 <_Z9vprintfmtPFviPvES_PKcPc+0x34a>
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800f31:	89 ca                	mov    %ecx,%edx
  800f33:	8d 45 14             	lea    0x14(%ebp),%eax
  800f36:	e8 9d fc ff ff       	call   800bd8 <_ZL7getuintPPci>
  800f3b:	89 c3                	mov    %eax,%ebx
  800f3d:	89 d6                	mov    %edx,%esi
			base = 10;
  800f3f:	b8 0a 00 00 00       	mov    $0xa,%eax
			goto number;
  800f44:	eb 5b                	jmp    800fa1 <_Z9vprintfmtPFviPvES_PKcPc+0x34a>

		// (unsigned) octal
		case 'o':
			num = getuint(&ap, lflag);
  800f46:	89 ca                	mov    %ecx,%edx
  800f48:	8d 45 14             	lea    0x14(%ebp),%eax
  800f4b:	e8 88 fc ff ff       	call   800bd8 <_ZL7getuintPPci>
  800f50:	89 c3                	mov    %eax,%ebx
  800f52:	89 d6                	mov    %edx,%esi
			base = 8;
  800f54:	b8 08 00 00 00       	mov    $0x8,%eax
			goto number;
  800f59:	eb 46                	jmp    800fa1 <_Z9vprintfmtPFviPvES_PKcPc+0x34a>

		// pointer
		case 'p':
			putch('0', putdat);
  800f5b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800f5f:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  800f66:	ff 55 08             	call   *0x8(%ebp)
			putch('x', putdat);
  800f69:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800f6d:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  800f74:	ff 55 08             	call   *0x8(%ebp)
			num = (unsigned long long)
				(uintptr_t) va_arg(ap, void *);
  800f77:	8b 45 14             	mov    0x14(%ebp),%eax
  800f7a:	8d 50 04             	lea    0x4(%eax),%edx
  800f7d:	89 55 14             	mov    %edx,0x14(%ebp)
  800f80:	8b 18                	mov    (%eax),%ebx
  800f82:	be 00 00 00 00       	mov    $0x0,%esi
			base = 16;
  800f87:	b8 10 00 00 00       	mov    $0x10,%eax
			goto number;
  800f8c:	eb 13                	jmp    800fa1 <_Z9vprintfmtPFviPvES_PKcPc+0x34a>

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  800f8e:	89 ca                	mov    %ecx,%edx
  800f90:	8d 45 14             	lea    0x14(%ebp),%eax
  800f93:	e8 40 fc ff ff       	call   800bd8 <_ZL7getuintPPci>
  800f98:	89 c3                	mov    %eax,%ebx
  800f9a:	89 d6                	mov    %edx,%esi
			base = 16;
  800f9c:	b8 10 00 00 00       	mov    $0x10,%eax
		number:
			printnum(putch, putdat, num, base, width, padc);
  800fa1:	0f be 55 e0          	movsbl -0x20(%ebp),%edx
  800fa5:	89 54 24 10          	mov    %edx,0x10(%esp)
  800fa9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800fac:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800fb0:	89 44 24 08          	mov    %eax,0x8(%esp)
  800fb4:	89 1c 24             	mov    %ebx,(%esp)
  800fb7:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fbb:	89 fa                	mov    %edi,%edx
  800fbd:	8b 45 08             	mov    0x8(%ebp),%eax
  800fc0:	e8 2b fb ff ff       	call   800af0 <_ZL8printnumPFviPvES_yjii>
			break;
  800fc5:	e9 99 fc ff ff       	jmp    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  800fca:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800fce:	89 14 24             	mov    %edx,(%esp)
  800fd1:	ff 55 08             	call   *0x8(%ebp)
			break;
  800fd4:	e9 8a fc ff ff       	jmp    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>

		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  800fd9:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800fdd:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  800fe4:	ff 55 08             	call   *0x8(%ebp)
			for (fmt--; fmt[-1] != '%'; fmt--)
  800fe7:	89 5d 10             	mov    %ebx,0x10(%ebp)
  800fea:	89 d8                	mov    %ebx,%eax
  800fec:	eb 02                	jmp    800ff0 <_Z9vprintfmtPFviPvES_PKcPc+0x399>
  800fee:	89 d0                	mov    %edx,%eax
  800ff0:	8d 50 ff             	lea    -0x1(%eax),%edx
  800ff3:	80 78 ff 25          	cmpb   $0x25,-0x1(%eax)
  800ff7:	75 f5                	jne    800fee <_Z9vprintfmtPFviPvES_PKcPc+0x397>
  800ff9:	89 45 10             	mov    %eax,0x10(%ebp)
  800ffc:	e9 62 fc ff ff       	jmp    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  801001:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801005:	c7 44 24 08 9d 49 81 	movl   $0x81499d,0x8(%esp)
  80100c:	00 
  80100d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801011:	8b 75 08             	mov    0x8(%ebp),%esi
  801014:	89 34 24             	mov    %esi,(%esp)
  801017:	e8 13 fc ff ff       	call   800c2f <_Z8printfmtPFviPvES_PKcz>
  80101c:	e9 42 fc ff ff       	jmp    800c63 <_Z9vprintfmtPFviPvES_PKcPc+0xc>
			for (fmt--; fmt[-1] != '%'; fmt--)
				/* do nothing */;
			break;
		}
	}
}
  801021:	83 c4 3c             	add    $0x3c,%esp
  801024:	5b                   	pop    %ebx
  801025:	5e                   	pop    %esi
  801026:	5f                   	pop    %edi
  801027:	5d                   	pop    %ebp
  801028:	c3                   	ret    

00801029 <_Z9vsnprintfPciPKcS_>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801029:	55                   	push   %ebp
  80102a:	89 e5                	mov    %esp,%ebp
  80102c:	83 ec 28             	sub    $0x28,%esp
  80102f:	8b 45 08             	mov    0x8(%ebp),%eax
  801032:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};
  801035:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  80103c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  80103f:	8d 4c 10 ff          	lea    -0x1(%eax,%edx,1),%ecx
  801043:	89 4d f0             	mov    %ecx,-0x10(%ebp)

	if (buf == NULL || n < 1)
  801046:	85 c0                	test   %eax,%eax
  801048:	74 30                	je     80107a <_Z9vsnprintfPciPKcS_+0x51>
  80104a:	85 d2                	test   %edx,%edx
  80104c:	7e 2c                	jle    80107a <_Z9vsnprintfPciPKcS_+0x51>
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt(sprintputch, &b, fmt, ap);
  80104e:	8b 45 14             	mov    0x14(%ebp),%eax
  801051:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801055:	8b 45 10             	mov    0x10(%ebp),%eax
  801058:	89 44 24 08          	mov    %eax,0x8(%esp)
  80105c:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80105f:	89 44 24 04          	mov    %eax,0x4(%esp)
  801063:	c7 04 24 12 0c 80 00 	movl   $0x800c12,(%esp)
  80106a:	e8 e8 fb ff ff       	call   800c57 <_Z9vprintfmtPFviPvES_PKcPc>

	// null terminate the buffer
	*b.buf = '\0';
  80106f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  801072:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  801075:	8b 45 f4             	mov    -0xc(%ebp),%eax
  801078:	eb 05                	jmp    80107f <_Z9vsnprintfPciPKcS_+0x56>
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
		return -E_INVAL;
  80107a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax

	// null terminate the buffer
	*b.buf = '\0';

	return b.cnt;
}
  80107f:	c9                   	leave  
  801080:	c3                   	ret    

00801081 <_Z8snprintfPciPKcz>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  801081:	55                   	push   %ebp
  801082:	89 e5                	mov    %esp,%ebp
  801084:	83 ec 18             	sub    $0x18,%esp
	va_list ap;
	int rc;

	va_start(ap, fmt);
  801087:	8d 45 14             	lea    0x14(%ebp),%eax
	rc = vsnprintf(buf, n, fmt, ap);
  80108a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80108e:	8b 45 10             	mov    0x10(%ebp),%eax
  801091:	89 44 24 08          	mov    %eax,0x8(%esp)
  801095:	8b 45 0c             	mov    0xc(%ebp),%eax
  801098:	89 44 24 04          	mov    %eax,0x4(%esp)
  80109c:	8b 45 08             	mov    0x8(%ebp),%eax
  80109f:	89 04 24             	mov    %eax,(%esp)
  8010a2:	e8 82 ff ff ff       	call   801029 <_Z9vsnprintfPciPKcS_>
	va_end(ap);

	return rc;
}
  8010a7:	c9                   	leave  
  8010a8:	c3                   	ret    
  8010a9:	00 00                	add    %al,(%eax)
  8010ab:	00 00                	add    %al,(%eax)
  8010ad:	00 00                	add    %al,(%eax)
	...

008010b0 <_Z6strlenPKc>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  8010b0:	55                   	push   %ebp
  8010b1:	89 e5                	mov    %esp,%ebp
  8010b3:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  8010b6:	b8 00 00 00 00       	mov    $0x0,%eax
  8010bb:	80 3a 00             	cmpb   $0x0,(%edx)
  8010be:	74 09                	je     8010c9 <_Z6strlenPKc+0x19>
		n++;
  8010c0:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  8010c3:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  8010c7:	75 f7                	jne    8010c0 <_Z6strlenPKc+0x10>
		n++;
	return n;
}
  8010c9:	5d                   	pop    %ebp
  8010ca:	c3                   	ret    

008010cb <_Z7strnlenPKcj>:

int
strnlen(const char *s, size_t size)
{
  8010cb:	55                   	push   %ebp
  8010cc:	89 e5                	mov    %esp,%ebp
  8010ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8010d1:	8b 55 0c             	mov    0xc(%ebp),%edx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  8010d4:	b8 00 00 00 00       	mov    $0x0,%eax
  8010d9:	39 c2                	cmp    %eax,%edx
  8010db:	74 0b                	je     8010e8 <_Z7strnlenPKcj+0x1d>
  8010dd:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
  8010e1:	74 05                	je     8010e8 <_Z7strnlenPKcj+0x1d>
		n++;
  8010e3:	83 c0 01             	add    $0x1,%eax
  8010e6:	eb f1                	jmp    8010d9 <_Z7strnlenPKcj+0xe>
	return n;
}
  8010e8:	5d                   	pop    %ebp
  8010e9:	c3                   	ret    

008010ea <_Z6strcpyPcPKc>:

char *
strcpy(char *dst, const char *src)
{
  8010ea:	55                   	push   %ebp
  8010eb:	89 e5                	mov    %esp,%ebp
  8010ed:	53                   	push   %ebx
  8010ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8010f1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	char *ret = dst;

	while ((*dst++ = *src++) != '\0')
  8010f4:	ba 00 00 00 00       	mov    $0x0,%edx
  8010f9:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  8010fd:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  801100:	83 c2 01             	add    $0x1,%edx
  801103:	84 c9                	test   %cl,%cl
  801105:	75 f2                	jne    8010f9 <_Z6strcpyPcPKc+0xf>
		/* do nothing */;
	return ret;
}
  801107:	5b                   	pop    %ebx
  801108:	5d                   	pop    %ebp
  801109:	c3                   	ret    

0080110a <_Z7strncpyPcPKcj>:

char *
strncpy(char *dst, const char *src, size_t size)
{
  80110a:	55                   	push   %ebp
  80110b:	89 e5                	mov    %esp,%ebp
  80110d:	56                   	push   %esi
  80110e:	53                   	push   %ebx
  80110f:	8b 45 08             	mov    0x8(%ebp),%eax
  801112:	8b 55 0c             	mov    0xc(%ebp),%edx
  801115:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret = dst;

	for (i = 0; i < size; i++) {
  801118:	85 f6                	test   %esi,%esi
  80111a:	74 18                	je     801134 <_Z7strncpyPcPKcj+0x2a>
  80111c:	b9 00 00 00 00       	mov    $0x0,%ecx
		*dst++ = *src;
  801121:	0f b6 1a             	movzbl (%edx),%ebx
  801124:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  801127:	80 3a 01             	cmpb   $0x1,(%edx)
  80112a:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size)
{
	size_t i;
	char *ret = dst;

	for (i = 0; i < size; i++) {
  80112d:	83 c1 01             	add    $0x1,%ecx
  801130:	39 ce                	cmp    %ecx,%esi
  801132:	77 ed                	ja     801121 <_Z7strncpyPcPKcj+0x17>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  801134:	5b                   	pop    %ebx
  801135:	5e                   	pop    %esi
  801136:	5d                   	pop    %ebp
  801137:	c3                   	ret    

00801138 <_Z7strlcpyPcPKcj>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  801138:	55                   	push   %ebp
  801139:	89 e5                	mov    %esp,%ebp
  80113b:	56                   	push   %esi
  80113c:	53                   	push   %ebx
  80113d:	8b 75 08             	mov    0x8(%ebp),%esi
  801140:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801143:	8b 55 10             	mov    0x10(%ebp),%edx
	char *dst_in = dst;

	if (size > 0) {
  801146:	89 f0                	mov    %esi,%eax
  801148:	85 d2                	test   %edx,%edx
  80114a:	74 17                	je     801163 <_Z7strlcpyPcPKcj+0x2b>
		while (--size > 0 && *src != '\0')
  80114c:	83 ea 01             	sub    $0x1,%edx
  80114f:	74 18                	je     801169 <_Z7strlcpyPcPKcj+0x31>
  801151:	80 39 00             	cmpb   $0x0,(%ecx)
  801154:	74 17                	je     80116d <_Z7strlcpyPcPKcj+0x35>
			*dst++ = *src++;
  801156:	0f b6 19             	movzbl (%ecx),%ebx
  801159:	88 18                	mov    %bl,(%eax)
  80115b:	83 c0 01             	add    $0x1,%eax
  80115e:	83 c1 01             	add    $0x1,%ecx
  801161:	eb e9                	jmp    80114c <_Z7strlcpyPcPKcj+0x14>
		*dst = '\0';
	}
	return dst - dst_in;
  801163:	29 f0                	sub    %esi,%eax
}
  801165:	5b                   	pop    %ebx
  801166:	5e                   	pop    %esi
  801167:	5d                   	pop    %ebp
  801168:	c3                   	ret    
strlcpy(char *dst, const char *src, size_t size)
{
	char *dst_in = dst;

	if (size > 0) {
		while (--size > 0 && *src != '\0')
  801169:	89 c2                	mov    %eax,%edx
  80116b:	eb 02                	jmp    80116f <_Z7strlcpyPcPKcj+0x37>
  80116d:	89 c2                	mov    %eax,%edx
			*dst++ = *src++;
		*dst = '\0';
  80116f:	c6 02 00             	movb   $0x0,(%edx)
  801172:	eb ef                	jmp    801163 <_Z7strlcpyPcPKcj+0x2b>

00801174 <_Z6strcmpPKcS0_>:
	return dst - dst_in;
}

int
strcmp(const char *p, const char *q)
{
  801174:	55                   	push   %ebp
  801175:	89 e5                	mov    %esp,%ebp
  801177:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80117a:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  80117d:	0f b6 01             	movzbl (%ecx),%eax
  801180:	84 c0                	test   %al,%al
  801182:	74 0c                	je     801190 <_Z6strcmpPKcS0_+0x1c>
  801184:	3a 02                	cmp    (%edx),%al
  801186:	75 08                	jne    801190 <_Z6strcmpPKcS0_+0x1c>
		p++, q++;
  801188:	83 c1 01             	add    $0x1,%ecx
  80118b:	83 c2 01             	add    $0x1,%edx
  80118e:	eb ed                	jmp    80117d <_Z6strcmpPKcS0_+0x9>
	return (unsigned char) *p - (unsigned char) *q;
  801190:	0f b6 c0             	movzbl %al,%eax
  801193:	0f b6 12             	movzbl (%edx),%edx
  801196:	29 d0                	sub    %edx,%eax
}
  801198:	5d                   	pop    %ebp
  801199:	c3                   	ret    

0080119a <_Z7strncmpPKcS0_j>:

int
strncmp(const char *p, const char *q, size_t n)
{
  80119a:	55                   	push   %ebp
  80119b:	89 e5                	mov    %esp,%ebp
  80119d:	53                   	push   %ebx
  80119e:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011a1:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8011a4:	8b 55 10             	mov    0x10(%ebp),%edx
	while (n > 0 && *p && *p == *q)
  8011a7:	85 d2                	test   %edx,%edx
  8011a9:	74 16                	je     8011c1 <_Z7strncmpPKcS0_j+0x27>
  8011ab:	0f b6 01             	movzbl (%ecx),%eax
  8011ae:	84 c0                	test   %al,%al
  8011b0:	74 17                	je     8011c9 <_Z7strncmpPKcS0_j+0x2f>
  8011b2:	3a 03                	cmp    (%ebx),%al
  8011b4:	75 13                	jne    8011c9 <_Z7strncmpPKcS0_j+0x2f>
		n--, p++, q++;
  8011b6:	83 ea 01             	sub    $0x1,%edx
  8011b9:	83 c1 01             	add    $0x1,%ecx
  8011bc:	83 c3 01             	add    $0x1,%ebx
  8011bf:	eb e6                	jmp    8011a7 <_Z7strncmpPKcS0_j+0xd>
	if (n == 0)
		return 0;
  8011c1:	b8 00 00 00 00       	mov    $0x0,%eax
	else
		return (unsigned char) *p - (unsigned char) *q;
}
  8011c6:	5b                   	pop    %ebx
  8011c7:	5d                   	pop    %ebp
  8011c8:	c3                   	ret    
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (unsigned char) *p - (unsigned char) *q;
  8011c9:	0f b6 01             	movzbl (%ecx),%eax
  8011cc:	0f b6 13             	movzbl (%ebx),%edx
  8011cf:	29 d0                	sub    %edx,%eax
  8011d1:	eb f3                	jmp    8011c6 <_Z7strncmpPKcS0_j+0x2c>

008011d3 <_Z6strchrPKcc>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  8011d3:	55                   	push   %ebp
  8011d4:	89 e5                	mov    %esp,%ebp
  8011d6:	8b 45 08             	mov    0x8(%ebp),%eax
  8011d9:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  8011dd:	0f b6 10             	movzbl (%eax),%edx
  8011e0:	84 d2                	test   %dl,%dl
  8011e2:	74 1f                	je     801203 <_Z6strchrPKcc+0x30>
		if (*s == c)
  8011e4:	38 ca                	cmp    %cl,%dl
  8011e6:	75 0a                	jne    8011f2 <_Z6strchrPKcc+0x1f>
  8011e8:	eb 1e                	jmp    801208 <_Z6strchrPKcc+0x35>
  8011ea:	38 ca                	cmp    %cl,%dl
  8011ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8011f0:	74 16                	je     801208 <_Z6strchrPKcc+0x35>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  8011f2:	83 c0 01             	add    $0x1,%eax
  8011f5:	0f b6 10             	movzbl (%eax),%edx
  8011f8:	84 d2                	test   %dl,%dl
  8011fa:	75 ee                	jne    8011ea <_Z6strchrPKcc+0x17>
		if (*s == c)
			return (char *) s;
	return 0;
  8011fc:	b8 00 00 00 00       	mov    $0x0,%eax
  801201:	eb 05                	jmp    801208 <_Z6strchrPKcc+0x35>
  801203:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801208:	5d                   	pop    %ebp
  801209:	c3                   	ret    

0080120a <_Z7strfindPKcc>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80120a:	55                   	push   %ebp
  80120b:	89 e5                	mov    %esp,%ebp
  80120d:	8b 45 08             	mov    0x8(%ebp),%eax
  801210:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801214:	0f b6 10             	movzbl (%eax),%edx
  801217:	84 d2                	test   %dl,%dl
  801219:	74 14                	je     80122f <_Z7strfindPKcc+0x25>
		if (*s == c)
  80121b:	38 ca                	cmp    %cl,%dl
  80121d:	75 06                	jne    801225 <_Z7strfindPKcc+0x1b>
  80121f:	eb 0e                	jmp    80122f <_Z7strfindPKcc+0x25>
  801221:	38 ca                	cmp    %cl,%dl
  801223:	74 0a                	je     80122f <_Z7strfindPKcc+0x25>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  801225:	83 c0 01             	add    $0x1,%eax
  801228:	0f b6 10             	movzbl (%eax),%edx
  80122b:	84 d2                	test   %dl,%dl
  80122d:	75 f2                	jne    801221 <_Z7strfindPKcc+0x17>
		if (*s == c)
			break;
	return (char *) s;
}
  80122f:	5d                   	pop    %ebp
  801230:	c3                   	ret    

00801231 <memset>:

asmlinkage void *
memset(void *v, int c, size_t n)
{
  801231:	55                   	push   %ebp
  801232:	89 e5                	mov    %esp,%ebp
  801234:	83 ec 0c             	sub    $0xc,%esp
  801237:	89 1c 24             	mov    %ebx,(%esp)
  80123a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80123e:	89 7c 24 08          	mov    %edi,0x8(%esp)
  801242:	8b 7d 08             	mov    0x8(%ebp),%edi
  801245:	8b 45 0c             	mov    0xc(%ebp),%eax
  801248:	8b 4d 10             	mov    0x10(%ebp),%ecx
#if ASM
	if ((uintptr_t) v % 4 == 0 && n % 4 == 0) {
  80124b:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801251:	75 25                	jne    801278 <memset+0x47>
  801253:	f6 c1 03             	test   $0x3,%cl
  801256:	75 20                	jne    801278 <memset+0x47>
		c &= 0xFF;
  801258:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  80125b:	89 d3                	mov    %edx,%ebx
  80125d:	c1 e3 08             	shl    $0x8,%ebx
  801260:	89 d6                	mov    %edx,%esi
  801262:	c1 e6 18             	shl    $0x18,%esi
  801265:	89 d0                	mov    %edx,%eax
  801267:	c1 e0 10             	shl    $0x10,%eax
  80126a:	09 f0                	or     %esi,%eax
  80126c:	09 d0                	or     %edx,%eax
  80126e:	09 d8                	or     %ebx,%eax
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
  801270:	c1 e9 02             	shr    $0x2,%ecx
  801273:	fc                   	cld    
  801274:	f3 ab                	rep stos %eax,%es:(%edi)
  801276:	eb 03                	jmp    80127b <memset+0x4a>
	} else
		asm volatile("cld; rep stosb\n"
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
  801278:	fc                   	cld    
  801279:	f3 aa                	rep stos %al,%es:(%edi)
	while (n-- > 0)
		*p++ = c;
#endif

	return v;
}
  80127b:	89 f8                	mov    %edi,%eax
  80127d:	8b 1c 24             	mov    (%esp),%ebx
  801280:	8b 74 24 04          	mov    0x4(%esp),%esi
  801284:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801288:	89 ec                	mov    %ebp,%esp
  80128a:	5d                   	pop    %ebp
  80128b:	c3                   	ret    

0080128c <memmove>:

asmlinkage void *
memmove(void *dst, const void *src, size_t n)
{
  80128c:	55                   	push   %ebp
  80128d:	89 e5                	mov    %esp,%ebp
  80128f:	83 ec 08             	sub    $0x8,%esp
  801292:	89 34 24             	mov    %esi,(%esp)
  801295:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801299:	8b 45 08             	mov    0x8(%ebp),%eax
  80129c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80129f:	8b 4d 10             	mov    0x10(%ebp),%ecx
#if ASM
	const char *s = (const char *) src;
	char *d = (char *) dst;

	if (s < d && s + n > d) {
  8012a2:	39 c6                	cmp    %eax,%esi
  8012a4:	73 36                	jae    8012dc <memmove+0x50>
  8012a6:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  8012a9:	39 d0                	cmp    %edx,%eax
  8012ab:	73 2f                	jae    8012dc <memmove+0x50>
		s += n;
		d += n;
  8012ad:	8d 3c 08             	lea    (%eax,%ecx,1),%edi
		if ((uintptr_t) s % 4 == 0 && (uintptr_t) d % 4 == 0
  8012b0:	f6 c2 03             	test   $0x3,%dl
  8012b3:	75 1b                	jne    8012d0 <memmove+0x44>
  8012b5:	f7 c7 03 00 00 00    	test   $0x3,%edi
  8012bb:	75 13                	jne    8012d0 <memmove+0x44>
  8012bd:	f6 c1 03             	test   $0x3,%cl
  8012c0:	75 0e                	jne    8012d0 <memmove+0x44>
		    && n % 4 == 0)
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
  8012c2:	83 ef 04             	sub    $0x4,%edi
  8012c5:	8d 72 fc             	lea    -0x4(%edx),%esi
  8012c8:	c1 e9 02             	shr    $0x2,%ecx
  8012cb:	fd                   	std    
  8012cc:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  8012ce:	eb 09                	jmp    8012d9 <memmove+0x4d>
		else
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
  8012d0:	83 ef 01             	sub    $0x1,%edi
  8012d3:	8d 72 ff             	lea    -0x1(%edx),%esi
  8012d6:	fd                   	std    
  8012d7:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  8012d9:	fc                   	cld    
  8012da:	eb 20                	jmp    8012fc <memmove+0x70>
	} else {
		if ((uintptr_t) s % 4 == 0 && (uintptr_t) d % 4 == 0
  8012dc:	f7 c6 03 00 00 00    	test   $0x3,%esi
  8012e2:	75 13                	jne    8012f7 <memmove+0x6b>
  8012e4:	a8 03                	test   $0x3,%al
  8012e6:	75 0f                	jne    8012f7 <memmove+0x6b>
  8012e8:	f6 c1 03             	test   $0x3,%cl
  8012eb:	75 0a                	jne    8012f7 <memmove+0x6b>
		    && n % 4 == 0)
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  8012ed:	c1 e9 02             	shr    $0x2,%ecx
  8012f0:	89 c7                	mov    %eax,%edi
  8012f2:	fc                   	cld    
  8012f3:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  8012f5:	eb 05                	jmp    8012fc <memmove+0x70>
		else
			asm volatile("cld; rep movsb\n"
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
  8012f7:	89 c7                	mov    %eax,%edi
  8012f9:	fc                   	cld    
  8012fa:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
			*d++ = *s++;

#endif

	return dst;
}
  8012fc:	8b 34 24             	mov    (%esp),%esi
  8012ff:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801303:	89 ec                	mov    %ebp,%esp
  801305:	5d                   	pop    %ebp
  801306:	c3                   	ret    

00801307 <memcpy>:

asmlinkage void *
memcpy(void *dst, const void *src, size_t n)
{
  801307:	55                   	push   %ebp
  801308:	89 e5                	mov    %esp,%ebp
  80130a:	83 ec 08             	sub    $0x8,%esp
  80130d:	89 34 24             	mov    %esi,(%esp)
  801310:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801314:	8b 45 08             	mov    0x8(%ebp),%eax
  801317:	8b 75 0c             	mov    0xc(%ebp),%esi
  80131a:	8b 4d 10             	mov    0x10(%ebp),%ecx
#if ASM
	const char *s = (const char *) src;
	char *d = (char *) dst;

	if ((uintptr_t) s % 4 == 0 && (uintptr_t) d % 4 == 0
  80131d:	f7 c6 03 00 00 00    	test   $0x3,%esi
  801323:	75 13                	jne    801338 <memcpy+0x31>
  801325:	a8 03                	test   $0x3,%al
  801327:	75 0f                	jne    801338 <memcpy+0x31>
  801329:	f6 c1 03             	test   $0x3,%cl
  80132c:	75 0a                	jne    801338 <memcpy+0x31>
	    && n % 4 == 0)
		asm volatile("cld; rep movsl\n"
			:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
  80132e:	c1 e9 02             	shr    $0x2,%ecx
  801331:	89 c7                	mov    %eax,%edi
  801333:	fc                   	cld    
  801334:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
  801336:	eb 05                	jmp    80133d <memcpy+0x36>
	else
		asm volatile("cld; rep movsb\n"
			:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
  801338:	89 c7                	mov    %eax,%edi
  80133a:	fc                   	cld    
  80133b:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
	while (n-- > 0)
		*d++ = *s++;
#endif

	return dst;
}
  80133d:	8b 34 24             	mov    (%esp),%esi
  801340:	8b 7c 24 04          	mov    0x4(%esp),%edi
  801344:	89 ec                	mov    %ebp,%esp
  801346:	5d                   	pop    %ebp
  801347:	c3                   	ret    

00801348 <memcmp>:

asmlinkage int
memcmp(const void *v1, const void *v2, size_t n)
{
  801348:	55                   	push   %ebp
  801349:	89 e5                	mov    %esp,%ebp
  80134b:	57                   	push   %edi
  80134c:	56                   	push   %esi
  80134d:	53                   	push   %ebx
  80134e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801351:	8b 75 0c             	mov    0xc(%ebp),%esi
  801354:	8b 7d 10             	mov    0x10(%ebp),%edi
		if (*s1 != *s2)
			return *s1 - *s2;
		s1++, s2++;
	}

	return 0;
  801357:	b8 00 00 00 00       	mov    $0x0,%eax
memcmp(const void *v1, const void *v2, size_t n)
{
	const unsigned char *s1 = (const unsigned char *) v1;
	const unsigned char *s2 = (const unsigned char *) v2;

	while (n-- > 0) {
  80135c:	85 ff                	test   %edi,%edi
  80135e:	74 38                	je     801398 <memcmp+0x50>
		if (*s1 != *s2)
  801360:	0f b6 03             	movzbl (%ebx),%eax
  801363:	0f b6 0e             	movzbl (%esi),%ecx
memcmp(const void *v1, const void *v2, size_t n)
{
	const unsigned char *s1 = (const unsigned char *) v1;
	const unsigned char *s2 = (const unsigned char *) v2;

	while (n-- > 0) {
  801366:	83 ef 01             	sub    $0x1,%edi
  801369:	ba 00 00 00 00       	mov    $0x0,%edx
		if (*s1 != *s2)
  80136e:	38 c8                	cmp    %cl,%al
  801370:	74 1d                	je     80138f <memcmp+0x47>
  801372:	eb 11                	jmp    801385 <memcmp+0x3d>
  801374:	0f b6 44 13 01       	movzbl 0x1(%ebx,%edx,1),%eax
  801379:	0f b6 4c 16 01       	movzbl 0x1(%esi,%edx,1),%ecx
  80137e:	83 c2 01             	add    $0x1,%edx
  801381:	38 c8                	cmp    %cl,%al
  801383:	74 0a                	je     80138f <memcmp+0x47>
			return *s1 - *s2;
  801385:	0f b6 c0             	movzbl %al,%eax
  801388:	0f b6 c9             	movzbl %cl,%ecx
  80138b:	29 c8                	sub    %ecx,%eax
  80138d:	eb 09                	jmp    801398 <memcmp+0x50>
memcmp(const void *v1, const void *v2, size_t n)
{
	const unsigned char *s1 = (const unsigned char *) v1;
	const unsigned char *s2 = (const unsigned char *) v2;

	while (n-- > 0) {
  80138f:	39 fa                	cmp    %edi,%edx
  801391:	75 e1                	jne    801374 <memcmp+0x2c>
		if (*s1 != *s2)
			return *s1 - *s2;
		s1++, s2++;
	}

	return 0;
  801393:	b8 00 00 00 00       	mov    $0x0,%eax
}
  801398:	5b                   	pop    %ebx
  801399:	5e                   	pop    %esi
  80139a:	5f                   	pop    %edi
  80139b:	5d                   	pop    %ebp
  80139c:	c3                   	ret    

0080139d <memfind>:

asmlinkage void *
memfind(const void *v, int c, size_t n)
{
  80139d:	55                   	push   %ebp
  80139e:	89 e5                	mov    %esp,%ebp
  8013a0:	53                   	push   %ebx
  8013a1:	8b 5d 08             	mov    0x8(%ebp),%ebx
	const unsigned char *s = (const unsigned char *) v;
  8013a4:	89 d8                	mov    %ebx,%eax
	const unsigned char *ends = s + n;
  8013a6:	89 da                	mov    %ebx,%edx
  8013a8:	03 55 10             	add    0x10(%ebp),%edx

	for (; s < ends; s++)
  8013ab:	39 d3                	cmp    %edx,%ebx
  8013ad:	73 15                	jae    8013c4 <memfind+0x27>
		if (*s == (unsigned char) c)
  8013af:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
  8013b3:	38 0b                	cmp    %cl,(%ebx)
  8013b5:	75 06                	jne    8013bd <memfind+0x20>
  8013b7:	eb 0b                	jmp    8013c4 <memfind+0x27>
  8013b9:	38 08                	cmp    %cl,(%eax)
  8013bb:	74 07                	je     8013c4 <memfind+0x27>
memfind(const void *v, int c, size_t n)
{
	const unsigned char *s = (const unsigned char *) v;
	const unsigned char *ends = s + n;

	for (; s < ends; s++)
  8013bd:	83 c0 01             	add    $0x1,%eax
  8013c0:	39 c2                	cmp    %eax,%edx
  8013c2:	77 f5                	ja     8013b9 <memfind+0x1c>
		if (*s == (unsigned char) c)
			break;
	return (void *) s;
}
  8013c4:	5b                   	pop    %ebx
  8013c5:	5d                   	pop    %ebp
  8013c6:	c3                   	ret    

008013c7 <_Z6strtolPKcPPci>:

long
strtol(const char *s, char **endptr, int base)
{
  8013c7:	55                   	push   %ebp
  8013c8:	89 e5                	mov    %esp,%ebp
  8013ca:	57                   	push   %edi
  8013cb:	56                   	push   %esi
  8013cc:	53                   	push   %ebx
  8013cd:	8b 55 08             	mov    0x8(%ebp),%edx
  8013d0:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8013d3:	0f b6 02             	movzbl (%edx),%eax
  8013d6:	3c 20                	cmp    $0x20,%al
  8013d8:	74 04                	je     8013de <_Z6strtolPKcPPci+0x17>
  8013da:	3c 09                	cmp    $0x9,%al
  8013dc:	75 0e                	jne    8013ec <_Z6strtolPKcPPci+0x25>
		s++;
  8013de:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  8013e1:	0f b6 02             	movzbl (%edx),%eax
  8013e4:	3c 20                	cmp    $0x20,%al
  8013e6:	74 f6                	je     8013de <_Z6strtolPKcPPci+0x17>
  8013e8:	3c 09                	cmp    $0x9,%al
  8013ea:	74 f2                	je     8013de <_Z6strtolPKcPPci+0x17>
		s++;

	// plus/minus sign
	if (*s == '+')
  8013ec:	3c 2b                	cmp    $0x2b,%al
  8013ee:	75 0a                	jne    8013fa <_Z6strtolPKcPPci+0x33>
		s++;
  8013f0:	83 c2 01             	add    $0x1,%edx
}

long
strtol(const char *s, char **endptr, int base)
{
	int neg = 0;
  8013f3:	bf 00 00 00 00       	mov    $0x0,%edi
  8013f8:	eb 10                	jmp    80140a <_Z6strtolPKcPPci+0x43>
  8013fa:	bf 00 00 00 00       	mov    $0x0,%edi
		s++;

	// plus/minus sign
	if (*s == '+')
		s++;
	else if (*s == '-')
  8013ff:	3c 2d                	cmp    $0x2d,%al
  801401:	75 07                	jne    80140a <_Z6strtolPKcPPci+0x43>
		s++, neg = 1;
  801403:	83 c2 01             	add    $0x1,%edx
  801406:	66 bf 01 00          	mov    $0x1,%di

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80140a:	85 db                	test   %ebx,%ebx
  80140c:	0f 94 c0             	sete   %al
  80140f:	74 05                	je     801416 <_Z6strtolPKcPPci+0x4f>
  801411:	83 fb 10             	cmp    $0x10,%ebx
  801414:	75 15                	jne    80142b <_Z6strtolPKcPPci+0x64>
  801416:	80 3a 30             	cmpb   $0x30,(%edx)
  801419:	75 10                	jne    80142b <_Z6strtolPKcPPci+0x64>
  80141b:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80141f:	75 0a                	jne    80142b <_Z6strtolPKcPPci+0x64>
		s += 2, base = 16;
  801421:	83 c2 02             	add    $0x2,%edx
  801424:	bb 10 00 00 00       	mov    $0x10,%ebx
  801429:	eb 13                	jmp    80143e <_Z6strtolPKcPPci+0x77>
	else if (base == 0 && s[0] == '0')
  80142b:	84 c0                	test   %al,%al
  80142d:	74 0f                	je     80143e <_Z6strtolPKcPPci+0x77>
		s++, base = 8;
	else if (base == 0)
		base = 10;
  80142f:	bb 0a 00 00 00       	mov    $0xa,%ebx
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  801434:	80 3a 30             	cmpb   $0x30,(%edx)
  801437:	75 05                	jne    80143e <_Z6strtolPKcPPci+0x77>
		s++, base = 8;
  801439:	83 c2 01             	add    $0x1,%edx
  80143c:	b3 08                	mov    $0x8,%bl
	else if (base == 0)
		base = 10;
  80143e:	b8 00 00 00 00       	mov    $0x0,%eax
  801443:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  801445:	0f b6 0a             	movzbl (%edx),%ecx
  801448:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80144b:	80 fb 09             	cmp    $0x9,%bl
  80144e:	77 08                	ja     801458 <_Z6strtolPKcPPci+0x91>
			dig = *s - '0';
  801450:	0f be c9             	movsbl %cl,%ecx
  801453:	83 e9 30             	sub    $0x30,%ecx
  801456:	eb 1e                	jmp    801476 <_Z6strtolPKcPPci+0xaf>
		else if (*s >= 'a' && *s <= 'z')
  801458:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80145b:	80 fb 19             	cmp    $0x19,%bl
  80145e:	77 08                	ja     801468 <_Z6strtolPKcPPci+0xa1>
			dig = *s - 'a' + 10;
  801460:	0f be c9             	movsbl %cl,%ecx
  801463:	83 e9 57             	sub    $0x57,%ecx
  801466:	eb 0e                	jmp    801476 <_Z6strtolPKcPPci+0xaf>
		else if (*s >= 'A' && *s <= 'Z')
  801468:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80146b:	80 fb 19             	cmp    $0x19,%bl
  80146e:	77 15                	ja     801485 <_Z6strtolPKcPPci+0xbe>
			dig = *s - 'A' + 10;
  801470:	0f be c9             	movsbl %cl,%ecx
  801473:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  801476:	39 f1                	cmp    %esi,%ecx
  801478:	7d 0f                	jge    801489 <_Z6strtolPKcPPci+0xc2>
			break;
		s++, val = (val * base) + dig;
  80147a:	83 c2 01             	add    $0x1,%edx
  80147d:	0f af c6             	imul   %esi,%eax
  801480:	8d 04 01             	lea    (%ecx,%eax,1),%eax
		s++, base = 8;
	else if (base == 0)
		base = 10;

	// digits
	while (1) {
  801483:	eb c0                	jmp    801445 <_Z6strtolPKcPPci+0x7e>

		if (*s >= '0' && *s <= '9')
			dig = *s - '0';
		else if (*s >= 'a' && *s <= 'z')
			dig = *s - 'a' + 10;
		else if (*s >= 'A' && *s <= 'Z')
  801485:	89 c1                	mov    %eax,%ecx
  801487:	eb 02                	jmp    80148b <_Z6strtolPKcPPci+0xc4>
			dig = *s - 'A' + 10;
		else
			break;
		if (dig >= base)
  801489:	89 c1                	mov    %eax,%ecx
			break;
		s++, val = (val * base) + dig;
		// we don't properly detect overflow!
	}

	if (endptr)
  80148b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80148f:	74 05                	je     801496 <_Z6strtolPKcPPci+0xcf>
		*endptr = (char *) s;
  801491:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801494:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  801496:	89 ca                	mov    %ecx,%edx
  801498:	f7 da                	neg    %edx
  80149a:	85 ff                	test   %edi,%edi
  80149c:	0f 45 c2             	cmovne %edx,%eax
}
  80149f:	5b                   	pop    %ebx
  8014a0:	5e                   	pop    %esi
  8014a1:	5f                   	pop    %edi
  8014a2:	5d                   	pop    %ebp
  8014a3:	c3                   	ret    

008014a4 <_Z9sys_cputsPKcj>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  8014a4:	55                   	push   %ebp
  8014a5:	89 e5                	mov    %esp,%ebp
  8014a7:	83 ec 0c             	sub    $0xc,%esp
  8014aa:	89 1c 24             	mov    %ebx,(%esp)
  8014ad:	89 74 24 04          	mov    %esi,0x4(%esp)
  8014b1:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8014b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8014ba:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8014bd:	8b 55 08             	mov    0x8(%ebp),%edx
  8014c0:	89 c3                	mov    %eax,%ebx
  8014c2:	89 c7                	mov    %eax,%edi
  8014c4:	89 c6                	mov    %eax,%esi
  8014c6:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  8014c8:	8b 1c 24             	mov    (%esp),%ebx
  8014cb:	8b 74 24 04          	mov    0x4(%esp),%esi
  8014cf:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8014d3:	89 ec                	mov    %ebp,%esp
  8014d5:	5d                   	pop    %ebp
  8014d6:	c3                   	ret    

008014d7 <_Z9sys_cgetcv>:

int
sys_cgetc(void)
{
  8014d7:	55                   	push   %ebp
  8014d8:	89 e5                	mov    %esp,%ebp
  8014da:	83 ec 0c             	sub    $0xc,%esp
  8014dd:	89 1c 24             	mov    %ebx,(%esp)
  8014e0:	89 74 24 04          	mov    %esi,0x4(%esp)
  8014e4:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8014e8:	ba 00 00 00 00       	mov    $0x0,%edx
  8014ed:	b8 01 00 00 00       	mov    $0x1,%eax
  8014f2:	89 d1                	mov    %edx,%ecx
  8014f4:	89 d3                	mov    %edx,%ebx
  8014f6:	89 d7                	mov    %edx,%edi
  8014f8:	89 d6                	mov    %edx,%esi
  8014fa:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  8014fc:	8b 1c 24             	mov    (%esp),%ebx
  8014ff:	8b 74 24 04          	mov    0x4(%esp),%esi
  801503:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801507:	89 ec                	mov    %ebp,%esp
  801509:	5d                   	pop    %ebp
  80150a:	c3                   	ret    

0080150b <_Z15sys_env_destroyi>:

int
sys_env_destroy(envid_t envid)
{
  80150b:	55                   	push   %ebp
  80150c:	89 e5                	mov    %esp,%ebp
  80150e:	83 ec 38             	sub    $0x38,%esp
  801511:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801514:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801517:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  80151a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80151f:	b8 03 00 00 00       	mov    $0x3,%eax
  801524:	8b 55 08             	mov    0x8(%ebp),%edx
  801527:	89 cb                	mov    %ecx,%ebx
  801529:	89 cf                	mov    %ecx,%edi
  80152b:	89 ce                	mov    %ecx,%esi
  80152d:	cd 30                	int    $0x30

	if(check && ret > 0)
  80152f:	85 c0                	test   %eax,%eax
  801531:	7e 28                	jle    80155b <_Z15sys_env_destroyi+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  801533:	89 44 24 10          	mov    %eax,0x10(%esp)
  801537:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  80153e:	00 
  80153f:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  801546:	00 
  801547:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80154e:	00 
  80154f:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  801556:	e8 5d f4 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  80155b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80155e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801561:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801564:	89 ec                	mov    %ebp,%esp
  801566:	5d                   	pop    %ebp
  801567:	c3                   	ret    

00801568 <_Z12sys_getenvidv>:

envid_t
sys_getenvid(void)
{
  801568:	55                   	push   %ebp
  801569:	89 e5                	mov    %esp,%ebp
  80156b:	83 ec 0c             	sub    $0xc,%esp
  80156e:	89 1c 24             	mov    %ebx,(%esp)
  801571:	89 74 24 04          	mov    %esi,0x4(%esp)
  801575:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  801579:	ba 00 00 00 00       	mov    $0x0,%edx
  80157e:	b8 02 00 00 00       	mov    $0x2,%eax
  801583:	89 d1                	mov    %edx,%ecx
  801585:	89 d3                	mov    %edx,%ebx
  801587:	89 d7                	mov    %edx,%edi
  801589:	89 d6                	mov    %edx,%esi
  80158b:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  80158d:	8b 1c 24             	mov    (%esp),%ebx
  801590:	8b 74 24 04          	mov    0x4(%esp),%esi
  801594:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801598:	89 ec                	mov    %ebp,%esp
  80159a:	5d                   	pop    %ebp
  80159b:	c3                   	ret    

0080159c <_Z9sys_yieldv>:

void
sys_yield(void)
{
  80159c:	55                   	push   %ebp
  80159d:	89 e5                	mov    %esp,%ebp
  80159f:	83 ec 0c             	sub    $0xc,%esp
  8015a2:	89 1c 24             	mov    %ebx,(%esp)
  8015a5:	89 74 24 04          	mov    %esi,0x4(%esp)
  8015a9:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8015ad:	ba 00 00 00 00       	mov    $0x0,%edx
  8015b2:	b8 04 00 00 00       	mov    $0x4,%eax
  8015b7:	89 d1                	mov    %edx,%ecx
  8015b9:	89 d3                	mov    %edx,%ebx
  8015bb:	89 d7                	mov    %edx,%edi
  8015bd:	89 d6                	mov    %edx,%esi
  8015bf:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  8015c1:	8b 1c 24             	mov    (%esp),%ebx
  8015c4:	8b 74 24 04          	mov    0x4(%esp),%esi
  8015c8:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8015cc:	89 ec                	mov    %ebp,%esp
  8015ce:	5d                   	pop    %ebp
  8015cf:	c3                   	ret    

008015d0 <_Z14sys_page_allociPvi>:

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  8015d0:	55                   	push   %ebp
  8015d1:	89 e5                	mov    %esp,%ebp
  8015d3:	83 ec 38             	sub    $0x38,%esp
  8015d6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8015d9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8015dc:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8015df:	be 00 00 00 00       	mov    $0x0,%esi
  8015e4:	b8 08 00 00 00       	mov    $0x8,%eax
  8015e9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8015ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8015ef:	8b 55 08             	mov    0x8(%ebp),%edx
  8015f2:	89 f7                	mov    %esi,%edi
  8015f4:	cd 30                	int    $0x30

	if(check && ret > 0)
  8015f6:	85 c0                	test   %eax,%eax
  8015f8:	7e 28                	jle    801622 <_Z14sys_page_allociPvi+0x52>
		panic("syscall %d returned %d (> 0)", num, ret);
  8015fa:	89 44 24 10          	mov    %eax,0x10(%esp)
  8015fe:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  801605:	00 
  801606:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  80160d:	00 
  80160e:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801615:	00 
  801616:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  80161d:	e8 96 f3 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  801622:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801625:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801628:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80162b:	89 ec                	mov    %ebp,%esp
  80162d:	5d                   	pop    %ebp
  80162e:	c3                   	ret    

0080162f <_Z12sys_page_mapiPviS_i>:

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  80162f:	55                   	push   %ebp
  801630:	89 e5                	mov    %esp,%ebp
  801632:	83 ec 38             	sub    $0x38,%esp
  801635:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801638:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80163b:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  80163e:	b8 09 00 00 00       	mov    $0x9,%eax
  801643:	8b 75 18             	mov    0x18(%ebp),%esi
  801646:	8b 7d 14             	mov    0x14(%ebp),%edi
  801649:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80164c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80164f:	8b 55 08             	mov    0x8(%ebp),%edx
  801652:	cd 30                	int    $0x30

	if(check && ret > 0)
  801654:	85 c0                	test   %eax,%eax
  801656:	7e 28                	jle    801680 <_Z12sys_page_mapiPviS_i+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801658:	89 44 24 10          	mov    %eax,0x10(%esp)
  80165c:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  801663:	00 
  801664:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  80166b:	00 
  80166c:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801673:	00 
  801674:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  80167b:	e8 38 f3 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  801680:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801683:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801686:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801689:	89 ec                	mov    %ebp,%esp
  80168b:	5d                   	pop    %ebp
  80168c:	c3                   	ret    

0080168d <_Z14sys_page_unmapiPv>:

int
sys_page_unmap(envid_t envid, void *va)
{
  80168d:	55                   	push   %ebp
  80168e:	89 e5                	mov    %esp,%ebp
  801690:	83 ec 38             	sub    $0x38,%esp
  801693:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801696:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801699:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  80169c:	bb 00 00 00 00       	mov    $0x0,%ebx
  8016a1:	b8 0a 00 00 00       	mov    $0xa,%eax
  8016a6:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8016a9:	8b 55 08             	mov    0x8(%ebp),%edx
  8016ac:	89 df                	mov    %ebx,%edi
  8016ae:	89 de                	mov    %ebx,%esi
  8016b0:	cd 30                	int    $0x30

	if(check && ret > 0)
  8016b2:	85 c0                	test   %eax,%eax
  8016b4:	7e 28                	jle    8016de <_Z14sys_page_unmapiPv+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8016b6:	89 44 24 10          	mov    %eax,0x10(%esp)
  8016ba:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  8016c1:	00 
  8016c2:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  8016c9:	00 
  8016ca:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8016d1:	00 
  8016d2:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  8016d9:	e8 da f2 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  8016de:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8016e1:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8016e4:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8016e7:	89 ec                	mov    %ebp,%esp
  8016e9:	5d                   	pop    %ebp
  8016ea:	c3                   	ret    

008016eb <_Z18sys_env_set_statusii>:

int
sys_env_set_status(envid_t envid, int status)
{
  8016eb:	55                   	push   %ebp
  8016ec:	89 e5                	mov    %esp,%ebp
  8016ee:	83 ec 38             	sub    $0x38,%esp
  8016f1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8016f4:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8016f7:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8016fa:	bb 00 00 00 00       	mov    $0x0,%ebx
  8016ff:	b8 05 00 00 00       	mov    $0x5,%eax
  801704:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801707:	8b 55 08             	mov    0x8(%ebp),%edx
  80170a:	89 df                	mov    %ebx,%edi
  80170c:	89 de                	mov    %ebx,%esi
  80170e:	cd 30                	int    $0x30

	if(check && ret > 0)
  801710:	85 c0                	test   %eax,%eax
  801712:	7e 28                	jle    80173c <_Z18sys_env_set_statusii+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801714:	89 44 24 10          	mov    %eax,0x10(%esp)
  801718:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  80171f:	00 
  801720:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  801727:	00 
  801728:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80172f:	00 
  801730:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  801737:	e8 7c f2 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  80173c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80173f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801742:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801745:	89 ec                	mov    %ebp,%esp
  801747:	5d                   	pop    %ebp
  801748:	c3                   	ret    

00801749 <_Z20sys_env_set_priorityii>:

int
sys_env_set_priority(envid_t envid, int priority)
{
  801749:	55                   	push   %ebp
  80174a:	89 e5                	mov    %esp,%ebp
  80174c:	83 ec 38             	sub    $0x38,%esp
  80174f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801752:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801755:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  801758:	bb 00 00 00 00       	mov    $0x0,%ebx
  80175d:	b8 06 00 00 00       	mov    $0x6,%eax
  801762:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801765:	8b 55 08             	mov    0x8(%ebp),%edx
  801768:	89 df                	mov    %ebx,%edi
  80176a:	89 de                	mov    %ebx,%esi
  80176c:	cd 30                	int    $0x30

	if(check && ret > 0)
  80176e:	85 c0                	test   %eax,%eax
  801770:	7e 28                	jle    80179a <_Z20sys_env_set_priorityii+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801772:	89 44 24 10          	mov    %eax,0x10(%esp)
  801776:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80177d:	00 
  80177e:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  801785:	00 
  801786:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  80178d:	00 
  80178e:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  801795:	e8 1e f2 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_env_set_priority(envid_t envid, int priority)
{
	return syscall(SYS_env_set_priority, 1, envid, priority, 0, 0, 0);
}
  80179a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80179d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8017a0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8017a3:	89 ec                	mov    %ebp,%esp
  8017a5:	5d                   	pop    %ebp
  8017a6:	c3                   	ret    

008017a7 <_Z21sys_env_set_trapframeiP9Trapframe>:

// sys_exofork is inlined in lib.h

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  8017a7:	55                   	push   %ebp
  8017a8:	89 e5                	mov    %esp,%ebp
  8017aa:	83 ec 38             	sub    $0x38,%esp
  8017ad:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8017b0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8017b3:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8017b6:	bb 00 00 00 00       	mov    $0x0,%ebx
  8017bb:	b8 0b 00 00 00       	mov    $0xb,%eax
  8017c0:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8017c3:	8b 55 08             	mov    0x8(%ebp),%edx
  8017c6:	89 df                	mov    %ebx,%edi
  8017c8:	89 de                	mov    %ebx,%esi
  8017ca:	cd 30                	int    $0x30

	if(check && ret > 0)
  8017cc:	85 c0                	test   %eax,%eax
  8017ce:	7e 28                	jle    8017f8 <_Z21sys_env_set_trapframeiP9Trapframe+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8017d0:	89 44 24 10          	mov    %eax,0x10(%esp)
  8017d4:	c7 44 24 0c 0b 00 00 	movl   $0xb,0xc(%esp)
  8017db:	00 
  8017dc:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  8017e3:	00 
  8017e4:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8017eb:	00 
  8017ec:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  8017f3:	e8 c0 f1 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  8017f8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8017fb:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8017fe:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801801:	89 ec                	mov    %ebp,%esp
  801803:	5d                   	pop    %ebp
  801804:	c3                   	ret    

00801805 <_Z26sys_env_set_pgfault_upcalliPv>:

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  801805:	55                   	push   %ebp
  801806:	89 e5                	mov    %esp,%ebp
  801808:	83 ec 38             	sub    $0x38,%esp
  80180b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80180e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801811:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  801814:	bb 00 00 00 00       	mov    $0x0,%ebx
  801819:	b8 0c 00 00 00       	mov    $0xc,%eax
  80181e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801821:	8b 55 08             	mov    0x8(%ebp),%edx
  801824:	89 df                	mov    %ebx,%edi
  801826:	89 de                	mov    %ebx,%esi
  801828:	cd 30                	int    $0x30

	if(check && ret > 0)
  80182a:	85 c0                	test   %eax,%eax
  80182c:	7e 28                	jle    801856 <_Z26sys_env_set_pgfault_upcalliPv+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80182e:	89 44 24 10          	mov    %eax,0x10(%esp)
  801832:	c7 44 24 0c 0c 00 00 	movl   $0xc,0xc(%esp)
  801839:	00 
  80183a:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  801841:	00 
  801842:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801849:	00 
  80184a:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  801851:	e8 62 f1 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  801856:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801859:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80185c:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80185f:	89 ec                	mov    %ebp,%esp
  801861:	5d                   	pop    %ebp
  801862:	c3                   	ret    

00801863 <_Z16sys_ipc_try_sendijPvi>:

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  801863:	55                   	push   %ebp
  801864:	89 e5                	mov    %esp,%ebp
  801866:	83 ec 0c             	sub    $0xc,%esp
  801869:	89 1c 24             	mov    %ebx,(%esp)
  80186c:	89 74 24 04          	mov    %esi,0x4(%esp)
  801870:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  801874:	be 00 00 00 00       	mov    $0x0,%esi
  801879:	b8 0d 00 00 00       	mov    $0xd,%eax
  80187e:	8b 7d 14             	mov    0x14(%ebp),%edi
  801881:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801884:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801887:	8b 55 08             	mov    0x8(%ebp),%edx
  80188a:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  80188c:	8b 1c 24             	mov    (%esp),%ebx
  80188f:	8b 74 24 04          	mov    0x4(%esp),%esi
  801893:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801897:	89 ec                	mov    %ebp,%esp
  801899:	5d                   	pop    %ebp
  80189a:	c3                   	ret    

0080189b <_Z12sys_ipc_recvPv>:

int
sys_ipc_recv(void *dstva)
{
  80189b:	55                   	push   %ebp
  80189c:	89 e5                	mov    %esp,%ebp
  80189e:	83 ec 38             	sub    $0x38,%esp
  8018a1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8018a4:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8018a7:	89 7d fc             	mov    %edi,-0x4(%ebp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8018aa:	b9 00 00 00 00       	mov    $0x0,%ecx
  8018af:	b8 0e 00 00 00       	mov    $0xe,%eax
  8018b4:	8b 55 08             	mov    0x8(%ebp),%edx
  8018b7:	89 cb                	mov    %ecx,%ebx
  8018b9:	89 cf                	mov    %ecx,%edi
  8018bb:	89 ce                	mov    %ecx,%esi
  8018bd:	cd 30                	int    $0x30

	if(check && ret > 0)
  8018bf:	85 c0                	test   %eax,%eax
  8018c1:	7e 28                	jle    8018eb <_Z12sys_ipc_recvPv+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  8018c3:	89 44 24 10          	mov    %eax,0x10(%esp)
  8018c7:	c7 44 24 0c 0e 00 00 	movl   $0xe,0xc(%esp)
  8018ce:	00 
  8018cf:	c7 44 24 08 b4 48 81 	movl   $0x8148b4,0x8(%esp)
  8018d6:	00 
  8018d7:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8018de:	00 
  8018df:	c7 04 24 d1 48 81 00 	movl   $0x8148d1,(%esp)
  8018e6:	e8 cd f0 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  8018eb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8018ee:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8018f1:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8018f4:	89 ec                	mov    %ebp,%esp
  8018f6:	5d                   	pop    %ebp
  8018f7:	c3                   	ret    

008018f8 <_Z18sys_program_lookupPKcj>:

int
sys_program_lookup(const char *name, size_t len)
{
  8018f8:	55                   	push   %ebp
  8018f9:	89 e5                	mov    %esp,%ebp
  8018fb:	83 ec 0c             	sub    $0xc,%esp
  8018fe:	89 1c 24             	mov    %ebx,(%esp)
  801901:	89 74 24 04          	mov    %esi,0x4(%esp)
  801905:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  801909:	bb 00 00 00 00       	mov    $0x0,%ebx
  80190e:	b8 0f 00 00 00       	mov    $0xf,%eax
  801913:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801916:	8b 55 08             	mov    0x8(%ebp),%edx
  801919:	89 df                	mov    %ebx,%edi
  80191b:	89 de                	mov    %ebx,%esi
  80191d:	cd 30                	int    $0x30

int
sys_program_lookup(const char *name, size_t len)
{
	return syscall(SYS_program_lookup, 0, (uintptr_t) name, len, 0, 0, 0);
}
  80191f:	8b 1c 24             	mov    (%esp),%ebx
  801922:	8b 74 24 04          	mov    0x4(%esp),%esi
  801926:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80192a:	89 ec                	mov    %ebp,%esp
  80192c:	5d                   	pop    %ebp
  80192d:	c3                   	ret    

0080192e <_Z13sys_time_msecv>:

uint32_t
sys_time_msec(void)
{
  80192e:	55                   	push   %ebp
  80192f:	89 e5                	mov    %esp,%ebp
  801931:	83 ec 0c             	sub    $0xc,%esp
  801934:	89 1c 24             	mov    %ebx,(%esp)
  801937:	89 74 24 04          	mov    %esi,0x4(%esp)
  80193b:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  80193f:	ba 00 00 00 00       	mov    $0x0,%edx
  801944:	b8 11 00 00 00       	mov    $0x11,%eax
  801949:	89 d1                	mov    %edx,%ecx
  80194b:	89 d3                	mov    %edx,%ebx
  80194d:	89 d7                	mov    %edx,%edi
  80194f:	89 d6                	mov    %edx,%esi
  801951:	cd 30                	int    $0x30

uint32_t
sys_time_msec(void)
{
    return syscall(SYS_time_msec, 0, 0, 0, 0, 0, 0);
}
  801953:	8b 1c 24             	mov    (%esp),%ebx
  801956:	8b 74 24 04          	mov    0x4(%esp),%esi
  80195a:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80195e:	89 ec                	mov    %ebp,%esp
  801960:	5d                   	pop    %ebp
  801961:	c3                   	ret    

00801962 <_Z18sys_e1000_transmitPvj>:

int
sys_e1000_transmit(void *buffer, size_t len)
{
  801962:	55                   	push   %ebp
  801963:	89 e5                	mov    %esp,%ebp
  801965:	83 ec 0c             	sub    $0xc,%esp
  801968:	89 1c 24             	mov    %ebx,(%esp)
  80196b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80196f:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  801973:	bb 00 00 00 00       	mov    $0x0,%ebx
  801978:	b8 12 00 00 00       	mov    $0x12,%eax
  80197d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801980:	8b 55 08             	mov    0x8(%ebp),%edx
  801983:	89 df                	mov    %ebx,%edi
  801985:	89 de                	mov    %ebx,%esi
  801987:	cd 30                	int    $0x30

int
sys_e1000_transmit(void *buffer, size_t len)
{
    return syscall(SYS_e1000_transmit, 0, (uint32_t)buffer, (uint32_t)len, 0, 0, 0);
}
  801989:	8b 1c 24             	mov    (%esp),%ebx
  80198c:	8b 74 24 04          	mov    0x4(%esp),%esi
  801990:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801994:	89 ec                	mov    %ebp,%esp
  801996:	5d                   	pop    %ebp
  801997:	c3                   	ret    

00801998 <_Z17sys_e1000_receivePv>:

size_t
sys_e1000_receive(void *buffer)
{
  801998:	55                   	push   %ebp
  801999:	89 e5                	mov    %esp,%ebp
  80199b:	83 ec 0c             	sub    $0xc,%esp
  80199e:	89 1c 24             	mov    %ebx,(%esp)
  8019a1:	89 74 24 04          	mov    %esi,0x4(%esp)
  8019a5:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8019a9:	b9 00 00 00 00       	mov    $0x0,%ecx
  8019ae:	b8 13 00 00 00       	mov    $0x13,%eax
  8019b3:	8b 55 08             	mov    0x8(%ebp),%edx
  8019b6:	89 cb                	mov    %ecx,%ebx
  8019b8:	89 cf                	mov    %ecx,%edi
  8019ba:	89 ce                	mov    %ecx,%esi
  8019bc:	cd 30                	int    $0x30

size_t
sys_e1000_receive(void *buffer)
{
    return syscall(SYS_e1000_receive, 0, (uint32_t)buffer, 0, 0, 0, 0);
}
  8019be:	8b 1c 24             	mov    (%esp),%ebx
  8019c1:	8b 74 24 04          	mov    0x4(%esp),%esi
  8019c5:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8019c9:	89 ec                	mov    %ebp,%esp
  8019cb:	5d                   	pop    %ebp
  8019cc:	c3                   	ret    

008019cd <_Z16sys_program_readiPvijj>:

ssize_t
sys_program_read(envid_t dst_env, void *va,
		 int programid, size_t offset, size_t len)
{
  8019cd:	55                   	push   %ebp
  8019ce:	89 e5                	mov    %esp,%ebp
  8019d0:	83 ec 0c             	sub    $0xc,%esp
  8019d3:	89 1c 24             	mov    %ebx,(%esp)
  8019d6:	89 74 24 04          	mov    %esi,0x4(%esp)
  8019da:	89 7c 24 08          	mov    %edi,0x8(%esp)
		  "d" (a1),
		  "c" (a2),
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
  8019de:	b8 10 00 00 00       	mov    $0x10,%eax
  8019e3:	8b 75 18             	mov    0x18(%ebp),%esi
  8019e6:	8b 7d 14             	mov    0x14(%ebp),%edi
  8019e9:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8019ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8019ef:	8b 55 08             	mov    0x8(%ebp),%edx
  8019f2:	cd 30                	int    $0x30
ssize_t
sys_program_read(envid_t dst_env, void *va,
		 int programid, size_t offset, size_t len)
{
	return syscall(SYS_program_read, 0, dst_env, (uintptr_t) va, programid, offset, len);
}
  8019f4:	8b 1c 24             	mov    (%esp),%ebx
  8019f7:	8b 74 24 04          	mov    0x4(%esp),%esi
  8019fb:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8019ff:	89 ec                	mov    %ebp,%esp
  801a01:	5d                   	pop    %ebp
  801a02:	c3                   	ret    
	...

00801a04 <_ZL7duppageijb>:
// Returns: 0 on success, < 0 on error.
// It is also OK to panic on error.
//
static int
duppage(envid_t envid, unsigned pn, bool shared = false)
{
  801a04:	55                   	push   %ebp
  801a05:	89 e5                	mov    %esp,%ebp
  801a07:	83 ec 38             	sub    $0x38,%esp
  801a0a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801a0d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801a10:	89 7d fc             	mov    %edi,-0x4(%ebp)
    // if a page is already COW, then it will be duplicated COW, even if using
    // sfork.  If we are meant to share, then we no longer want to get rid
    // of the write permissions.  Finally, if we aren't meant to share,
    // then we must be COW, so all writable pages are COW

    if((vpt[pn] & PTE_SHARE))
  801a13:	8b 1c 95 00 00 80 ef 	mov    -0x10800000(,%edx,4),%ebx
  801a1a:	f6 c7 04             	test   $0x4,%bh
  801a1d:	74 31                	je     801a50 <_ZL7duppageijb+0x4c>
    {
        r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), vpt[pn] & PTE_SYSCALL);
  801a1f:	8b 0c 95 00 00 80 ef 	mov    -0x10800000(,%edx,4),%ecx
  801a26:	c1 e2 0c             	shl    $0xc,%edx
  801a29:	81 e1 07 0e 00 00    	and    $0xe07,%ecx
  801a2f:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  801a33:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801a37:	89 44 24 08          	mov    %eax,0x8(%esp)
  801a3b:	89 54 24 04          	mov    %edx,0x4(%esp)
  801a3f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801a46:	e8 e4 fb ff ff       	call   80162f <_Z12sys_page_mapiPviS_i>
        return r;
  801a4b:	e9 8c 00 00 00       	jmp    801adc <_ZL7duppageijb+0xd8>
    }


    if((vpt[pn] & PTE_COW))
  801a50:	8b 34 95 00 00 80 ef 	mov    -0x10800000(,%edx,4),%esi
        perm = PTE_COW;
  801a57:	bb 00 08 00 00       	mov    $0x800,%ebx
        r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), vpt[pn] & PTE_SYSCALL);
        return r;
    }


    if((vpt[pn] & PTE_COW))
  801a5c:	f7 c6 00 08 00 00    	test   $0x800,%esi
  801a62:	75 2a                	jne    801a8e <_ZL7duppageijb+0x8a>
        perm = PTE_COW;
    else if (shared)
  801a64:	84 c9                	test   %cl,%cl
  801a66:	74 0f                	je     801a77 <_ZL7duppageijb+0x73>
        perm = PTE_SHARED | ((vpt[pn] & PTE_W)?PTE_W:0);
  801a68:	8b 1c 95 00 00 80 ef 	mov    -0x10800000(,%edx,4),%ebx
  801a6f:	83 e3 02             	and    $0x2,%ebx
  801a72:	80 cf 02             	or     $0x2,%bh
  801a75:	eb 17                	jmp    801a8e <_ZL7duppageijb+0x8a>
    else if (vpt[pn] & PTE_W)
  801a77:	8b 0c 95 00 00 80 ef 	mov    -0x10800000(,%edx,4),%ecx
  801a7e:	83 e1 02             	and    $0x2,%ecx
//
static int
duppage(envid_t envid, unsigned pn, bool shared = false)
{
	int r;
    int perm = 0;
  801a81:	83 f9 01             	cmp    $0x1,%ecx
  801a84:	19 db                	sbb    %ebx,%ebx
  801a86:	f7 d3                	not    %ebx
  801a88:	81 e3 00 08 00 00    	and    $0x800,%ebx
        perm = PTE_SHARED | ((vpt[pn] & PTE_W)?PTE_W:0);
    else if (vpt[pn] & PTE_W)
        perm = PTE_COW;

    // map the page with the given permissions in our new environment
	if((r = sys_page_map(0, (void *)(pn * PGSIZE), envid, (void *)(pn * PGSIZE), PTE_P|PTE_U|perm)))
  801a8e:	89 df                	mov    %ebx,%edi
  801a90:	83 cf 05             	or     $0x5,%edi
  801a93:	89 d6                	mov    %edx,%esi
  801a95:	c1 e6 0c             	shl    $0xc,%esi
  801a98:	89 7c 24 10          	mov    %edi,0x10(%esp)
  801a9c:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801aa0:	89 44 24 08          	mov    %eax,0x8(%esp)
  801aa4:	89 74 24 04          	mov    %esi,0x4(%esp)
  801aa8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801aaf:	e8 7b fb ff ff       	call   80162f <_Z12sys_page_mapiPviS_i>
  801ab4:	85 c0                	test   %eax,%eax
  801ab6:	75 24                	jne    801adc <_ZL7duppageijb+0xd8>
        return r;

    // remap it in our own environment (to make sure it is COW)
    if(perm)
  801ab8:	85 db                	test   %ebx,%ebx
  801aba:	74 20                	je     801adc <_ZL7duppageijb+0xd8>
	    if((r = sys_page_map(0, (void *)(pn * PGSIZE), 0, (void *)(pn * PGSIZE), PTE_P|PTE_U|perm)))
  801abc:	89 7c 24 10          	mov    %edi,0x10(%esp)
  801ac0:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801ac4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801acb:	00 
  801acc:	89 74 24 04          	mov    %esi,0x4(%esp)
  801ad0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801ad7:	e8 53 fb ff ff       	call   80162f <_Z12sys_page_mapiPviS_i>
            return r;

    return 0;
}
  801adc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801adf:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801ae2:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801ae5:	89 ec                	mov    %ebp,%esp
  801ae7:	5d                   	pop    %ebp
  801ae8:	c3                   	ret    

00801ae9 <_ZL7pgfaultP10UTrapframe>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy and call resume(utf).
//
static void
pgfault(struct UTrapframe *utf)
{
  801ae9:	55                   	push   %ebp
  801aea:	89 e5                	mov    %esp,%ebp
  801aec:	83 ec 28             	sub    $0x28,%esp
  801aef:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  801af2:	89 75 fc             	mov    %esi,-0x4(%ebp)
  801af5:	8b 5d 08             	mov    0x8(%ebp),%ebx
    void *addr = (void *)utf->utf_fault_va;
  801af8:	8b 33                	mov    (%ebx),%esi

    // page number
    uint32_t pn = (uint32_t)addr >> 12;
    
    // if this isn't a COW case, just return
    if (!(err & FEC_W) || !(vpt[pn] & PTE_COW))
  801afa:	f6 43 04 02          	testb  $0x2,0x4(%ebx)
  801afe:	0f 84 ff 00 00 00    	je     801c03 <_ZL7pgfaultP10UTrapframe+0x11a>
	// Check that the faulting access was (1) a write, and (2) to a
	// copy-on-write page.  If not, return 0.
	// Hint: Use vpd and vpt.

    // page number
    uint32_t pn = (uint32_t)addr >> 12;
  801b04:	89 f0                	mov    %esi,%eax
  801b06:	c1 e8 0c             	shr    $0xc,%eax
    
    // if this isn't a COW case, just return
    if (!(err & FEC_W) || !(vpt[pn] & PTE_COW))
  801b09:	8b 04 85 00 00 80 ef 	mov    -0x10800000(,%eax,4),%eax
  801b10:	f6 c4 08             	test   $0x8,%ah
  801b13:	0f 84 ea 00 00 00    	je     801c03 <_ZL7pgfaultP10UTrapframe+0x11a>

    // now we need to copy the page and update our mapping so we can write to it
    addr = ROUNDDOWN(addr, PGSIZE);

    // allocate a new page in PFTEMP
    if ((r = sys_page_alloc(0, PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
  801b19:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801b20:	00 
  801b21:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801b28:	00 
  801b29:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801b30:	e8 9b fa ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  801b35:	85 c0                	test   %eax,%eax
  801b37:	79 20                	jns    801b59 <_ZL7pgfaultP10UTrapframe+0x70>
        panic("sys_page_alloc: %e", r);
  801b39:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b3d:	c7 44 24 08 df 48 81 	movl   $0x8148df,0x8(%esp)
  801b44:	00 
  801b45:	c7 44 24 04 2c 00 00 	movl   $0x2c,0x4(%esp)
  801b4c:	00 
  801b4d:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801b54:	e8 5f ee ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

    // now we need to copy the page and update our mapping so we can write to it
    addr = ROUNDDOWN(addr, PGSIZE);
  801b59:	81 e6 00 f0 ff ff    	and    $0xfffff000,%esi
    // allocate a new page in PFTEMP
    if ((r = sys_page_alloc(0, PFTEMP, PTE_P|PTE_U|PTE_W)) < 0)
        panic("sys_page_alloc: %e", r);

    // copy everything over to it
    memcpy(PFTEMP, addr, PGSIZE);
  801b5f:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  801b66:	00 
  801b67:	89 74 24 04          	mov    %esi,0x4(%esp)
  801b6b:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  801b72:	e8 90 f7 ff ff       	call   801307 <memcpy>

    // now remap our page at addr to PFTEMP, with write permissions
    if ((r = sys_page_map(0, PFTEMP, 0, addr, PTE_P|PTE_U|PTE_W)) < 0)
  801b77:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  801b7e:	00 
  801b7f:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801b83:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801b8a:	00 
  801b8b:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801b92:	00 
  801b93:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801b9a:	e8 90 fa ff ff       	call   80162f <_Z12sys_page_mapiPviS_i>
  801b9f:	85 c0                	test   %eax,%eax
  801ba1:	79 20                	jns    801bc3 <_ZL7pgfaultP10UTrapframe+0xda>
        panic("sys_page_map: %e", r);
  801ba3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ba7:	c7 44 24 08 fd 48 81 	movl   $0x8148fd,0x8(%esp)
  801bae:	00 
  801baf:	c7 44 24 04 33 00 00 	movl   $0x33,0x4(%esp)
  801bb6:	00 
  801bb7:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801bbe:	e8 f5 ed ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    // and unmap PFTEMP
    if ((r = sys_page_unmap(0, PFTEMP)) < 0)
  801bc3:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801bca:	00 
  801bcb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801bd2:	e8 b6 fa ff ff       	call   80168d <_Z14sys_page_unmapiPv>
  801bd7:	85 c0                	test   %eax,%eax
  801bd9:	79 20                	jns    801bfb <_ZL7pgfaultP10UTrapframe+0x112>
        panic("sys_page_unmap: %e", r);
  801bdb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801bdf:	c7 44 24 08 0e 49 81 	movl   $0x81490e,0x8(%esp)
  801be6:	00 
  801be7:	c7 44 24 04 37 00 00 	movl   $0x37,0x4(%esp)
  801bee:	00 
  801bef:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801bf6:	e8 bd ed ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    resume(utf);
  801bfb:	89 1c 24             	mov    %ebx,(%esp)
  801bfe:	e8 1d 30 00 00       	call   804c20 <resume>
}
  801c03:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  801c06:	8b 75 fc             	mov    -0x4(%ebp),%esi
  801c09:	89 ec                	mov    %ebp,%esp
  801c0b:	5d                   	pop    %ebp
  801c0c:	c3                   	ret    

00801c0d <_Z4forkv>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  801c0d:	55                   	push   %ebp
  801c0e:	89 e5                	mov    %esp,%ebp
  801c10:	57                   	push   %edi
  801c11:	56                   	push   %esi
  801c12:	53                   	push   %ebx
  801c13:	83 ec 1c             	sub    $0x1c,%esp
    int r;                          // errors
    int pn = UTOP / PGSIZE - 1;     // page number
    

    add_pgfault_handler(pgfault);
  801c16:	c7 04 24 e9 1a 80 00 	movl   $0x801ae9,(%esp)
  801c1d:	e8 29 2f 00 00       	call   804b4b <_Z19add_pgfault_handlerPFvP10UTrapframeE>
	envid_t ret;
	__asm __volatile("int %2"
		: "=a" (ret)
		: "a" (SYS_exofork),
		  "i" (T_SYSCALL)
	);
  801c22:	be 07 00 00 00       	mov    $0x7,%esi
  801c27:	89 f0                	mov    %esi,%eax
  801c29:	cd 30                	int    $0x30
  801c2b:	89 c6                	mov    %eax,%esi
  801c2d:	89 c7                	mov    %eax,%edi

    // fork new environment
    envid_t envid = sys_exofork();
    if (envid < 0)
  801c2f:	85 c0                	test   %eax,%eax
  801c31:	79 20                	jns    801c53 <_Z4forkv+0x46>
        panic("sys_exofork: %e", envid);
  801c33:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801c37:	c7 44 24 08 21 49 81 	movl   $0x814921,0x8(%esp)
  801c3e:	00 
  801c3f:	c7 44 24 04 87 00 00 	movl   $0x87,0x4(%esp)
  801c46:	00 
  801c47:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801c4e:	e8 65 ed ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        thisenv = &envs[ENVX(sys_getenvid())];
        return 0;
    }

    // loop over all pages in the user address space (below the stack)
    while (--pn >= 0)
  801c53:	bb fe ef 0e 00       	mov    $0xeeffe,%ebx
    envid_t envid = sys_exofork();
    if (envid < 0)
        panic("sys_exofork: %e", envid);

    // if we are the child, update thisenv and exit
    if (envid == 0)
  801c58:	85 c0                	test   %eax,%eax
  801c5a:	75 1c                	jne    801c78 <_Z4forkv+0x6b>
    {
        thisenv = &envs[ENVX(sys_getenvid())];
  801c5c:	e8 07 f9 ff ff       	call   801568 <_Z12sys_getenvidv>
  801c61:	25 ff 03 00 00       	and    $0x3ff,%eax
  801c66:	6b c0 78             	imul   $0x78,%eax,%eax
  801c69:	05 00 00 00 ef       	add    $0xef000000,%eax
  801c6e:	a3 98 90 81 00       	mov    %eax,0x819098
        return 0;
  801c73:	e9 de 00 00 00       	jmp    801d56 <_Z4forkv+0x149>
    // loop over all pages in the user address space (below the stack)
    while (--pn >= 0)
    {
        // if the page directory present bit isn't set, we can
        // skip all of the pages of that directory entry
        if(!(vpd[pn >> 10] & PTE_P))
  801c78:	89 d8                	mov    %ebx,%eax
  801c7a:	c1 f8 0a             	sar    $0xa,%eax
  801c7d:	8b 04 85 00 e0 bb ef 	mov    -0x10442000(,%eax,4),%eax
  801c84:	a8 01                	test   $0x1,%al
  801c86:	75 08                	jne    801c90 <_Z4forkv+0x83>
            pn = (pn >> 10) << 10;
  801c88:	81 e3 00 fc ff ff    	and    $0xfffffc00,%ebx
  801c8e:	eb 19                	jmp    801ca9 <_Z4forkv+0x9c>

        // if the page table entry is set, then we need to 
        // duplicate the page
        else if (vpt[pn] & PTE_P)
  801c90:	8b 04 9d 00 00 80 ef 	mov    -0x10800000(,%ebx,4),%eax
  801c97:	a8 01                	test   $0x1,%al
  801c99:	74 0e                	je     801ca9 <_Z4forkv+0x9c>
            duppage(envid, pn);
  801c9b:	b9 00 00 00 00       	mov    $0x0,%ecx
  801ca0:	89 da                	mov    %ebx,%edx
  801ca2:	89 f8                	mov    %edi,%eax
  801ca4:	e8 5b fd ff ff       	call   801a04 <_ZL7duppageijb>
        thisenv = &envs[ENVX(sys_getenvid())];
        return 0;
    }

    // loop over all pages in the user address space (below the stack)
    while (--pn >= 0)
  801ca9:	83 eb 01             	sub    $0x1,%ebx
  801cac:	79 ca                	jns    801c78 <_Z4forkv+0x6b>
            duppage(envid, pn);
    }


    // set the pgfault_upcall of the child
    if ((r = sys_env_set_pgfault_upcall(envid, (void *)thisenv->env_pgfault_upcall)))
  801cae:	a1 98 90 81 00       	mov    0x819098,%eax
  801cb3:	8b 40 5c             	mov    0x5c(%eax),%eax
  801cb6:	89 44 24 04          	mov    %eax,0x4(%esp)
  801cba:	89 34 24             	mov    %esi,(%esp)
  801cbd:	e8 43 fb ff ff       	call   801805 <_Z26sys_env_set_pgfault_upcalliPv>
  801cc2:	85 c0                	test   %eax,%eax
  801cc4:	74 20                	je     801ce6 <_Z4forkv+0xd9>
        panic("sys_env_set_pgfault_upcall: %e", r);
  801cc6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801cca:	c7 44 24 08 48 49 81 	movl   $0x814948,0x8(%esp)
  801cd1:	00 
  801cd2:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  801cd9:	00 
  801cda:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801ce1:	e8 d2 ec ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    // give the child an exception stack page
    if ((r = sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
  801ce6:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801ced:	00 
  801cee:	c7 44 24 04 00 f0 ff 	movl   $0xeefff000,0x4(%esp)
  801cf5:	ee 
  801cf6:	89 34 24             	mov    %esi,(%esp)
  801cf9:	e8 d2 f8 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  801cfe:	85 c0                	test   %eax,%eax
  801d00:	79 20                	jns    801d22 <_Z4forkv+0x115>
        panic("sys_page_alloc: %e", r);
  801d02:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801d06:	c7 44 24 08 df 48 81 	movl   $0x8148df,0x8(%esp)
  801d0d:	00 
  801d0e:	c7 44 24 04 a5 00 00 	movl   $0xa5,0x4(%esp)
  801d15:	00 
  801d16:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801d1d:	e8 96 ec ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    // and let the child go free!
    if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  801d22:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  801d29:	00 
  801d2a:	89 34 24             	mov    %esi,(%esp)
  801d2d:	e8 b9 f9 ff ff       	call   8016eb <_Z18sys_env_set_statusii>
  801d32:	85 c0                	test   %eax,%eax
  801d34:	79 20                	jns    801d56 <_Z4forkv+0x149>
        panic("sys_env_set_status: %e", r);
  801d36:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801d3a:	c7 44 24 08 31 49 81 	movl   $0x814931,0x8(%esp)
  801d41:	00 
  801d42:	c7 44 24 04 a9 00 00 	movl   $0xa9,0x4(%esp)
  801d49:	00 
  801d4a:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801d51:	e8 62 ec ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    return envid;
}
  801d56:	89 f0                	mov    %esi,%eax
  801d58:	83 c4 1c             	add    $0x1c,%esp
  801d5b:	5b                   	pop    %ebx
  801d5c:	5e                   	pop    %esi
  801d5d:	5f                   	pop    %edi
  801d5e:	5d                   	pop    %ebp
  801d5f:	c3                   	ret    

00801d60 <_Z5sforkv>:

// Challenge!
int
sfork(void)
{
  801d60:	55                   	push   %ebp
  801d61:	89 e5                	mov    %esp,%ebp
  801d63:	57                   	push   %edi
  801d64:	56                   	push   %esi
  801d65:	53                   	push   %ebx
  801d66:	83 ec 2c             	sub    $0x2c,%esp
    int r; 

    add_pgfault_handler(pgfault);
  801d69:	c7 04 24 e9 1a 80 00 	movl   $0x801ae9,(%esp)
  801d70:	e8 d6 2d 00 00       	call   804b4b <_Z19add_pgfault_handlerPFvP10UTrapframeE>
  801d75:	be 07 00 00 00       	mov    $0x7,%esi
  801d7a:	89 f0                	mov    %esi,%eax
  801d7c:	cd 30                	int    $0x30
  801d7e:	89 c6                	mov    %eax,%esi
  801d80:	89 c7                	mov    %eax,%edi

    // make a new child
    envid_t envid = sys_exofork();
    if (envid < 0)
  801d82:	85 c0                	test   %eax,%eax
  801d84:	79 20                	jns    801da6 <_Z5sforkv+0x46>
        panic("sys_exofork: %e", envid);
  801d86:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801d8a:	c7 44 24 08 21 49 81 	movl   $0x814921,0x8(%esp)
  801d91:	00 
  801d92:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  801d99:	00 
  801d9a:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801da1:	e8 12 ec ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    // unlike above, no need to set thisenv for child
    if (envid == 0)
  801da6:	85 c0                	test   %eax,%eax
  801da8:	0f 84 40 01 00 00    	je     801eee <_Z5sforkv+0x18e>

static __inline uint32_t
read_esp(void)
{
        uint32_t esp;
        __asm __volatile("movl %%esp,%0" : "=r" (esp));
  801dae:	89 e3                	mov    %esp,%ebx
        return 0;
    
    // we only want to share the pages below the current stack page
    int pn = (read_esp() >> 12) - 1;
  801db0:	c1 eb 0c             	shr    $0xc,%ebx
  801db3:	83 eb 01             	sub    $0x1,%ebx
  801db6:	89 5d e4             	mov    %ebx,-0x1c(%ebp)

    // remember the lowest stack page so we can mark all of them COW
    int pn_start = pn;

    // same as in fork
    while (--pn >= 0)
  801db9:	eb 31                	jmp    801dec <_Z5sforkv+0x8c>
    {
        if(!(vpd[pn >> 10] & PTE_P))
  801dbb:	89 d8                	mov    %ebx,%eax
  801dbd:	c1 f8 0a             	sar    $0xa,%eax
  801dc0:	8b 04 85 00 e0 bb ef 	mov    -0x10442000(,%eax,4),%eax
  801dc7:	a8 01                	test   $0x1,%al
  801dc9:	75 08                	jne    801dd3 <_Z5sforkv+0x73>
            pn = (pn >> 10) << 10;
  801dcb:	81 e3 00 fc ff ff    	and    $0xfffffc00,%ebx
  801dd1:	eb 19                	jmp    801dec <_Z5sforkv+0x8c>
        else if (vpt[pn] & PTE_P)
  801dd3:	8b 04 9d 00 00 80 ef 	mov    -0x10800000(,%ebx,4),%eax
  801dda:	a8 01                	test   $0x1,%al
  801ddc:	74 0e                	je     801dec <_Z5sforkv+0x8c>
            duppage(envid, pn, true);
  801dde:	b9 01 00 00 00       	mov    $0x1,%ecx
  801de3:	89 da                	mov    %ebx,%edx
  801de5:	89 f8                	mov    %edi,%eax
  801de7:	e8 18 fc ff ff       	call   801a04 <_ZL7duppageijb>

    // remember the lowest stack page so we can mark all of them COW
    int pn_start = pn;

    // same as in fork
    while (--pn >= 0)
  801dec:	83 eb 01             	sub    $0x1,%ebx
  801def:	79 ca                	jns    801dbb <_Z5sforkv+0x5b>
        else if (vpt[pn] & PTE_P)
            duppage(envid, pn, true);
    }

    // same as above, but duppage isn't flagged to share pages
    for(int i = pn_start; i < (int)(UTOP / PGSIZE - 1); i++)
  801df1:	81 7d e4 fe ef 0e 00 	cmpl   $0xeeffe,-0x1c(%ebp)
  801df8:	7f 3f                	jg     801e39 <_Z5sforkv+0xd9>
  801dfa:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
    {
        if(!(vpd[i >> 10] & PTE_P))
  801dfd:	89 d8                	mov    %ebx,%eax
  801dff:	c1 f8 0a             	sar    $0xa,%eax
  801e02:	8b 04 85 00 e0 bb ef 	mov    -0x10442000(,%eax,4),%eax
  801e09:	a8 01                	test   $0x1,%al
  801e0b:	75 08                	jne    801e15 <_Z5sforkv+0xb5>
            i = (i >> 10) << 10;
  801e0d:	81 e3 00 fc ff ff    	and    $0xfffffc00,%ebx
  801e13:	eb 19                	jmp    801e2e <_Z5sforkv+0xce>
        else if (vpt[i] & PTE_P)
  801e15:	8b 04 9d 00 00 80 ef 	mov    -0x10800000(,%ebx,4),%eax
  801e1c:	a8 01                	test   $0x1,%al
  801e1e:	74 0e                	je     801e2e <_Z5sforkv+0xce>
            duppage(envid, i);
  801e20:	b9 00 00 00 00       	mov    $0x0,%ecx
  801e25:	89 da                	mov    %ebx,%edx
  801e27:	89 f8                	mov    %edi,%eax
  801e29:	e8 d6 fb ff ff       	call   801a04 <_ZL7duppageijb>
        else if (vpt[pn] & PTE_P)
            duppage(envid, pn, true);
    }

    // same as above, but duppage isn't flagged to share pages
    for(int i = pn_start; i < (int)(UTOP / PGSIZE - 1); i++)
  801e2e:	83 c3 01             	add    $0x1,%ebx
  801e31:	81 fb fe ef 0e 00    	cmp    $0xeeffe,%ebx
  801e37:	7e c4                	jle    801dfd <_Z5sforkv+0x9d>
        else if (vpt[i] & PTE_P)
            duppage(envid, i);
    }

    // same as in fork!
    if ((r = sys_env_set_pgfault_upcall(envid, (void *)THISENV->env_pgfault_upcall)))
  801e39:	e8 2a f7 ff ff       	call   801568 <_Z12sys_getenvidv>
  801e3e:	25 ff 03 00 00       	and    $0x3ff,%eax
  801e43:	6b c0 78             	imul   $0x78,%eax,%eax
  801e46:	05 0c 00 00 ef       	add    $0xef00000c,%eax
  801e4b:	8b 40 50             	mov    0x50(%eax),%eax
  801e4e:	89 44 24 04          	mov    %eax,0x4(%esp)
  801e52:	89 34 24             	mov    %esi,(%esp)
  801e55:	e8 ab f9 ff ff       	call   801805 <_Z26sys_env_set_pgfault_upcalliPv>
  801e5a:	85 c0                	test   %eax,%eax
  801e5c:	74 20                	je     801e7e <_Z5sforkv+0x11e>
        panic("sys_env_set_pgfault_upcall: %e", r);
  801e5e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801e62:	c7 44 24 08 48 49 81 	movl   $0x814948,0x8(%esp)
  801e69:	00 
  801e6a:	c7 44 24 04 d9 00 00 	movl   $0xd9,0x4(%esp)
  801e71:	00 
  801e72:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801e79:	e8 3a eb ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    if ((r = sys_page_alloc(envid, (void *)(UXSTACKTOP-PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
  801e7e:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801e85:	00 
  801e86:	c7 44 24 04 00 f0 ff 	movl   $0xeefff000,0x4(%esp)
  801e8d:	ee 
  801e8e:	89 34 24             	mov    %esi,(%esp)
  801e91:	e8 3a f7 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  801e96:	85 c0                	test   %eax,%eax
  801e98:	79 20                	jns    801eba <_Z5sforkv+0x15a>
        panic("sys_page_alloc: %e", r);
  801e9a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801e9e:	c7 44 24 08 df 48 81 	movl   $0x8148df,0x8(%esp)
  801ea5:	00 
  801ea6:	c7 44 24 04 dc 00 00 	movl   $0xdc,0x4(%esp)
  801ead:	00 
  801eae:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801eb5:	e8 fe ea ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0)
  801eba:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  801ec1:	00 
  801ec2:	89 34 24             	mov    %esi,(%esp)
  801ec5:	e8 21 f8 ff ff       	call   8016eb <_Z18sys_env_set_statusii>
  801eca:	85 c0                	test   %eax,%eax
  801ecc:	79 20                	jns    801eee <_Z5sforkv+0x18e>
        panic("sys_env_set_status: %e", r);
  801ece:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801ed2:	c7 44 24 08 31 49 81 	movl   $0x814931,0x8(%esp)
  801ed9:	00 
  801eda:	c7 44 24 04 de 00 00 	movl   $0xde,0x4(%esp)
  801ee1:	00 
  801ee2:	c7 04 24 f2 48 81 00 	movl   $0x8148f2,(%esp)
  801ee9:	e8 ca ea ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    return envid;
    
}
  801eee:	89 f0                	mov    %esi,%eax
  801ef0:	83 c4 2c             	add    $0x2c,%esp
  801ef3:	5b                   	pop    %ebx
  801ef4:	5e                   	pop    %esi
  801ef5:	5f                   	pop    %edi
  801ef6:	5d                   	pop    %ebp
  801ef7:	c3                   	ret    
	...

00801f00 <_Z8ipc_recvPiPvS_>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  801f00:	55                   	push   %ebp
  801f01:	89 e5                	mov    %esp,%ebp
  801f03:	56                   	push   %esi
  801f04:	53                   	push   %ebx
  801f05:	83 ec 10             	sub    $0x10,%esp
  801f08:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801f0b:	8b 45 0c             	mov    0xc(%ebp),%eax
  801f0e:	8b 75 10             	mov    0x10(%ebp),%esi
    int ret;
    
    // UTOP is above the valid region for ipc mapping
    if (pg == NULL)
        pg = (void *)UTOP;
  801f11:	85 c0                	test   %eax,%eax
  801f13:	ba 00 00 00 ef       	mov    $0xef000000,%edx
  801f18:	0f 44 c2             	cmove  %edx,%eax

    // if there is an error in receiving, null everything out and return
    if ((ret = sys_ipc_recv(pg)) < 0)
  801f1b:	89 04 24             	mov    %eax,(%esp)
  801f1e:	e8 78 f9 ff ff       	call   80189b <_Z12sys_ipc_recvPv>
  801f23:	85 c0                	test   %eax,%eax
  801f25:	79 16                	jns    801f3d <_Z8ipc_recvPiPvS_+0x3d>
    {
        if(from_env_store)
  801f27:	85 db                	test   %ebx,%ebx
  801f29:	74 06                	je     801f31 <_Z8ipc_recvPiPvS_+0x31>
            *from_env_store = 0;
  801f2b:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
        if(perm_store)
  801f31:	85 f6                	test   %esi,%esi
  801f33:	74 53                	je     801f88 <_Z8ipc_recvPiPvS_+0x88>
            *perm_store = 0;
  801f35:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  801f3b:	eb 4b                	jmp    801f88 <_Z8ipc_recvPiPvS_+0x88>
        return ret;
    }

    // else set env_store and perm_store to the proper return values, and 
    // return the sent value
    if(from_env_store)
  801f3d:	85 db                	test   %ebx,%ebx
  801f3f:	74 17                	je     801f58 <_Z8ipc_recvPiPvS_+0x58>
        *from_env_store = THISENV->env_ipc_from;
  801f41:	e8 22 f6 ff ff       	call   801568 <_Z12sys_getenvidv>
  801f46:	25 ff 03 00 00       	and    $0x3ff,%eax
  801f4b:	6b c0 78             	imul   $0x78,%eax,%eax
  801f4e:	05 0c 00 00 ef       	add    $0xef00000c,%eax
  801f53:	8b 40 60             	mov    0x60(%eax),%eax
  801f56:	89 03                	mov    %eax,(%ebx)
    if(perm_store)
  801f58:	85 f6                	test   %esi,%esi
  801f5a:	74 17                	je     801f73 <_Z8ipc_recvPiPvS_+0x73>
        *perm_store = THISENV->env_ipc_perm;
  801f5c:	e8 07 f6 ff ff       	call   801568 <_Z12sys_getenvidv>
  801f61:	25 ff 03 00 00       	and    $0x3ff,%eax
  801f66:	6b c0 78             	imul   $0x78,%eax,%eax
  801f69:	05 00 00 00 ef       	add    $0xef000000,%eax
  801f6e:	8b 40 70             	mov    0x70(%eax),%eax
  801f71:	89 06                	mov    %eax,(%esi)
    return THISENV->env_ipc_value;
  801f73:	e8 f0 f5 ff ff       	call   801568 <_Z12sys_getenvidv>
  801f78:	25 ff 03 00 00       	and    $0x3ff,%eax
  801f7d:	6b c0 78             	imul   $0x78,%eax,%eax
  801f80:	05 08 00 00 ef       	add    $0xef000008,%eax
  801f85:	8b 40 60             	mov    0x60(%eax),%eax

}
  801f88:	83 c4 10             	add    $0x10,%esp
  801f8b:	5b                   	pop    %ebx
  801f8c:	5e                   	pop    %esi
  801f8d:	5d                   	pop    %ebp
  801f8e:	c3                   	ret    

00801f8f <_Z8ipc_sendijPvi>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  801f8f:	55                   	push   %ebp
  801f90:	89 e5                	mov    %esp,%ebp
  801f92:	57                   	push   %edi
  801f93:	56                   	push   %esi
  801f94:	53                   	push   %ebx
  801f95:	83 ec 1c             	sub    $0x1c,%esp
  801f98:	8b 75 08             	mov    0x8(%ebp),%esi
  801f9b:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801f9e:	8b 5d 10             	mov    0x10(%ebp),%ebx
	// UTOP is above the valid region for ipc mapping
    if (pg == NULL)
  801fa1:	85 db                	test   %ebx,%ebx
        pg = (void *) UTOP;
  801fa3:	b8 00 00 00 ef       	mov    $0xef000000,%eax
  801fa8:	0f 44 d8             	cmove  %eax,%ebx

    int ret;

    // continue until the message is sent
    while (true)
        if ((ret = sys_ipc_try_send(to_env, val, pg, perm)) < 0)
  801fab:	8b 45 14             	mov    0x14(%ebp),%eax
  801fae:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801fb2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  801fb6:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801fba:	89 34 24             	mov    %esi,(%esp)
  801fbd:	e8 a1 f8 ff ff       	call   801863 <_Z16sys_ipc_try_sendijPvi>
  801fc2:	85 c0                	test   %eax,%eax
  801fc4:	79 31                	jns    801ff7 <_Z8ipc_sendijPvi+0x68>
        {
            // yield, since we don't know how long it will take for
            // the other environment to wait for a message
            if (ret == -E_IPC_NOT_RECV)
  801fc6:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801fc9:	75 0c                	jne    801fd7 <_Z8ipc_sendijPvi+0x48>
            {
                sys_yield();
  801fcb:	90                   	nop
  801fcc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  801fd0:	e8 c7 f5 ff ff       	call   80159c <_Z9sys_yieldv>
  801fd5:	eb d4                	jmp    801fab <_Z8ipc_sendijPvi+0x1c>
            }
            else
                panic("ipc_send: %e", ret);
  801fd7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801fdb:	c7 44 24 08 67 49 81 	movl   $0x814967,0x8(%esp)
  801fe2:	00 
  801fe3:	c7 44 24 04 4f 00 00 	movl   $0x4f,0x4(%esp)
  801fea:	00 
  801feb:	c7 04 24 74 49 81 00 	movl   $0x814974,(%esp)
  801ff2:	e8 c1 e9 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        }
        else
            return;    
}
  801ff7:	83 c4 1c             	add    $0x1c,%esp
  801ffa:	5b                   	pop    %ebx
  801ffb:	5e                   	pop    %esi
  801ffc:	5f                   	pop    %edi
  801ffd:	5d                   	pop    %ebp
  801ffe:	c3                   	ret    
	...

00802000 <_ZL8fd_validPK2Fd>:

// Return true iff 'fd' is a valid file descriptor pointer.
//
static bool
fd_valid(const struct Fd *fd)
{
  802000:	55                   	push   %ebp
  802001:	89 e5                	mov    %esp,%ebp
	return PGOFF(fd) == 0 && fd >= (const struct Fd *) FDTABLE
		&& fd < (const struct Fd *) (FDTABLE + NFD * PGSIZE);
  802003:	a9 ff 0f 00 00       	test   $0xfff,%eax
  802008:	75 11                	jne    80201b <_ZL8fd_validPK2Fd+0x1b>
  80200a:	3d ff ff ff cf       	cmp    $0xcfffffff,%eax
  80200f:	76 0a                	jbe    80201b <_ZL8fd_validPK2Fd+0x1b>
}

// Return true iff 'fd' is a valid file descriptor pointer.
//
static bool
fd_valid(const struct Fd *fd)
  802011:	3d ff ff 01 d0       	cmp    $0xd001ffff,%eax
  802016:	0f 96 c0             	setbe  %al
  802019:	eb 05                	jmp    802020 <_ZL8fd_validPK2Fd+0x20>
{
	return PGOFF(fd) == 0 && fd >= (const struct Fd *) FDTABLE
		&& fd < (const struct Fd *) (FDTABLE + NFD * PGSIZE);
  80201b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802020:	5d                   	pop    %ebp
  802021:	c3                   	ret    

00802022 <_ZL9fd_isopenPK2Fd>:

// Return true iff 'fd' is currently open.
//
static bool
fd_isopen(const struct Fd *fd)
{
  802022:	55                   	push   %ebp
  802023:	89 e5                	mov    %esp,%ebp
  802025:	53                   	push   %ebx
  802026:	83 ec 14             	sub    $0x14,%esp
  802029:	89 c3                	mov    %eax,%ebx
	assert(fd_valid(fd));
  80202b:	e8 d0 ff ff ff       	call   802000 <_ZL8fd_validPK2Fd>
  802030:	84 c0                	test   %al,%al
  802032:	75 24                	jne    802058 <_ZL9fd_isopenPK2Fd+0x36>
  802034:	c7 44 24 0c 7e 49 81 	movl   $0x81497e,0xc(%esp)
  80203b:	00 
  80203c:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  802043:	00 
  802044:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
  80204b:	00 
  80204c:	c7 04 24 a0 49 81 00 	movl   $0x8149a0,(%esp)
  802053:	e8 60 e9 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	return (vpd[PDX(fd)] & PTE_P) && (vpt[PGNUM(fd)] & PTE_P);
  802058:	89 d8                	mov    %ebx,%eax
  80205a:	c1 e8 16             	shr    $0x16,%eax
  80205d:	8b 14 85 00 e0 bb ef 	mov    -0x10442000(,%eax,4),%edx
  802064:	b8 00 00 00 00       	mov    $0x0,%eax
  802069:	f6 c2 01             	test   $0x1,%dl
  80206c:	74 0d                	je     80207b <_ZL9fd_isopenPK2Fd+0x59>
  80206e:	c1 eb 0c             	shr    $0xc,%ebx
  802071:	8b 04 9d 00 00 80 ef 	mov    -0x10800000(,%ebx,4),%eax
}

// Return true iff 'fd' is currently open.
//
static bool
fd_isopen(const struct Fd *fd)
  802078:	83 e0 01             	and    $0x1,%eax
{
	assert(fd_valid(fd));
	return (vpd[PDX(fd)] & PTE_P) && (vpt[PGNUM(fd)] & PTE_P);
}
  80207b:	83 c4 14             	add    $0x14,%esp
  80207e:	5b                   	pop    %ebx
  80207f:	5d                   	pop    %ebp
  802080:	c3                   	ret    

00802081 <_Z9fd_lookupiPP2Fdb>:
// or NULL is returned.
// Returns 0 on success, < 0 error code on failure.
//
int
fd_lookup(int fdnum, struct Fd **fd_store, bool must_exist)
{
  802081:	55                   	push   %ebp
  802082:	89 e5                	mov    %esp,%ebp
  802084:	83 ec 08             	sub    $0x8,%esp
  802087:	89 1c 24             	mov    %ebx,(%esp)
  80208a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80208e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802091:	8b 75 0c             	mov    0xc(%ebp),%esi
  802094:	0f b6 45 10          	movzbl 0x10(%ebp),%eax
	struct Fd *fd = (struct Fd *) (FDTABLE + fdnum * PGSIZE);

	if (fdnum < 0 || fdnum >= NFD || (must_exist && !fd_isopen(fd))) {
  802098:	83 fb 1f             	cmp    $0x1f,%ebx
  80209b:	77 18                	ja     8020b5 <_Z9fd_lookupiPP2Fdb+0x34>
// Returns 0 on success, < 0 error code on failure.
//
int
fd_lookup(int fdnum, struct Fd **fd_store, bool must_exist)
{
	struct Fd *fd = (struct Fd *) (FDTABLE + fdnum * PGSIZE);
  80209d:	81 c3 00 00 0d 00    	add    $0xd0000,%ebx
  8020a3:	c1 e3 0c             	shl    $0xc,%ebx

	if (fdnum < 0 || fdnum >= NFD || (must_exist && !fd_isopen(fd))) {
  8020a6:	84 c0                	test   %al,%al
  8020a8:	74 21                	je     8020cb <_Z9fd_lookupiPP2Fdb+0x4a>
  8020aa:	89 d8                	mov    %ebx,%eax
  8020ac:	e8 71 ff ff ff       	call   802022 <_ZL9fd_isopenPK2Fd>
  8020b1:	84 c0                	test   %al,%al
  8020b3:	75 16                	jne    8020cb <_Z9fd_lookupiPP2Fdb+0x4a>
		*fd_store = 0;
  8020b5:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		return -E_INVAL;
  8020bb:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	} else {
		*fd_store = fd;
		return 0;
	}
}
  8020c0:	8b 1c 24             	mov    (%esp),%ebx
  8020c3:	8b 74 24 04          	mov    0x4(%esp),%esi
  8020c7:	89 ec                	mov    %ebp,%esp
  8020c9:	5d                   	pop    %ebp
  8020ca:	c3                   	ret    

	if (fdnum < 0 || fdnum >= NFD || (must_exist && !fd_isopen(fd))) {
		*fd_store = 0;
		return -E_INVAL;
	} else {
		*fd_store = fd;
  8020cb:	89 1e                	mov    %ebx,(%esi)
		return 0;
  8020cd:	b8 00 00 00 00       	mov    $0x0,%eax
  8020d2:	eb ec                	jmp    8020c0 <_Z9fd_lookupiPP2Fdb+0x3f>

008020d4 <_Z6fd2numP2Fd>:

// Return the file descriptor number for a 'struct Fd'.
//
int
fd2num(struct Fd *fd)
{
  8020d4:	55                   	push   %ebp
  8020d5:	89 e5                	mov    %esp,%ebp
  8020d7:	53                   	push   %ebx
  8020d8:	83 ec 14             	sub    $0x14,%esp
  8020db:	8b 5d 08             	mov    0x8(%ebp),%ebx
	assert(fd_valid(fd));
  8020de:	89 d8                	mov    %ebx,%eax
  8020e0:	e8 1b ff ff ff       	call   802000 <_ZL8fd_validPK2Fd>
  8020e5:	84 c0                	test   %al,%al
  8020e7:	75 24                	jne    80210d <_Z6fd2numP2Fd+0x39>
  8020e9:	c7 44 24 0c 7e 49 81 	movl   $0x81497e,0xc(%esp)
  8020f0:	00 
  8020f1:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  8020f8:	00 
  8020f9:	c7 44 24 04 3d 00 00 	movl   $0x3d,0x4(%esp)
  802100:	00 
  802101:	c7 04 24 a0 49 81 00 	movl   $0x8149a0,(%esp)
  802108:	e8 ab e8 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
  80210d:	8d 83 00 00 00 30    	lea    0x30000000(%ebx),%eax
  802113:	c1 e8 0c             	shr    $0xc,%eax
}
  802116:	83 c4 14             	add    $0x14,%esp
  802119:	5b                   	pop    %ebx
  80211a:	5d                   	pop    %ebp
  80211b:	c3                   	ret    

0080211c <_Z7fd2dataP2Fd>:

// Return the file descriptor data pointer for a 'struct Fd'.
//
char *
fd2data(struct Fd *fd)
{
  80211c:	55                   	push   %ebp
  80211d:	89 e5                	mov    %esp,%ebp
  80211f:	83 ec 18             	sub    $0x18,%esp
	int num = fd2num(fd);
  802122:	8b 45 08             	mov    0x8(%ebp),%eax
  802125:	89 04 24             	mov    %eax,(%esp)
  802128:	e8 a7 ff ff ff       	call   8020d4 <_Z6fd2numP2Fd>
	return (char *) (FDDATA + num * PGSIZE);
  80212d:	05 20 00 0d 00       	add    $0xd0020,%eax
  802132:	c1 e0 0c             	shl    $0xc,%eax
}
  802135:	c9                   	leave  
  802136:	c3                   	ret    

00802137 <_Z14fd_find_unusedPP2Fd>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_find_unused(struct Fd **fd_store)
{
  802137:	55                   	push   %ebp
  802138:	89 e5                	mov    %esp,%ebp
  80213a:	57                   	push   %edi
  80213b:	56                   	push   %esi
  80213c:	53                   	push   %ebx
  80213d:	83 ec 2c             	sub    $0x2c,%esp
  802140:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct Fd *fd;

	for (i = 0; i < NFD; i++) {
  802143:	bb 00 00 00 00       	mov    $0x0,%ebx
		(void) fd_lookup(i, &fd, false);
  802148:	8d 75 e4             	lea    -0x1c(%ebp),%esi
  80214b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802152:	00 
  802153:	89 74 24 04          	mov    %esi,0x4(%esp)
  802157:	89 1c 24             	mov    %ebx,(%esp)
  80215a:	e8 22 ff ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
		if (!fd_isopen(fd)) {
  80215f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802162:	e8 bb fe ff ff       	call   802022 <_ZL9fd_isopenPK2Fd>
  802167:	84 c0                	test   %al,%al
  802169:	75 0c                	jne    802177 <_Z14fd_find_unusedPP2Fd+0x40>
			*fd_store = fd;
  80216b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80216e:	89 07                	mov    %eax,(%edi)
			return 0;
  802170:	b8 00 00 00 00       	mov    $0x0,%eax
  802175:	eb 13                	jmp    80218a <_Z14fd_find_unusedPP2Fd+0x53>
fd_find_unused(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < NFD; i++) {
  802177:	83 c3 01             	add    $0x1,%ebx
  80217a:	83 fb 20             	cmp    $0x20,%ebx
  80217d:	75 cc                	jne    80214b <_Z14fd_find_unusedPP2Fd+0x14>
		if (!fd_isopen(fd)) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  80217f:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
	return -E_MAX_OPEN;
  802185:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  80218a:	83 c4 2c             	add    $0x2c,%esp
  80218d:	5b                   	pop    %ebx
  80218e:	5e                   	pop    %esi
  80218f:	5f                   	pop    %edi
  802190:	5d                   	pop    %ebp
  802191:	c3                   	ret    

00802192 <_Z10dev_lookupiPP3Dev>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  802192:	55                   	push   %ebp
  802193:	89 e5                	mov    %esp,%ebp
  802195:	53                   	push   %ebx
  802196:	83 ec 14             	sub    $0x14,%esp
  802199:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80219c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int i;
	for (i = 0; devtab[i]; i++)
  80219f:	b8 00 00 00 00       	mov    $0x0,%eax
		if (devtab[i]->dev_id == dev_id) {
  8021a4:	39 0d 04 80 81 00    	cmp    %ecx,0x818004
  8021aa:	75 16                	jne    8021c2 <_Z10dev_lookupiPP3Dev+0x30>
  8021ac:	eb 06                	jmp    8021b4 <_Z10dev_lookupiPP3Dev+0x22>
  8021ae:	39 0a                	cmp    %ecx,(%edx)
  8021b0:	75 10                	jne    8021c2 <_Z10dev_lookupiPP3Dev+0x30>
  8021b2:	eb 05                	jmp    8021b9 <_Z10dev_lookupiPP3Dev+0x27>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8021b4:	ba 04 80 81 00       	mov    $0x818004,%edx
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
  8021b9:	89 13                	mov    %edx,(%ebx)
			return 0;
  8021bb:	b8 00 00 00 00       	mov    $0x0,%eax
  8021c0:	eb 35                	jmp    8021f7 <_Z10dev_lookupiPP3Dev+0x65>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  8021c2:	83 c0 01             	add    $0x1,%eax
  8021c5:	8b 14 85 0c 4a 81 00 	mov    0x814a0c(,%eax,4),%edx
  8021cc:	85 d2                	test   %edx,%edx
  8021ce:	75 de                	jne    8021ae <_Z10dev_lookupiPP3Dev+0x1c>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", thisenv->env_id, dev_id);
  8021d0:	a1 98 90 81 00       	mov    0x819098,%eax
  8021d5:	8b 40 04             	mov    0x4(%eax),%eax
  8021d8:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8021dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021e0:	c7 04 24 c8 49 81 00 	movl   $0x8149c8,(%esp)
  8021e7:	e8 ea e8 ff ff       	call   800ad6 <_Z7cprintfPKcz>
	*dev = 0;
  8021ec:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	return -E_INVAL;
  8021f2:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  8021f7:	83 c4 14             	add    $0x14,%esp
  8021fa:	5b                   	pop    %ebx
  8021fb:	5d                   	pop    %ebp
  8021fc:	c3                   	ret    

008021fd <_Z8fd_closeP2Fdb>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  8021fd:	55                   	push   %ebp
  8021fe:	89 e5                	mov    %esp,%ebp
  802200:	56                   	push   %esi
  802201:	53                   	push   %ebx
  802202:	83 ec 20             	sub    $0x20,%esp
  802205:	8b 75 08             	mov    0x8(%ebp),%esi
  802208:	0f b6 5d 0c          	movzbl 0xc(%ebp),%ebx
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2, must_exist)) < 0
  80220c:	89 34 24             	mov    %esi,(%esp)
  80220f:	e8 c0 fe ff ff       	call   8020d4 <_Z6fd2numP2Fd>
  802214:	0f b6 d3             	movzbl %bl,%edx
  802217:	89 54 24 08          	mov    %edx,0x8(%esp)
  80221b:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80221e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802222:	89 04 24             	mov    %eax,(%esp)
  802225:	e8 57 fe ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  80222a:	85 c0                	test   %eax,%eax
  80222c:	78 05                	js     802233 <_Z8fd_closeP2Fdb+0x36>
  80222e:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  802231:	74 0c                	je     80223f <_Z8fd_closeP2Fdb+0x42>
	    || fd != fd2)
		return (must_exist ? -E_INVAL : 0);
  802233:	80 fb 01             	cmp    $0x1,%bl
  802236:	19 db                	sbb    %ebx,%ebx
  802238:	f7 d3                	not    %ebx
  80223a:	83 e3 fd             	and    $0xfffffffd,%ebx
  80223d:	eb 3d                	jmp    80227c <_Z8fd_closeP2Fdb+0x7f>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  80223f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802242:	89 44 24 04          	mov    %eax,0x4(%esp)
  802246:	8b 06                	mov    (%esi),%eax
  802248:	89 04 24             	mov    %eax,(%esp)
  80224b:	e8 42 ff ff ff       	call   802192 <_Z10dev_lookupiPP3Dev>
  802250:	89 c3                	mov    %eax,%ebx
  802252:	85 c0                	test   %eax,%eax
  802254:	78 16                	js     80226c <_Z8fd_closeP2Fdb+0x6f>
		if (dev->dev_close)
  802256:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802259:	8b 40 10             	mov    0x10(%eax),%eax
			r = (*dev->dev_close)(fd);
		else
			r = 0;
  80225c:	bb 00 00 00 00       	mov    $0x0,%ebx
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2, must_exist)) < 0
	    || fd != fd2)
		return (must_exist ? -E_INVAL : 0);
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
		if (dev->dev_close)
  802261:	85 c0                	test   %eax,%eax
  802263:	74 07                	je     80226c <_Z8fd_closeP2Fdb+0x6f>
			r = (*dev->dev_close)(fd);
  802265:	89 34 24             	mov    %esi,(%esp)
  802268:	ff d0                	call   *%eax
  80226a:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  80226c:	89 74 24 04          	mov    %esi,0x4(%esp)
  802270:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802277:	e8 11 f4 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
	return r;
}
  80227c:	89 d8                	mov    %ebx,%eax
  80227e:	83 c4 20             	add    $0x20,%esp
  802281:	5b                   	pop    %ebx
  802282:	5e                   	pop    %esi
  802283:	5d                   	pop    %ebp
  802284:	c3                   	ret    

00802285 <_Z5closei>:
// File descriptor interface functions
// --------------------------------------------------------------

int
close(int fdnum)
{
  802285:	55                   	push   %ebp
  802286:	89 e5                	mov    %esp,%ebp
  802288:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;
	if ((r = fd_lookup(fdnum, &fd, true)) < 0)
  80228b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  802292:	00 
  802293:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802296:	89 44 24 04          	mov    %eax,0x4(%esp)
  80229a:	8b 45 08             	mov    0x8(%ebp),%eax
  80229d:	89 04 24             	mov    %eax,(%esp)
  8022a0:	e8 dc fd ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  8022a5:	85 c0                	test   %eax,%eax
  8022a7:	78 13                	js     8022bc <_Z5closei+0x37>
		return r;
	else
		return fd_close(fd, true);
  8022a9:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8022b0:	00 
  8022b1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8022b4:	89 04 24             	mov    %eax,(%esp)
  8022b7:	e8 41 ff ff ff       	call   8021fd <_Z8fd_closeP2Fdb>
}
  8022bc:	c9                   	leave  
  8022bd:	c3                   	ret    

008022be <_Z9close_allv>:

void
close_all(void)
{
  8022be:	55                   	push   %ebp
  8022bf:	89 e5                	mov    %esp,%ebp
  8022c1:	53                   	push   %ebx
  8022c2:	83 ec 14             	sub    $0x14,%esp
	int i;
	for (i = 0; i < NFD; i++)
  8022c5:	bb 00 00 00 00       	mov    $0x0,%ebx
		close(i);
  8022ca:	89 1c 24             	mov    %ebx,(%esp)
  8022cd:	e8 b3 ff ff ff       	call   802285 <_Z5closei>

void
close_all(void)
{
	int i;
	for (i = 0; i < NFD; i++)
  8022d2:	83 c3 01             	add    $0x1,%ebx
  8022d5:	83 fb 20             	cmp    $0x20,%ebx
  8022d8:	75 f0                	jne    8022ca <_Z9close_allv+0xc>
		close(i);
}
  8022da:	83 c4 14             	add    $0x14,%esp
  8022dd:	5b                   	pop    %ebx
  8022de:	5d                   	pop    %ebp
  8022df:	c3                   	ret    

008022e0 <_Z3dupii>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8022e0:	55                   	push   %ebp
  8022e1:	89 e5                	mov    %esp,%ebp
  8022e3:	83 ec 48             	sub    $0x48,%esp
  8022e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8022e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8022ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8022ef:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd, true)) < 0
  8022f2:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8022f9:	00 
  8022fa:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8022fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  802301:	8b 45 08             	mov    0x8(%ebp),%eax
  802304:	89 04 24             	mov    %eax,(%esp)
  802307:	e8 75 fd ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  80230c:	89 c3                	mov    %eax,%ebx
  80230e:	85 c0                	test   %eax,%eax
  802310:	0f 88 ce 00 00 00    	js     8023e4 <_Z3dupii+0x104>
  802316:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80231d:	00 
	    || (r = fd_lookup(newfdnum, &newfd, false)) < 0)
  80231e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  802321:	89 44 24 04          	mov    %eax,0x4(%esp)
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd, true)) < 0
  802325:	89 34 24             	mov    %esi,(%esp)
  802328:	e8 54 fd ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  80232d:	89 c3                	mov    %eax,%ebx
  80232f:	85 c0                	test   %eax,%eax
  802331:	0f 89 bc 00 00 00    	jns    8023f3 <_Z3dupii+0x113>
  802337:	e9 a8 00 00 00       	jmp    8023e4 <_Z3dupii+0x104>
	close(newfdnum);

	ova = fd2data(oldfd);
	nva = fd2data(newfd);

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[PGNUM(ova)] & PTE_P))
  80233c:	89 d8                	mov    %ebx,%eax
  80233e:	c1 e8 0c             	shr    $0xc,%eax
  802341:	8b 14 85 00 00 80 ef 	mov    -0x10800000(,%eax,4),%edx
  802348:	f6 c2 01             	test   $0x1,%dl
  80234b:	74 32                	je     80237f <_Z3dupii+0x9f>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
  80234d:	8b 04 85 00 00 80 ef 	mov    -0x10800000(,%eax,4),%eax
  802354:	25 07 0e 00 00       	and    $0xe07,%eax
  802359:	89 44 24 10          	mov    %eax,0x10(%esp)
  80235d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  802361:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802368:	00 
  802369:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80236d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802374:	e8 b6 f2 ff ff       	call   80162f <_Z12sys_page_mapiPviS_i>
  802379:	89 c3                	mov    %eax,%ebx
  80237b:	85 c0                	test   %eax,%eax
  80237d:	78 3e                	js     8023bd <_Z3dupii+0xdd>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
  80237f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802382:	89 c2                	mov    %eax,%edx
  802384:	c1 ea 0c             	shr    $0xc,%edx
  802387:	8b 14 95 00 00 80 ef 	mov    -0x10800000(,%edx,4),%edx
  80238e:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  802394:	89 54 24 10          	mov    %edx,0x10(%esp)
  802398:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80239b:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80239f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8023a6:	00 
  8023a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023ab:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8023b2:	e8 78 f2 ff ff       	call   80162f <_Z12sys_page_mapiPviS_i>
  8023b7:	89 c3                	mov    %eax,%ebx
  8023b9:	85 c0                	test   %eax,%eax
  8023bb:	79 25                	jns    8023e2 <_Z3dupii+0x102>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8023bd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8023c0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8023cb:	e8 bd f2 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
	sys_page_unmap(0, nva);
  8023d0:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8023d4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8023db:	e8 ad f2 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
	return r;
  8023e0:	eb 02                	jmp    8023e4 <_Z3dupii+0x104>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[PGNUM(ova)] & PTE_SYSCALL)) < 0)
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[PGNUM(oldfd)] & PTE_SYSCALL)) < 0)
		goto err;

	return newfdnum;
  8023e2:	89 f3                	mov    %esi,%ebx

err:
	sys_page_unmap(0, newfd);
	sys_page_unmap(0, nva);
	return r;
}
  8023e4:	89 d8                	mov    %ebx,%eax
  8023e6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8023e9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8023ec:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8023ef:	89 ec                	mov    %ebp,%esp
  8023f1:	5d                   	pop    %ebp
  8023f2:	c3                   	ret    
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd, true)) < 0
	    || (r = fd_lookup(newfdnum, &newfd, false)) < 0)
		return r;
	close(newfdnum);
  8023f3:	89 34 24             	mov    %esi,(%esp)
  8023f6:	e8 8a fe ff ff       	call   802285 <_Z5closei>

	ova = fd2data(oldfd);
  8023fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8023fe:	89 04 24             	mov    %eax,(%esp)
  802401:	e8 16 fd ff ff       	call   80211c <_Z7fd2dataP2Fd>
  802406:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  802408:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80240b:	89 04 24             	mov    %eax,(%esp)
  80240e:	e8 09 fd ff ff       	call   80211c <_Z7fd2dataP2Fd>
  802413:	89 c7                	mov    %eax,%edi

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[PGNUM(ova)] & PTE_P))
  802415:	89 d8                	mov    %ebx,%eax
  802417:	c1 e8 16             	shr    $0x16,%eax
  80241a:	8b 04 85 00 e0 bb ef 	mov    -0x10442000(,%eax,4),%eax
  802421:	a8 01                	test   $0x1,%al
  802423:	0f 85 13 ff ff ff    	jne    80233c <_Z3dupii+0x5c>
  802429:	e9 51 ff ff ff       	jmp    80237f <_Z3dupii+0x9f>

0080242e <_Z4readiPvj>:
	return r;
}

ssize_t
read(int fdnum, void *buf, size_t n)
{
  80242e:	55                   	push   %ebp
  80242f:	89 e5                	mov    %esp,%ebp
  802431:	53                   	push   %ebx
  802432:	83 ec 24             	sub    $0x24,%esp
  802435:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  802438:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80243f:	00 
  802440:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802443:	89 44 24 04          	mov    %eax,0x4(%esp)
  802447:	89 1c 24             	mov    %ebx,(%esp)
  80244a:	e8 32 fc ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  80244f:	85 c0                	test   %eax,%eax
  802451:	78 5f                	js     8024b2 <_Z4readiPvj+0x84>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802453:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802456:	89 44 24 04          	mov    %eax,0x4(%esp)
  80245a:	8b 45 f0             	mov    -0x10(%ebp),%eax
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  80245d:	8b 00                	mov    (%eax),%eax
  80245f:	89 04 24             	mov    %eax,(%esp)
  802462:	e8 2b fd ff ff       	call   802192 <_Z10dev_lookupiPP3Dev>
  802467:	85 c0                	test   %eax,%eax
  802469:	79 4d                	jns    8024b8 <_Z4readiPvj+0x8a>
  80246b:	eb 45                	jmp    8024b2 <_Z4readiPvj+0x84>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
  80246d:	a1 98 90 81 00       	mov    0x819098,%eax
  802472:	8b 40 04             	mov    0x4(%eax),%eax
  802475:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802479:	89 44 24 04          	mov    %eax,0x4(%esp)
  80247d:	c7 04 24 a9 49 81 00 	movl   $0x8149a9,(%esp)
  802484:	e8 4d e6 ff ff       	call   800ad6 <_Z7cprintfPKcz>
		return -E_INVAL;
  802489:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80248e:	eb 22                	jmp    8024b2 <_Z4readiPvj+0x84>
	}
	if (!dev->dev_read)
  802490:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802493:	8b 50 08             	mov    0x8(%eax),%edx
		return -E_NOT_SUPP;
  802496:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
		cprintf("[%08x] read %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_read)
  80249b:	85 d2                	test   %edx,%edx
  80249d:	74 13                	je     8024b2 <_Z4readiPvj+0x84>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  80249f:	8b 45 10             	mov    0x10(%ebp),%eax
  8024a2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8024a6:	8b 45 0c             	mov    0xc(%ebp),%eax
  8024a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024ad:	89 0c 24             	mov    %ecx,(%esp)
  8024b0:	ff d2                	call   *%edx
}
  8024b2:	83 c4 24             	add    $0x24,%esp
  8024b5:	5b                   	pop    %ebx
  8024b6:	5d                   	pop    %ebp
  8024b7:	c3                   	ret    
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  8024b8:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  8024bb:	8b 41 08             	mov    0x8(%ecx),%eax
  8024be:	83 e0 03             	and    $0x3,%eax
  8024c1:	83 f8 01             	cmp    $0x1,%eax
  8024c4:	75 ca                	jne    802490 <_Z4readiPvj+0x62>
  8024c6:	eb a5                	jmp    80246d <_Z4readiPvj+0x3f>

008024c8 <_Z5readniPvj>:
	return (*dev->dev_read)(fd, buf, n);
}

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  8024c8:	55                   	push   %ebp
  8024c9:	89 e5                	mov    %esp,%ebp
  8024cb:	57                   	push   %edi
  8024cc:	56                   	push   %esi
  8024cd:	53                   	push   %ebx
  8024ce:	83 ec 1c             	sub    $0x1c,%esp
  8024d1:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8024d4:	8b 75 10             	mov    0x10(%ebp),%esi
	int m;
	size_t tot;

	for (tot = 0; tot < n; tot += m) {
  8024d7:	85 f6                	test   %esi,%esi
  8024d9:	74 2f                	je     80250a <_Z5readniPvj+0x42>
  8024db:	bb 00 00 00 00       	mov    $0x0,%ebx
		m = read(fdnum, (char*)buf + tot, n - tot);
  8024e0:	89 f0                	mov    %esi,%eax
  8024e2:	29 d8                	sub    %ebx,%eax
  8024e4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8024e8:	8d 04 1f             	lea    (%edi,%ebx,1),%eax
  8024eb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024ef:	8b 45 08             	mov    0x8(%ebp),%eax
  8024f2:	89 04 24             	mov    %eax,(%esp)
  8024f5:	e8 34 ff ff ff       	call   80242e <_Z4readiPvj>
		if (m < 0)
  8024fa:	85 c0                	test   %eax,%eax
  8024fc:	78 13                	js     802511 <_Z5readniPvj+0x49>
			return m;
		if (m == 0)
  8024fe:	85 c0                	test   %eax,%eax
  802500:	74 0d                	je     80250f <_Z5readniPvj+0x47>
readn(int fdnum, void *buf, size_t n)
{
	int m;
	size_t tot;

	for (tot = 0; tot < n; tot += m) {
  802502:	01 c3                	add    %eax,%ebx
  802504:	39 de                	cmp    %ebx,%esi
  802506:	77 d8                	ja     8024e0 <_Z5readniPvj+0x18>
  802508:	eb 05                	jmp    80250f <_Z5readniPvj+0x47>
  80250a:	bb 00 00 00 00       	mov    $0x0,%ebx
		if (m < 0)
			return m;
		if (m == 0)
			break;
	}
	return tot;
  80250f:	89 d8                	mov    %ebx,%eax
}
  802511:	83 c4 1c             	add    $0x1c,%esp
  802514:	5b                   	pop    %ebx
  802515:	5e                   	pop    %esi
  802516:	5f                   	pop    %edi
  802517:	5d                   	pop    %ebp
  802518:	c3                   	ret    

00802519 <_Z5writeiPKvj>:

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  802519:	55                   	push   %ebp
  80251a:	89 e5                	mov    %esp,%ebp
  80251c:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  80251f:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  802526:	00 
  802527:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80252a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80252e:	8b 45 08             	mov    0x8(%ebp),%eax
  802531:	89 04 24             	mov    %eax,(%esp)
  802534:	e8 48 fb ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  802539:	85 c0                	test   %eax,%eax
  80253b:	78 3c                	js     802579 <_Z5writeiPKvj+0x60>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80253d:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802540:	89 44 24 04          	mov    %eax,0x4(%esp)
  802544:	8b 45 f0             	mov    -0x10(%ebp),%eax
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  802547:	8b 00                	mov    (%eax),%eax
  802549:	89 04 24             	mov    %eax,(%esp)
  80254c:	e8 41 fc ff ff       	call   802192 <_Z10dev_lookupiPP3Dev>
  802551:	85 c0                	test   %eax,%eax
  802553:	79 26                	jns    80257b <_Z5writeiPKvj+0x62>
  802555:	eb 22                	jmp    802579 <_Z5writeiPKvj+0x60>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY)
		return -E_INVAL;
	if (!dev->dev_write)
  802557:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80255a:	8b 48 0c             	mov    0xc(%eax),%ecx
		return -E_NOT_SUPP;
  80255d:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	if ((r = fd_lookup(fdnum, &fd, true)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY)
		return -E_INVAL;
	if (!dev->dev_write)
  802562:	85 c9                	test   %ecx,%ecx
  802564:	74 13                	je     802579 <_Z5writeiPKvj+0x60>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  802566:	8b 45 10             	mov    0x10(%ebp),%eax
  802569:	89 44 24 08          	mov    %eax,0x8(%esp)
  80256d:	8b 45 0c             	mov    0xc(%ebp),%eax
  802570:	89 44 24 04          	mov    %eax,0x4(%esp)
  802574:	89 14 24             	mov    %edx,(%esp)
  802577:	ff d1                	call   *%ecx
}
  802579:	c9                   	leave  
  80257a:	c3                   	ret    
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY)
  80257b:	8b 55 f0             	mov    -0x10(%ebp),%edx
		return -E_INVAL;
  80257e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY)
  802583:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  802587:	74 f0                	je     802579 <_Z5writeiPKvj+0x60>
  802589:	eb cc                	jmp    802557 <_Z5writeiPKvj+0x3e>

0080258b <_Z4seekii>:
	return (*dev->dev_write)(fd, buf, n);
}

int
seek(int fdnum, off_t offset)
{
  80258b:	55                   	push   %ebp
  80258c:	89 e5                	mov    %esp,%ebp
  80258e:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0)
  802591:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  802598:	00 
  802599:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80259c:	89 44 24 04          	mov    %eax,0x4(%esp)
  8025a0:	8b 45 08             	mov    0x8(%ebp),%eax
  8025a3:	89 04 24             	mov    %eax,(%esp)
  8025a6:	e8 d6 fa ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  8025ab:	85 c0                	test   %eax,%eax
  8025ad:	78 0e                	js     8025bd <_Z4seekii+0x32>
		return r;
	fd->fd_offset = offset;
  8025af:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8025b2:	8b 55 0c             	mov    0xc(%ebp),%edx
  8025b5:	89 50 04             	mov    %edx,0x4(%eax)
	return 0;
  8025b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8025bd:	c9                   	leave  
  8025be:	c3                   	ret    

008025bf <_Z9ftruncateii>:

int
ftruncate(int fdnum, off_t newsize)
{
  8025bf:	55                   	push   %ebp
  8025c0:	89 e5                	mov    %esp,%ebp
  8025c2:	53                   	push   %ebx
  8025c3:	83 ec 24             	sub    $0x24,%esp
  8025c6:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  8025c9:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8025d0:	00 
  8025d1:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8025d4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8025d8:	89 1c 24             	mov    %ebx,(%esp)
  8025db:	e8 a1 fa ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  8025e0:	85 c0                	test   %eax,%eax
  8025e2:	78 58                	js     80263c <_Z9ftruncateii+0x7d>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  8025e4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8025e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8025eb:	8b 45 f0             	mov    -0x10(%ebp),%eax
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  8025ee:	8b 00                	mov    (%eax),%eax
  8025f0:	89 04 24             	mov    %eax,(%esp)
  8025f3:	e8 9a fb ff ff       	call   802192 <_Z10dev_lookupiPP3Dev>
  8025f8:	85 c0                	test   %eax,%eax
  8025fa:	79 46                	jns    802642 <_Z9ftruncateii+0x83>
  8025fc:	eb 3e                	jmp    80263c <_Z9ftruncateii+0x7d>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n", thisenv->env_id, fdnum);
  8025fe:	a1 98 90 81 00       	mov    0x819098,%eax
  802603:	8b 40 04             	mov    0x4(%eax),%eax
  802606:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80260a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80260e:	c7 04 24 e8 49 81 00 	movl   $0x8149e8,(%esp)
  802615:	e8 bc e4 ff ff       	call   800ad6 <_Z7cprintfPKcz>
		return -E_INVAL;
  80261a:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80261f:	eb 1b                	jmp    80263c <_Z9ftruncateii+0x7d>
	}
	if (!dev->dev_trunc)
  802621:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802624:	8b 50 18             	mov    0x18(%eax),%edx
		return -E_NOT_SUPP;
  802627:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n", thisenv->env_id, fdnum);
		return -E_INVAL;
	}
	if (!dev->dev_trunc)
  80262c:	85 d2                	test   %edx,%edx
  80262e:	74 0c                	je     80263c <_Z9ftruncateii+0x7d>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  802630:	8b 45 0c             	mov    0xc(%ebp),%eax
  802633:	89 44 24 04          	mov    %eax,0x4(%esp)
  802637:	89 0c 24             	mov    %ecx,(%esp)
  80263a:	ff d2                	call   *%edx
}
  80263c:	83 c4 24             	add    $0x24,%esp
  80263f:	5b                   	pop    %ebx
  802640:	5d                   	pop    %ebp
  802641:	c3                   	ret    
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  802642:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  802645:	f6 41 08 03          	testb  $0x3,0x8(%ecx)
  802649:	75 d6                	jne    802621 <_Z9ftruncateii+0x62>
  80264b:	eb b1                	jmp    8025fe <_Z9ftruncateii+0x3f>

0080264d <_Z5fstatiP4Stat>:
	return (*dev->dev_trunc)(fd, newsize);
}

int
fstat(int fdnum, struct Stat *stat)
{
  80264d:	55                   	push   %ebp
  80264e:	89 e5                	mov    %esp,%ebp
  802650:	53                   	push   %ebx
  802651:	83 ec 24             	sub    $0x24,%esp
  802654:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  802657:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80265e:	00 
  80265f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802662:	89 44 24 04          	mov    %eax,0x4(%esp)
  802666:	8b 45 08             	mov    0x8(%ebp),%eax
  802669:	89 04 24             	mov    %eax,(%esp)
  80266c:	e8 10 fa ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  802671:	85 c0                	test   %eax,%eax
  802673:	78 3e                	js     8026b3 <_Z5fstatiP4Stat+0x66>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802675:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802678:	89 44 24 04          	mov    %eax,0x4(%esp)
  80267c:	8b 45 f0             	mov    -0x10(%ebp),%eax
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
  80267f:	8b 00                	mov    (%eax),%eax
  802681:	89 04 24             	mov    %eax,(%esp)
  802684:	e8 09 fb ff ff       	call   802192 <_Z10dev_lookupiPP3Dev>
  802689:	85 c0                	test   %eax,%eax
  80268b:	79 2c                	jns    8026b9 <_Z5fstatiP4Stat+0x6c>
  80268d:	eb 24                	jmp    8026b3 <_Z5fstatiP4Stat+0x66>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  80268f:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  802692:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
	stat->st_ftype = 0;
  802699:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
	stat->st_dev = dev;
  8026a0:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
	return (*dev->dev_stat)(fd, stat);
  8026a6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8026ad:	89 04 24             	mov    %eax,(%esp)
  8026b0:	ff 52 14             	call   *0x14(%edx)
}
  8026b3:	83 c4 24             	add    $0x24,%esp
  8026b6:	5b                   	pop    %ebx
  8026b7:	5d                   	pop    %ebp
  8026b8:	c3                   	ret    
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  8026b9:	8b 55 f4             	mov    -0xc(%ebp),%edx
		return -E_NOT_SUPP;
  8026bc:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  8026c1:	83 7a 14 00          	cmpl   $0x0,0x14(%edx)
  8026c5:	75 c8                	jne    80268f <_Z5fstatiP4Stat+0x42>
  8026c7:	eb ea                	jmp    8026b3 <_Z5fstatiP4Stat+0x66>

008026c9 <_Z4statPKcP4Stat>:
	return (*dev->dev_stat)(fd, stat);
}

int
stat(const char *path, struct Stat *stat)
{
  8026c9:	55                   	push   %ebp
  8026ca:	89 e5                	mov    %esp,%ebp
  8026cc:	83 ec 18             	sub    $0x18,%esp
  8026cf:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8026d2:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  8026d5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8026dc:	00 
  8026dd:	8b 45 08             	mov    0x8(%ebp),%eax
  8026e0:	89 04 24             	mov    %eax,(%esp)
  8026e3:	e8 d6 09 00 00       	call   8030be <_Z4openPKci>
  8026e8:	89 c3                	mov    %eax,%ebx
  8026ea:	85 c0                	test   %eax,%eax
  8026ec:	78 1b                	js     802709 <_Z4statPKcP4Stat+0x40>
		return fd;
	r = fstat(fd, stat);
  8026ee:	8b 45 0c             	mov    0xc(%ebp),%eax
  8026f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8026f5:	89 1c 24             	mov    %ebx,(%esp)
  8026f8:	e8 50 ff ff ff       	call   80264d <_Z5fstatiP4Stat>
  8026fd:	89 c6                	mov    %eax,%esi
	close(fd);
  8026ff:	89 1c 24             	mov    %ebx,(%esp)
  802702:	e8 7e fb ff ff       	call   802285 <_Z5closei>
	return r;
  802707:	89 f3                	mov    %esi,%ebx
}
  802709:	89 d8                	mov    %ebx,%eax
  80270b:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80270e:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802711:	89 ec                	mov    %ebp,%esp
  802713:	5d                   	pop    %ebp
  802714:	c3                   	ret    
	...

00802720 <_ZL10inode_dataP5Inodei>:
// in the file 'ino'.
// Returns NULL if 'off' is out of range for the file.
//
static void *
inode_data(struct Inode *ino, off_t off)
{
  802720:	55                   	push   %ebp
  802721:	89 e5                	mov    %esp,%ebp
	blocknum_t blocknum;
	if (off < 0 || off >= ino->i_size)
		return 0;
  802723:	b9 00 00 00 00       	mov    $0x0,%ecx
//
static void *
inode_data(struct Inode *ino, off_t off)
{
	blocknum_t blocknum;
	if (off < 0 || off >= ino->i_size)
  802728:	85 d2                	test   %edx,%edx
  80272a:	78 33                	js     80275f <_ZL10inode_dataP5Inodei+0x3f>
  80272c:	3b 50 08             	cmp    0x8(%eax),%edx
  80272f:	7d 2e                	jge    80275f <_ZL10inode_dataP5Inodei+0x3f>
		return 0;
	blocknum = ino->i_direct[off / PGSIZE];
  802731:	8d 8a ff 0f 00 00    	lea    0xfff(%edx),%ecx
  802737:	85 d2                	test   %edx,%edx
  802739:	0f 49 ca             	cmovns %edx,%ecx
  80273c:	c1 f9 0c             	sar    $0xc,%ecx
	return (void *) (FSMAP + blocknum * BLKSIZE + off % PGSIZE);
  80273f:	8b 4c 88 0c          	mov    0xc(%eax,%ecx,4),%ecx
  802743:	c1 e1 0c             	shl    $0xc,%ecx
  802746:	89 d0                	mov    %edx,%eax
  802748:	c1 f8 1f             	sar    $0x1f,%eax
  80274b:	c1 e8 14             	shr    $0x14,%eax
  80274e:	01 c2                	add    %eax,%edx
  802750:	81 e2 ff 0f 00 00    	and    $0xfff,%edx
  802756:	29 c2                	sub    %eax,%edx
  802758:	8d 8c 11 00 00 00 50 	lea    0x50000000(%ecx,%edx,1),%ecx
}
  80275f:	89 c8                	mov    %ecx,%eax
  802761:	5d                   	pop    %ebp
  802762:	c3                   	ret    

00802763 <_ZL9stat_basePK5InodeP4Stat>:
    return fd->fd_offset - orig_offset;
}

static void
stat_base(const struct Inode *ino, struct Stat *stat)
{
  802763:	55                   	push   %ebp
  802764:	89 e5                	mov    %esp,%ebp
	stat->st_size = ino->i_size;
  802766:	8b 48 08             	mov    0x8(%eax),%ecx
  802769:	89 4a 78             	mov    %ecx,0x78(%edx)
	stat->st_ftype = ino->i_ftype;
  80276c:	8b 00                	mov    (%eax),%eax
  80276e:	89 42 7c             	mov    %eax,0x7c(%edx)
	stat->st_dev = &devfile;
  802771:	c7 82 80 00 00 00 04 	movl   $0x818004,0x80(%edx)
  802778:	80 81 00 
}
  80277b:	5d                   	pop    %ebp
  80277c:	c3                   	ret    

0080277d <_ZL9get_inodei>:
// Return a pointer to inode number 'inum'.
// The inode might not be in memory right now (it should be demand paged).
//
static struct Inode *
get_inode(int inum)
{
  80277d:	55                   	push   %ebp
  80277e:	89 e5                	mov    %esp,%ebp
  802780:	83 ec 18             	sub    $0x18,%esp
	blocknum_t b = 1 + ROUNDUP(super->s_nblocks, PGSIZE) / PGSIZE + inum;
  802783:	8b 15 04 10 00 50    	mov    0x50001004,%edx
	if (inum == 0 || inum > super->s_ninodes)
  802789:	85 c0                	test   %eax,%eax
  80278b:	74 08                	je     802795 <_ZL9get_inodei+0x18>
  80278d:	3b 05 08 10 00 50    	cmp    0x50001008,%eax
  802793:	7e 20                	jle    8027b5 <_ZL9get_inodei+0x38>
		panic("inode %d out of range", inum);
  802795:	89 44 24 0c          	mov    %eax,0xc(%esp)
  802799:	c7 44 24 08 20 4a 81 	movl   $0x814a20,0x8(%esp)
  8027a0:	00 
  8027a1:	c7 44 24 04 47 00 00 	movl   $0x47,0x4(%esp)
  8027a8:	00 
  8027a9:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  8027b0:	e8 03 e2 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
// The inode might not be in memory right now (it should be demand paged).
//
static struct Inode *
get_inode(int inum)
{
	blocknum_t b = 1 + ROUNDUP(super->s_nblocks, PGSIZE) / PGSIZE + inum;
  8027b5:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  8027bb:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  8027c1:	8d 8a ff 0f 00 00    	lea    0xfff(%edx),%ecx
  8027c7:	85 d2                	test   %edx,%edx
  8027c9:	0f 48 d1             	cmovs  %ecx,%edx
  8027cc:	c1 fa 0c             	sar    $0xc,%edx
	if (inum == 0 || inum > super->s_ninodes)
		panic("inode %d out of range", inum);
	return (struct Inode *) (FSMAP + b * BLKSIZE);
  8027cf:	8d 84 10 01 00 05 00 	lea    0x50001(%eax,%edx,1),%eax
  8027d6:	c1 e0 0c             	shl    $0xc,%eax
}
  8027d9:	c9                   	leave  
  8027da:	c3                   	ret    

008027db <_ZL10bcache_ipcPvi>:
// for the file system block containing 'addr'.
// Returns 0 on success, < 0 on error.
//
static int
bcache_ipc(void *addr, int reqtype)
{
  8027db:	55                   	push   %ebp
  8027dc:	89 e5                	mov    %esp,%ebp
  8027de:	56                   	push   %esi
  8027df:	53                   	push   %ebx
  8027e0:	83 ec 10             	sub    $0x10,%esp
	int r;
	blocknum_t b = ((uintptr_t) addr - FSMAP) / BLKSIZE;
  8027e3:	8d b0 00 00 00 b0    	lea    -0x50000000(%eax),%esi
  8027e9:	c1 ee 0c             	shr    $0xc,%esi
	if (b < 0 || b > (blocknum_t) (DISKSIZE / BLKSIZE))
  8027ec:	81 fe 00 00 08 00    	cmp    $0x80000,%esi
  8027f2:	76 20                	jbe    802814 <_ZL10bcache_ipcPvi+0x39>
		panic("bcache_ipc: va %08x out of disk address range", addr);
  8027f4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8027f8:	c7 44 24 08 5c 4a 81 	movl   $0x814a5c,0x8(%esp)
  8027ff:	00 
  802800:	c7 44 24 04 1f 00 00 	movl   $0x1f,0x4(%esp)
  802807:	00 
  802808:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  80280f:	e8 a4 e1 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	// Be careful: check 'super' might not be loaded!
	if (b >= 2 && b >= super->s_nblocks)
  802814:	83 fe 01             	cmp    $0x1,%esi
  802817:	7e 08                	jle    802821 <_ZL10bcache_ipcPvi+0x46>
  802819:	3b 35 04 10 00 50    	cmp    0x50001004,%esi
  80281f:	7d 12                	jge    802833 <_ZL10bcache_ipcPvi+0x58>
		panic("bcache_ipc: block %d out of file system bounds", b);

	do {
		ipc_send(ENVID_BUFCACHE, MAKE_BCREQ(b, reqtype), 0, 0);
  802821:	89 f3                	mov    %esi,%ebx
  802823:	c1 e3 04             	shl    $0x4,%ebx
  802826:	09 d3                	or     %edx,%ebx
		r = ipc_recv(0, (void *) (FSMAP + b * PGSIZE), 0);
  802828:	81 c6 00 00 05 00    	add    $0x50000,%esi
  80282e:	c1 e6 0c             	shl    $0xc,%esi
  802831:	eb 20                	jmp    802853 <_ZL10bcache_ipcPvi+0x78>
	blocknum_t b = ((uintptr_t) addr - FSMAP) / BLKSIZE;
	if (b < 0 || b > (blocknum_t) (DISKSIZE / BLKSIZE))
		panic("bcache_ipc: va %08x out of disk address range", addr);
	// Be careful: check 'super' might not be loaded!
	if (b >= 2 && b >= super->s_nblocks)
		panic("bcache_ipc: block %d out of file system bounds", b);
  802833:	89 74 24 0c          	mov    %esi,0xc(%esp)
  802837:	c7 44 24 08 8c 4a 81 	movl   $0x814a8c,0x8(%esp)
  80283e:	00 
  80283f:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  802846:	00 
  802847:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  80284e:	e8 65 e1 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

	do {
		ipc_send(ENVID_BUFCACHE, MAKE_BCREQ(b, reqtype), 0, 0);
  802853:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80285a:	00 
  80285b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802862:	00 
  802863:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802867:	c7 04 24 00 11 00 00 	movl   $0x1100,(%esp)
  80286e:	e8 1c f7 ff ff       	call   801f8f <_Z8ipc_sendijPvi>
		r = ipc_recv(0, (void *) (FSMAP + b * PGSIZE), 0);
  802873:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80287a:	00 
  80287b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80287f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802886:	e8 75 f6 ff ff       	call   801f00 <_Z8ipc_recvPiPvS_>
		panic("bcache_ipc: va %08x out of disk address range", addr);
	// Be careful: check 'super' might not be loaded!
	if (b >= 2 && b >= super->s_nblocks)
		panic("bcache_ipc: block %d out of file system bounds", b);

	do {
  80288b:	83 f8 f0             	cmp    $0xfffffff0,%eax
  80288e:	74 c3                	je     802853 <_ZL10bcache_ipcPvi+0x78>
		ipc_send(ENVID_BUFCACHE, MAKE_BCREQ(b, reqtype), 0, 0);
		r = ipc_recv(0, (void *) (FSMAP + b * PGSIZE), 0);
	} while (r == -E_AGAIN);

	return r;
}
  802890:	83 c4 10             	add    $0x10,%esp
  802893:	5b                   	pop    %ebx
  802894:	5e                   	pop    %esi
  802895:	5d                   	pop    %ebp
  802896:	c3                   	ret    

00802897 <_ZL10inode_openiPP5Inode>:
// Every inode_open() must be balanced by an inode_close().
// Returns 0 on success, < 0 on failure.
//
static int
inode_open(int inum, struct Inode **ino_store)
{
  802897:	55                   	push   %ebp
  802898:	89 e5                	mov    %esp,%ebp
  80289a:	83 ec 28             	sub    $0x28,%esp
  80289d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8028a0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8028a3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8028a6:	89 c7                	mov    %eax,%edi
  8028a8:	89 d6                	mov    %edx,%esi
	int r;
	struct Inode *ino;

	// Always make sure our pagefault handler is installed.
	add_pgfault_handler(bcache_pgfault_handler);
  8028aa:	c7 04 24 3d 2b 80 00 	movl   $0x802b3d,(%esp)
  8028b1:	e8 95 22 00 00       	call   804b4b <_Z19add_pgfault_handlerPFvP10UTrapframeE>

	ino = get_inode(inum);
  8028b6:	89 f8                	mov    %edi,%eax
  8028b8:	e8 c0 fe ff ff       	call   80277d <_ZL9get_inodei>
  8028bd:	89 c3                	mov    %eax,%ebx
	r = bcache_ipc(ino, BCREQ_MAP_WLOCK);
  8028bf:	ba 02 00 00 00       	mov    $0x2,%edx
  8028c4:	e8 12 ff ff ff       	call   8027db <_ZL10bcache_ipcPvi>
	if (r < 0) {
  8028c9:	85 c0                	test   %eax,%eax
  8028cb:	79 08                	jns    8028d5 <_ZL10inode_openiPP5Inode+0x3e>
		*ino_store = 0;
  8028cd:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
		return r;
  8028d3:	eb 2e                	jmp    802903 <_ZL10inode_openiPP5Inode+0x6c>
	}

	// Initialize memory-only fields when an inode is first read from disk.
	if (r == 0) {		// i.e., the block has not been INITIALIZEd
  8028d5:	85 c0                	test   %eax,%eax
  8028d7:	75 1c                	jne    8028f5 <_ZL10inode_openiPP5Inode+0x5e>
		ino->i_inum = inum;
  8028d9:	89 bb f4 0f 00 00    	mov    %edi,0xff4(%ebx)
		ino->i_opencount = 0;
  8028df:	c7 83 f8 0f 00 00 00 	movl   $0x0,0xff8(%ebx)
  8028e6:	00 00 00 
		bcache_ipc(ino, BCREQ_INITIALIZE);
  8028e9:	ba 06 00 00 00       	mov    $0x6,%edx
  8028ee:	89 d8                	mov    %ebx,%eax
  8028f0:	e8 e6 fe ff ff       	call   8027db <_ZL10bcache_ipcPvi>
	}

	// Account for our reservation and return.
	++ino->i_opencount;
  8028f5:	83 83 f8 0f 00 00 01 	addl   $0x1,0xff8(%ebx)
	*ino_store = ino;
  8028fc:	89 1e                	mov    %ebx,(%esi)
	return 0;
  8028fe:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802903:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802906:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802909:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80290c:	89 ec                	mov    %ebp,%esp
  80290e:	5d                   	pop    %ebp
  80290f:	c3                   	ret    

00802910 <_ZL14inode_set_sizeP5Inodej>:
// On error, the inode's size and disk's allocation state should be unchanged.
// On success, any changed blocks are flushed.
//
static int
inode_set_size(struct Inode *ino, size_t size)
{
  802910:	55                   	push   %ebp
  802911:	89 e5                	mov    %esp,%ebp
  802913:	57                   	push   %edi
  802914:	56                   	push   %esi
  802915:	53                   	push   %ebx
  802916:	83 ec 2c             	sub    $0x2c,%esp
  802919:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80291c:	89 55 d8             	mov    %edx,-0x28(%ebp)
	// LAB 5: Your code somewhere here

	int b1, b2;

	if (size > MAXFILESIZE)
		return -E_FILE_SIZE;
  80291f:	b8 ee ff ff ff       	mov    $0xffffffee,%eax
	// all cases.  Read the spec carefully: what is missing?
	// LAB 5: Your code somewhere here

	int b1, b2;

	if (size > MAXFILESIZE)
  802924:	81 fa 00 a0 3f 00    	cmp    $0x3fa000,%edx
  80292a:	0f 87 3d 01 00 00    	ja     802a6d <_ZL14inode_set_sizeP5Inodej+0x15d>
		return -E_FILE_SIZE;
    b1 = ino->i_size / BLKSIZE;
  802930:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  802933:	8b 42 08             	mov    0x8(%edx),%eax
  802936:	8d b0 ff 0f 00 00    	lea    0xfff(%eax),%esi
  80293c:	85 c0                	test   %eax,%eax
  80293e:	0f 49 f0             	cmovns %eax,%esi
  802941:	c1 fe 0c             	sar    $0xc,%esi
  802944:	89 f3                	mov    %esi,%ebx
    b2 = ROUNDUP(size, BLKSIZE) / BLKSIZE;
  802946:	8b 7d d8             	mov    -0x28(%ebp),%edi
  802949:	81 c7 ff 0f 00 00    	add    $0xfff,%edi
  80294f:	c1 ef 0c             	shr    $0xc,%edi
    if (size >= (size_t)ino->i_size)
  802952:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  802955:	0f 82 a6 00 00 00    	jb     802a01 <_ZL14inode_set_sizeP5Inodej+0xf1>
    {
        for (; b1 < b2; ++b1)
  80295b:	39 fe                	cmp    %edi,%esi
  80295d:	0f 8d f2 00 00 00    	jge    802a55 <_ZL14inode_set_sizeP5Inodej+0x145>
//	possibly others
// On error, the inode's size and disk's allocation state should be unchanged.
// On success, any changed blocks are flushed.
//
static int
inode_set_size(struct Inode *ino, size_t size)
  802963:	8d 74 b2 0c          	lea    0xc(%edx,%esi,4),%esi
  802967:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80296a:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80296d:	89 75 e0             	mov    %esi,-0x20(%ebp)
    b1 = ino->i_size / BLKSIZE;
    b2 = ROUNDUP(size, BLKSIZE) / BLKSIZE;
    if (size >= (size_t)ino->i_size)
    {
        for (; b1 < b2; ++b1)
            if (ino->i_direct[b1] == 0) {
  802970:	83 3e 00             	cmpl   $0x0,(%esi)
  802973:	75 77                	jne    8029ec <_ZL14inode_set_sizeP5Inodej+0xdc>
	// Find a free block, allocate it, and return its number.
	// Use block locking to avoid concurrency issues -- but try to
	// avoid unnecessary IPCs.
	//
	// LAB 5: Your code here.
    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
  802975:	ba 02 00 00 00       	mov    $0x2,%edx
  80297a:	b8 00 20 00 50       	mov    $0x50002000,%eax
  80297f:	e8 57 fe ff ff       	call   8027db <_ZL10bcache_ipcPvi>
    for(blocknum_t i = 2; i < super->s_nblocks; i++)
  802984:	8b 0d 04 10 00 50    	mov    0x50001004,%ecx
  80298a:	83 f9 02             	cmp    $0x2,%ecx
  80298d:	7e 43                	jle    8029d2 <_ZL14inode_set_sizeP5Inodej+0xc2>
    {
        if(freemap[i] != 0)
  80298f:	b8 03 20 00 50       	mov    $0x50002003,%eax
	// Use block locking to avoid concurrency issues -- but try to
	// avoid unnecessary IPCs.
	//
	// LAB 5: Your code here.
    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
    for(blocknum_t i = 2; i < super->s_nblocks; i++)
  802994:	bb 02 00 00 00       	mov    $0x2,%ebx
    {
        if(freemap[i] != 0)
  802999:	80 3d 02 20 00 50 00 	cmpb   $0x0,0x50002002
  8029a0:	74 29                	je     8029cb <_ZL14inode_set_sizeP5Inodej+0xbb>
  8029a2:	e9 ce 00 00 00       	jmp    802a75 <_ZL14inode_set_sizeP5Inodej+0x165>
  8029a7:	89 c7                	mov    %eax,%edi
  8029a9:	0f b6 10             	movzbl (%eax),%edx
  8029ac:	83 c0 01             	add    $0x1,%eax
  8029af:	84 d2                	test   %dl,%dl
  8029b1:	74 18                	je     8029cb <_ZL14inode_set_sizeP5Inodej+0xbb>
        {
            freemap[i] = 0;
  8029b3:	c6 07 00             	movb   $0x0,(%edi)
            bcache_ipc(freemap, BCREQ_UNLOCK_FLUSH);
  8029b6:	ba 05 00 00 00       	mov    $0x5,%edx
  8029bb:	b8 00 20 00 50       	mov    $0x50002000,%eax
  8029c0:	e8 16 fe ff ff       	call   8027db <_ZL10bcache_ipcPvi>
    if (size >= (size_t)ino->i_size)
    {
        for (; b1 < b2; ++b1)
            if (ino->i_direct[b1] == 0) {
                blocknum_t b = block_alloc();
                if (b < 0) {
  8029c5:	85 db                	test   %ebx,%ebx
  8029c7:	79 1e                	jns    8029e7 <_ZL14inode_set_sizeP5Inodej+0xd7>
  8029c9:	eb 07                	jmp    8029d2 <_ZL14inode_set_sizeP5Inodej+0xc2>
	// Use block locking to avoid concurrency issues -- but try to
	// avoid unnecessary IPCs.
	//
	// LAB 5: Your code here.
    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
    for(blocknum_t i = 2; i < super->s_nblocks; i++)
  8029cb:	83 c3 01             	add    $0x1,%ebx
  8029ce:	39 d9                	cmp    %ebx,%ecx
  8029d0:	7f d5                	jg     8029a7 <_ZL14inode_set_sizeP5Inodej+0x97>
    {
        for (; b1 < b2; ++b1)
            if (ino->i_direct[b1] == 0) {
                blocknum_t b = block_alloc();
                if (b < 0) {
                    inode_set_size(ino, ino->i_size);
  8029d2:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8029d5:	8b 50 08             	mov    0x8(%eax),%edx
  8029d8:	e8 33 ff ff ff       	call   802910 <_ZL14inode_set_sizeP5Inodej>
                    return -E_NO_DISK;
  8029dd:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  8029e2:	e9 86 00 00 00       	jmp    802a6d <_ZL14inode_set_sizeP5Inodej+0x15d>
                }
                ino->i_direct[b1] = b;
  8029e7:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8029ea:	89 1a                	mov    %ebx,(%edx)
		return -E_FILE_SIZE;
    b1 = ino->i_size / BLKSIZE;
    b2 = ROUNDUP(size, BLKSIZE) / BLKSIZE;
    if (size >= (size_t)ino->i_size)
    {
        for (; b1 < b2; ++b1)
  8029ec:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
  8029f0:	83 c6 04             	add    $0x4,%esi
  8029f3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8029f6:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  8029f9:	0f 8f 6e ff ff ff    	jg     80296d <_ZL14inode_set_sizeP5Inodej+0x5d>
  8029ff:	eb 54                	jmp    802a55 <_ZL14inode_set_sizeP5Inodej+0x145>
                ino->i_direct[b1] = b;
            }
    }
    else
    {
        if(!(size % BLKSIZE))
  802a01:	8b 45 d8             	mov    -0x28(%ebp),%eax
  802a04:	25 ff 0f 00 00       	and    $0xfff,%eax
            b2--;
  802a09:	83 f8 01             	cmp    $0x1,%eax
  802a0c:	83 df 00             	sbb    $0x0,%edi
	    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
  802a0f:	ba 02 00 00 00       	mov    $0x2,%edx
  802a14:	b8 00 20 00 50       	mov    $0x50002000,%eax
  802a19:	e8 bd fd ff ff       	call   8027db <_ZL10bcache_ipcPvi>
        for(; b2 < b1; b1--)
  802a1e:	39 f7                	cmp    %esi,%edi
  802a20:	7d 24                	jge    802a46 <_ZL14inode_set_sizeP5Inodej+0x136>
//	possibly others
// On error, the inode's size and disk's allocation state should be unchanged.
// On success, any changed blocks are flushed.
//
static int
inode_set_size(struct Inode *ino, size_t size)
  802a22:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  802a25:	8d 44 b2 0c          	lea    0xc(%edx,%esi,4),%eax
    {
        if(!(size % BLKSIZE))
            b2--;
	    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
        for(; b2 < b1; b1--)
            if (ino->i_direct[b1] != 0)
  802a29:	8b 10                	mov    (%eax),%edx
  802a2b:	85 d2                	test   %edx,%edx
  802a2d:	74 0d                	je     802a3c <_ZL14inode_set_sizeP5Inodej+0x12c>
            {
                freemap[ino->i_direct[b1]] = 1;
  802a2f:	c6 82 00 20 00 50 01 	movb   $0x1,0x50002000(%edx)
                ino->i_direct[b1] = 0;
  802a36:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    else
    {
        if(!(size % BLKSIZE))
            b2--;
	    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
        for(; b2 < b1; b1--)
  802a3c:	83 eb 01             	sub    $0x1,%ebx
  802a3f:	83 e8 04             	sub    $0x4,%eax
  802a42:	39 fb                	cmp    %edi,%ebx
  802a44:	75 e3                	jne    802a29 <_ZL14inode_set_sizeP5Inodej+0x119>
            if (ino->i_direct[b1] != 0)
            {
                freemap[ino->i_direct[b1]] = 1;
                ino->i_direct[b1] = 0;
            }
	    bcache_ipc(freemap, BCREQ_UNLOCK_FLUSH);
  802a46:	ba 05 00 00 00       	mov    $0x5,%edx
  802a4b:	b8 00 20 00 50       	mov    $0x50002000,%eax
  802a50:	e8 86 fd ff ff       	call   8027db <_ZL10bcache_ipcPvi>
    }
	ino->i_size = size;
  802a55:	8b 55 d8             	mov    -0x28(%ebp),%edx
  802a58:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  802a5b:	89 50 08             	mov    %edx,0x8(%eax)
	bcache_ipc(ino, BCREQ_FLUSH);
  802a5e:	ba 04 00 00 00       	mov    $0x4,%edx
  802a63:	e8 73 fd ff ff       	call   8027db <_ZL10bcache_ipcPvi>
	return 0;
  802a68:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802a6d:	83 c4 2c             	add    $0x2c,%esp
  802a70:	5b                   	pop    %ebx
  802a71:	5e                   	pop    %esi
  802a72:	5f                   	pop    %edi
  802a73:	5d                   	pop    %ebp
  802a74:	c3                   	ret    
    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
    for(blocknum_t i = 2; i < super->s_nblocks; i++)
    {
        if(freemap[i] != 0)
        {
            freemap[i] = 0;
  802a75:	c6 05 02 20 00 50 00 	movb   $0x0,0x50002002
            bcache_ipc(freemap, BCREQ_UNLOCK_FLUSH);
  802a7c:	ba 05 00 00 00       	mov    $0x5,%edx
  802a81:	b8 00 20 00 50       	mov    $0x50002000,%eax
  802a86:	e8 50 fd ff ff       	call   8027db <_ZL10bcache_ipcPvi>
	// Use block locking to avoid concurrency issues -- but try to
	// avoid unnecessary IPCs.
	//
	// LAB 5: Your code here.
    bcache_ipc(freemap, BCREQ_MAP_WLOCK);
    for(blocknum_t i = 2; i < super->s_nblocks; i++)
  802a8b:	bb 02 00 00 00       	mov    $0x2,%ebx
  802a90:	e9 52 ff ff ff       	jmp    8029e7 <_ZL14inode_set_sizeP5Inodej+0xd7>

00802a95 <_ZL11inode_closeP5Inode>:
// Reduce its i_opencount and unlock the corresponding block.
// If the inode is now free, then free the corresponding data blocks.
//
static int
inode_close(struct Inode *ino)
{
  802a95:	55                   	push   %ebp
  802a96:	89 e5                	mov    %esp,%ebp
  802a98:	53                   	push   %ebx
  802a99:	83 ec 04             	sub    $0x4,%esp
  802a9c:	89 c3                	mov    %eax,%ebx
	--ino->i_opencount;
  802a9e:	8b 80 f8 0f 00 00    	mov    0xff8(%eax),%eax
  802aa4:	83 e8 01             	sub    $0x1,%eax
  802aa7:	89 83 f8 0f 00 00    	mov    %eax,0xff8(%ebx)
	// The inode might now be free.
	// If no references remain on disk or in memory, then free the
	// corresponding data blocks.
	//
	// LAB 5: Your code here.
    if(!ino->i_refcount && !ino->i_opencount)
  802aad:	83 7b 04 00          	cmpl   $0x0,0x4(%ebx)
  802ab1:	75 40                	jne    802af3 <_ZL11inode_closeP5Inode+0x5e>
  802ab3:	85 c0                	test   %eax,%eax
  802ab5:	75 3c                	jne    802af3 <_ZL11inode_closeP5Inode+0x5e>
    {
        bcache_ipc(freemap, BCREQ_MAP_WLOCK);
  802ab7:	ba 02 00 00 00       	mov    $0x2,%edx
  802abc:	b8 00 20 00 50       	mov    $0x50002000,%eax
  802ac1:	e8 15 fd ff ff       	call   8027db <_ZL10bcache_ipcPvi>
        for(int i = 0; i < NDIRECT; i++)
  802ac6:	b8 00 00 00 00       	mov    $0x0,%eax
        {
            if(ino->i_direct[i] != 0)
  802acb:	8b 54 83 0c          	mov    0xc(%ebx,%eax,4),%edx
  802acf:	85 d2                	test   %edx,%edx
  802ad1:	74 07                	je     802ada <_ZL11inode_closeP5Inode+0x45>
                freemap[ino->i_direct[i]] = 1;
  802ad3:	c6 82 00 20 00 50 01 	movb   $0x1,0x50002000(%edx)
	//
	// LAB 5: Your code here.
    if(!ino->i_refcount && !ino->i_opencount)
    {
        bcache_ipc(freemap, BCREQ_MAP_WLOCK);
        for(int i = 0; i < NDIRECT; i++)
  802ada:	83 c0 01             	add    $0x1,%eax
  802add:	3d fa 03 00 00       	cmp    $0x3fa,%eax
  802ae2:	75 e7                	jne    802acb <_ZL11inode_closeP5Inode+0x36>
        {
            if(ino->i_direct[i] != 0)
                freemap[ino->i_direct[i]] = 1;
            
        }
        bcache_ipc(freemap, BCREQ_UNLOCK_FLUSH);
  802ae4:	ba 05 00 00 00       	mov    $0x5,%edx
  802ae9:	b8 00 20 00 50       	mov    $0x50002000,%eax
  802aee:	e8 e8 fc ff ff       	call   8027db <_ZL10bcache_ipcPvi>
    }
    
	return bcache_ipc(ino, BCREQ_UNLOCK);
  802af3:	ba 03 00 00 00       	mov    $0x3,%edx
  802af8:	89 d8                	mov    %ebx,%eax
  802afa:	e8 dc fc ff ff       	call   8027db <_ZL10bcache_ipcPvi>
}
  802aff:	83 c4 04             	add    $0x4,%esp
  802b02:	5b                   	pop    %ebx
  802b03:	5d                   	pop    %ebp
  802b04:	c3                   	ret    

00802b05 <_ZL13devfile_truncP2Fdi>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  802b05:	55                   	push   %ebp
  802b06:	89 e5                	mov    %esp,%ebp
  802b08:	53                   	push   %ebx
  802b09:	83 ec 14             	sub    $0x14,%esp
	int r;
	struct Inode *ino;

	if ((r = inode_open(fd->fd_file.inum, &ino)) < 0)
  802b0c:	8b 45 08             	mov    0x8(%ebp),%eax
  802b0f:	8b 40 0c             	mov    0xc(%eax),%eax
  802b12:	8d 55 f4             	lea    -0xc(%ebp),%edx
  802b15:	e8 7d fd ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  802b1a:	89 c3                	mov    %eax,%ebx
  802b1c:	85 c0                	test   %eax,%eax
  802b1e:	78 15                	js     802b35 <_ZL13devfile_truncP2Fdi+0x30>
		return r;

	r = inode_set_size(ino, newsize);
  802b20:	8b 55 0c             	mov    0xc(%ebp),%edx
  802b23:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802b26:	e8 e5 fd ff ff       	call   802910 <_ZL14inode_set_sizeP5Inodej>
  802b2b:	89 c3                	mov    %eax,%ebx

	inode_close(ino);
  802b2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802b30:	e8 60 ff ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
	return r;
}
  802b35:	89 d8                	mov    %ebx,%eax
  802b37:	83 c4 14             	add    $0x14,%esp
  802b3a:	5b                   	pop    %ebx
  802b3b:	5d                   	pop    %ebp
  802b3c:	c3                   	ret    

00802b3d <_ZL22bcache_pgfault_handlerP10UTrapframe>:
// Panic if the load fails.
// If the fault isn't in the disk area, return so other handlers run.
//
static void
bcache_pgfault_handler(struct UTrapframe *utf)
{
  802b3d:	55                   	push   %ebp
  802b3e:	89 e5                	mov    %esp,%ebp
  802b40:	53                   	push   %ebx
  802b41:	83 ec 14             	sub    $0x14,%esp
  802b44:	8b 5d 08             	mov    0x8(%ebp),%ebx
    void *va = (void *)utf->utf_fault_va;
  802b47:	8b 03                	mov    (%ebx),%eax
    if (va < (void *)FSMAP || va >= (void *)(FSMAP + DISKSIZE))
  802b49:	89 c2                	mov    %eax,%edx
  802b4b:	81 ea 00 00 00 50    	sub    $0x50000000,%edx
  802b51:	78 32                	js     802b85 <_ZL22bcache_pgfault_handlerP10UTrapframe+0x48>
        return;
    if (bcache_ipc(va, BCREQ_MAP))
  802b53:	ba 00 00 00 00       	mov    $0x0,%edx
  802b58:	e8 7e fc ff ff       	call   8027db <_ZL10bcache_ipcPvi>
  802b5d:	85 c0                	test   %eax,%eax
  802b5f:	74 1c                	je     802b7d <_ZL22bcache_pgfault_handlerP10UTrapframe+0x40>
        panic("bcache_ipc failure");
  802b61:	c7 44 24 08 41 4a 81 	movl   $0x814a41,0x8(%esp)
  802b68:	00 
  802b69:	c7 44 24 04 3a 00 00 	movl   $0x3a,0x4(%esp)
  802b70:	00 
  802b71:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  802b78:	e8 3b de ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    resume(utf);
  802b7d:	89 1c 24             	mov    %ebx,(%esp)
  802b80:	e8 9b 20 00 00       	call   804c20 <resume>
}
  802b85:	83 c4 14             	add    $0x14,%esp
  802b88:	5b                   	pop    %ebx
  802b89:	5d                   	pop    %ebp
  802b8a:	c3                   	ret    

00802b8b <_ZL12devfile_statP2FdP4Stat>:
	stat->st_dev = &devfile;
}

static int
devfile_stat(struct Fd *fd, struct Stat *stat)
{
  802b8b:	55                   	push   %ebp
  802b8c:	89 e5                	mov    %esp,%ebp
  802b8e:	83 ec 28             	sub    $0x28,%esp
  802b91:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802b94:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802b97:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802b9a:	8b 75 0c             	mov    0xc(%ebp),%esi
	int r;
	struct Inode *ino;

	if ((r = inode_open(fd->fd_file.inum, &ino)) < 0)
  802b9d:	8b 43 0c             	mov    0xc(%ebx),%eax
  802ba0:	8d 55 f4             	lea    -0xc(%ebp),%edx
  802ba3:	e8 ef fc ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  802ba8:	85 c0                	test   %eax,%eax
  802baa:	78 26                	js     802bd2 <_ZL12devfile_statP2FdP4Stat+0x47>
		return r;

	strcpy(stat->st_name, fd->fd_file.open_path);
  802bac:	83 c3 10             	add    $0x10,%ebx
  802baf:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802bb3:	89 34 24             	mov    %esi,(%esp)
  802bb6:	e8 2f e5 ff ff       	call   8010ea <_Z6strcpyPcPKc>
	stat_base(ino, stat);
  802bbb:	89 f2                	mov    %esi,%edx
  802bbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802bc0:	e8 9e fb ff ff       	call   802763 <_ZL9stat_basePK5InodeP4Stat>

	inode_close(ino);
  802bc5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802bc8:	e8 c8 fe ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
	return 0;
  802bcd:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802bd2:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802bd5:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802bd8:	89 ec                	mov    %ebp,%esp
  802bda:	5d                   	pop    %ebp
  802bdb:	c3                   	ret    

00802bdc <_ZL13devfile_closeP2Fd>:

// Close the file descriptor.
//
static int
devfile_close(struct Fd *fd)
{
  802bdc:	55                   	push   %ebp
  802bdd:	89 e5                	mov    %esp,%ebp
  802bdf:	53                   	push   %ebx
  802be0:	83 ec 24             	sub    $0x24,%esp
  802be3:	8b 5d 08             	mov    0x8(%ebp),%ebx
	// But the file descriptor might still be open elsewhere
	// (because of fork and dup).  Use pageref to check.
	//
	// LAB 5: Your code here.
    //cprintf("%d\n", pageref(fd));
    if (pageref(fd) > 1)
  802be6:	89 1c 24             	mov    %ebx,(%esp)
  802be9:	e8 9e 15 00 00       	call   80418c <_Z7pagerefPv>
  802bee:	89 c2                	mov    %eax,%edx
        return 0;
  802bf0:	b8 00 00 00 00       	mov    $0x0,%eax
	// But the file descriptor might still be open elsewhere
	// (because of fork and dup).  Use pageref to check.
	//
	// LAB 5: Your code here.
    //cprintf("%d\n", pageref(fd));
    if (pageref(fd) > 1)
  802bf5:	83 fa 01             	cmp    $0x1,%edx
  802bf8:	7f 1e                	jg     802c18 <_ZL13devfile_closeP2Fd+0x3c>
        return 0;
    struct Inode *ino;
    int r;
    if ((r = inode_open(fd->fd_file.inum, &ino)) < 0)
  802bfa:	8b 43 0c             	mov    0xc(%ebx),%eax
  802bfd:	8d 55 f4             	lea    -0xc(%ebp),%edx
  802c00:	e8 92 fc ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  802c05:	85 c0                	test   %eax,%eax
  802c07:	78 0f                	js     802c18 <_ZL13devfile_closeP2Fd+0x3c>
        return r;
    ino->i_opencount--;
  802c09:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802c0c:	83 a8 f8 0f 00 00 01 	subl   $0x1,0xff8(%eax)
    return inode_close(ino);
  802c13:	e8 7d fe ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
}
  802c18:	83 c4 24             	add    $0x24,%esp
  802c1b:	5b                   	pop    %ebx
  802c1c:	5d                   	pop    %ebp
  802c1d:	c3                   	ret    

00802c1e <_ZL13devfile_writeP2FdPKvj>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  802c1e:	55                   	push   %ebp
  802c1f:	89 e5                	mov    %esp,%ebp
  802c21:	57                   	push   %edi
  802c22:	56                   	push   %esi
  802c23:	53                   	push   %ebx
  802c24:	83 ec 3c             	sub    $0x3c,%esp
  802c27:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802c2a:	8b 75 10             	mov    0x10(%ebp),%esi
	// Be careful of block boundaries!
	// Flush any blocks you change using BCREQ_FLUSH.
	//
	// LAB 5: Your code here.
    int r;
    size_t orig_offset = fd->fd_offset;
  802c2d:	8b 43 04             	mov    0x4(%ebx),%eax
  802c30:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    struct Inode *ino;
    if((r = inode_open(fd->fd_file.inum, &ino)) < 0)
  802c33:	8b 43 0c             	mov    0xc(%ebx),%eax
  802c36:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802c39:	e8 59 fc ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  802c3e:	85 c0                	test   %eax,%eax
  802c40:	0f 88 8c 00 00 00    	js     802cd2 <_ZL13devfile_writeP2FdPKvj+0xb4>
        return r;
    void *data;
    size_t n2 = ROUNDUP(fd->fd_offset, PGSIZE) - fd->fd_offset;
  802c46:	8b 53 04             	mov    0x4(%ebx),%edx
  802c49:	8d ba ff 0f 00 00    	lea    0xfff(%edx),%edi
  802c4f:	81 e7 00 f0 ff ff    	and    $0xfffff000,%edi
  802c55:	29 d7                	sub    %edx,%edi
  802c57:	39 f7                	cmp    %esi,%edi
  802c59:	0f 47 fe             	cmova  %esi,%edi
    if (n2 > n)
        n2 = n;
    if(n2)
  802c5c:	85 ff                	test   %edi,%edi
  802c5e:	74 16                	je     802c76 <_ZL13devfile_writeP2FdPKvj+0x58>
    {
        n -= n2;
        if(fd->fd_offset + n2 > (size_t)ino->i_size && 
  802c60:	8d 14 17             	lea    (%edi,%edx,1),%edx
  802c63:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802c66:	3b 50 08             	cmp    0x8(%eax),%edx
  802c69:	76 6f                	jbe    802cda <_ZL13devfile_writeP2FdPKvj+0xbc>
           inode_set_size(ino, fd->fd_offset + n2) < 0)
  802c6b:	e8 a0 fc ff ff       	call   802910 <_ZL14inode_set_sizeP5Inodej>
    if (n2 > n)
        n2 = n;
    if(n2)
    {
        n -= n2;
        if(fd->fd_offset + n2 > (size_t)ino->i_size && 
  802c70:	85 c0                	test   %eax,%eax
  802c72:	79 66                	jns    802cda <_ZL13devfile_writeP2FdPKvj+0xbc>
  802c74:	eb 4e                	jmp    802cc4 <_ZL13devfile_writeP2FdPKvj+0xa6>
        memcpy(data, buf, n2);
        fd->fd_offset += n2;
        bcache_ipc(data, BCREQ_FLUSH);
        buf = (void *)((char *)buf + n2);
    }
    while (n / PGSIZE)
  802c76:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  802c7c:	76 24                	jbe    802ca2 <_ZL13devfile_writeP2FdPKvj+0x84>
  802c7e:	89 f7                	mov    %esi,%edi
    {
        if(fd->fd_offset + PGSIZE > (size_t)ino->i_size && 
  802c80:	8b 53 04             	mov    0x4(%ebx),%edx
  802c83:	81 c2 00 10 00 00    	add    $0x1000,%edx
  802c89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802c8c:	3b 50 08             	cmp    0x8(%eax),%edx
  802c8f:	0f 86 83 00 00 00    	jbe    802d18 <_ZL13devfile_writeP2FdPKvj+0xfa>
           inode_set_size(ino, fd->fd_offset + PGSIZE) < 0)
  802c95:	e8 76 fc ff ff       	call   802910 <_ZL14inode_set_sizeP5Inodej>
        bcache_ipc(data, BCREQ_FLUSH);
        buf = (void *)((char *)buf + n2);
    }
    while (n / PGSIZE)
    {
        if(fd->fd_offset + PGSIZE > (size_t)ino->i_size && 
  802c9a:	85 c0                	test   %eax,%eax
  802c9c:	79 7a                	jns    802d18 <_ZL13devfile_writeP2FdPKvj+0xfa>
  802c9e:	66 90                	xchg   %ax,%ax
  802ca0:	eb 22                	jmp    802cc4 <_ZL13devfile_writeP2FdPKvj+0xa6>
        bcache_ipc(data, BCREQ_FLUSH);
        n -= PGSIZE;
        buf = (void *)((char *)buf + PGSIZE);
        fd->fd_offset += PGSIZE;
    }
    if (n > 0)
  802ca2:	85 f6                	test   %esi,%esi
  802ca4:	74 1e                	je     802cc4 <_ZL13devfile_writeP2FdPKvj+0xa6>
    {
        if(fd->fd_offset + n > (size_t)ino->i_size && 
  802ca6:	89 f2                	mov    %esi,%edx
  802ca8:	03 53 04             	add    0x4(%ebx),%edx
  802cab:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802cae:	3b 50 08             	cmp    0x8(%eax),%edx
  802cb1:	0f 86 b8 00 00 00    	jbe    802d6f <_ZL13devfile_writeP2FdPKvj+0x151>
           inode_set_size(ino, fd->fd_offset + n) < 0)
  802cb7:	e8 54 fc ff ff       	call   802910 <_ZL14inode_set_sizeP5Inodej>
        buf = (void *)((char *)buf + PGSIZE);
        fd->fd_offset += PGSIZE;
    }
    if (n > 0)
    {
        if(fd->fd_offset + n > (size_t)ino->i_size && 
  802cbc:	85 c0                	test   %eax,%eax
  802cbe:	0f 89 ab 00 00 00    	jns    802d6f <_ZL13devfile_writeP2FdPKvj+0x151>
        bcache_ipc(data, BCREQ_FLUSH);
        fd->fd_offset += n;
    }

wrapup:
    inode_close(ino);
  802cc4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802cc7:	e8 c9 fd ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
    return fd->fd_offset - orig_offset;
  802ccc:	8b 43 04             	mov    0x4(%ebx),%eax
  802ccf:	2b 45 d4             	sub    -0x2c(%ebp),%eax
}
  802cd2:	83 c4 3c             	add    $0x3c,%esp
  802cd5:	5b                   	pop    %ebx
  802cd6:	5e                   	pop    %esi
  802cd7:	5f                   	pop    %edi
  802cd8:	5d                   	pop    %ebp
  802cd9:	c3                   	ret    
    size_t n2 = ROUNDUP(fd->fd_offset, PGSIZE) - fd->fd_offset;
    if (n2 > n)
        n2 = n;
    if(n2)
    {
        n -= n2;
  802cda:	29 fe                	sub    %edi,%esi
        if(fd->fd_offset + n2 > (size_t)ino->i_size && 
           inode_set_size(ino, fd->fd_offset + n2) < 0)
            goto wrapup;
        data = inode_data(ino, fd->fd_offset);
  802cdc:	8b 53 04             	mov    0x4(%ebx),%edx
  802cdf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802ce2:	e8 39 fa ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  802ce7:	89 45 d0             	mov    %eax,-0x30(%ebp)
        memcpy(data, buf, n2);
  802cea:	89 7c 24 08          	mov    %edi,0x8(%esp)
  802cee:	8b 45 0c             	mov    0xc(%ebp),%eax
  802cf1:	89 44 24 04          	mov    %eax,0x4(%esp)
  802cf5:	8b 45 d0             	mov    -0x30(%ebp),%eax
  802cf8:	89 04 24             	mov    %eax,(%esp)
  802cfb:	e8 07 e6 ff ff       	call   801307 <memcpy>
        fd->fd_offset += n2;
  802d00:	01 7b 04             	add    %edi,0x4(%ebx)
        bcache_ipc(data, BCREQ_FLUSH);
  802d03:	ba 04 00 00 00       	mov    $0x4,%edx
  802d08:	8b 45 d0             	mov    -0x30(%ebp),%eax
  802d0b:	e8 cb fa ff ff       	call   8027db <_ZL10bcache_ipcPvi>
        buf = (void *)((char *)buf + n2);
  802d10:	01 7d 0c             	add    %edi,0xc(%ebp)
  802d13:	e9 5e ff ff ff       	jmp    802c76 <_ZL13devfile_writeP2FdPKvj+0x58>
    while (n / PGSIZE)
    {
        if(fd->fd_offset + PGSIZE > (size_t)ino->i_size && 
           inode_set_size(ino, fd->fd_offset + PGSIZE) < 0)
            goto wrapup;
        data = inode_data(ino, fd->fd_offset);
  802d18:	8b 53 04             	mov    0x4(%ebx),%edx
  802d1b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802d1e:	e8 fd f9 ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  802d23:	89 c6                	mov    %eax,%esi
        memcpy(data, buf, PGSIZE);
  802d25:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  802d2c:	00 
  802d2d:	8b 45 0c             	mov    0xc(%ebp),%eax
  802d30:	89 44 24 04          	mov    %eax,0x4(%esp)
  802d34:	89 34 24             	mov    %esi,(%esp)
  802d37:	e8 cb e5 ff ff       	call   801307 <memcpy>
        bcache_ipc(data, BCREQ_FLUSH);
  802d3c:	ba 04 00 00 00       	mov    $0x4,%edx
  802d41:	89 f0                	mov    %esi,%eax
  802d43:	e8 93 fa ff ff       	call   8027db <_ZL10bcache_ipcPvi>
        n -= PGSIZE;
  802d48:	81 ef 00 10 00 00    	sub    $0x1000,%edi
        buf = (void *)((char *)buf + PGSIZE);
  802d4e:	81 45 0c 00 10 00 00 	addl   $0x1000,0xc(%ebp)
        fd->fd_offset += PGSIZE;
  802d55:	81 43 04 00 10 00 00 	addl   $0x1000,0x4(%ebx)
        memcpy(data, buf, n2);
        fd->fd_offset += n2;
        bcache_ipc(data, BCREQ_FLUSH);
        buf = (void *)((char *)buf + n2);
    }
    while (n / PGSIZE)
  802d5c:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
  802d62:	0f 87 18 ff ff ff    	ja     802c80 <_ZL13devfile_writeP2FdPKvj+0x62>
  802d68:	89 fe                	mov    %edi,%esi
  802d6a:	e9 33 ff ff ff       	jmp    802ca2 <_ZL13devfile_writeP2FdPKvj+0x84>
    if (n > 0)
    {
        if(fd->fd_offset + n > (size_t)ino->i_size && 
           inode_set_size(ino, fd->fd_offset + n) < 0)
            goto wrapup;
        data = inode_data(ino, fd->fd_offset);
  802d6f:	8b 53 04             	mov    0x4(%ebx),%edx
  802d72:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802d75:	e8 a6 f9 ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  802d7a:	89 c7                	mov    %eax,%edi
        memcpy(data, buf, n);
  802d7c:	89 74 24 08          	mov    %esi,0x8(%esp)
  802d80:	8b 45 0c             	mov    0xc(%ebp),%eax
  802d83:	89 44 24 04          	mov    %eax,0x4(%esp)
  802d87:	89 3c 24             	mov    %edi,(%esp)
  802d8a:	e8 78 e5 ff ff       	call   801307 <memcpy>
        bcache_ipc(data, BCREQ_FLUSH);
  802d8f:	ba 04 00 00 00       	mov    $0x4,%edx
  802d94:	89 f8                	mov    %edi,%eax
  802d96:	e8 40 fa ff ff       	call   8027db <_ZL10bcache_ipcPvi>
        fd->fd_offset += n;
  802d9b:	01 73 04             	add    %esi,0x4(%ebx)
  802d9e:	e9 21 ff ff ff       	jmp    802cc4 <_ZL13devfile_writeP2FdPKvj+0xa6>

00802da3 <_ZL12devfile_readP2FdPvj>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  802da3:	55                   	push   %ebp
  802da4:	89 e5                	mov    %esp,%ebp
  802da6:	57                   	push   %edi
  802da7:	56                   	push   %esi
  802da8:	53                   	push   %ebx
  802da9:	83 ec 3c             	sub    $0x3c,%esp
  802dac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  802daf:	8b 7d 10             	mov    0x10(%ebp),%edi
	// Use inode_open, inode_close, and inode_data.
	// Be careful of block boundaries!
	//
	// LAB 5: Your code here.
    int r;
    ssize_t orig_offset = fd->fd_offset;
  802db2:	8b 43 04             	mov    0x4(%ebx),%eax
  802db5:	89 45 d0             	mov    %eax,-0x30(%ebp)
    struct Inode *ino;
    if((r = inode_open(fd->fd_file.inum, &ino)) < 0)
  802db8:	8b 43 0c             	mov    0xc(%ebx),%eax
  802dbb:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802dbe:	e8 d4 fa ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  802dc3:	85 c0                	test   %eax,%eax
  802dc5:	0f 88 d3 00 00 00    	js     802e9e <_ZL12devfile_readP2FdPvj+0xfb>
        return r;

    void *data;
    if (n + fd->fd_offset > (size_t)ino->i_size)
  802dcb:	8b 73 04             	mov    0x4(%ebx),%esi
  802dce:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802dd1:	8d 0c 37             	lea    (%edi,%esi,1),%ecx
        n = ino->i_size - fd->fd_offset;
  802dd4:	8b 50 08             	mov    0x8(%eax),%edx
  802dd7:	29 f2                	sub    %esi,%edx
  802dd9:	3b 48 08             	cmp    0x8(%eax),%ecx
  802ddc:	0f 47 fa             	cmova  %edx,%edi
    size_t n2 = ROUNDUP(fd->fd_offset, PGSIZE) - fd->fd_offset;
    if (n2 > n)
        n2 = n;
    n -= n2;
    if((data = inode_data(ino, fd->fd_offset)) == 0)
  802ddf:	89 f2                	mov    %esi,%edx
  802de1:	e8 3a f9 ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  802de6:	85 c0                	test   %eax,%eax
  802de8:	0f 84 a2 00 00 00    	je     802e90 <_ZL12devfile_readP2FdPvj+0xed>
        return r;

    void *data;
    if (n + fd->fd_offset > (size_t)ino->i_size)
        n = ino->i_size - fd->fd_offset;
    size_t n2 = ROUNDUP(fd->fd_offset, PGSIZE) - fd->fd_offset;
  802dee:	8d 96 ff 0f 00 00    	lea    0xfff(%esi),%edx
  802df4:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
  802dfa:	29 f2                	sub    %esi,%edx
  802dfc:	39 d7                	cmp    %edx,%edi
  802dfe:	0f 46 d7             	cmovbe %edi,%edx
  802e01:	89 55 d4             	mov    %edx,-0x2c(%ebp)
    if (n2 > n)
        n2 = n;
    n -= n2;
  802e04:	29 d7                	sub    %edx,%edi
    if((data = inode_data(ino, fd->fd_offset)) == 0)
        goto wrapup;
    fd->fd_offset += n2;
  802e06:	01 d6                	add    %edx,%esi
  802e08:	89 73 04             	mov    %esi,0x4(%ebx)
    memcpy(buf, data, n2);
  802e0b:	89 54 24 08          	mov    %edx,0x8(%esp)
  802e0f:	89 44 24 04          	mov    %eax,0x4(%esp)
  802e13:	8b 45 0c             	mov    0xc(%ebp),%eax
  802e16:	89 04 24             	mov    %eax,(%esp)
  802e19:	e8 e9 e4 ff ff       	call   801307 <memcpy>
    buf = (void *)((char *)buf + n2);
  802e1e:	8b 75 0c             	mov    0xc(%ebp),%esi
  802e21:	03 75 d4             	add    -0x2c(%ebp),%esi
    while (n / PGSIZE)
  802e24:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
  802e2a:	76 3e                	jbe    802e6a <_ZL12devfile_readP2FdPvj+0xc7>
    {
        if((data = inode_data(ino, fd->fd_offset)) == 0)
  802e2c:	8b 53 04             	mov    0x4(%ebx),%edx
  802e2f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802e32:	e8 e9 f8 ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  802e37:	85 c0                	test   %eax,%eax
  802e39:	74 55                	je     802e90 <_ZL12devfile_readP2FdPvj+0xed>
            goto wrapup;
        memcpy(buf, data, PGSIZE);
  802e3b:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  802e42:	00 
  802e43:	89 44 24 04          	mov    %eax,0x4(%esp)
  802e47:	89 34 24             	mov    %esi,(%esp)
  802e4a:	e8 b8 e4 ff ff       	call   801307 <memcpy>
        n -= PGSIZE;
  802e4f:	81 ef 00 10 00 00    	sub    $0x1000,%edi
//
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
  802e55:	81 c6 00 10 00 00    	add    $0x1000,%esi
        if((data = inode_data(ino, fd->fd_offset)) == 0)
            goto wrapup;
        memcpy(buf, data, PGSIZE);
        n -= PGSIZE;
        buf = (void *)((char *)buf + PGSIZE);
        fd->fd_offset += PGSIZE;
  802e5b:	81 43 04 00 10 00 00 	addl   $0x1000,0x4(%ebx)
    if((data = inode_data(ino, fd->fd_offset)) == 0)
        goto wrapup;
    fd->fd_offset += n2;
    memcpy(buf, data, n2);
    buf = (void *)((char *)buf + n2);
    while (n / PGSIZE)
  802e62:	81 ff ff 0f 00 00    	cmp    $0xfff,%edi
  802e68:	77 c2                	ja     802e2c <_ZL12devfile_readP2FdPvj+0x89>
        memcpy(buf, data, PGSIZE);
        n -= PGSIZE;
        buf = (void *)((char *)buf + PGSIZE);
        fd->fd_offset += PGSIZE;
    }
    if (n > 0)
  802e6a:	85 ff                	test   %edi,%edi
  802e6c:	74 22                	je     802e90 <_ZL12devfile_readP2FdPvj+0xed>
    {
        if((data = inode_data(ino, fd->fd_offset)) == 0)
  802e6e:	8b 53 04             	mov    0x4(%ebx),%edx
  802e71:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802e74:	e8 a7 f8 ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  802e79:	85 c0                	test   %eax,%eax
  802e7b:	74 13                	je     802e90 <_ZL12devfile_readP2FdPvj+0xed>
            goto wrapup;
        memcpy(buf, data, n);
  802e7d:	89 7c 24 08          	mov    %edi,0x8(%esp)
  802e81:	89 44 24 04          	mov    %eax,0x4(%esp)
  802e85:	89 34 24             	mov    %esi,(%esp)
  802e88:	e8 7a e4 ff ff       	call   801307 <memcpy>
        fd->fd_offset += n;
  802e8d:	01 7b 04             	add    %edi,0x4(%ebx)
    }

wrapup:
    inode_close(ino);
  802e90:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802e93:	e8 fd fb ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
    return fd->fd_offset - orig_offset;
  802e98:	8b 43 04             	mov    0x4(%ebx),%eax
  802e9b:	2b 45 d0             	sub    -0x30(%ebp),%eax
}
  802e9e:	83 c4 3c             	add    $0x3c,%esp
  802ea1:	5b                   	pop    %ebx
  802ea2:	5e                   	pop    %esi
  802ea3:	5f                   	pop    %edi
  802ea4:	5d                   	pop    %ebp
  802ea5:	c3                   	ret    

00802ea6 <_ZL9path_walkPKcPP5InodePP8Direntryi>:
//
static int
path_walk(const char *path,
	  struct Inode **dirino_store, struct Direntry **de_store,
	  int create)
{
  802ea6:	55                   	push   %ebp
  802ea7:	89 e5                	mov    %esp,%ebp
  802ea9:	57                   	push   %edi
  802eaa:	56                   	push   %esi
  802eab:	53                   	push   %ebx
  802eac:	83 ec 4c             	sub    $0x4c,%esp
  802eaf:	89 c6                	mov    %eax,%esi
  802eb1:	89 55 bc             	mov    %edx,-0x44(%ebp)
  802eb4:	89 4d b8             	mov    %ecx,-0x48(%ebp)
	struct Inode *ino, *next_ino;
	struct Direntry *de;
	const char *component;
	int component_len;

	*dirino_store = 0;
  802eb7:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
	*de_store = 0;
  802ebd:	8b 45 b8             	mov    -0x48(%ebp),%eax
  802ec0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	if ((r = inode_open(1, &ino)) < 0)
  802ec6:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  802ec9:	b8 01 00 00 00       	mov    $0x1,%eax
  802ece:	e8 c4 f9 ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  802ed3:	89 c7                	mov    %eax,%edi
  802ed5:	85 c0                	test   %eax,%eax
  802ed7:	0f 88 cd 01 00 00    	js     8030aa <_ZL9path_walkPKcPP5InodePP8Direntryi+0x204>

static const char *
path_next_component(const char *path,
		    const char **component, int *component_len)
{
	while (*path == '/')
  802edd:	89 f3                	mov    %esi,%ebx
  802edf:	80 3e 2f             	cmpb   $0x2f,(%esi)
  802ee2:	75 08                	jne    802eec <_ZL9path_walkPKcPP5InodePP8Direntryi+0x46>
		++path;
  802ee4:	83 c3 01             	add    $0x1,%ebx

static const char *
path_next_component(const char *path,
		    const char **component, int *component_len)
{
	while (*path == '/')
  802ee7:	80 3b 2f             	cmpb   $0x2f,(%ebx)
  802eea:	74 f8                	je     802ee4 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x3e>
		++path;
	*component = path;
	while (*path != '/' && *path != 0)
  802eec:	0f b6 03             	movzbl (%ebx),%eax
  802eef:	3c 2f                	cmp    $0x2f,%al
  802ef1:	74 16                	je     802f09 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x63>
  802ef3:	84 c0                	test   %al,%al
  802ef5:	74 12                	je     802f09 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x63>
  802ef7:	89 da                	mov    %ebx,%edx
		++path;
  802ef9:	83 c2 01             	add    $0x1,%edx
		    const char **component, int *component_len)
{
	while (*path == '/')
		++path;
	*component = path;
	while (*path != '/' && *path != 0)
  802efc:	0f b6 02             	movzbl (%edx),%eax
  802eff:	3c 2f                	cmp    $0x2f,%al
  802f01:	74 08                	je     802f0b <_ZL9path_walkPKcPP5InodePP8Direntryi+0x65>
  802f03:	84 c0                	test   %al,%al
  802f05:	75 f2                	jne    802ef9 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x53>
  802f07:	eb 02                	jmp    802f0b <_ZL9path_walkPKcPP5InodePP8Direntryi+0x65>
  802f09:	89 da                	mov    %ebx,%edx
		++path;
	*component_len = path - *component;
  802f0b:	89 d0                	mov    %edx,%eax
  802f0d:	29 d8                	sub    %ebx,%eax
  802f0f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	while (*path == '/')
  802f12:	0f b6 02             	movzbl (%edx),%eax
  802f15:	89 d6                	mov    %edx,%esi
  802f17:	3c 2f                	cmp    $0x2f,%al
  802f19:	75 0a                	jne    802f25 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x7f>
		++path;
  802f1b:	83 c6 01             	add    $0x1,%esi
		++path;
	*component = path;
	while (*path != '/' && *path != 0)
		++path;
	*component_len = path - *component;
	while (*path == '/')
  802f1e:	0f b6 06             	movzbl (%esi),%eax
  802f21:	3c 2f                	cmp    $0x2f,%al
  802f23:	74 f6                	je     802f1b <_ZL9path_walkPKcPP5InodePP8Direntryi+0x75>
	while (1) {
		// Find next path component
		path = path_next_component(path, &component, &component_len);

		// Special case: root directory
		if (component_len == 0) {
  802f25:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  802f29:	75 1b                	jne    802f46 <_ZL9path_walkPKcPP5InodePP8Direntryi+0xa0>
			*dirino_store = ino;
  802f2b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802f2e:	8b 55 bc             	mov    -0x44(%ebp),%edx
  802f31:	89 02                	mov    %eax,(%edx)
			*de_store = &super->s_root;
  802f33:	8b 45 b8             	mov    -0x48(%ebp),%eax
  802f36:	c7 00 0c 10 00 50    	movl   $0x5000100c,(%eax)
			return 0;
  802f3c:	bf 00 00 00 00       	mov    $0x0,%edi
  802f41:	e9 64 01 00 00       	jmp    8030aa <_ZL9path_walkPKcPP5InodePP8Direntryi+0x204>
		}

		// Look up directory component
		// (This is the last path component iff *path == 0.)
		if ((r = dir_find(ino, component, component_len, &de,
				  create && *path == 0)) < 0)
  802f46:	c6 45 cb 00          	movb   $0x0,-0x35(%ebp)
  802f4a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  802f4e:	74 06                	je     802f56 <_ZL9path_walkPKcPP5InodePP8Direntryi+0xb0>
//
// Returns 0 on success, < 0 on error.
// Error codes: See dir_find().
//
static int
path_walk(const char *path,
  802f50:	84 c0                	test   %al,%al
  802f52:	0f 94 45 cb          	sete   -0x35(%ebp)
		}

		// Look up directory component
		// (This is the last path component iff *path == 0.)
		if ((r = dir_find(ino, component, component_len, &de,
				  create && *path == 0)) < 0)
  802f56:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  802f59:	89 55 d0             	mov    %edx,-0x30(%ebp)
	off_t off;
	struct Direntry *empty = 0;

	*de_store = 0;

	if (ino->i_ftype != FTYPE_DIR)
  802f5c:	83 3a 02             	cmpl   $0x2,(%edx)
  802f5f:	0f 85 f4 00 00 00    	jne    803059 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1b3>
		return -E_BAD_PATH;

	for (off = 0; off < ino->i_size; off += sizeof(struct Direntry)) {
  802f65:	89 d0                	mov    %edx,%eax
  802f67:	8b 52 08             	mov    0x8(%edx),%edx
  802f6a:	85 d2                	test   %edx,%edx
  802f6c:	7e 78                	jle    802fe6 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x140>
  802f6e:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
  802f75:	bf 00 00 00 00       	mov    $0x0,%edi
  802f7a:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
  802f7d:	89 fb                	mov    %edi,%ebx
  802f7f:	89 75 c0             	mov    %esi,-0x40(%ebp)
  802f82:	89 c6                	mov    %eax,%esi
		struct Direntry *de = (struct Direntry *) inode_data(ino, off);
  802f84:	89 da                	mov    %ebx,%edx
  802f86:	89 f0                	mov    %esi,%eax
  802f88:	e8 93 f7 ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  802f8d:	89 c7                	mov    %eax,%edi

		if (de->de_inum != 0
  802f8f:	83 38 00             	cmpl   $0x0,(%eax)
  802f92:	74 26                	je     802fba <_ZL9path_walkPKcPP5InodePP8Direntryi+0x114>
  802f94:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  802f97:	3b 50 04             	cmp    0x4(%eax),%edx
  802f9a:	75 33                	jne    802fcf <_ZL9path_walkPKcPP5InodePP8Direntryi+0x129>
		    && de->de_namelen == namelen
		    && memcmp(de->de_name, name, namelen) == 0) {
  802f9c:	89 54 24 08          	mov    %edx,0x8(%esp)
  802fa0:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  802fa3:	89 44 24 04          	mov    %eax,0x4(%esp)
  802fa7:	8d 47 08             	lea    0x8(%edi),%eax
  802faa:	89 04 24             	mov    %eax,(%esp)
  802fad:	e8 96 e3 ff ff       	call   801348 <memcmp>
		return -E_BAD_PATH;

	for (off = 0; off < ino->i_size; off += sizeof(struct Direntry)) {
		struct Direntry *de = (struct Direntry *) inode_data(ino, off);

		if (de->de_inum != 0
  802fb2:	85 c0                	test   %eax,%eax
  802fb4:	0f 84 fa 00 00 00    	je     8030b4 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x20e>
		    && memcmp(de->de_name, name, namelen) == 0) {
			*de_store = de;
			return 0;
		}

		if (de->de_inum == 0 && !empty)
  802fba:	83 3f 00             	cmpl   $0x0,(%edi)
  802fbd:	75 10                	jne    802fcf <_ZL9path_walkPKcPP5InodePP8Direntryi+0x129>
  802fbf:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  802fc3:	0f 94 c0             	sete   %al

	if (ino->i_ftype != FTYPE_DIR)
		return -E_BAD_PATH;

	for (off = 0; off < ino->i_size; off += sizeof(struct Direntry)) {
		struct Direntry *de = (struct Direntry *) inode_data(ino, off);
  802fc6:	84 c0                	test   %al,%al
  802fc8:	0f 44 7d cc          	cmove  -0x34(%ebp),%edi
  802fcc:	89 7d cc             	mov    %edi,-0x34(%ebp)
//
// Returns 0 on success, < 0 on error.
// Error codes: See dir_find().
//
static int
path_walk(const char *path,
  802fcf:	8d 83 80 00 00 00    	lea    0x80(%ebx),%eax
  802fd5:	89 c3                	mov    %eax,%ebx
	*de_store = 0;

	if (ino->i_ftype != FTYPE_DIR)
		return -E_BAD_PATH;

	for (off = 0; off < ino->i_size; off += sizeof(struct Direntry)) {
  802fd7:	8b 56 08             	mov    0x8(%esi),%edx
  802fda:	39 d0                	cmp    %edx,%eax
  802fdc:	7c a6                	jl     802f84 <_ZL9path_walkPKcPP5InodePP8Direntryi+0xde>
  802fde:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  802fe1:	8b 75 c0             	mov    -0x40(%ebp),%esi
  802fe4:	eb 07                	jmp    802fed <_ZL9path_walkPKcPP5InodePP8Direntryi+0x147>
  802fe6:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)

		if (de->de_inum == 0 && !empty)
			empty = de;
	}

	if (!create)
  802fed:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  802ff1:	74 6d                	je     803060 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1ba>
		return -E_NOT_FOUND;

	if (!empty) {
  802ff3:	83 7d cc 00          	cmpl   $0x0,-0x34(%ebp)
  802ff7:	75 24                	jne    80301d <_ZL9path_walkPKcPP5InodePP8Direntryi+0x177>
		int r = inode_set_size(ino, ino->i_size + sizeof(struct Direntry));
  802ff9:	83 ea 80             	sub    $0xffffff80,%edx
  802ffc:	8b 45 d0             	mov    -0x30(%ebp),%eax
  802fff:	e8 0c f9 ff ff       	call   802910 <_ZL14inode_set_sizeP5Inodej>
		if (r < 0)
  803004:	85 c0                	test   %eax,%eax
  803006:	0f 88 90 00 00 00    	js     80309c <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1f6>
			return r;
		empty = (struct Direntry *) inode_data(ino, ino->i_size - sizeof(struct Direntry));
  80300c:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80300f:	8b 50 08             	mov    0x8(%eax),%edx
  803012:	83 c2 80             	add    $0xffffff80,%edx
  803015:	e8 06 f7 ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  80301a:	89 45 cc             	mov    %eax,-0x34(%ebp)
	}

	memset(empty, 0, sizeof(struct Direntry));
  80301d:	c7 44 24 08 80 00 00 	movl   $0x80,0x8(%esp)
  803024:	00 
  803025:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80302c:	00 
  80302d:	8b 55 cc             	mov    -0x34(%ebp),%edx
  803030:	89 14 24             	mov    %edx,(%esp)
  803033:	e8 f9 e1 ff ff       	call   801231 <memset>
	empty->de_namelen = namelen;
  803038:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80303b:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80303e:	89 50 04             	mov    %edx,0x4(%eax)
	memcpy(empty->de_name, name, namelen);
  803041:	89 54 24 08          	mov    %edx,0x8(%esp)
  803045:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803049:	83 c0 08             	add    $0x8,%eax
  80304c:	89 04 24             	mov    %eax,(%esp)
  80304f:	e8 b3 e2 ff ff       	call   801307 <memcpy>
	*de_store = empty;
  803054:	8b 7d cc             	mov    -0x34(%ebp),%edi
  803057:	eb 5e                	jmp    8030b7 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x211>
	struct Direntry *empty = 0;

	*de_store = 0;

	if (ino->i_ftype != FTYPE_DIR)
		return -E_BAD_PATH;
  803059:	bf f3 ff ff ff       	mov    $0xfffffff3,%edi
  80305e:	eb 42                	jmp    8030a2 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1fc>
		if (de->de_inum == 0 && !empty)
			empty = de;
	}

	if (!create)
		return -E_NOT_FOUND;
  803060:	bf f4 ff ff ff       	mov    $0xfffffff4,%edi
  803065:	eb 3b                	jmp    8030a2 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1fc>
				  create && *path == 0)) < 0)
			goto fail;

		// If done, return this direntry
		if (*path == 0) {
			*dirino_store = ino;
  803067:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80306a:	8b 55 bc             	mov    -0x44(%ebp),%edx
  80306d:	89 02                	mov    %eax,(%edx)
			*de_store = de;
  80306f:	8b 45 b8             	mov    -0x48(%ebp),%eax
  803072:	89 38                	mov    %edi,(%eax)
			return 0;
  803074:	bf 00 00 00 00       	mov    $0x0,%edi
  803079:	eb 2f                	jmp    8030aa <_ZL9path_walkPKcPP5InodePP8Direntryi+0x204>
		}

		// Otherwise, walk into subdirectory.
		// Always open the next inode before closing the current one.
		if ((r = inode_open(de->de_inum, &next_ino)) < 0)
  80307b:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80307e:	8b 07                	mov    (%edi),%eax
  803080:	e8 12 f8 ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  803085:	85 c0                	test   %eax,%eax
  803087:	78 17                	js     8030a0 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1fa>
			goto fail;
		inode_close(ino);
  803089:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80308c:	e8 04 fa ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
		ino = next_ino;
  803091:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803094:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	*dirino_store = 0;
	*de_store = 0;
	if ((r = inode_open(1, &ino)) < 0)
		return r;

	while (1) {
  803097:	e9 41 fe ff ff       	jmp    802edd <_ZL9path_walkPKcPP5InodePP8Direntryi+0x37>
  80309c:	89 c7                	mov    %eax,%edi
  80309e:	eb 02                	jmp    8030a2 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1fc>
  8030a0:	89 c7                	mov    %eax,%edi
		inode_close(ino);
		ino = next_ino;
	}

 fail:
	inode_close(ino);
  8030a2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8030a5:	e8 eb f9 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
	return r;
}
  8030aa:	89 f8                	mov    %edi,%eax
  8030ac:	83 c4 4c             	add    $0x4c,%esp
  8030af:	5b                   	pop    %ebx
  8030b0:	5e                   	pop    %esi
  8030b1:	5f                   	pop    %edi
  8030b2:	5d                   	pop    %ebp
  8030b3:	c3                   	ret    
  8030b4:	8b 75 c0             	mov    -0x40(%ebp),%esi
		if ((r = dir_find(ino, component, component_len, &de,
				  create && *path == 0)) < 0)
			goto fail;

		// If done, return this direntry
		if (*path == 0) {
  8030b7:	80 3e 00             	cmpb   $0x0,(%esi)
  8030ba:	75 bf                	jne    80307b <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1d5>
  8030bc:	eb a9                	jmp    803067 <_ZL9path_walkPKcPP5InodePP8Direntryi+0x1c1>

008030be <_Z4openPKci>:
//	-E_MAX_FD if no more file descriptors
//	-E_NOT_FOUND if the file (or a path component) was not found
//	(and others)
int
open(const char *path, int mode)
{
  8030be:	55                   	push   %ebp
  8030bf:	89 e5                	mov    %esp,%ebp
  8030c1:	57                   	push   %edi
  8030c2:	56                   	push   %esi
  8030c3:	53                   	push   %ebx
  8030c4:	83 ec 3c             	sub    $0x3c,%esp
  8030c7:	8b 75 08             	mov    0x8(%ebp),%esi
	// and allocate a page there (PTE_P|PTE_U|PTE_W|PTE_SHARE).
	//
	// LAB 5: Your code here
    int r;
    struct Fd *fd;
    if((r = fd_find_unused(&fd)) < 0 || 
  8030ca:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8030cd:	89 04 24             	mov    %eax,(%esp)
  8030d0:	e8 62 f0 ff ff       	call   802137 <_Z14fd_find_unusedPP2Fd>
  8030d5:	89 c3                	mov    %eax,%ebx
  8030d7:	85 c0                	test   %eax,%eax
  8030d9:	0f 88 16 02 00 00    	js     8032f5 <_Z4openPKci+0x237>
  8030df:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8030e6:	00 
  8030e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8030ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  8030ee:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8030f5:	e8 d6 e4 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  8030fa:	89 c3                	mov    %eax,%ebx
  8030fc:	b8 00 00 00 00       	mov    $0x0,%eax
  803101:	85 db                	test   %ebx,%ebx
  803103:	0f 88 ec 01 00 00    	js     8032f5 <_Z4openPKci+0x237>
	// The root directory is a special case -- if you aren't careful,
	// you will deadlock when the root directory is opened.  (Why?)
	//
	// LAB 5: Your code here.
    int i;
    for(i = 0; i < MAXNAMELEN && path[i]; i++); 
  803109:	80 3c 06 00          	cmpb   $0x0,(%esi,%eax,1)
  80310d:	0f 84 ec 01 00 00    	je     8032ff <_Z4openPKci+0x241>
  803113:	83 c0 01             	add    $0x1,%eax
  803116:	83 f8 78             	cmp    $0x78,%eax
  803119:	75 ee                	jne    803109 <_Z4openPKci+0x4b>
    if(i == MAXNAMELEN)
    {
        r = -E_BAD_PATH;
  80311b:	bb f3 ff ff ff       	mov    $0xfffffff3,%ebx
  803120:	e9 b9 01 00 00       	jmp    8032de <_Z4openPKci+0x220>
        goto err2;
    }
    struct Inode *dirino;
    struct Direntry *de;
    if((r = path_walk(path, &dirino, &de, mode & O_CREAT)))
  803125:	8b 7d 0c             	mov    0xc(%ebp),%edi
  803128:	81 e7 00 01 00 00    	and    $0x100,%edi
  80312e:	89 3c 24             	mov    %edi,(%esp)
  803131:	8d 4d dc             	lea    -0x24(%ebp),%ecx
  803134:	8d 55 e0             	lea    -0x20(%ebp),%edx
  803137:	89 f0                	mov    %esi,%eax
  803139:	e8 68 fd ff ff       	call   802ea6 <_ZL9path_walkPKcPP5InodePP8Direntryi>
  80313e:	89 c3                	mov    %eax,%ebx
  803140:	85 c0                	test   %eax,%eax
  803142:	0f 85 96 01 00 00    	jne    8032de <_Z4openPKci+0x220>
        goto err2;
    struct Inode *fileino;
    
    if(!(mode & O_CREAT))
  803148:	85 ff                	test   %edi,%edi
  80314a:	75 41                	jne    80318d <_Z4openPKci+0xcf>
    {
        if(de == &super->s_root)
  80314c:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80314f:	3d 0c 10 00 50       	cmp    $0x5000100c,%eax
  803154:	75 08                	jne    80315e <_Z4openPKci+0xa0>
            fileino = dirino;
  803156:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803159:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80315c:	eb 14                	jmp    803172 <_Z4openPKci+0xb4>
        else if((r = inode_open(de->de_inum, &fileino)) < 0)
  80315e:	8d 55 d8             	lea    -0x28(%ebp),%edx
  803161:	8b 00                	mov    (%eax),%eax
  803163:	e8 2f f7 ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  803168:	89 c3                	mov    %eax,%ebx
  80316a:	85 c0                	test   %eax,%eax
  80316c:	0f 88 5d 01 00 00    	js     8032cf <_Z4openPKci+0x211>
            goto err3;
        
        if(fileino->i_ftype == FTYPE_DIR && (
  803172:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803175:	83 38 02             	cmpl   $0x2,(%eax)
  803178:	0f 85 d2 00 00 00    	jne    803250 <_Z4openPKci+0x192>
  80317e:	f6 45 0c 03          	testb  $0x3,0xc(%ebp)
  803182:	0f 84 c8 00 00 00    	je     803250 <_Z4openPKci+0x192>
  803188:	e9 38 01 00 00       	jmp    8032c5 <_Z4openPKci+0x207>
inode_alloc(struct Inode **ino_store)
{
	inum_t inum;
	int r;
	struct Inode *ino;
	*ino_store = 0;
  80318d:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
	for (inum = 2; inum < super->s_ninodes; ++inum) {
  803194:	83 3d 08 10 00 50 02 	cmpl   $0x2,0x50001008
  80319b:	0f 8e a8 00 00 00    	jle    803249 <_Z4openPKci+0x18b>
  8031a1:	bf 02 00 00 00       	mov    $0x2,%edi
		if ((r = inode_open(inum, &ino)) < 0)
  8031a6:	8d 55 d4             	lea    -0x2c(%ebp),%edx
  8031a9:	89 f8                	mov    %edi,%eax
  8031ab:	e8 e7 f6 ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  8031b0:	89 c3                	mov    %eax,%ebx
  8031b2:	85 c0                	test   %eax,%eax
  8031b4:	0f 88 15 01 00 00    	js     8032cf <_Z4openPKci+0x211>
			return r;
		if (ino->i_refcount == 0 && ino->i_opencount == 1) {
  8031ba:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8031bd:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8031c1:	75 68                	jne    80322b <_Z4openPKci+0x16d>
  8031c3:	83 b8 f8 0f 00 00 01 	cmpl   $0x1,0xff8(%eax)
  8031ca:	75 5f                	jne    80322b <_Z4openPKci+0x16d>
			*ino_store = ino;
  8031cc:	89 45 d8             	mov    %eax,-0x28(%ebp)
    }
    else 
    {
        if((r = inode_alloc(&fileino)) < 0)
            goto err3;
        fileino->i_ftype = FTYPE_REG;
  8031cf:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
        fileino->i_refcount = 1;
  8031d5:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8031d8:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
        fileino->i_size = 0;
  8031df:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
        memset(&fileino->i_direct, 0, NDIRECT * sizeof (blocknum_t));
  8031e6:	c7 44 24 08 e8 0f 00 	movl   $0xfe8,0x8(%esp)
  8031ed:	00 
  8031ee:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8031f5:	00 
  8031f6:	83 c0 0c             	add    $0xc,%eax
  8031f9:	89 04 24             	mov    %eax,(%esp)
  8031fc:	e8 30 e0 ff ff       	call   801231 <memset>
        de->de_inum = fileino->i_inum;
  803201:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803204:	8b 90 f4 0f 00 00    	mov    0xff4(%eax),%edx
  80320a:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80320d:	89 10                	mov    %edx,(%eax)
        bcache_ipc(fileino, BCREQ_FLUSH); 
  80320f:	ba 04 00 00 00       	mov    $0x4,%edx
  803214:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803217:	e8 bf f5 ff ff       	call   8027db <_ZL10bcache_ipcPvi>
        bcache_ipc(dirino, BCREQ_FLUSH); 
  80321c:	ba 04 00 00 00       	mov    $0x4,%edx
  803221:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803224:	e8 b2 f5 ff ff       	call   8027db <_ZL10bcache_ipcPvi>
  803229:	eb 25                	jmp    803250 <_Z4openPKci+0x192>
			return r;
		if (ino->i_refcount == 0 && ino->i_opencount == 1) {
			*ino_store = ino;
			return 0;
		}
		inode_close(ino);
  80322b:	e8 65 f8 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
{
	inum_t inum;
	int r;
	struct Inode *ino;
	*ino_store = 0;
	for (inum = 2; inum < super->s_ninodes; ++inum) {
  803230:	83 c7 01             	add    $0x1,%edi
  803233:	3b 3d 08 10 00 50    	cmp    0x50001008,%edi
  803239:	0f 8c 67 ff ff ff    	jl     8031a6 <_Z4openPKci+0xe8>
			*ino_store = ino;
			return 0;
		}
		inode_close(ino);
	}
	return -E_NO_DISK;
  80323f:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  803244:	e9 86 00 00 00       	jmp    8032cf <_Z4openPKci+0x211>
  803249:	bb f6 ff ff ff       	mov    $0xfffffff6,%ebx
  80324e:	eb 7f                	jmp    8032cf <_Z4openPKci+0x211>
    }
	// If '(mode & O_TRUNC) != 0' and the open mode is not read-only,
	// set the file's length to 0.  Flush any blocks you change.
	//
	// LAB 5: Your code here (Exercise 8).
    if((mode & O_TRUNC))
  803250:	f7 45 0c 00 02 00 00 	testl  $0x200,0xc(%ebp)
  803257:	74 0d                	je     803266 <_Z4openPKci+0x1a8>
    {
        inode_set_size(fileino, 0);
  803259:	ba 00 00 00 00       	mov    $0x0,%edx
  80325e:	8b 45 d8             	mov    -0x28(%ebp),%eax
  803261:	e8 aa f6 ff ff       	call   802910 <_ZL14inode_set_sizeP5Inodej>
	// error messages later.
	// You must account for the open file reference in the inode as well.
	// Clean up any open inodes.
	//
	// LAB 5: Your code here (Exercise 4).
    fd->fd_dev_id = devfile.dev_id;
  803266:	8b 15 04 80 81 00    	mov    0x818004,%edx
  80326c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80326f:	89 10                	mov    %edx,(%eax)
    fd->fd_offset = 0;
  803271:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803274:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    fd->fd_omode = mode;
  80327b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80327e:	89 50 08             	mov    %edx,0x8(%eax)
    fd->fd_file.inum = fileino->i_inum; 
  803281:	8b 55 d8             	mov    -0x28(%ebp),%edx
  803284:	8b 92 f4 0f 00 00    	mov    0xff4(%edx),%edx
  80328a:	89 50 0c             	mov    %edx,0xc(%eax)
    strcpy(fd->fd_file.open_path, path);
  80328d:	89 74 24 04          	mov    %esi,0x4(%esp)
  803291:	83 c0 10             	add    $0x10,%eax
  803294:	89 04 24             	mov    %eax,(%esp)
  803297:	e8 4e de ff ff       	call   8010ea <_Z6strcpyPcPKc>
    fileino->i_opencount++;
  80329c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80329f:	83 80 f8 0f 00 00 01 	addl   $0x1,0xff8(%eax)
    inode_close(dirino);
  8032a6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8032a9:	e8 e7 f7 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
    inode_close(fileino);
  8032ae:	8b 45 d8             	mov    -0x28(%ebp),%eax
  8032b1:	e8 df f7 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
    return fd2num(fd);
  8032b6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8032b9:	89 04 24             	mov    %eax,(%esp)
  8032bc:	e8 13 ee ff ff       	call   8020d4 <_Z6fd2numP2Fd>
  8032c1:	89 c3                	mov    %eax,%ebx
  8032c3:	eb 30                	jmp    8032f5 <_Z4openPKci+0x237>

err4:
    inode_close(fileino);
  8032c5:	e8 cb f7 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
            goto err3;
        
        if(fileino->i_ftype == FTYPE_DIR && (
           mode & O_ACCMODE) != O_RDONLY)
        {
            r = -E_IS_DIR;
  8032ca:	bb ed ff ff ff       	mov    $0xffffffed,%ebx
    return fd2num(fd);

err4:
    inode_close(fileino);
err3:
    inode_close(dirino);
  8032cf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8032d2:	e8 be f7 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
  8032d7:	eb 05                	jmp    8032de <_Z4openPKci+0x220>
	// LAB 5: Your code here.
    int i;
    for(i = 0; i < MAXNAMELEN && path[i]; i++); 
    if(i == MAXNAMELEN)
    {
        r = -E_BAD_PATH;
  8032d9:	bb f3 ff ff ff       	mov    $0xfffffff3,%ebx
err4:
    inode_close(fileino);
err3:
    inode_close(dirino);
err2:
    sys_page_unmap(thisenv->env_id, fd);
  8032de:	a1 98 90 81 00       	mov    0x819098,%eax
  8032e3:	8b 40 04             	mov    0x4(%eax),%eax
  8032e6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8032e9:	89 54 24 04          	mov    %edx,0x4(%esp)
  8032ed:	89 04 24             	mov    %eax,(%esp)
  8032f0:	e8 98 e3 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
err1:
    return r;
}
  8032f5:	89 d8                	mov    %ebx,%eax
  8032f7:	83 c4 3c             	add    $0x3c,%esp
  8032fa:	5b                   	pop    %ebx
  8032fb:	5e                   	pop    %esi
  8032fc:	5f                   	pop    %edi
  8032fd:	5d                   	pop    %ebp
  8032fe:	c3                   	ret    
	// you will deadlock when the root directory is opened.  (Why?)
	//
	// LAB 5: Your code here.
    int i;
    for(i = 0; i < MAXNAMELEN && path[i]; i++); 
    if(i == MAXNAMELEN)
  8032ff:	83 f8 78             	cmp    $0x78,%eax
  803302:	0f 85 1d fe ff ff    	jne    803125 <_Z4openPKci+0x67>
  803308:	eb cf                	jmp    8032d9 <_Z4openPKci+0x21b>

0080330a <_Z5istatiP4Stat>:
	return 0;
}

int
istat(inum_t inum, struct Stat *stat)
{
  80330a:	55                   	push   %ebp
  80330b:	89 e5                	mov    %esp,%ebp
  80330d:	53                   	push   %ebx
  80330e:	83 ec 24             	sub    $0x24,%esp
  803311:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Inode *ino;

	if ((r = inode_open(inum, &ino)) < 0)
  803314:	8d 55 f4             	lea    -0xc(%ebp),%edx
  803317:	8b 45 08             	mov    0x8(%ebp),%eax
  80331a:	e8 78 f5 ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  80331f:	85 c0                	test   %eax,%eax
  803321:	78 27                	js     80334a <_Z5istatiP4Stat+0x40>
		return r;

	strcpy(stat->st_name, "<inode>");
  803323:	c7 44 24 04 54 4a 81 	movl   $0x814a54,0x4(%esp)
  80332a:	00 
  80332b:	89 1c 24             	mov    %ebx,(%esp)
  80332e:	e8 b7 dd ff ff       	call   8010ea <_Z6strcpyPcPKc>
	stat_base(ino, stat);
  803333:	89 da                	mov    %ebx,%edx
  803335:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803338:	e8 26 f4 ff ff       	call   802763 <_ZL9stat_basePK5InodeP4Stat>

	inode_close(ino);
  80333d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803340:	e8 50 f7 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
	return 0;
  803345:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80334a:	83 c4 24             	add    $0x24,%esp
  80334d:	5b                   	pop    %ebx
  80334e:	5d                   	pop    %ebp
  80334f:	c3                   	ret    

00803350 <_Z6unlinkPKc>:

// Deletes a file.
//
int
unlink(const char *path)
{
  803350:	55                   	push   %ebp
  803351:	89 e5                	mov    %esp,%ebp
  803353:	53                   	push   %ebx
  803354:	83 ec 24             	sub    $0x24,%esp
	int r;
	struct Inode *dirino, *ino;
	struct Direntry *de;

	if ((r = path_walk(path, &dirino, &de, 0)) < 0)
  803357:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80335e:	8d 4d ec             	lea    -0x14(%ebp),%ecx
  803361:	8d 55 f4             	lea    -0xc(%ebp),%edx
  803364:	8b 45 08             	mov    0x8(%ebp),%eax
  803367:	e8 3a fb ff ff       	call   802ea6 <_ZL9path_walkPKcPP5InodePP8Direntryi>
  80336c:	89 c3                	mov    %eax,%ebx
  80336e:	85 c0                	test   %eax,%eax
  803370:	78 5f                	js     8033d1 <_Z6unlinkPKc+0x81>
		goto done;
	if ((r = inode_open(de->de_inum, &ino)) < 0)
  803372:	8d 55 f0             	lea    -0x10(%ebp),%edx
  803375:	8b 45 ec             	mov    -0x14(%ebp),%eax
  803378:	8b 00                	mov    (%eax),%eax
  80337a:	e8 18 f5 ff ff       	call   802897 <_ZL10inode_openiPP5Inode>
  80337f:	89 c3                	mov    %eax,%ebx
  803381:	85 c0                	test   %eax,%eax
  803383:	78 44                	js     8033c9 <_Z6unlinkPKc+0x79>
		goto closedirino;
	if (ino->i_ftype == FTYPE_DIR) {
		r = -E_IS_DIR;
  803385:	bb ed ff ff ff       	mov    $0xffffffed,%ebx

	if ((r = path_walk(path, &dirino, &de, 0)) < 0)
		goto done;
	if ((r = inode_open(de->de_inum, &ino)) < 0)
		goto closedirino;
	if (ino->i_ftype == FTYPE_DIR) {
  80338a:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80338d:	83 38 02             	cmpl   $0x2,(%eax)
  803390:	74 2f                	je     8033c1 <_Z6unlinkPKc+0x71>
		r = -E_IS_DIR;
		goto closeino;
	}
	// clear directory entry
	de->de_inum = 0;
  803392:	8b 45 ec             	mov    -0x14(%ebp),%eax
  803395:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	--ino->i_refcount;
  80339b:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80339e:	83 68 04 01          	subl   $0x1,0x4(%eax)
	bcache_ipc(de, BCREQ_FLUSH);
  8033a2:	ba 04 00 00 00       	mov    $0x4,%edx
  8033a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8033aa:	e8 2c f4 ff ff       	call   8027db <_ZL10bcache_ipcPvi>
	bcache_ipc(ino, BCREQ_FLUSH);
  8033af:	ba 04 00 00 00       	mov    $0x4,%edx
  8033b4:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8033b7:	e8 1f f4 ff ff       	call   8027db <_ZL10bcache_ipcPvi>
	r = 0;
  8033bc:	bb 00 00 00 00       	mov    $0x0,%ebx
 closeino:
	inode_close(ino);
  8033c1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8033c4:	e8 cc f6 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
 closedirino:
	inode_close(dirino);
  8033c9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8033cc:	e8 c4 f6 ff ff       	call   802a95 <_ZL11inode_closeP5Inode>
 done:
	return r;
}
  8033d1:	89 d8                	mov    %ebx,%eax
  8033d3:	83 c4 24             	add    $0x24,%esp
  8033d6:	5b                   	pop    %ebx
  8033d7:	5d                   	pop    %ebp
  8033d8:	c3                   	ret    

008033d9 <_Z4syncv>:

// Synchronizes the disk with buffer cache.
//
int
sync(void)
{
  8033d9:	55                   	push   %ebp
  8033da:	89 e5                	mov    %esp,%ebp
	// Our current implementation is synchronous.
	return 0;
}
  8033dc:	b8 00 00 00 00       	mov    $0x0,%eax
  8033e1:	5d                   	pop    %ebp
  8033e2:	c3                   	ret    

008033e3 <_Z4fsckv>:
// get confused and report transient "errors."
// Returns 0 if the file system is OK, -E_INVAL if any errors were found.
//
int
fsck(void)
{
  8033e3:	55                   	push   %ebp
  8033e4:	89 e5                	mov    %esp,%ebp
  8033e6:	57                   	push   %edi
  8033e7:	56                   	push   %esi
  8033e8:	53                   	push   %ebx
  8033e9:	81 ec cc 00 00 00    	sub    $0xcc,%esp
	blocknum_t min_nblocks;
	int i, j, k;
	int errors = 0;

	add_pgfault_handler(bcache_pgfault_handler);
  8033ef:	c7 04 24 3d 2b 80 00 	movl   $0x802b3d,(%esp)
  8033f6:	e8 50 17 00 00       	call   804b4b <_Z19add_pgfault_handlerPFvP10UTrapframeE>

	// superblock checks
	if (super->s_magic != FS_MAGIC)
  8033fb:	a1 00 10 00 50       	mov    0x50001000,%eax
  803400:	3d ae 30 05 4a       	cmp    $0x4a0530ae,%eax
  803405:	74 28                	je     80342f <_Z4fsckv+0x4c>
		panic("fsck: file system magic number %08x should be %08x", super->s_magic, FS_MAGIC);
  803407:	c7 44 24 10 ae 30 05 	movl   $0x4a0530ae,0x10(%esp)
  80340e:	4a 
  80340f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803413:	c7 44 24 08 bc 4a 81 	movl   $0x814abc,0x8(%esp)
  80341a:	00 
  80341b:	c7 44 24 04 1b 03 00 	movl   $0x31b,0x4(%esp)
  803422:	00 
  803423:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  80342a:	e8 89 d5 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	if (super->s_nblocks < 4)
  80342f:	a1 04 10 00 50       	mov    0x50001004,%eax
  803434:	83 f8 03             	cmp    $0x3,%eax
  803437:	7f 1c                	jg     803455 <_Z4fsckv+0x72>
		panic("fsck: file system must have at least 4 blocks");
  803439:	c7 44 24 08 f0 4a 81 	movl   $0x814af0,0x8(%esp)
  803440:	00 
  803441:	c7 44 24 04 1d 03 00 	movl   $0x31d,0x4(%esp)
  803448:	00 
  803449:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  803450:	e8 63 d5 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	if (super->s_ninodes < 1)
  803455:	8b 15 08 10 00 50    	mov    0x50001008,%edx
  80345b:	85 d2                	test   %edx,%edx
  80345d:	7f 1c                	jg     80347b <_Z4fsckv+0x98>
		panic("fsck: file system must have at least 1 inode");
  80345f:	c7 44 24 08 20 4b 81 	movl   $0x814b20,0x8(%esp)
  803466:	00 
  803467:	c7 44 24 04 1f 03 00 	movl   $0x31f,0x4(%esp)
  80346e:	00 
  80346f:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  803476:	e8 3d d5 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	min_nblocks = 2 /* boot sector, superblock */
		+ ROUNDUP(super->s_nblocks, BLKSIZE) / BLKSIZE /* freemap */
  80347b:	8d 88 ff 0f 00 00    	lea    0xfff(%eax),%ecx
  803481:	81 e1 00 f0 ff ff    	and    $0xfffff000,%ecx
		+ (super->s_ninodes - 1); /* inodes */
  803487:	8d 99 ff 0f 00 00    	lea    0xfff(%ecx),%ebx
  80348d:	85 c9                	test   %ecx,%ecx
  80348f:	0f 48 cb             	cmovs  %ebx,%ecx
  803492:	c1 f9 0c             	sar    $0xc,%ecx
  803495:	8d 4c 0a 01          	lea    0x1(%edx,%ecx,1),%ecx
  803499:	89 8d 54 ff ff ff    	mov    %ecx,-0xac(%ebp)
	if (super->s_nblocks < min_nblocks)
  80349f:	39 c8                	cmp    %ecx,%eax
  8034a1:	7c 13                	jl     8034b6 <_Z4fsckv+0xd3>
		panic("fsck: file system with %d inodes has %d blocks, needs at least %d", super->s_ninodes, super->s_nblocks, min_nblocks);

	// basic freemap checks: initial blocks not free, free blocks marked
	// with 1 (later checks will overwrite freemap)
	for (i = 0; i < super->s_nblocks; ++i)
  8034a3:	85 c0                	test   %eax,%eax
  8034a5:	7f 3d                	jg     8034e4 <_Z4fsckv+0x101>
  8034a7:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
  8034ae:	00 00 00 
  8034b1:	e9 ac 00 00 00       	jmp    803562 <_Z4fsckv+0x17f>
		panic("fsck: file system must have at least 1 inode");
	min_nblocks = 2 /* boot sector, superblock */
		+ ROUNDUP(super->s_nblocks, BLKSIZE) / BLKSIZE /* freemap */
		+ (super->s_ninodes - 1); /* inodes */
	if (super->s_nblocks < min_nblocks)
		panic("fsck: file system with %d inodes has %d blocks, needs at least %d", super->s_ninodes, super->s_nblocks, min_nblocks);
  8034b6:	8b 8d 54 ff ff ff    	mov    -0xac(%ebp),%ecx
  8034bc:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  8034c0:	89 44 24 10          	mov    %eax,0x10(%esp)
  8034c4:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8034c8:	c7 44 24 08 50 4b 81 	movl   $0x814b50,0x8(%esp)
  8034cf:	00 
  8034d0:	c7 44 24 04 24 03 00 	movl   $0x324,0x4(%esp)
  8034d7:	00 
  8034d8:	c7 04 24 36 4a 81 00 	movl   $0x814a36,(%esp)
  8034df:	e8 d4 d4 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

	// basic freemap checks: initial blocks not free, free blocks marked
	// with 1 (later checks will overwrite freemap)
	for (i = 0; i < super->s_nblocks; ++i)
  8034e4:	be 00 20 00 50       	mov    $0x50002000,%esi
  8034e9:	c7 85 60 ff ff ff 00 	movl   $0x0,-0xa0(%ebp)
  8034f0:	00 00 00 
  8034f3:	bb 00 00 00 00       	mov    $0x0,%ebx
  8034f8:	8b bd 54 ff ff ff    	mov    -0xac(%ebp),%edi
		if (i < min_nblocks && freemap[i] != 0) {
  8034fe:	39 df                	cmp    %ebx,%edi
  803500:	7e 27                	jle    803529 <_Z4fsckv+0x146>
  803502:	0f b6 06             	movzbl (%esi),%eax
  803505:	84 c0                	test   %al,%al
  803507:	74 4b                	je     803554 <_Z4fsckv+0x171>
			cprintf("fsck: freemap[%d]: should be 0 (allocated), is %d\n", i, freemap[i]);
  803509:	0f be c0             	movsbl %al,%eax
  80350c:	89 44 24 08          	mov    %eax,0x8(%esp)
  803510:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803514:	c7 04 24 94 4b 81 00 	movl   $0x814b94,(%esp)
  80351b:	e8 b6 d5 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  803520:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  803527:	eb 2b                	jmp    803554 <_Z4fsckv+0x171>
		} else if (freemap[i] != 0 && freemap[i] != 1) {
  803529:	0f b6 06             	movzbl (%esi),%eax
  80352c:	3c 01                	cmp    $0x1,%al
  80352e:	76 24                	jbe    803554 <_Z4fsckv+0x171>
			cprintf("fsck: freemap[%d]: should be 0 or 1, is %d\n", i, freemap[i]);
  803530:	0f be c0             	movsbl %al,%eax
  803533:	89 44 24 08          	mov    %eax,0x8(%esp)
  803537:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80353b:	c7 04 24 c8 4b 81 00 	movl   $0x814bc8,(%esp)
  803542:	e8 8f d5 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  803547:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
			freemap[i] = (freemap[i] > 0 ? 1 : 0);
  80354e:	80 3e 00             	cmpb   $0x0,(%esi)
  803551:	0f 9f 06             	setg   (%esi)
	if (super->s_nblocks < min_nblocks)
		panic("fsck: file system with %d inodes has %d blocks, needs at least %d", super->s_ninodes, super->s_nblocks, min_nblocks);

	// basic freemap checks: initial blocks not free, free blocks marked
	// with 1 (later checks will overwrite freemap)
	for (i = 0; i < super->s_nblocks; ++i)
  803554:	83 c3 01             	add    $0x1,%ebx
  803557:	83 c6 01             	add    $0x1,%esi
  80355a:	39 1d 04 10 00 50    	cmp    %ebx,0x50001004
  803560:	7f 9c                	jg     8034fe <_Z4fsckv+0x11b>
			freemap[i] = (freemap[i] > 0 ? 1 : 0);
		}

	// inode checks: inode 1 is referenced, unreferenced inodes
	// have no data pointers, ftype makes sense, no data pointer overlap
	for (i = 1; i < super->s_ninodes; ++i) {
  803562:	83 3d 08 10 00 50 01 	cmpl   $0x1,0x50001008
  803569:	0f 8e e1 02 00 00    	jle    803850 <_Z4fsckv+0x46d>
  80356f:	c7 85 58 ff ff ff 01 	movl   $0x1,-0xa8(%ebp)
  803576:	00 00 00 
		struct Inode *ino = get_inode(i);
  803579:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
  80357f:	e8 f9 f1 ff ff       	call   80277d <_ZL9get_inodei>
  803584:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
		off_t true_size;
		// check for open-but-unreferenced inode; be careful of
		// uninitialized inodes (use bcache_ipc to check)
		bool active = ino->i_refcount != 0;
  80358a:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
		if (!active && ino->i_opencount != 0
  80358e:	0f 95 85 5c ff ff ff 	setne  -0xa4(%ebp)
  803595:	75 22                	jne    8035b9 <_Z4fsckv+0x1d6>
  803597:	83 b8 f8 0f 00 00 00 	cmpl   $0x0,0xff8(%eax)
  80359e:	0f 84 a9 06 00 00    	je     803c4d <_Z4fsckv+0x86a>
		    && bcache_ipc(ino, BCREQ_MAP) != 0)
  8035a4:	ba 00 00 00 00       	mov    $0x0,%edx
  8035a9:	e8 2d f2 ff ff       	call   8027db <_ZL10bcache_ipcPvi>
		struct Inode *ino = get_inode(i);
		off_t true_size;
		// check for open-but-unreferenced inode; be careful of
		// uninitialized inodes (use bcache_ipc to check)
		bool active = ino->i_refcount != 0;
		if (!active && ino->i_opencount != 0
  8035ae:	85 c0                	test   %eax,%eax
  8035b0:	74 3a                	je     8035ec <_Z4fsckv+0x209>
		    && bcache_ipc(ino, BCREQ_MAP) != 0)
			active = true;
  8035b2:	c6 85 5c ff ff ff 01 	movb   $0x1,-0xa4(%ebp)
		if (active && ino->i_ftype != FTYPE_REG && ino->i_ftype != FTYPE_DIR) {
  8035b9:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  8035bf:	8b 02                	mov    (%edx),%eax
  8035c1:	83 f8 01             	cmp    $0x1,%eax
  8035c4:	74 26                	je     8035ec <_Z4fsckv+0x209>
  8035c6:	83 f8 02             	cmp    $0x2,%eax
  8035c9:	74 21                	je     8035ec <_Z4fsckv+0x209>
			cprintf("fsck: inode[%d]: odd i_ftype %d\n", i, ino->i_ftype);
  8035cb:	89 44 24 08          	mov    %eax,0x8(%esp)
  8035cf:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
  8035d5:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8035d9:	c7 04 24 f4 4b 81 00 	movl   $0x814bf4,(%esp)
  8035e0:	e8 f1 d4 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  8035e5:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
		}
		if (i == 1 && ino->i_refcount == 0) {
  8035ec:	83 bd 58 ff ff ff 01 	cmpl   $0x1,-0xa8(%ebp)
  8035f3:	75 3f                	jne    803634 <_Z4fsckv+0x251>
  8035f5:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
  8035fb:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  8035ff:	75 15                	jne    803616 <_Z4fsckv+0x233>
			cprintf("fsck: inode[1]: root inode should be referenced\n");
  803601:	c7 04 24 18 4c 81 00 	movl   $0x814c18,(%esp)
  803608:	e8 c9 d4 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  80360d:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  803614:	eb 1e                	jmp    803634 <_Z4fsckv+0x251>
		} else if (i == 1 && ino->i_ftype != FTYPE_DIR) {
  803616:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  80361c:	83 3a 02             	cmpl   $0x2,(%edx)
  80361f:	74 13                	je     803634 <_Z4fsckv+0x251>
			cprintf("fsck: inode[1]: root inode should be directory\n");
  803621:	c7 04 24 4c 4c 81 00 	movl   $0x814c4c,(%esp)
  803628:	e8 a9 d4 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  80362d:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
		}
		if (active && ino->i_inum != i) {
			cprintf("fsck: inode[%d]: wrong inumber %d\n", i, ino->i_inum);
			++errors;
		}
		true_size = active ? ino->i_size : 0;
  803634:	bf 00 00 00 00       	mov    $0x0,%edi
			++errors;
		} else if (i == 1 && ino->i_ftype != FTYPE_DIR) {
			cprintf("fsck: inode[1]: root inode should be directory\n");
			++errors;
		}
		if (active && ino->i_size > MAXFILESIZE) {
  803639:	80 bd 5c ff ff ff 00 	cmpb   $0x0,-0xa4(%ebp)
  803640:	0f 84 93 00 00 00    	je     8036d9 <_Z4fsckv+0x2f6>
  803646:	8b 8d 64 ff ff ff    	mov    -0x9c(%ebp),%ecx
  80364c:	8b 41 08             	mov    0x8(%ecx),%eax
  80364f:	3d 00 a0 3f 00       	cmp    $0x3fa000,%eax
  803654:	7e 23                	jle    803679 <_Z4fsckv+0x296>
			cprintf("fsck: inode[%d]: size %d too large\n", i, ino->i_size);
  803656:	89 44 24 08          	mov    %eax,0x8(%esp)
  80365a:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
  803660:	89 44 24 04          	mov    %eax,0x4(%esp)
  803664:	c7 04 24 7c 4c 81 00 	movl   $0x814c7c,(%esp)
  80366b:	e8 66 d4 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  803670:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  803677:	eb 09                	jmp    803682 <_Z4fsckv+0x29f>
		}
		if (active && ino->i_inum != i) {
  803679:	80 bd 5c ff ff ff 00 	cmpb   $0x0,-0xa4(%ebp)
  803680:	74 4b                	je     8036cd <_Z4fsckv+0x2ea>
  803682:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  803688:	8b 82 f4 0f 00 00    	mov    0xff4(%edx),%eax
  80368e:	3b 85 58 ff ff ff    	cmp    -0xa8(%ebp),%eax
  803694:	74 23                	je     8036b9 <_Z4fsckv+0x2d6>
			cprintf("fsck: inode[%d]: wrong inumber %d\n", i, ino->i_inum);
  803696:	89 44 24 08          	mov    %eax,0x8(%esp)
  80369a:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
  8036a0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8036a4:	c7 04 24 a0 4c 81 00 	movl   $0x814ca0,(%esp)
  8036ab:	e8 26 d4 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  8036b0:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  8036b7:	eb 09                	jmp    8036c2 <_Z4fsckv+0x2df>
		}
		true_size = active ? ino->i_size : 0;
  8036b9:	80 bd 5c ff ff ff 00 	cmpb   $0x0,-0xa4(%ebp)
  8036c0:	74 12                	je     8036d4 <_Z4fsckv+0x2f1>
  8036c2:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
  8036c8:	8b 78 08             	mov    0x8(%eax),%edi
  8036cb:	eb 0c                	jmp    8036d9 <_Z4fsckv+0x2f6>
  8036cd:	bf 00 00 00 00       	mov    $0x0,%edi
  8036d2:	eb 05                	jmp    8036d9 <_Z4fsckv+0x2f6>
  8036d4:	bf 00 00 00 00       	mov    $0x0,%edi
		for (j = 0; j < NDIRECT; ++j) {
  8036d9:	bb 00 00 00 00       	mov    $0x0,%ebx
			blocknum_t b = ino->i_direct[j];
  8036de:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  8036e4:	8b 74 9a 0c          	mov    0xc(%edx,%ebx,4),%esi
// Does no locking, so if run in parallel with other environments, it can
// get confused and report transient "errors."
// Returns 0 if the file system is OK, -E_INVAL if any errors were found.
//
int
fsck(void)
  8036e8:	89 d8                	mov    %ebx,%eax
  8036ea:	c1 e0 0c             	shl    $0xc,%eax
			++errors;
		}
		true_size = active ? ino->i_size : 0;
		for (j = 0; j < NDIRECT; ++j) {
			blocknum_t b = ino->i_direct[j];
			if (j * BLKSIZE < true_size && !b) {
  8036ed:	39 c7                	cmp    %eax,%edi
  8036ef:	7e 2b                	jle    80371c <_Z4fsckv+0x339>
  8036f1:	85 f6                	test   %esi,%esi
  8036f3:	75 27                	jne    80371c <_Z4fsckv+0x339>
				cprintf("fsck: inode[%d]: direct block %d is null, though file size is %d\n", i, j, true_size);
  8036f5:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  8036f9:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8036fd:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
  803703:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  803707:	c7 04 24 c4 4c 81 00 	movl   $0x814cc4,(%esp)
  80370e:	e8 c3 d3 ff ff       	call   800ad6 <_Z7cprintfPKcz>
				++errors;
  803713:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  80371a:	eb 36                	jmp    803752 <_Z4fsckv+0x36f>
			} else if (j * BLKSIZE >= true_size && b && active) {
  80371c:	39 f8                	cmp    %edi,%eax
  80371e:	7c 32                	jl     803752 <_Z4fsckv+0x36f>
  803720:	85 f6                	test   %esi,%esi
  803722:	74 2e                	je     803752 <_Z4fsckv+0x36f>
  803724:	80 bd 5c ff ff ff 00 	cmpb   $0x0,-0xa4(%ebp)
  80372b:	74 25                	je     803752 <_Z4fsckv+0x36f>
				cprintf("fsck: inode[%d]: direct block %d exists, though file size is %d\n", i, j, true_size);
  80372d:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  803731:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  803735:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
  80373b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80373f:	c7 04 24 08 4d 81 00 	movl   $0x814d08,(%esp)
  803746:	e8 8b d3 ff ff       	call   800ad6 <_Z7cprintfPKcz>
				++errors;
  80374b:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
			}
			if (b && active) {
  803752:	85 f6                	test   %esi,%esi
  803754:	0f 84 a0 00 00 00    	je     8037fa <_Z4fsckv+0x417>
  80375a:	80 bd 5c ff ff ff 00 	cmpb   $0x0,-0xa4(%ebp)
  803761:	0f 84 93 00 00 00    	je     8037fa <_Z4fsckv+0x417>
				if (b < min_nblocks) {
  803767:	39 b5 54 ff ff ff    	cmp    %esi,-0xac(%ebp)
  80376d:	7e 27                	jle    803796 <_Z4fsckv+0x3b3>
					cprintf("fsck: inode[%d]: direct block %d == %d is in special block range\n", i, j, b);
  80376f:	89 74 24 0c          	mov    %esi,0xc(%esp)
  803773:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  803777:	8b 95 58 ff ff ff    	mov    -0xa8(%ebp),%edx
  80377d:	89 54 24 04          	mov    %edx,0x4(%esp)
  803781:	c7 04 24 4c 4d 81 00 	movl   $0x814d4c,(%esp)
  803788:	e8 49 d3 ff ff       	call   800ad6 <_Z7cprintfPKcz>
					++errors;
  80378d:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  803794:	eb 64                	jmp    8037fa <_Z4fsckv+0x417>
				} else if (freemap[b] == 1) {
  803796:	0f b6 86 00 20 00 50 	movzbl 0x50002000(%esi),%eax
  80379d:	3c 01                	cmp    $0x1,%al
  80379f:	75 27                	jne    8037c8 <_Z4fsckv+0x3e5>
					cprintf("fsck: inode[%d]: direct block %d == %d is marked as free\n", i, j, b);
  8037a1:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8037a5:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8037a9:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
  8037af:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8037b3:	c7 04 24 90 4d 81 00 	movl   $0x814d90,(%esp)
  8037ba:	e8 17 d3 ff ff       	call   800ad6 <_Z7cprintfPKcz>
					++errors;
  8037bf:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  8037c6:	eb 32                	jmp    8037fa <_Z4fsckv+0x417>
				} else if (freemap[b] == -1) {
  8037c8:	3c ff                	cmp    $0xff,%al
  8037ca:	75 27                	jne    8037f3 <_Z4fsckv+0x410>
					cprintf("fsck: inode[%d]: direct block %d == %d used more than once\n", i, j, b);
  8037cc:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8037d0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8037d4:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
  8037da:	89 44 24 04          	mov    %eax,0x4(%esp)
  8037de:	c7 04 24 cc 4d 81 00 	movl   $0x814dcc,(%esp)
  8037e5:	e8 ec d2 ff ff       	call   800ad6 <_Z7cprintfPKcz>
					++errors;
  8037ea:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  8037f1:	eb 07                	jmp    8037fa <_Z4fsckv+0x417>
				} else
					freemap[b] = -1;
  8037f3:	c6 86 00 20 00 50 ff 	movb   $0xff,0x50002000(%esi)
		if (active && ino->i_inum != i) {
			cprintf("fsck: inode[%d]: wrong inumber %d\n", i, ino->i_inum);
			++errors;
		}
		true_size = active ? ino->i_size : 0;
		for (j = 0; j < NDIRECT; ++j) {
  8037fa:	83 c3 01             	add    $0x1,%ebx
  8037fd:	81 fb fa 03 00 00    	cmp    $0x3fa,%ebx
  803803:	0f 85 d5 fe ff ff    	jne    8036de <_Z4fsckv+0x2fb>
					++errors;
				} else
					freemap[b] = -1;
			}
		}
		ino->i_fsck_refcount = (i == 1 ? 1 : 0);
  803809:	83 bd 58 ff ff ff 01 	cmpl   $0x1,-0xa8(%ebp)
  803810:	0f 94 c0             	sete   %al
  803813:	0f b6 c0             	movzbl %al,%eax
  803816:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  80381c:	88 82 fc 0f 00 00    	mov    %al,0xffc(%edx)
  803822:	c6 82 fd 0f 00 00 00 	movb   $0x0,0xffd(%edx)
  803829:	c6 82 fe 0f 00 00 00 	movb   $0x0,0xffe(%edx)
		ino->i_fsck_checked = 0;
  803830:	c6 82 ff 0f 00 00 00 	movb   $0x0,0xfff(%edx)
			freemap[i] = (freemap[i] > 0 ? 1 : 0);
		}

	// inode checks: inode 1 is referenced, unreferenced inodes
	// have no data pointers, ftype makes sense, no data pointer overlap
	for (i = 1; i < super->s_ninodes; ++i) {
  803837:	83 85 58 ff ff ff 01 	addl   $0x1,-0xa8(%ebp)
  80383e:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
  803844:	39 0d 08 10 00 50    	cmp    %ecx,0x50001008
  80384a:	0f 8f 29 fd ff ff    	jg     803579 <_Z4fsckv+0x196>
	}

	// directory checks
	while (1) {
		struct Inode *ino;
		for (i = 1; i < super->s_ninodes; ++i) {
  803850:	83 3d 08 10 00 50 01 	cmpl   $0x1,0x50001008
  803857:	0f 8e 7f 03 00 00    	jle    803bdc <_Z4fsckv+0x7f9>
  80385d:	be 01 00 00 00       	mov    $0x1,%esi
			ino = get_inode(i);
  803862:	89 f0                	mov    %esi,%eax
  803864:	e8 14 ef ff ff       	call   80277d <_ZL9get_inodei>
			if (ino->i_fsck_refcount > 0
  803869:	0f b6 88 fc 0f 00 00 	movzbl 0xffc(%eax),%ecx
  803870:	0f b6 90 fd 0f 00 00 	movzbl 0xffd(%eax),%edx
  803877:	c1 e2 08             	shl    $0x8,%edx
  80387a:	09 ca                	or     %ecx,%edx
  80387c:	0f b6 88 fe 0f 00 00 	movzbl 0xffe(%eax),%ecx
  803883:	c1 e1 10             	shl    $0x10,%ecx
  803886:	09 ca                	or     %ecx,%edx
  803888:	0f b6 88 ff 0f 00 00 	movzbl 0xfff(%eax),%ecx
  80388f:	83 e1 7f             	and    $0x7f,%ecx
  803892:	c1 e1 18             	shl    $0x18,%ecx
  803895:	09 d1                	or     %edx,%ecx
  803897:	74 0e                	je     8038a7 <_Z4fsckv+0x4c4>
  803899:	80 b8 ff 0f 00 00 00 	cmpb   $0x0,0xfff(%eax)
  8038a0:	78 05                	js     8038a7 <_Z4fsckv+0x4c4>
  8038a2:	83 38 02             	cmpl   $0x2,(%eax)
  8038a5:	74 1f                	je     8038c6 <_Z4fsckv+0x4e3>
	}

	// directory checks
	while (1) {
		struct Inode *ino;
		for (i = 1; i < super->s_ninodes; ++i) {
  8038a7:	83 c6 01             	add    $0x1,%esi
  8038aa:	a1 08 10 00 50       	mov    0x50001008,%eax
  8038af:	39 f0                	cmp    %esi,%eax
  8038b1:	7f af                	jg     803862 <_Z4fsckv+0x47f>
			}
		}
	}

	// refcount consistency
	for (i = 1; i < super->s_ninodes; ++i) {
  8038b3:	bb 01 00 00 00       	mov    $0x1,%ebx
  8038b8:	83 f8 01             	cmp    $0x1,%eax
  8038bb:	0f 8f ad 02 00 00    	jg     803b6e <_Z4fsckv+0x78b>
  8038c1:	e9 16 03 00 00       	jmp    803bdc <_Z4fsckv+0x7f9>
  8038c6:	89 c3                	mov    %eax,%ebx
				goto check_directory_inode;
		}
		break;

	check_directory_inode:
		ino->i_fsck_checked = 1;
  8038c8:	80 88 ff 0f 00 00 80 	orb    $0x80,0xfff(%eax)
		if (ino->i_size % sizeof(struct Direntry) != 0) {
  8038cf:	8b 40 08             	mov    0x8(%eax),%eax
  8038d2:	a8 7f                	test   $0x7f,%al
  8038d4:	74 23                	je     8038f9 <_Z4fsckv+0x516>
			cprintf("inode[%d]: directory size %d not multiple of %d\n", i, ino->i_size, sizeof(struct Direntry));
  8038d6:	c7 44 24 0c 80 00 00 	movl   $0x80,0xc(%esp)
  8038dd:	00 
  8038de:	89 44 24 08          	mov    %eax,0x8(%esp)
  8038e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8038e6:	c7 04 24 08 4e 81 00 	movl   $0x814e08,(%esp)
  8038ed:	e8 e4 d1 ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  8038f2:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
	}

	// directory checks
	while (1) {
		struct Inode *ino;
		for (i = 1; i < super->s_ninodes; ++i) {
  8038f9:	c7 85 64 ff ff ff 00 	movl   $0x0,-0x9c(%ebp)
  803900:	00 00 00 
  803903:	89 9d 58 ff ff ff    	mov    %ebx,-0xa8(%ebp)
  803909:	e9 3d 02 00 00       	jmp    803b4b <_Z4fsckv+0x768>
		if (ino->i_size % sizeof(struct Direntry) != 0) {
			cprintf("inode[%d]: directory size %d not multiple of %d\n", i, ino->i_size, sizeof(struct Direntry));
			++errors;
		}
		for (j = 0; (off_t) (j + sizeof(struct Direntry)) <= ino->i_size; j += sizeof(struct Direntry)) {
			struct Direntry *de = (struct Direntry *) inode_data(ino, j);
  80390e:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  803914:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
  80391a:	e8 01 ee ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
  80391f:	89 c3                	mov    %eax,%ebx
			char name[MAXNAMELEN];
			int namelen;

			if (de->de_inum == 0)
  803921:	83 38 00             	cmpl   $0x0,(%eax)
  803924:	0f 84 15 02 00 00    	je     803b3f <_Z4fsckv+0x75c>
				continue;

			if (de->de_namelen <= 0 || de->de_namelen >= MAXNAMELEN) {
  80392a:	8b 40 04             	mov    0x4(%eax),%eax
  80392d:	8d 50 ff             	lea    -0x1(%eax),%edx
  803930:	83 fa 76             	cmp    $0x76,%edx
  803933:	76 27                	jbe    80395c <_Z4fsckv+0x579>
				cprintf("inode[%d] de@%d: bad filename length %d\n", i, j, de->de_namelen);
  803935:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803939:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
  80393f:	89 44 24 08          	mov    %eax,0x8(%esp)
  803943:	89 74 24 04          	mov    %esi,0x4(%esp)
  803947:	c7 04 24 3c 4e 81 00 	movl   $0x814e3c,(%esp)
  80394e:	e8 83 d1 ff ff       	call   800ad6 <_Z7cprintfPKcz>
				++errors;
  803953:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  80395a:	eb 28                	jmp    803984 <_Z4fsckv+0x5a1>
			} else if (de->de_name[de->de_namelen] != 0) {
  80395c:	80 7c 03 08 00       	cmpb   $0x0,0x8(%ebx,%eax,1)
  803961:	74 21                	je     803984 <_Z4fsckv+0x5a1>
				cprintf("inode[%d] de@%d: filename is not null terminated\n", i, j);
  803963:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  803969:	89 54 24 08          	mov    %edx,0x8(%esp)
  80396d:	89 74 24 04          	mov    %esi,0x4(%esp)
  803971:	c7 04 24 68 4e 81 00 	movl   $0x814e68,(%esp)
  803978:	e8 59 d1 ff ff       	call   800ad6 <_Z7cprintfPKcz>
				++errors;
  80397d:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
			}
			memcpy(name, de->de_name, MAXNAMELEN);
  803984:	c7 44 24 08 78 00 00 	movl   $0x78,0x8(%esp)
  80398b:	00 
  80398c:	8d 43 08             	lea    0x8(%ebx),%eax
  80398f:	89 44 24 04          	mov    %eax,0x4(%esp)
  803993:	8d 8d 70 ff ff ff    	lea    -0x90(%ebp),%ecx
  803999:	89 0c 24             	mov    %ecx,(%esp)
  80399c:	e8 66 d9 ff ff       	call   801307 <memcpy>
  8039a1:	83 7b 04 77          	cmpl   $0x77,0x4(%ebx)
  8039a5:	bf 77 00 00 00       	mov    $0x77,%edi
  8039aa:	0f 4e 7b 04          	cmovle 0x4(%ebx),%edi
  8039ae:	85 ff                	test   %edi,%edi
  8039b0:	b8 00 00 00 00       	mov    $0x0,%eax
  8039b5:	0f 48 f8             	cmovs  %eax,%edi
			namelen = MAX(MIN(de->de_namelen, MAXNAMELEN - 1), 0);
			name[namelen] = 0;
  8039b8:	c6 84 3d 70 ff ff ff 	movb   $0x0,-0x90(%ebp,%edi,1)
  8039bf:	00 

			if (de->de_inum >= super->s_ninodes) {
  8039c0:	8b 03                	mov    (%ebx),%eax
  8039c2:	3b 05 08 10 00 50    	cmp    0x50001008,%eax
  8039c8:	7c 3e                	jl     803a08 <_Z4fsckv+0x625>
				cprintf("inode[%d] de@%d (%s): inode %d out of range\n", i, j, name, de->de_inum);
  8039ca:	89 44 24 10          	mov    %eax,0x10(%esp)
  8039ce:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
  8039d4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8039d8:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  8039de:	89 54 24 08          	mov    %edx,0x8(%esp)
  8039e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8039e6:	c7 04 24 9c 4e 81 00 	movl   $0x814e9c,(%esp)
  8039ed:	e8 e4 d0 ff ff       	call   800ad6 <_Z7cprintfPKcz>
				++errors;
  8039f2:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
	}

	// directory checks
	while (1) {
		struct Inode *ino;
		for (i = 1; i < super->s_ninodes; ++i) {
  8039f9:	c7 85 5c ff ff ff 00 	movl   $0x0,-0xa4(%ebp)
  803a00:	00 00 00 
  803a03:	e9 0b 01 00 00       	jmp    803b13 <_Z4fsckv+0x730>

			if (de->de_inum >= super->s_ninodes) {
				cprintf("inode[%d] de@%d (%s): inode %d out of range\n", i, j, name, de->de_inum);
				++errors;
			} else {
				struct Inode *refed = get_inode(de->de_inum);
  803a08:	e8 70 ed ff ff       	call   80277d <_ZL9get_inodei>
				++refed->i_fsck_refcount;
  803a0d:	0f b6 88 fc 0f 00 00 	movzbl 0xffc(%eax),%ecx
  803a14:	0f b6 90 fd 0f 00 00 	movzbl 0xffd(%eax),%edx
  803a1b:	c1 e2 08             	shl    $0x8,%edx
  803a1e:	09 d1                	or     %edx,%ecx
  803a20:	0f b6 90 fe 0f 00 00 	movzbl 0xffe(%eax),%edx
  803a27:	c1 e2 10             	shl    $0x10,%edx
  803a2a:	09 d1                	or     %edx,%ecx
  803a2c:	0f b6 90 ff 0f 00 00 	movzbl 0xfff(%eax),%edx
  803a33:	83 e2 7f             	and    $0x7f,%edx
  803a36:	c1 e2 18             	shl    $0x18,%edx
  803a39:	09 ca                	or     %ecx,%edx
  803a3b:	83 c2 01             	add    $0x1,%edx
  803a3e:	89 d1                	mov    %edx,%ecx
  803a40:	81 e1 ff ff ff 7f    	and    $0x7fffffff,%ecx
  803a46:	88 90 fc 0f 00 00    	mov    %dl,0xffc(%eax)
  803a4c:	0f b6 d5             	movzbl %ch,%edx
  803a4f:	88 90 fd 0f 00 00    	mov    %dl,0xffd(%eax)
  803a55:	89 ca                	mov    %ecx,%edx
  803a57:	c1 ea 10             	shr    $0x10,%edx
  803a5a:	88 90 fe 0f 00 00    	mov    %dl,0xffe(%eax)
  803a60:	c1 e9 18             	shr    $0x18,%ecx
  803a63:	0f b6 90 ff 0f 00 00 	movzbl 0xfff(%eax),%edx
  803a6a:	83 e2 80             	and    $0xffffff80,%edx
  803a6d:	09 ca                	or     %ecx,%edx
  803a6f:	88 90 ff 0f 00 00    	mov    %dl,0xfff(%eax)
				if (refed->i_refcount == 0) {
  803a75:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803a79:	0f 85 7a ff ff ff    	jne    8039f9 <_Z4fsckv+0x616>
					cprintf("inode[%d] de@%d (%s): refers to free inode %d\n", i, j, name, de->de_inum);
  803a7f:	8b 03                	mov    (%ebx),%eax
  803a81:	89 44 24 10          	mov    %eax,0x10(%esp)
  803a85:	8d 8d 70 ff ff ff    	lea    -0x90(%ebp),%ecx
  803a8b:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  803a8f:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
  803a95:	89 44 24 08          	mov    %eax,0x8(%esp)
  803a99:	89 74 24 04          	mov    %esi,0x4(%esp)
  803a9d:	c7 04 24 cc 4e 81 00 	movl   $0x814ecc,(%esp)
  803aa4:	e8 2d d0 ff ff       	call   800ad6 <_Z7cprintfPKcz>
					++errors;
  803aa9:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
  803ab0:	e9 44 ff ff ff       	jmp    8039f9 <_Z4fsckv+0x616>
				}
			}
			for (k = 0; k < j && de->de_namelen < MAXNAMELEN; k += sizeof(struct Direntry)) {
				struct Direntry *xde = (struct Direntry *) inode_data(ino, k);
				if (xde->de_inum != 0
  803ab5:	3b 78 04             	cmp    0x4(%eax),%edi
  803ab8:	75 52                	jne    803b0c <_Z4fsckv+0x729>
				    && xde->de_namelen == namelen
				    && memcmp(xde->de_name, name, namelen) == 0) {
  803aba:	89 7c 24 08          	mov    %edi,0x8(%esp)
  803abe:	8d 95 70 ff ff ff    	lea    -0x90(%ebp),%edx
  803ac4:	89 54 24 04          	mov    %edx,0x4(%esp)
  803ac8:	83 c0 08             	add    $0x8,%eax
  803acb:	89 04 24             	mov    %eax,(%esp)
  803ace:	e8 75 d8 ff ff       	call   801348 <memcmp>
					++errors;
				}
			}
			for (k = 0; k < j && de->de_namelen < MAXNAMELEN; k += sizeof(struct Direntry)) {
				struct Direntry *xde = (struct Direntry *) inode_data(ino, k);
				if (xde->de_inum != 0
  803ad3:	85 c0                	test   %eax,%eax
  803ad5:	75 35                	jne    803b0c <_Z4fsckv+0x729>
				    && xde->de_namelen == namelen
				    && memcmp(xde->de_name, name, namelen) == 0) {
					cprintf("inode[%d] de@%d (%s): same filename as de@%d\n", i, j, name, k);
  803ad7:	8b 8d 5c ff ff ff    	mov    -0xa4(%ebp),%ecx
  803add:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  803ae1:	8d 85 70 ff ff ff    	lea    -0x90(%ebp),%eax
  803ae7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803aeb:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  803af1:	89 54 24 08          	mov    %edx,0x8(%esp)
  803af5:	89 74 24 04          	mov    %esi,0x4(%esp)
  803af9:	c7 04 24 fc 4e 81 00 	movl   $0x814efc,(%esp)
  803b00:	e8 d1 cf ff ff       	call   800ad6 <_Z7cprintfPKcz>
					++errors;
  803b05:	83 85 60 ff ff ff 01 	addl   $0x1,-0xa0(%ebp)
// Does no locking, so if run in parallel with other environments, it can
// get confused and report transient "errors."
// Returns 0 if the file system is OK, -E_INVAL if any errors were found.
//
int
fsck(void)
  803b0c:	83 ad 5c ff ff ff 80 	subl   $0xffffff80,-0xa4(%ebp)
				if (refed->i_refcount == 0) {
					cprintf("inode[%d] de@%d (%s): refers to free inode %d\n", i, j, name, de->de_inum);
					++errors;
				}
			}
			for (k = 0; k < j && de->de_namelen < MAXNAMELEN; k += sizeof(struct Direntry)) {
  803b13:	8b 8d 5c ff ff ff    	mov    -0xa4(%ebp),%ecx
  803b19:	39 8d 64 ff ff ff    	cmp    %ecx,-0x9c(%ebp)
  803b1f:	7e 1e                	jle    803b3f <_Z4fsckv+0x75c>
  803b21:	83 7b 04 77          	cmpl   $0x77,0x4(%ebx)
  803b25:	7f 18                	jg     803b3f <_Z4fsckv+0x75c>
				struct Direntry *xde = (struct Direntry *) inode_data(ino, k);
  803b27:	89 ca                	mov    %ecx,%edx
  803b29:	8b 85 58 ff ff ff    	mov    -0xa8(%ebp),%eax
  803b2f:	e8 ec eb ff ff       	call   802720 <_ZL10inode_dataP5Inodei>
				if (xde->de_inum != 0
  803b34:	83 38 00             	cmpl   $0x0,(%eax)
  803b37:	0f 85 78 ff ff ff    	jne    803ab5 <_Z4fsckv+0x6d2>
  803b3d:	eb cd                	jmp    803b0c <_Z4fsckv+0x729>
		ino->i_fsck_checked = 1;
		if (ino->i_size % sizeof(struct Direntry) != 0) {
			cprintf("inode[%d]: directory size %d not multiple of %d\n", i, ino->i_size, sizeof(struct Direntry));
			++errors;
		}
		for (j = 0; (off_t) (j + sizeof(struct Direntry)) <= ino->i_size; j += sizeof(struct Direntry)) {
  803b3f:	8b 85 50 ff ff ff    	mov    -0xb0(%ebp),%eax
  803b45:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%ebp)
// Does no locking, so if run in parallel with other environments, it can
// get confused and report transient "errors."
// Returns 0 if the file system is OK, -E_INVAL if any errors were found.
//
int
fsck(void)
  803b4b:	8b 95 64 ff ff ff    	mov    -0x9c(%ebp),%edx
  803b51:	83 ea 80             	sub    $0xffffff80,%edx
  803b54:	89 95 50 ff ff ff    	mov    %edx,-0xb0(%ebp)
		ino->i_fsck_checked = 1;
		if (ino->i_size % sizeof(struct Direntry) != 0) {
			cprintf("inode[%d]: directory size %d not multiple of %d\n", i, ino->i_size, sizeof(struct Direntry));
			++errors;
		}
		for (j = 0; (off_t) (j + sizeof(struct Direntry)) <= ino->i_size; j += sizeof(struct Direntry)) {
  803b5a:	8b 8d 58 ff ff ff    	mov    -0xa8(%ebp),%ecx
  803b60:	3b 51 08             	cmp    0x8(%ecx),%edx
  803b63:	0f 8f e7 fc ff ff    	jg     803850 <_Z4fsckv+0x46d>
  803b69:	e9 a0 fd ff ff       	jmp    80390e <_Z4fsckv+0x52b>
  803b6e:	8b b5 60 ff ff ff    	mov    -0xa0(%ebp),%esi
		}
	}

	// refcount consistency
	for (i = 1; i < super->s_ninodes; ++i) {
		struct Inode *ino = get_inode(i);
  803b74:	89 d8                	mov    %ebx,%eax
  803b76:	e8 02 ec ff ff       	call   80277d <_ZL9get_inodei>
		if (ino->i_refcount != ino->i_fsck_refcount) {
  803b7b:	8b 50 04             	mov    0x4(%eax),%edx
  803b7e:	0f b6 88 fc 0f 00 00 	movzbl 0xffc(%eax),%ecx
  803b85:	0f b6 b8 fd 0f 00 00 	movzbl 0xffd(%eax),%edi
  803b8c:	c1 e7 08             	shl    $0x8,%edi
  803b8f:	09 f9                	or     %edi,%ecx
  803b91:	0f b6 b8 fe 0f 00 00 	movzbl 0xffe(%eax),%edi
  803b98:	c1 e7 10             	shl    $0x10,%edi
  803b9b:	09 f9                	or     %edi,%ecx
  803b9d:	0f b6 b8 ff 0f 00 00 	movzbl 0xfff(%eax),%edi
  803ba4:	83 e7 7f             	and    $0x7f,%edi
  803ba7:	c1 e7 18             	shl    $0x18,%edi
  803baa:	09 f9                	or     %edi,%ecx
  803bac:	39 ca                	cmp    %ecx,%edx
  803bae:	74 1b                	je     803bcb <_Z4fsckv+0x7e8>
			cprintf("fsck: inode[%d]: refcount %d should be %d\n", i, ino->i_refcount, ino->i_fsck_refcount);
  803bb0:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  803bb4:	89 54 24 08          	mov    %edx,0x8(%esp)
  803bb8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803bbc:	c7 04 24 2c 4f 81 00 	movl   $0x814f2c,(%esp)
  803bc3:	e8 0e cf ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  803bc8:	83 c6 01             	add    $0x1,%esi
			}
		}
	}

	// refcount consistency
	for (i = 1; i < super->s_ninodes; ++i) {
  803bcb:	83 c3 01             	add    $0x1,%ebx
  803bce:	39 1d 08 10 00 50    	cmp    %ebx,0x50001008
  803bd4:	7f 9e                	jg     803b74 <_Z4fsckv+0x791>
  803bd6:	89 b5 60 ff ff ff    	mov    %esi,-0xa0(%ebp)
			++errors;
		}
	}

	// clean up freemap
	for (i = 0; i < super->s_nblocks; ++i)
  803bdc:	83 3d 04 10 00 50 00 	cmpl   $0x0,0x50001004
  803be3:	7e 4f                	jle    803c34 <_Z4fsckv+0x851>
  803be5:	bb 00 00 00 00       	mov    $0x0,%ebx
  803bea:	8b b5 60 ff ff ff    	mov    -0xa0(%ebp),%esi
		if (freemap[i] == -1)
  803bf0:	0f b6 83 00 20 00 50 	movzbl 0x50002000(%ebx),%eax
  803bf7:	3c ff                	cmp    $0xff,%al
  803bf9:	75 09                	jne    803c04 <_Z4fsckv+0x821>
			freemap[i] = 0;
  803bfb:	c6 83 00 20 00 50 00 	movb   $0x0,0x50002000(%ebx)
  803c02:	eb 1f                	jmp    803c23 <_Z4fsckv+0x840>
		else if (freemap[i] == 0 && i >= min_nblocks) {
  803c04:	84 c0                	test   %al,%al
  803c06:	75 1b                	jne    803c23 <_Z4fsckv+0x840>
  803c08:	3b 9d 54 ff ff ff    	cmp    -0xac(%ebp),%ebx
  803c0e:	7c 13                	jl     803c23 <_Z4fsckv+0x840>
			cprintf("fsck: freemap[%d]: unreferenced block is not free\n", i);
  803c10:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803c14:	c7 04 24 58 4f 81 00 	movl   $0x814f58,(%esp)
  803c1b:	e8 b6 ce ff ff       	call   800ad6 <_Z7cprintfPKcz>
			++errors;
  803c20:	83 c6 01             	add    $0x1,%esi
			++errors;
		}
	}

	// clean up freemap
	for (i = 0; i < super->s_nblocks; ++i)
  803c23:	83 c3 01             	add    $0x1,%ebx
  803c26:	39 1d 04 10 00 50    	cmp    %ebx,0x50001004
  803c2c:	7f c2                	jg     803bf0 <_Z4fsckv+0x80d>
  803c2e:	89 b5 60 ff ff ff    	mov    %esi,-0xa0(%ebp)
		else if (freemap[i] == 0 && i >= min_nblocks) {
			cprintf("fsck: freemap[%d]: unreferenced block is not free\n", i);
			++errors;
		}

	return errors ? -E_INVAL : 0;
  803c34:	83 bd 60 ff ff ff 01 	cmpl   $0x1,-0xa0(%ebp)
  803c3b:	19 c0                	sbb    %eax,%eax
  803c3d:	f7 d0                	not    %eax
  803c3f:	83 e0 fd             	and    $0xfffffffd,%eax
}
  803c42:	81 c4 cc 00 00 00    	add    $0xcc,%esp
  803c48:	5b                   	pop    %ebx
  803c49:	5e                   	pop    %esi
  803c4a:	5f                   	pop    %edi
  803c4b:	5d                   	pop    %ebp
  803c4c:	c3                   	ret    
		// uninitialized inodes (use bcache_ipc to check)
		bool active = ino->i_refcount != 0;
		if (!active && ino->i_opencount != 0
		    && bcache_ipc(ino, BCREQ_MAP) != 0)
			active = true;
		if (active && ino->i_ftype != FTYPE_REG && ino->i_ftype != FTYPE_DIR) {
  803c4d:	80 bd 5c ff ff ff 00 	cmpb   $0x0,-0xa4(%ebp)
  803c54:	0f 84 92 f9 ff ff    	je     8035ec <_Z4fsckv+0x209>
  803c5a:	e9 5a f9 ff ff       	jmp    8035b9 <_Z4fsckv+0x1d6>
	...

00803c60 <_ZL12devpipe_statP2FdP4Stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  803c60:	55                   	push   %ebp
  803c61:	89 e5                	mov    %esp,%ebp
  803c63:	83 ec 18             	sub    $0x18,%esp
  803c66:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  803c69:	89 75 fc             	mov    %esi,-0x4(%ebp)
  803c6c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  803c6f:	8b 45 08             	mov    0x8(%ebp),%eax
  803c72:	89 04 24             	mov    %eax,(%esp)
  803c75:	e8 a2 e4 ff ff       	call   80211c <_Z7fd2dataP2Fd>
  803c7a:	89 c3                	mov    %eax,%ebx
	strcpy(stat->st_name, "<pipe>");
  803c7c:	c7 44 24 04 8b 4f 81 	movl   $0x814f8b,0x4(%esp)
  803c83:	00 
  803c84:	89 34 24             	mov    %esi,(%esp)
  803c87:	e8 5e d4 ff ff       	call   8010ea <_Z6strcpyPcPKc>
	stat->st_size = p->p_wpos - p->p_rpos;
  803c8c:	8b 43 04             	mov    0x4(%ebx),%eax
  803c8f:	2b 03                	sub    (%ebx),%eax
  803c91:	89 46 78             	mov    %eax,0x78(%esi)
	stat->st_ftype = FTYPE_REG;
  803c94:	c7 46 7c 01 00 00 00 	movl   $0x1,0x7c(%esi)
	stat->st_dev = &devpipe;
  803c9b:	c7 86 80 00 00 00 20 	movl   $0x818020,0x80(%esi)
  803ca2:	80 81 00 
	return 0;
}
  803ca5:	b8 00 00 00 00       	mov    $0x0,%eax
  803caa:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  803cad:	8b 75 fc             	mov    -0x4(%ebp),%esi
  803cb0:	89 ec                	mov    %ebp,%esp
  803cb2:	5d                   	pop    %ebp
  803cb3:	c3                   	ret    

00803cb4 <_ZL13devpipe_closeP2Fd>:

static int
devpipe_close(struct Fd *fd)
{
  803cb4:	55                   	push   %ebp
  803cb5:	89 e5                	mov    %esp,%ebp
  803cb7:	53                   	push   %ebx
  803cb8:	83 ec 14             	sub    $0x14,%esp
  803cbb:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  803cbe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803cc2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803cc9:	e8 bf d9 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
	return sys_page_unmap(0, fd2data(fd));
  803cce:	89 1c 24             	mov    %ebx,(%esp)
  803cd1:	e8 46 e4 ff ff       	call   80211c <_Z7fd2dataP2Fd>
  803cd6:	89 44 24 04          	mov    %eax,0x4(%esp)
  803cda:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803ce1:	e8 a7 d9 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
}
  803ce6:	83 c4 14             	add    $0x14,%esp
  803ce9:	5b                   	pop    %ebx
  803cea:	5d                   	pop    %ebp
  803ceb:	c3                   	ret    

00803cec <_ZL13_pipeisclosedP2FdP4Pipe>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  803cec:	55                   	push   %ebp
  803ced:	89 e5                	mov    %esp,%ebp
  803cef:	57                   	push   %edi
  803cf0:	56                   	push   %esi
  803cf1:	53                   	push   %ebx
  803cf2:	83 ec 2c             	sub    $0x2c,%esp
  803cf5:	89 c7                	mov    %eax,%edi
  803cf7:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	// LAB 5: Your code here.
    int i;
    uint32_t orig_id;
    while(true)
    {
        orig_id = thisenv->env_runs;
  803cfa:	a1 98 90 81 00       	mov    0x819098,%eax
  803cff:	8b 70 58             	mov    0x58(%eax),%esi
        i = pageref(fd) == pageref(p);
  803d02:	89 3c 24             	mov    %edi,(%esp)
  803d05:	e8 82 04 00 00       	call   80418c <_Z7pagerefPv>
  803d0a:	89 c3                	mov    %eax,%ebx
  803d0c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803d0f:	89 04 24             	mov    %eax,(%esp)
  803d12:	e8 75 04 00 00       	call   80418c <_Z7pagerefPv>
  803d17:	39 c3                	cmp    %eax,%ebx
  803d19:	0f 94 c0             	sete   %al
  803d1c:	0f b6 c0             	movzbl %al,%eax
        if(orig_id == thisenv->env_runs)
  803d1f:	8b 15 98 90 81 00    	mov    0x819098,%edx
  803d25:	8b 52 58             	mov    0x58(%edx),%edx
  803d28:	39 d6                	cmp    %edx,%esi
  803d2a:	75 08                	jne    803d34 <_ZL13_pipeisclosedP2FdP4Pipe+0x48>
            return i;
        else if(i)
            cprintf("pipe race avoided\n");
    }
}
  803d2c:	83 c4 2c             	add    $0x2c,%esp
  803d2f:	5b                   	pop    %ebx
  803d30:	5e                   	pop    %esi
  803d31:	5f                   	pop    %edi
  803d32:	5d                   	pop    %ebp
  803d33:	c3                   	ret    
    {
        orig_id = thisenv->env_runs;
        i = pageref(fd) == pageref(p);
        if(orig_id == thisenv->env_runs)
            return i;
        else if(i)
  803d34:	85 c0                	test   %eax,%eax
  803d36:	74 c2                	je     803cfa <_ZL13_pipeisclosedP2FdP4Pipe+0xe>
            cprintf("pipe race avoided\n");
  803d38:	c7 04 24 92 4f 81 00 	movl   $0x814f92,(%esp)
  803d3f:	e8 92 cd ff ff       	call   800ad6 <_Z7cprintfPKcz>
  803d44:	eb b4                	jmp    803cfa <_ZL13_pipeisclosedP2FdP4Pipe+0xe>

00803d46 <_ZL13devpipe_writeP2FdPKvj>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  803d46:	55                   	push   %ebp
  803d47:	89 e5                	mov    %esp,%ebp
  803d49:	57                   	push   %edi
  803d4a:	56                   	push   %esi
  803d4b:	53                   	push   %ebx
  803d4c:	83 ec 1c             	sub    $0x1c,%esp
  803d4f:	8b 75 08             	mov    0x8(%ebp),%esi
	// wait for the pipe to empty and then keep copying.
	// If the pipe is full and closed, return the number of characters
	// written.  Use _pipeisclosed to check whether the pipe is closed.

	// LAB 5: Your code here.
	struct Pipe *p = (struct Pipe *) fd2data(fd);
  803d52:	89 34 24             	mov    %esi,(%esp)
  803d55:	e8 c2 e3 ff ff       	call   80211c <_Z7fd2dataP2Fd>
  803d5a:	89 c3                	mov    %eax,%ebx
	uint8_t *buf = (uint8_t *) vbuf;
	size_t i;

	for (i = 0; i < n; i++) {
  803d5c:	bf 00 00 00 00       	mov    $0x0,%edi
  803d61:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  803d65:	75 46                	jne    803dad <_ZL13devpipe_writeP2FdPKvj+0x67>
  803d67:	eb 52                	jmp    803dbb <_ZL13devpipe_writeP2FdPKvj+0x75>
		while (p->p_wpos - p->p_rpos == PIPEBUFSIZ) {
			// The pipe is currently full
			// If any data has been read, return it.
			// Otherwise, check for EOF; if not EOF, yield
			// and try again.
			if (_pipeisclosed(fd, p))
  803d69:	89 da                	mov    %ebx,%edx
  803d6b:	89 f0                	mov    %esi,%eax
  803d6d:	e8 7a ff ff ff       	call   803cec <_ZL13_pipeisclosedP2FdP4Pipe>
  803d72:	85 c0                	test   %eax,%eax
  803d74:	75 49                	jne    803dbf <_ZL13devpipe_writeP2FdPKvj+0x79>
				return 0;
			else
				sys_yield();
  803d76:	e8 21 d8 ff ff       	call   80159c <_Z9sys_yieldv>
	struct Pipe *p = (struct Pipe *) fd2data(fd);
	uint8_t *buf = (uint8_t *) vbuf;
	size_t i;

	for (i = 0; i < n; i++) {
		while (p->p_wpos - p->p_rpos == PIPEBUFSIZ) {
  803d7b:	8b 43 04             	mov    0x4(%ebx),%eax
  803d7e:	89 c2                	mov    %eax,%edx
  803d80:	2b 13                	sub    (%ebx),%edx
  803d82:	83 fa 20             	cmp    $0x20,%edx
  803d85:	74 e2                	je     803d69 <_ZL13devpipe_writeP2FdPKvj+0x23>
				return 0;
			else
				sys_yield();
		}

		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  803d87:	89 c2                	mov    %eax,%edx
  803d89:	c1 fa 1f             	sar    $0x1f,%edx
  803d8c:	c1 ea 1b             	shr    $0x1b,%edx
  803d8f:	01 d0                	add    %edx,%eax
  803d91:	83 e0 1f             	and    $0x1f,%eax
  803d94:	29 d0                	sub    %edx,%eax
  803d96:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  803d99:	0f b6 14 39          	movzbl (%ecx,%edi,1),%edx
  803d9d:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
		// The increment must come AFTER we write to the buffer,
		// or the C compiler might update the pointer before writing
		// to the buffer!  In fact, we need a memory barrier here---
		// on some machines a memory barrier instruction.
		asm volatile("" : : : "memory");
		p->p_wpos++;
  803da1:	83 43 04 01          	addl   $0x1,0x4(%ebx)
	// LAB 5: Your code here.
	struct Pipe *p = (struct Pipe *) fd2data(fd);
	uint8_t *buf = (uint8_t *) vbuf;
	size_t i;

	for (i = 0; i < n; i++) {
  803da5:	83 c7 01             	add    $0x1,%edi
  803da8:	39 7d 10             	cmp    %edi,0x10(%ebp)
  803dab:	76 0e                	jbe    803dbb <_ZL13devpipe_writeP2FdPKvj+0x75>
		while (p->p_wpos - p->p_rpos == PIPEBUFSIZ) {
  803dad:	8b 43 04             	mov    0x4(%ebx),%eax
  803db0:	89 c2                	mov    %eax,%edx
  803db2:	2b 13                	sub    (%ebx),%edx
  803db4:	83 fa 20             	cmp    $0x20,%edx
  803db7:	74 b0                	je     803d69 <_ZL13devpipe_writeP2FdPKvj+0x23>
  803db9:	eb cc                	jmp    803d87 <_ZL13devpipe_writeP2FdPKvj+0x41>
		// on some machines a memory barrier instruction.
		asm volatile("" : : : "memory");
		p->p_wpos++;
	}

	return i;
  803dbb:	89 f8                	mov    %edi,%eax
  803dbd:	eb 05                	jmp    803dc4 <_ZL13devpipe_writeP2FdPKvj+0x7e>
			// The pipe is currently full
			// If any data has been read, return it.
			// Otherwise, check for EOF; if not EOF, yield
			// and try again.
			if (_pipeisclosed(fd, p))
				return 0;
  803dbf:	b8 00 00 00 00       	mov    $0x0,%eax
		asm volatile("" : : : "memory");
		p->p_wpos++;
	}

	return i;
}
  803dc4:	83 c4 1c             	add    $0x1c,%esp
  803dc7:	5b                   	pop    %ebx
  803dc8:	5e                   	pop    %esi
  803dc9:	5f                   	pop    %edi
  803dca:	5d                   	pop    %ebp
  803dcb:	c3                   	ret    

00803dcc <_ZL12devpipe_readP2FdPvj>:
}


static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  803dcc:	55                   	push   %ebp
  803dcd:	89 e5                	mov    %esp,%ebp
  803dcf:	83 ec 28             	sub    $0x28,%esp
  803dd2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803dd5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803dd8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803ddb:	8b 7d 08             	mov    0x8(%ebp),%edi
	struct Pipe *p = (struct Pipe *) fd2data(fd);
  803dde:	89 3c 24             	mov    %edi,(%esp)
  803de1:	e8 36 e3 ff ff       	call   80211c <_Z7fd2dataP2Fd>
  803de6:	89 c3                	mov    %eax,%ebx
	uint8_t *buf = (uint8_t *) vbuf;
	size_t i;

	for (i = 0; i < n; i++) {
  803de8:	be 00 00 00 00       	mov    $0x0,%esi
  803ded:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  803df1:	75 47                	jne    803e3a <_ZL12devpipe_readP2FdPvj+0x6e>
  803df3:	eb 52                	jmp    803e47 <_ZL12devpipe_readP2FdPvj+0x7b>
			// The pipe is currently empty.
			// If any data has been read, return it.
			// Otherwise, check for EOF; if not EOF, yield
			// and try again.
			if (i > 0)
				return i;
  803df5:	89 f0                	mov    %esi,%eax
  803df7:	eb 5e                	jmp    803e57 <_ZL12devpipe_readP2FdPvj+0x8b>
			else if (_pipeisclosed(fd, p))
  803df9:	89 da                	mov    %ebx,%edx
  803dfb:	89 f8                	mov    %edi,%eax
  803dfd:	8d 76 00             	lea    0x0(%esi),%esi
  803e00:	e8 e7 fe ff ff       	call   803cec <_ZL13_pipeisclosedP2FdP4Pipe>
  803e05:	85 c0                	test   %eax,%eax
  803e07:	75 49                	jne    803e52 <_ZL12devpipe_readP2FdPvj+0x86>
				return 0;
			else
				sys_yield();
  803e09:	e8 8e d7 ff ff       	call   80159c <_Z9sys_yieldv>
	struct Pipe *p = (struct Pipe *) fd2data(fd);
	uint8_t *buf = (uint8_t *) vbuf;
	size_t i;

	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  803e0e:	8b 03                	mov    (%ebx),%eax
  803e10:	3b 43 04             	cmp    0x4(%ebx),%eax
  803e13:	74 e4                	je     803df9 <_ZL12devpipe_readP2FdPvj+0x2d>
				return 0;
			else
				sys_yield();
		}

		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  803e15:	89 c2                	mov    %eax,%edx
  803e17:	c1 fa 1f             	sar    $0x1f,%edx
  803e1a:	c1 ea 1b             	shr    $0x1b,%edx
  803e1d:	01 d0                	add    %edx,%eax
  803e1f:	83 e0 1f             	and    $0x1f,%eax
  803e22:	29 d0                	sub    %edx,%eax
  803e24:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  803e29:	8b 55 0c             	mov    0xc(%ebp),%edx
  803e2c:	88 04 32             	mov    %al,(%edx,%esi,1)
		// The increment must come AFTER we write to the buffer,
		// or the C compiler might update the pointer before writing
		// to the buffer!  In fact, we need a memory barrier here---
		// on some machines a memory barrier instruction.
		asm volatile("" : : : "memory");
		p->p_rpos++;
  803e2f:	83 03 01             	addl   $0x1,(%ebx)
{
	struct Pipe *p = (struct Pipe *) fd2data(fd);
	uint8_t *buf = (uint8_t *) vbuf;
	size_t i;

	for (i = 0; i < n; i++) {
  803e32:	83 c6 01             	add    $0x1,%esi
  803e35:	39 75 10             	cmp    %esi,0x10(%ebp)
  803e38:	76 0d                	jbe    803e47 <_ZL12devpipe_readP2FdPvj+0x7b>
		while (p->p_rpos == p->p_wpos) {
  803e3a:	8b 03                	mov    (%ebx),%eax
  803e3c:	3b 43 04             	cmp    0x4(%ebx),%eax
  803e3f:	75 d4                	jne    803e15 <_ZL12devpipe_readP2FdPvj+0x49>
			// The pipe is currently empty.
			// If any data has been read, return it.
			// Otherwise, check for EOF; if not EOF, yield
			// and try again.
			if (i > 0)
  803e41:	85 f6                	test   %esi,%esi
  803e43:	75 b0                	jne    803df5 <_ZL12devpipe_readP2FdPvj+0x29>
  803e45:	eb b2                	jmp    803df9 <_ZL12devpipe_readP2FdPvj+0x2d>
		// on some machines a memory barrier instruction.
		asm volatile("" : : : "memory");
		p->p_rpos++;
	}

	return i;
  803e47:	89 f0                	mov    %esi,%eax
  803e49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803e50:	eb 05                	jmp    803e57 <_ZL12devpipe_readP2FdPvj+0x8b>
			// Otherwise, check for EOF; if not EOF, yield
			// and try again.
			if (i > 0)
				return i;
			else if (_pipeisclosed(fd, p))
				return 0;
  803e52:	b8 00 00 00 00       	mov    $0x0,%eax
		asm volatile("" : : : "memory");
		p->p_rpos++;
	}

	return i;
}
  803e57:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803e5a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803e5d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803e60:	89 ec                	mov    %ebp,%esp
  803e62:	5d                   	pop    %ebp
  803e63:	c3                   	ret    

00803e64 <_Z4pipePi>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  803e64:	55                   	push   %ebp
  803e65:	89 e5                	mov    %esp,%ebp
  803e67:	83 ec 48             	sub    $0x48,%esp
  803e6a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803e6d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803e70:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803e73:	8b 7d 08             	mov    0x8(%ebp),%edi
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_find_unused(&fd0)) < 0
  803e76:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803e79:	89 04 24             	mov    %eax,(%esp)
  803e7c:	e8 b6 e2 ff ff       	call   802137 <_Z14fd_find_unusedPP2Fd>
  803e81:	89 c3                	mov    %eax,%ebx
  803e83:	85 c0                	test   %eax,%eax
  803e85:	0f 88 0b 01 00 00    	js     803f96 <_Z4pipePi+0x132>
  803e8b:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  803e92:	00 
  803e93:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803e96:	89 44 24 04          	mov    %eax,0x4(%esp)
  803e9a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803ea1:	e8 2a d7 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  803ea6:	89 c3                	mov    %eax,%ebx
  803ea8:	85 c0                	test   %eax,%eax
  803eaa:	0f 89 f5 00 00 00    	jns    803fa5 <_Z4pipePi+0x141>
  803eb0:	e9 e1 00 00 00       	jmp    803f96 <_Z4pipePi+0x132>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err;

	if ((r = fd_find_unused(&fd1)) < 0
  803eb5:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  803ebc:	00 
  803ebd:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803ec0:	89 44 24 04          	mov    %eax,0x4(%esp)
  803ec4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803ecb:	e8 00 d7 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  803ed0:	89 c3                	mov    %eax,%ebx
  803ed2:	85 c0                	test   %eax,%eax
  803ed4:	0f 89 e2 00 00 00    	jns    803fbc <_Z4pipePi+0x158>
  803eda:	e9 a4 00 00 00       	jmp    803f83 <_Z4pipePi+0x11f>

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  803edf:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803ee2:	89 04 24             	mov    %eax,(%esp)
  803ee5:	e8 32 e2 ff ff       	call   80211c <_Z7fd2dataP2Fd>
  803eea:	c7 44 24 10 07 04 00 	movl   $0x407,0x10(%esp)
  803ef1:	00 
  803ef2:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803ef6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  803efd:	00 
  803efe:	89 74 24 04          	mov    %esi,0x4(%esp)
  803f02:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803f09:	e8 21 d7 ff ff       	call   80162f <_Z12sys_page_mapiPviS_i>
  803f0e:	89 c3                	mov    %eax,%ebx
  803f10:	85 c0                	test   %eax,%eax
  803f12:	78 4c                	js     803f60 <_Z4pipePi+0xfc>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  803f14:	8b 15 20 80 81 00    	mov    0x818020,%edx
  803f1a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803f1d:	89 10                	mov    %edx,(%eax)
	fd0->fd_omode = O_RDONLY;
  803f1f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803f22:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

	fd1->fd_dev_id = devpipe.dev_id;
  803f29:	8b 15 20 80 81 00    	mov    0x818020,%edx
  803f2f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803f32:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  803f34:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803f37:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", thisenv->env_id, vpt[PGNUM(va)]);

	pfd[0] = fd2num(fd0);
  803f3e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803f41:	89 04 24             	mov    %eax,(%esp)
  803f44:	e8 8b e1 ff ff       	call   8020d4 <_Z6fd2numP2Fd>
  803f49:	89 07                	mov    %eax,(%edi)
	pfd[1] = fd2num(fd1);
  803f4b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803f4e:	89 04 24             	mov    %eax,(%esp)
  803f51:	e8 7e e1 ff ff       	call   8020d4 <_Z6fd2numP2Fd>
  803f56:	89 47 04             	mov    %eax,0x4(%edi)
	return 0;
  803f59:	bb 00 00 00 00       	mov    $0x0,%ebx
  803f5e:	eb 36                	jmp    803f96 <_Z4pipePi+0x132>

    err3:
	sys_page_unmap(0, va);
  803f60:	89 74 24 04          	mov    %esi,0x4(%esp)
  803f64:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803f6b:	e8 1d d7 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
    err2:
	sys_page_unmap(0, fd1);
  803f70:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803f73:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f77:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803f7e:	e8 0a d7 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
    err1:
	sys_page_unmap(0, fd0);
  803f83:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803f86:	89 44 24 04          	mov    %eax,0x4(%esp)
  803f8a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803f91:	e8 f7 d6 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
    err:
	return r;
}
  803f96:	89 d8                	mov    %ebx,%eax
  803f98:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803f9b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803f9e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803fa1:	89 ec                	mov    %ebp,%esp
  803fa3:	5d                   	pop    %ebp
  803fa4:	c3                   	ret    
	// allocate the file descriptor table entries
	if ((r = fd_find_unused(&fd0)) < 0
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err;

	if ((r = fd_find_unused(&fd1)) < 0
  803fa5:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803fa8:	89 04 24             	mov    %eax,(%esp)
  803fab:	e8 87 e1 ff ff       	call   802137 <_Z14fd_find_unusedPP2Fd>
  803fb0:	89 c3                	mov    %eax,%ebx
  803fb2:	85 c0                	test   %eax,%eax
  803fb4:	0f 89 fb fe ff ff    	jns    803eb5 <_Z4pipePi+0x51>
  803fba:	eb c7                	jmp    803f83 <_Z4pipePi+0x11f>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  803fbc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803fbf:	89 04 24             	mov    %eax,(%esp)
  803fc2:	e8 55 e1 ff ff       	call   80211c <_Z7fd2dataP2Fd>
  803fc7:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  803fc9:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  803fd0:	00 
  803fd1:	89 44 24 04          	mov    %eax,0x4(%esp)
  803fd5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803fdc:	e8 ef d5 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  803fe1:	89 c3                	mov    %eax,%ebx
  803fe3:	85 c0                	test   %eax,%eax
  803fe5:	0f 89 f4 fe ff ff    	jns    803edf <_Z4pipePi+0x7b>
  803feb:	eb 83                	jmp    803f70 <_Z4pipePi+0x10c>

00803fed <_Z12pipeisclosedi>:
    }
}

int
pipeisclosed(int fdnum)
{
  803fed:	55                   	push   %ebp
  803fee:	89 e5                	mov    %esp,%ebp
  803ff0:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd, true)) < 0)
  803ff3:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803ffa:	00 
  803ffb:	8d 45 f4             	lea    -0xc(%ebp),%eax
  803ffe:	89 44 24 04          	mov    %eax,0x4(%esp)
  804002:	8b 45 08             	mov    0x8(%ebp),%eax
  804005:	89 04 24             	mov    %eax,(%esp)
  804008:	e8 74 e0 ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  80400d:	85 c0                	test   %eax,%eax
  80400f:	78 15                	js     804026 <_Z12pipeisclosedi+0x39>
		return r;
	p = (struct Pipe*) fd2data(fd);
  804011:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804014:	89 04 24             	mov    %eax,(%esp)
  804017:	e8 00 e1 ff ff       	call   80211c <_Z7fd2dataP2Fd>
	return _pipeisclosed(fd, p);
  80401c:	89 c2                	mov    %eax,%edx
  80401e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804021:	e8 c6 fc ff ff       	call   803cec <_ZL13_pipeisclosedP2FdP4Pipe>
}
  804026:	c9                   	leave  
  804027:	c3                   	ret    

00804028 <_Z18pipe_ipc_recv_readv>:

int
pipe_ipc_recv_read() {
  804028:	55                   	push   %ebp
  804029:	89 e5                	mov    %esp,%ebp
  80402b:	53                   	push   %ebx
  80402c:	83 ec 24             	sub    $0x24,%esp
    int r;
    struct Fd *fd;

    // allocate the file descriptor table entries
    if ((r = fd_find_unused(&fd)) < 0
  80402f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804032:	89 04 24             	mov    %eax,(%esp)
  804035:	e8 fd e0 ff ff       	call   802137 <_Z14fd_find_unusedPP2Fd>
  80403a:	89 c3                	mov    %eax,%ebx
  80403c:	85 c0                	test   %eax,%eax
  80403e:	0f 88 be 00 00 00    	js     804102 <_Z18pipe_ipc_recv_readv+0xda>
  804044:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  80404b:	00 
  80404c:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80404f:	89 44 24 04          	mov    %eax,0x4(%esp)
  804053:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80405a:	e8 71 d5 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  80405f:	89 c3                	mov    %eax,%ebx
  804061:	85 c0                	test   %eax,%eax
  804063:	0f 89 a1 00 00 00    	jns    80410a <_Z18pipe_ipc_recv_readv+0xe2>
  804069:	e9 94 00 00 00       	jmp    804102 <_Z18pipe_ipc_recv_readv+0xda>
    int perm;
    if ((r = ipc_recv(&from_env, fd2data(fd), &perm)) < 0) {
        goto err1;
    }

    if(perm == 0)
  80406e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  804071:	85 c0                	test   %eax,%eax
  804073:	75 0e                	jne    804083 <_Z18pipe_ipc_recv_readv+0x5b>
        cprintf("no page was actually transferred!\n");
  804075:	c7 04 24 f0 4f 81 00 	movl   $0x814ff0,(%esp)
  80407c:	e8 55 ca ff ff       	call   800ad6 <_Z7cprintfPKcz>
  804081:	eb 10                	jmp    804093 <_Z18pipe_ipc_recv_readv+0x6b>
    else
        cprintf("perm: %x\n", perm);
  804083:	89 44 24 04          	mov    %eax,0x4(%esp)
  804087:	c7 04 24 a5 4f 81 00 	movl   $0x814fa5,(%esp)
  80408e:	e8 43 ca ff ff       	call   800ad6 <_Z7cprintfPKcz>

    cprintf("finished ipc_recv\n");
  804093:	c7 04 24 af 4f 81 00 	movl   $0x814faf,(%esp)
  80409a:	e8 37 ca ff ff       	call   800ad6 <_Z7cprintfPKcz>

    assert(perm & PTE_U && perm & PTE_P);
  80409f:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8040a2:	a8 04                	test   $0x4,%al
  8040a4:	74 04                	je     8040aa <_Z18pipe_ipc_recv_readv+0x82>
  8040a6:	a8 01                	test   $0x1,%al
  8040a8:	75 24                	jne    8040ce <_Z18pipe_ipc_recv_readv+0xa6>
  8040aa:	c7 44 24 0c c2 4f 81 	movl   $0x814fc2,0xc(%esp)
  8040b1:	00 
  8040b2:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  8040b9:	00 
  8040ba:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  8040c1:	00 
  8040c2:	c7 04 24 df 4f 81 00 	movl   $0x814fdf,(%esp)
  8040c9:	e8 ea c8 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    
    // set up fd structures
    fd->fd_dev_id = devpipe.dev_id;
  8040ce:	8b 15 20 80 81 00    	mov    0x818020,%edx
  8040d4:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8040d7:	89 10                	mov    %edx,(%eax)
    fd->fd_omode = O_RDONLY;
  8040d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8040dc:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return fd2num(fd);
  8040e3:	89 04 24             	mov    %eax,(%esp)
  8040e6:	e8 e9 df ff ff       	call   8020d4 <_Z6fd2numP2Fd>
  8040eb:	89 c3                	mov    %eax,%ebx
  8040ed:	eb 13                	jmp    804102 <_Z18pipe_ipc_recv_readv+0xda>

err1:
    sys_page_unmap(0, fd);
  8040ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8040f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8040f6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8040fd:	e8 8b d5 ff ff       	call   80168d <_Z14sys_page_unmapiPv>
err:
    return r;
}
  804102:	89 d8                	mov    %ebx,%eax
  804104:	83 c4 24             	add    $0x24,%esp
  804107:	5b                   	pop    %ebx
  804108:	5d                   	pop    %ebp
  804109:	c3                   	ret    
        goto err;
    }

    envid_t from_env;
    int perm;
    if ((r = ipc_recv(&from_env, fd2data(fd), &perm)) < 0) {
  80410a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80410d:	89 04 24             	mov    %eax,(%esp)
  804110:	e8 07 e0 ff ff       	call   80211c <_Z7fd2dataP2Fd>
  804115:	8d 55 ec             	lea    -0x14(%ebp),%edx
  804118:	89 54 24 08          	mov    %edx,0x8(%esp)
  80411c:	89 44 24 04          	mov    %eax,0x4(%esp)
  804120:	8d 45 f0             	lea    -0x10(%ebp),%eax
  804123:	89 04 24             	mov    %eax,(%esp)
  804126:	e8 d5 dd ff ff       	call   801f00 <_Z8ipc_recvPiPvS_>
  80412b:	89 c3                	mov    %eax,%ebx
  80412d:	85 c0                	test   %eax,%eax
  80412f:	0f 89 39 ff ff ff    	jns    80406e <_Z18pipe_ipc_recv_readv+0x46>
  804135:	eb b8                	jmp    8040ef <_Z18pipe_ipc_recv_readv+0xc7>

00804137 <_Z13pipe_ipc_sendii>:
    return r;
}


int
pipe_ipc_send(envid_t envid, int read_fdnum) {
  804137:	55                   	push   %ebp
  804138:	89 e5                	mov    %esp,%ebp
  80413a:	83 ec 28             	sub    $0x28,%esp
    struct Fd *fd;
    int r;
    if ((r = fd_lookup(read_fdnum, &fd, true)) < 0) {
  80413d:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  804144:	00 
  804145:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804148:	89 44 24 04          	mov    %eax,0x4(%esp)
  80414c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80414f:	89 04 24             	mov    %eax,(%esp)
  804152:	e8 2a df ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  804157:	85 c0                	test   %eax,%eax
  804159:	78 2f                	js     80418a <_Z13pipe_ipc_sendii+0x53>
        return r;
    }
    ipc_send(envid, 0, fd2data(fd), PTE_P | PTE_U | PTE_W);
  80415b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80415e:	89 04 24             	mov    %eax,(%esp)
  804161:	e8 b6 df ff ff       	call   80211c <_Z7fd2dataP2Fd>
  804166:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80416d:	00 
  80416e:	89 44 24 08          	mov    %eax,0x8(%esp)
  804172:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804179:	00 
  80417a:	8b 45 08             	mov    0x8(%ebp),%eax
  80417d:	89 04 24             	mov    %eax,(%esp)
  804180:	e8 0a de ff ff       	call   801f8f <_Z8ipc_sendijPvi>
    return 0;
  804185:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80418a:	c9                   	leave  
  80418b:	c3                   	ret    

0080418c <_Z7pagerefPv>:
#include <inc/lib.h>

int
pageref(void *v)
{
  80418c:	55                   	push   %ebp
  80418d:	89 e5                	mov    %esp,%ebp
  80418f:	8b 55 08             	mov    0x8(%ebp),%edx
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  804192:	89 d0                	mov    %edx,%eax
  804194:	c1 e8 16             	shr    $0x16,%eax
  804197:	8b 0c 85 00 e0 bb ef 	mov    -0x10442000(,%eax,4),%ecx
		return 0;
  80419e:	b8 00 00 00 00       	mov    $0x0,%eax
int
pageref(void *v)
{
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  8041a3:	f6 c1 01             	test   $0x1,%cl
  8041a6:	74 1d                	je     8041c5 <_Z7pagerefPv+0x39>
		return 0;
	pte = vpt[PGNUM(v)];
  8041a8:	c1 ea 0c             	shr    $0xc,%edx
  8041ab:	8b 14 95 00 00 80 ef 	mov    -0x10800000(,%edx,4),%edx
	if (!(pte & PTE_P))
  8041b2:	f6 c2 01             	test   $0x1,%dl
  8041b5:	74 0e                	je     8041c5 <_Z7pagerefPv+0x39>
		return 0;
	return pages[PGNUM(pte)].pp_ref;
  8041b7:	c1 ea 0c             	shr    $0xc,%edx
  8041ba:	0f b7 04 d5 04 00 40 	movzwl -0x10bffffc(,%edx,8),%eax
  8041c1:	ef 
  8041c2:	0f b7 c0             	movzwl %ax,%eax
}
  8041c5:	5d                   	pop    %ebp
  8041c6:	c3                   	ret    
	...

008041d0 <_ZL12devsock_statP2FdP4Stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  8041d0:	55                   	push   %ebp
  8041d1:	89 e5                	mov    %esp,%ebp
  8041d3:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  8041d6:	c7 44 24 04 13 50 81 	movl   $0x815013,0x4(%esp)
  8041dd:	00 
  8041de:	8b 45 0c             	mov    0xc(%ebp),%eax
  8041e1:	89 04 24             	mov    %eax,(%esp)
  8041e4:	e8 01 cf ff ff       	call   8010ea <_Z6strcpyPcPKc>
	return 0;
}
  8041e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8041ee:	c9                   	leave  
  8041ef:	c3                   	ret    

008041f0 <_ZL13devsock_closeP2Fd>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  8041f0:	55                   	push   %ebp
  8041f1:	89 e5                	mov    %esp,%ebp
  8041f3:	53                   	push   %ebx
  8041f4:	83 ec 14             	sub    $0x14,%esp
  8041f7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (pageref(fd) == 1)
  8041fa:	89 1c 24             	mov    %ebx,(%esp)
  8041fd:	e8 8a ff ff ff       	call   80418c <_Z7pagerefPv>
  804202:	89 c2                	mov    %eax,%edx
		return nsipc_close(fd->fd_sock.sockid);
	else
		return 0;
  804204:	b8 00 00 00 00       	mov    $0x0,%eax
}

static int
devsock_close(struct Fd *fd)
{
	if (pageref(fd) == 1)
  804209:	83 fa 01             	cmp    $0x1,%edx
  80420c:	75 0b                	jne    804219 <_ZL13devsock_closeP2Fd+0x29>
		return nsipc_close(fd->fd_sock.sockid);
  80420e:	8b 43 0c             	mov    0xc(%ebx),%eax
  804211:	89 04 24             	mov    %eax,(%esp)
  804214:	e8 fe 02 00 00       	call   804517 <_Z11nsipc_closei>
	else
		return 0;
}
  804219:	83 c4 14             	add    $0x14,%esp
  80421c:	5b                   	pop    %ebx
  80421d:	5d                   	pop    %ebp
  80421e:	c3                   	ret    

0080421f <_ZL13devsock_writeP2FdPKvj>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  80421f:	55                   	push   %ebp
  804220:	89 e5                	mov    %esp,%ebp
  804222:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  804225:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80422c:	00 
  80422d:	8b 45 10             	mov    0x10(%ebp),%eax
  804230:	89 44 24 08          	mov    %eax,0x8(%esp)
  804234:	8b 45 0c             	mov    0xc(%ebp),%eax
  804237:	89 44 24 04          	mov    %eax,0x4(%esp)
  80423b:	8b 45 08             	mov    0x8(%ebp),%eax
  80423e:	8b 40 0c             	mov    0xc(%eax),%eax
  804241:	89 04 24             	mov    %eax,(%esp)
  804244:	e8 c9 03 00 00       	call   804612 <_Z10nsipc_sendiPKvij>
}
  804249:	c9                   	leave  
  80424a:	c3                   	ret    

0080424b <_ZL12devsock_readP2FdPvj>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  80424b:	55                   	push   %ebp
  80424c:	89 e5                	mov    %esp,%ebp
  80424e:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  804251:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804258:	00 
  804259:	8b 45 10             	mov    0x10(%ebp),%eax
  80425c:	89 44 24 08          	mov    %eax,0x8(%esp)
  804260:	8b 45 0c             	mov    0xc(%ebp),%eax
  804263:	89 44 24 04          	mov    %eax,0x4(%esp)
  804267:	8b 45 08             	mov    0x8(%ebp),%eax
  80426a:	8b 40 0c             	mov    0xc(%eax),%eax
  80426d:	89 04 24             	mov    %eax,(%esp)
  804270:	e8 1d 03 00 00       	call   804592 <_Z10nsipc_recviPvij>
}
  804275:	c9                   	leave  
  804276:	c3                   	ret    

00804277 <_ZL12alloc_sockfdi>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  804277:	55                   	push   %ebp
  804278:	89 e5                	mov    %esp,%ebp
  80427a:	83 ec 28             	sub    $0x28,%esp
  80427d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  804280:	89 75 fc             	mov    %esi,-0x4(%ebp)
  804283:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_find_unused(&sfd)) < 0
  804285:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804288:	89 04 24             	mov    %eax,(%esp)
  80428b:	e8 a7 de ff ff       	call   802137 <_Z14fd_find_unusedPP2Fd>
  804290:	89 c3                	mov    %eax,%ebx
  804292:	85 c0                	test   %eax,%eax
  804294:	78 21                	js     8042b7 <_ZL12alloc_sockfdi+0x40>
  804296:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  80429d:	00 
  80429e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8042a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8042a5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8042ac:	e8 1f d3 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  8042b1:	89 c3                	mov    %eax,%ebx
  8042b3:	85 c0                	test   %eax,%eax
  8042b5:	79 14                	jns    8042cb <_ZL12alloc_sockfdi+0x54>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
		nsipc_close(sockid);
  8042b7:	89 34 24             	mov    %esi,(%esp)
  8042ba:	e8 58 02 00 00       	call   804517 <_Z11nsipc_closei>

	sfd->fd_dev_id = devsock.dev_id;
	sfd->fd_omode = O_RDWR;
	sfd->fd_sock.sockid = sockid;
	return fd2num(sfd);
}
  8042bf:	89 d8                	mov    %ebx,%eax
  8042c1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8042c4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8042c7:	89 ec                	mov    %ebp,%esp
  8042c9:	5d                   	pop    %ebp
  8042ca:	c3                   	ret    
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0) {
		nsipc_close(sockid);
		return r;
	}

	sfd->fd_dev_id = devsock.dev_id;
  8042cb:	8b 15 3c 80 81 00    	mov    0x81803c,%edx
  8042d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8042d4:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  8042d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8042d9:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  8042e0:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  8042e3:	89 04 24             	mov    %eax,(%esp)
  8042e6:	e8 e9 dd ff ff       	call   8020d4 <_Z6fd2numP2Fd>
  8042eb:	89 c3                	mov    %eax,%ebx
  8042ed:	eb d0                	jmp    8042bf <_ZL12alloc_sockfdi+0x48>

008042ef <_ZL9fd2sockidi>:
    devsock_stat,
};

static int
fd2sockid(int fd)
{
  8042ef:	55                   	push   %ebp
  8042f0:	89 e5                	mov    %esp,%ebp
  8042f2:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd, 0)) < 0)
  8042f5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8042fc:	00 
  8042fd:	8d 55 f4             	lea    -0xc(%ebp),%edx
  804300:	89 54 24 04          	mov    %edx,0x4(%esp)
  804304:	89 04 24             	mov    %eax,(%esp)
  804307:	e8 75 dd ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  80430c:	85 c0                	test   %eax,%eax
  80430e:	78 15                	js     804325 <_ZL9fd2sockidi+0x36>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  804310:	8b 55 f4             	mov    -0xc(%ebp),%edx
		return -E_NOT_SUPP;
  804313:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd, 0)) < 0)
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  804318:	8b 0d 3c 80 81 00    	mov    0x81803c,%ecx
  80431e:	39 0a                	cmp    %ecx,(%edx)
  804320:	75 03                	jne    804325 <_ZL9fd2sockidi+0x36>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  804322:	8b 42 0c             	mov    0xc(%edx),%eax
}
  804325:	c9                   	leave  
  804326:	c3                   	ret    

00804327 <_Z6acceptiP8sockaddrPj>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804327:	55                   	push   %ebp
  804328:	89 e5                	mov    %esp,%ebp
  80432a:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80432d:	8b 45 08             	mov    0x8(%ebp),%eax
  804330:	e8 ba ff ff ff       	call   8042ef <_ZL9fd2sockidi>
  804335:	85 c0                	test   %eax,%eax
  804337:	78 1f                	js     804358 <_Z6acceptiP8sockaddrPj+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  804339:	8b 55 10             	mov    0x10(%ebp),%edx
  80433c:	89 54 24 08          	mov    %edx,0x8(%esp)
  804340:	8b 55 0c             	mov    0xc(%ebp),%edx
  804343:	89 54 24 04          	mov    %edx,0x4(%esp)
  804347:	89 04 24             	mov    %eax,(%esp)
  80434a:	e8 19 01 00 00       	call   804468 <_Z12nsipc_acceptiP8sockaddrPj>
  80434f:	85 c0                	test   %eax,%eax
  804351:	78 05                	js     804358 <_Z6acceptiP8sockaddrPj+0x31>
		return r;
	return alloc_sockfd(r);
  804353:	e8 1f ff ff ff       	call   804277 <_ZL12alloc_sockfdi>
}
  804358:	c9                   	leave  
  804359:	c3                   	ret    

0080435a <_Z4bindiP8sockaddrj>:

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80435a:	55                   	push   %ebp
  80435b:	89 e5                	mov    %esp,%ebp
  80435d:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  804360:	8b 45 08             	mov    0x8(%ebp),%eax
  804363:	e8 87 ff ff ff       	call   8042ef <_ZL9fd2sockidi>
  804368:	85 c0                	test   %eax,%eax
  80436a:	78 16                	js     804382 <_Z4bindiP8sockaddrj+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  80436c:	8b 55 10             	mov    0x10(%ebp),%edx
  80436f:	89 54 24 08          	mov    %edx,0x8(%esp)
  804373:	8b 55 0c             	mov    0xc(%ebp),%edx
  804376:	89 54 24 04          	mov    %edx,0x4(%esp)
  80437a:	89 04 24             	mov    %eax,(%esp)
  80437d:	e8 34 01 00 00       	call   8044b6 <_Z10nsipc_bindiP8sockaddrj>
}
  804382:	c9                   	leave  
  804383:	c3                   	ret    

00804384 <_Z8shutdownii>:

int
shutdown(int s, int how)
{
  804384:	55                   	push   %ebp
  804385:	89 e5                	mov    %esp,%ebp
  804387:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80438a:	8b 45 08             	mov    0x8(%ebp),%eax
  80438d:	e8 5d ff ff ff       	call   8042ef <_ZL9fd2sockidi>
  804392:	85 c0                	test   %eax,%eax
  804394:	78 0f                	js     8043a5 <_Z8shutdownii+0x21>
		return r;
	return nsipc_shutdown(r, how);
  804396:	8b 55 0c             	mov    0xc(%ebp),%edx
  804399:	89 54 24 04          	mov    %edx,0x4(%esp)
  80439d:	89 04 24             	mov    %eax,(%esp)
  8043a0:	e8 50 01 00 00       	call   8044f5 <_Z14nsipc_shutdownii>
}
  8043a5:	c9                   	leave  
  8043a6:	c3                   	ret    

008043a7 <_Z7connectiPK8sockaddrj>:
		return 0;
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  8043a7:	55                   	push   %ebp
  8043a8:	89 e5                	mov    %esp,%ebp
  8043aa:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8043ad:	8b 45 08             	mov    0x8(%ebp),%eax
  8043b0:	e8 3a ff ff ff       	call   8042ef <_ZL9fd2sockidi>
  8043b5:	85 c0                	test   %eax,%eax
  8043b7:	78 16                	js     8043cf <_Z7connectiPK8sockaddrj+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  8043b9:	8b 55 10             	mov    0x10(%ebp),%edx
  8043bc:	89 54 24 08          	mov    %edx,0x8(%esp)
  8043c0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8043c3:	89 54 24 04          	mov    %edx,0x4(%esp)
  8043c7:	89 04 24             	mov    %eax,(%esp)
  8043ca:	e8 62 01 00 00       	call   804531 <_Z13nsipc_connectiPK8sockaddrj>
}
  8043cf:	c9                   	leave  
  8043d0:	c3                   	ret    

008043d1 <_Z6listenii>:

int
listen(int s, int backlog)
{
  8043d1:	55                   	push   %ebp
  8043d2:	89 e5                	mov    %esp,%ebp
  8043d4:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8043d7:	8b 45 08             	mov    0x8(%ebp),%eax
  8043da:	e8 10 ff ff ff       	call   8042ef <_ZL9fd2sockidi>
  8043df:	85 c0                	test   %eax,%eax
  8043e1:	78 0f                	js     8043f2 <_Z6listenii+0x21>
		return r;
	return nsipc_listen(r, backlog);
  8043e3:	8b 55 0c             	mov    0xc(%ebp),%edx
  8043e6:	89 54 24 04          	mov    %edx,0x4(%esp)
  8043ea:	89 04 24             	mov    %eax,(%esp)
  8043ed:	e8 7e 01 00 00       	call   804570 <_Z12nsipc_listenii>
}
  8043f2:	c9                   	leave  
  8043f3:	c3                   	ret    

008043f4 <_Z6socketiii>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  8043f4:	55                   	push   %ebp
  8043f5:	89 e5                	mov    %esp,%ebp
  8043f7:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  8043fa:	8b 45 10             	mov    0x10(%ebp),%eax
  8043fd:	89 44 24 08          	mov    %eax,0x8(%esp)
  804401:	8b 45 0c             	mov    0xc(%ebp),%eax
  804404:	89 44 24 04          	mov    %eax,0x4(%esp)
  804408:	8b 45 08             	mov    0x8(%ebp),%eax
  80440b:	89 04 24             	mov    %eax,(%esp)
  80440e:	e8 72 02 00 00       	call   804685 <_Z12nsipc_socketiii>
  804413:	85 c0                	test   %eax,%eax
  804415:	78 05                	js     80441c <_Z6socketiii+0x28>
		return r;
	return alloc_sockfd(r);
  804417:	e8 5b fe ff ff       	call   804277 <_ZL12alloc_sockfdi>
}
  80441c:	c9                   	leave  
  80441d:	8d 76 00             	lea    0x0(%esi),%esi
  804420:	c3                   	ret    
  804421:	00 00                	add    %al,(%eax)
	...

00804424 <_ZL5nsipcj>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  804424:	55                   	push   %ebp
  804425:	89 e5                	mov    %esp,%ebp
  804427:	83 ec 18             	sub    $0x18,%esp
	static_assert(sizeof(nsipcbuf) == PGSIZE);

	if (debug)
		cprintf("[%08x] nsipc %d\n", thisenv->env_id, type);

	ipc_send(nsenv, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  80442a:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  804431:	00 
  804432:	c7 44 24 08 00 a0 81 	movl   $0x81a000,0x8(%esp)
  804439:	00 
  80443a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80443e:	c7 04 24 01 11 00 00 	movl   $0x1101,(%esp)
  804445:	e8 45 db ff ff       	call   801f8f <_Z8ipc_sendijPvi>
	return ipc_recv(NULL, NULL, NULL);
  80444a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804451:	00 
  804452:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804459:	00 
  80445a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804461:	e8 9a da ff ff       	call   801f00 <_Z8ipc_recvPiPvS_>
}
  804466:	c9                   	leave  
  804467:	c3                   	ret    

00804468 <_Z12nsipc_acceptiP8sockaddrPj>:

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804468:	55                   	push   %ebp
  804469:	89 e5                	mov    %esp,%ebp
  80446b:	53                   	push   %ebx
  80446c:	83 ec 14             	sub    $0x14,%esp
	int r;

	nsipcbuf.accept.req_s = s;
  80446f:	8b 45 08             	mov    0x8(%ebp),%eax
  804472:	a3 00 a0 81 00       	mov    %eax,0x81a000
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  804477:	b8 01 00 00 00       	mov    $0x1,%eax
  80447c:	e8 a3 ff ff ff       	call   804424 <_ZL5nsipcj>
  804481:	89 c3                	mov    %eax,%ebx
  804483:	85 c0                	test   %eax,%eax
  804485:	78 27                	js     8044ae <_Z12nsipc_acceptiP8sockaddrPj+0x46>
		memmove(addr, &nsipcbuf.acceptRet.ret_addr, nsipcbuf.acceptRet.ret_addrlen);
  804487:	a1 10 a0 81 00       	mov    0x81a010,%eax
  80448c:	89 44 24 08          	mov    %eax,0x8(%esp)
  804490:	c7 44 24 04 00 a0 81 	movl   $0x81a000,0x4(%esp)
  804497:	00 
  804498:	8b 45 0c             	mov    0xc(%ebp),%eax
  80449b:	89 04 24             	mov    %eax,(%esp)
  80449e:	e8 e9 cd ff ff       	call   80128c <memmove>
		*addrlen = nsipcbuf.acceptRet.ret_addrlen;
  8044a3:	8b 15 10 a0 81 00    	mov    0x81a010,%edx
  8044a9:	8b 45 10             	mov    0x10(%ebp),%eax
  8044ac:	89 10                	mov    %edx,(%eax)
	}
	return r;
}
  8044ae:	89 d8                	mov    %ebx,%eax
  8044b0:	83 c4 14             	add    $0x14,%esp
  8044b3:	5b                   	pop    %ebx
  8044b4:	5d                   	pop    %ebp
  8044b5:	c3                   	ret    

008044b6 <_Z10nsipc_bindiP8sockaddrj>:

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  8044b6:	55                   	push   %ebp
  8044b7:	89 e5                	mov    %esp,%ebp
  8044b9:	53                   	push   %ebx
  8044ba:	83 ec 14             	sub    $0x14,%esp
  8044bd:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  8044c0:	8b 45 08             	mov    0x8(%ebp),%eax
  8044c3:	a3 00 a0 81 00       	mov    %eax,0x81a000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  8044c8:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8044cc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8044cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8044d3:	c7 04 24 04 a0 81 00 	movl   $0x81a004,(%esp)
  8044da:	e8 ad cd ff ff       	call   80128c <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  8044df:	89 1d 14 a0 81 00    	mov    %ebx,0x81a014
	return nsipc(NSREQ_BIND);
  8044e5:	b8 02 00 00 00       	mov    $0x2,%eax
  8044ea:	e8 35 ff ff ff       	call   804424 <_ZL5nsipcj>
}
  8044ef:	83 c4 14             	add    $0x14,%esp
  8044f2:	5b                   	pop    %ebx
  8044f3:	5d                   	pop    %ebp
  8044f4:	c3                   	ret    

008044f5 <_Z14nsipc_shutdownii>:

int
nsipc_shutdown(int s, int how)
{
  8044f5:	55                   	push   %ebp
  8044f6:	89 e5                	mov    %esp,%ebp
  8044f8:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  8044fb:	8b 45 08             	mov    0x8(%ebp),%eax
  8044fe:	a3 00 a0 81 00       	mov    %eax,0x81a000
	nsipcbuf.shutdown.req_how = how;
  804503:	8b 45 0c             	mov    0xc(%ebp),%eax
  804506:	a3 04 a0 81 00       	mov    %eax,0x81a004
	return nsipc(NSREQ_SHUTDOWN);
  80450b:	b8 03 00 00 00       	mov    $0x3,%eax
  804510:	e8 0f ff ff ff       	call   804424 <_ZL5nsipcj>
}
  804515:	c9                   	leave  
  804516:	c3                   	ret    

00804517 <_Z11nsipc_closei>:

int
nsipc_close(int s)
{
  804517:	55                   	push   %ebp
  804518:	89 e5                	mov    %esp,%ebp
  80451a:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  80451d:	8b 45 08             	mov    0x8(%ebp),%eax
  804520:	a3 00 a0 81 00       	mov    %eax,0x81a000
	return nsipc(NSREQ_CLOSE);
  804525:	b8 04 00 00 00       	mov    $0x4,%eax
  80452a:	e8 f5 fe ff ff       	call   804424 <_ZL5nsipcj>
}
  80452f:	c9                   	leave  
  804530:	c3                   	ret    

00804531 <_Z13nsipc_connectiPK8sockaddrj>:

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804531:	55                   	push   %ebp
  804532:	89 e5                	mov    %esp,%ebp
  804534:	53                   	push   %ebx
  804535:	83 ec 14             	sub    $0x14,%esp
  804538:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  80453b:	8b 45 08             	mov    0x8(%ebp),%eax
  80453e:	a3 00 a0 81 00       	mov    %eax,0x81a000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  804543:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  804547:	8b 45 0c             	mov    0xc(%ebp),%eax
  80454a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80454e:	c7 04 24 04 a0 81 00 	movl   $0x81a004,(%esp)
  804555:	e8 32 cd ff ff       	call   80128c <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  80455a:	89 1d 14 a0 81 00    	mov    %ebx,0x81a014
	return nsipc(NSREQ_CONNECT);
  804560:	b8 05 00 00 00       	mov    $0x5,%eax
  804565:	e8 ba fe ff ff       	call   804424 <_ZL5nsipcj>
}
  80456a:	83 c4 14             	add    $0x14,%esp
  80456d:	5b                   	pop    %ebx
  80456e:	5d                   	pop    %ebp
  80456f:	c3                   	ret    

00804570 <_Z12nsipc_listenii>:

int
nsipc_listen(int s, int backlog)
{
  804570:	55                   	push   %ebp
  804571:	89 e5                	mov    %esp,%ebp
  804573:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  804576:	8b 45 08             	mov    0x8(%ebp),%eax
  804579:	a3 00 a0 81 00       	mov    %eax,0x81a000
	nsipcbuf.listen.req_backlog = backlog;
  80457e:	8b 45 0c             	mov    0xc(%ebp),%eax
  804581:	a3 04 a0 81 00       	mov    %eax,0x81a004
	return nsipc(NSREQ_LISTEN);
  804586:	b8 06 00 00 00       	mov    $0x6,%eax
  80458b:	e8 94 fe ff ff       	call   804424 <_ZL5nsipcj>
}
  804590:	c9                   	leave  
  804591:	c3                   	ret    

00804592 <_Z10nsipc_recviPvij>:

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  804592:	55                   	push   %ebp
  804593:	89 e5                	mov    %esp,%ebp
  804595:	56                   	push   %esi
  804596:	53                   	push   %ebx
  804597:	83 ec 10             	sub    $0x10,%esp
  80459a:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  80459d:	8b 45 08             	mov    0x8(%ebp),%eax
  8045a0:	a3 00 a0 81 00       	mov    %eax,0x81a000
	nsipcbuf.recv.req_len = len;
  8045a5:	89 35 04 a0 81 00    	mov    %esi,0x81a004
	nsipcbuf.recv.req_flags = flags;
  8045ab:	8b 45 14             	mov    0x14(%ebp),%eax
  8045ae:	a3 08 a0 81 00       	mov    %eax,0x81a008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  8045b3:	b8 07 00 00 00       	mov    $0x7,%eax
  8045b8:	e8 67 fe ff ff       	call   804424 <_ZL5nsipcj>
  8045bd:	89 c3                	mov    %eax,%ebx
  8045bf:	85 c0                	test   %eax,%eax
  8045c1:	78 46                	js     804609 <_Z10nsipc_recviPvij+0x77>
		assert(r < 1600 && r <= len);
  8045c3:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  8045c8:	7f 04                	jg     8045ce <_Z10nsipc_recviPvij+0x3c>
  8045ca:	39 f0                	cmp    %esi,%eax
  8045cc:	7e 24                	jle    8045f2 <_Z10nsipc_recviPvij+0x60>
  8045ce:	c7 44 24 0c 1f 50 81 	movl   $0x81501f,0xc(%esp)
  8045d5:	00 
  8045d6:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  8045dd:	00 
  8045de:	c7 44 24 04 5f 00 00 	movl   $0x5f,0x4(%esp)
  8045e5:	00 
  8045e6:	c7 04 24 34 50 81 00 	movl   $0x815034,(%esp)
  8045ed:	e8 c6 c3 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  8045f2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8045f6:	c7 44 24 04 00 a0 81 	movl   $0x81a000,0x4(%esp)
  8045fd:	00 
  8045fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  804601:	89 04 24             	mov    %eax,(%esp)
  804604:	e8 83 cc ff ff       	call   80128c <memmove>
	}

	return r;
}
  804609:	89 d8                	mov    %ebx,%eax
  80460b:	83 c4 10             	add    $0x10,%esp
  80460e:	5b                   	pop    %ebx
  80460f:	5e                   	pop    %esi
  804610:	5d                   	pop    %ebp
  804611:	c3                   	ret    

00804612 <_Z10nsipc_sendiPKvij>:

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  804612:	55                   	push   %ebp
  804613:	89 e5                	mov    %esp,%ebp
  804615:	53                   	push   %ebx
  804616:	83 ec 14             	sub    $0x14,%esp
  804619:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  80461c:	8b 45 08             	mov    0x8(%ebp),%eax
  80461f:	a3 00 a0 81 00       	mov    %eax,0x81a000
	assert(size < 1600);
  804624:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  80462a:	7e 24                	jle    804650 <_Z10nsipc_sendiPKvij+0x3e>
  80462c:	c7 44 24 0c 40 50 81 	movl   $0x815040,0xc(%esp)
  804633:	00 
  804634:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80463b:	00 
  80463c:	c7 44 24 04 6a 00 00 	movl   $0x6a,0x4(%esp)
  804643:	00 
  804644:	c7 04 24 34 50 81 00 	movl   $0x815034,(%esp)
  80464b:	e8 68 c3 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  804650:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  804654:	8b 45 0c             	mov    0xc(%ebp),%eax
  804657:	89 44 24 04          	mov    %eax,0x4(%esp)
  80465b:	c7 04 24 0c a0 81 00 	movl   $0x81a00c,(%esp)
  804662:	e8 25 cc ff ff       	call   80128c <memmove>
	nsipcbuf.send.req_size = size;
  804667:	89 1d 04 a0 81 00    	mov    %ebx,0x81a004
	nsipcbuf.send.req_flags = flags;
  80466d:	8b 45 14             	mov    0x14(%ebp),%eax
  804670:	a3 08 a0 81 00       	mov    %eax,0x81a008
	return nsipc(NSREQ_SEND);
  804675:	b8 08 00 00 00       	mov    $0x8,%eax
  80467a:	e8 a5 fd ff ff       	call   804424 <_ZL5nsipcj>
}
  80467f:	83 c4 14             	add    $0x14,%esp
  804682:	5b                   	pop    %ebx
  804683:	5d                   	pop    %ebp
  804684:	c3                   	ret    

00804685 <_Z12nsipc_socketiii>:

int
nsipc_socket(int domain, int type, int protocol)
{
  804685:	55                   	push   %ebp
  804686:	89 e5                	mov    %esp,%ebp
  804688:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  80468b:	8b 45 08             	mov    0x8(%ebp),%eax
  80468e:	a3 00 a0 81 00       	mov    %eax,0x81a000
	nsipcbuf.socket.req_type = type;
  804693:	8b 45 0c             	mov    0xc(%ebp),%eax
  804696:	a3 04 a0 81 00       	mov    %eax,0x81a004
	nsipcbuf.socket.req_protocol = protocol;
  80469b:	8b 45 10             	mov    0x10(%ebp),%eax
  80469e:	a3 08 a0 81 00       	mov    %eax,0x81a008
	return nsipc(NSREQ_SOCKET);
  8046a3:	b8 09 00 00 00       	mov    $0x9,%eax
  8046a8:	e8 77 fd ff ff       	call   804424 <_ZL5nsipcj>
}
  8046ad:	c9                   	leave  
  8046ae:	c3                   	ret    
	...

008046b0 <_Z4freePv>:
	return v;
}

void
free(void *v)
{
  8046b0:	55                   	push   %ebp
  8046b1:	89 e5                	mov    %esp,%ebp
  8046b3:	53                   	push   %ebx
  8046b4:	83 ec 14             	sub    $0x14,%esp
  8046b7:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  8046ba:	85 db                	test   %ebx,%ebx
  8046bc:	0f 84 ba 00 00 00    	je     80477c <_Z4freePv+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  8046c2:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  8046c8:	76 08                	jbe    8046d2 <_Z4freePv+0x22>
  8046ca:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  8046d0:	76 24                	jbe    8046f6 <_Z4freePv+0x46>
  8046d2:	c7 44 24 0c 4c 50 81 	movl   $0x81504c,0xc(%esp)
  8046d9:	00 
  8046da:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  8046e1:	00 
  8046e2:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  8046e9:	00 
  8046ea:	c7 04 24 7a 50 81 00 	movl   $0x81507a,(%esp)
  8046f1:	e8 c2 c2 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

	c = (uint8_t *)ROUNDDOWN(v, PGSIZE);
  8046f6:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  8046fc:	eb 4a                	jmp    804748 <_Z4freePv+0x98>
		sys_page_unmap(0, c);
  8046fe:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804702:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804709:	e8 7f cf ff ff       	call   80168d <_Z14sys_page_unmapiPv>
		c += PGSIZE;
  80470e:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  804714:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  80471a:	76 08                	jbe    804724 <_Z4freePv+0x74>
  80471c:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  804722:	76 24                	jbe    804748 <_Z4freePv+0x98>
  804724:	c7 44 24 0c 87 50 81 	movl   $0x815087,0xc(%esp)
  80472b:	00 
  80472c:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  804733:	00 
  804734:	c7 44 24 04 82 00 00 	movl   $0x82,0x4(%esp)
  80473b:	00 
  80473c:	c7 04 24 7a 50 81 00 	movl   $0x81507a,(%esp)
  804743:	e8 70 c2 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = (uint8_t *)ROUNDDOWN(v, PGSIZE);

	while (vpt[PGNUM(c)] & PTE_CONTINUED) {
  804748:	89 d8                	mov    %ebx,%eax
  80474a:	c1 e8 0c             	shr    $0xc,%eax
  80474d:	8b 04 85 00 00 80 ef 	mov    -0x10800000(,%eax,4),%eax
  804754:	f6 c4 04             	test   $0x4,%ah
  804757:	75 a5                	jne    8046fe <_Z4freePv+0x4e>
	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
	if (--(*ref) == 0)
  804759:	8b 83 fc 0f 00 00    	mov    0xffc(%ebx),%eax
  80475f:	83 e8 01             	sub    $0x1,%eax
  804762:	89 83 fc 0f 00 00    	mov    %eax,0xffc(%ebx)
  804768:	85 c0                	test   %eax,%eax
  80476a:	75 10                	jne    80477c <_Z4freePv+0xcc>
		sys_page_unmap(0, c);
  80476c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  804770:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804777:	e8 11 cf ff ff       	call   80168d <_Z14sys_page_unmapiPv>
}
  80477c:	83 c4 14             	add    $0x14,%esp
  80477f:	5b                   	pop    %ebx
  804780:	5d                   	pop    %ebp
  804781:	c3                   	ret    

00804782 <_Z6mallocj>:
	return 1;
}

void*
malloc(size_t n)
{
  804782:	55                   	push   %ebp
  804783:	89 e5                	mov    %esp,%ebp
  804785:	57                   	push   %edi
  804786:	56                   	push   %esi
  804787:	53                   	push   %ebx
  804788:	83 ec 2c             	sub    $0x2c,%esp
	int cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  80478b:	83 3d 00 b0 81 00 00 	cmpl   $0x0,0x81b000
  804792:	75 0a                	jne    80479e <_Z6mallocj+0x1c>
		mptr = mbegin;
  804794:	c7 05 00 b0 81 00 00 	movl   $0x8000000,0x81b000
  80479b:	00 00 08 

	n = ROUNDUP(n, 4);
  80479e:	8b 45 08             	mov    0x8(%ebp),%eax
  8047a1:	83 c0 03             	add    $0x3,%eax
  8047a4:	83 e0 fc             	and    $0xfffffffc,%eax
  8047a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	if (n >= MAXMALLOC)
  8047aa:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  8047af:	0f 87 65 01 00 00    	ja     80491a <_Z6mallocj+0x198>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  8047b5:	a1 00 b0 81 00       	mov    0x81b000,%eax
  8047ba:	a9 ff 0f 00 00       	test   $0xfff,%eax
  8047bf:	74 4d                	je     80480e <_Z6mallocj+0x8c>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  8047c1:	89 c1                	mov    %eax,%ecx
  8047c3:	c1 e9 0c             	shr    $0xc,%ecx
  8047c6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8047c9:	8d 54 18 03          	lea    0x3(%eax,%ebx,1),%edx
  8047cd:	c1 ea 0c             	shr    $0xc,%edx
  8047d0:	39 d1                	cmp    %edx,%ecx
  8047d2:	75 1e                	jne    8047f2 <_Z6mallocj+0x70>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  8047d4:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
  8047da:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  8047e0:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  8047e4:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8047e7:	89 15 00 b0 81 00    	mov    %edx,0x81b000
			return v;
  8047ed:	e9 2d 01 00 00       	jmp    80491f <_Z6mallocj+0x19d>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  8047f2:	89 04 24             	mov    %eax,(%esp)
  8047f5:	e8 b6 fe ff ff       	call   8046b0 <_Z4freePv>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  8047fa:	a1 00 b0 81 00       	mov    0x81b000,%eax
  8047ff:	05 00 10 00 00       	add    $0x1000,%eax
  804804:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  804809:	a3 00 b0 81 00       	mov    %eax,0x81b000
  80480e:	8b 15 00 b0 81 00    	mov    0x81b000,%edx
	return 1;
}

void*
malloc(size_t n)
{
  804814:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  80481b:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80481e:	83 c7 04             	add    $0x4,%edi
  804821:	eb 05                	jmp    804828 <_Z6mallocj+0xa6>
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
			mptr = mbegin;
  804823:	ba 00 00 00 08       	mov    $0x8000000,%edx
	 * runs of more than a page can't have ref counts so we
	 * flag the PTE entries instead.
	 */
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
  804828:	89 7d e0             	mov    %edi,-0x20(%ebp)
  80482b:	89 d3                	mov    %edx,%ebx
  80482d:	8d 34 17             	lea    (%edi,%edx,1),%esi
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804830:	39 f2                	cmp    %esi,%edx
  804832:	0f 83 b1 00 00 00    	jae    8048e9 <_Z6mallocj+0x167>
  804838:	89 d0                	mov    %edx,%eax
		if (va >= (uintptr_t) mend
  80483a:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  80483f:	77 2a                	ja     80486b <_Z6mallocj+0xe9>
  804841:	89 c1                	mov    %eax,%ecx
  804843:	c1 e9 16             	shr    $0x16,%ecx
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  804846:	8b 0c 8d 00 e0 bb ef 	mov    -0x10442000(,%ecx,4),%ecx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  80484d:	f6 c1 01             	test   $0x1,%cl
  804850:	0f 84 d1 00 00 00    	je     804927 <_Z6mallocj+0x1a5>
  804856:	89 c1                	mov    %eax,%ecx
  804858:	c1 e9 0c             	shr    $0xc,%ecx
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[PGNUM(va)] & PTE_P)))
  80485b:	8b 0c 8d 00 00 80 ef 	mov    -0x10800000(,%ecx,4),%ecx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  804862:	f6 c1 01             	test   $0x1,%cl
  804865:	0f 84 bc 00 00 00    	je     804927 <_Z6mallocj+0x1a5>
			return 0;
	return 1;
}

void*
malloc(size_t n)
  80486b:	8d 93 00 10 00 00    	lea    0x1000(%ebx),%edx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  804871:	81 fa 00 00 00 10    	cmp    $0x10000000,%edx
  804877:	75 af                	jne    804828 <_Z6mallocj+0xa6>
			mptr = mbegin;
			if (++nwrap == 2)
  804879:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
  80487d:	83 7d dc 02          	cmpl   $0x2,-0x24(%ebp)
  804881:	75 a0                	jne    804823 <_Z6mallocj+0xa1>
  804883:	c7 05 00 b0 81 00 00 	movl   $0x8000000,0x81b000
  80488a:	00 00 08 
				return 0;	/* out of address space */
  80488d:	b8 00 00 00 00       	mov    $0x0,%eax
  804892:	e9 88 00 00 00       	jmp    80491f <_Z6mallocj+0x19d>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  804897:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  80489d:	39 fe                	cmp    %edi,%esi
  80489f:	19 c0                	sbb    %eax,%eax
  8048a1:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  8048a6:	83 c8 07             	or     $0x7,%eax
  8048a9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8048ad:	89 d8                	mov    %ebx,%eax
  8048af:	03 05 00 b0 81 00    	add    0x81b000,%eax
  8048b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8048b9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8048c0:	e8 0b cd ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  8048c5:	85 c0                	test   %eax,%eax
  8048c7:	79 30                	jns    8048f9 <_Z6mallocj+0x177>
			for (; i >= 0; i -= PGSIZE)
				sys_page_unmap(0, mptr + i);
  8048c9:	89 d8                	mov    %ebx,%eax
  8048cb:	03 05 00 b0 81 00    	add    0x81b000,%eax
  8048d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8048d5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8048dc:	e8 ac cd ff ff       	call   80168d <_Z14sys_page_unmapiPv>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  8048e1:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  8048e7:	eb e0                	jmp    8048c9 <_Z6mallocj+0x147>
  8048e9:	89 15 00 b0 81 00    	mov    %edx,0x81b000

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  8048ef:	bb 00 00 00 00       	mov    $0x0,%ebx
  8048f4:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8048f7:	eb 02                	jmp    8048fb <_Z6mallocj+0x179>
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  8048f9:	89 f3                	mov    %esi,%ebx
  8048fb:	39 fb                	cmp    %edi,%ebx
  8048fd:	72 98                	jb     804897 <_Z6mallocj+0x115>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  8048ff:	a1 00 b0 81 00       	mov    0x81b000,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  804904:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  80490b:	00 
	v = mptr;
	mptr += n;
  80490c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80490f:	8d 14 10             	lea    (%eax,%edx,1),%edx
  804912:	89 15 00 b0 81 00    	mov    %edx,0x81b000
	return v;
  804918:	eb 05                	jmp    80491f <_Z6mallocj+0x19d>
		mptr = mbegin;

	n = ROUNDUP(n, 4);

	if (n >= MAXMALLOC)
		return 0;
  80491a:	b8 00 00 00 00       	mov    $0x0,%eax
	ref = (uint32_t*) (mptr + i - 4);
	*ref = 2;	/* reference for mptr, reference for returned block */
	v = mptr;
	mptr += n;
	return v;
}
  80491f:	83 c4 2c             	add    $0x2c,%esp
  804922:	5b                   	pop    %ebx
  804923:	5e                   	pop    %esi
  804924:	5f                   	pop    %edi
  804925:	5d                   	pop    %ebp
  804926:	c3                   	ret    
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  804927:	05 00 10 00 00       	add    $0x1000,%eax
  80492c:	39 f0                	cmp    %esi,%eax
  80492e:	0f 82 06 ff ff ff    	jb     80483a <_Z6mallocj+0xb8>
  804934:	89 15 00 b0 81 00    	mov    %edx,0x81b000
  80493a:	eb b3                	jmp    8048ef <_Z6mallocj+0x16d>
  80493c:	00 00                	add    %al,(%eax)
	...

00804940 <_ZL13devcons_closeP2Fd>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  804940:	55                   	push   %ebp
  804941:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  804943:	b8 00 00 00 00       	mov    $0x0,%eax
  804948:	5d                   	pop    %ebp
  804949:	c3                   	ret    

0080494a <_ZL12devcons_statP2FdP4Stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  80494a:	55                   	push   %ebp
  80494b:	89 e5                	mov    %esp,%ebp
  80494d:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<cons>");
  804950:	c7 44 24 04 9f 50 81 	movl   $0x81509f,0x4(%esp)
  804957:	00 
  804958:	8b 45 0c             	mov    0xc(%ebp),%eax
  80495b:	89 04 24             	mov    %eax,(%esp)
  80495e:	e8 87 c7 ff ff       	call   8010ea <_Z6strcpyPcPKc>
	return 0;
}
  804963:	b8 00 00 00 00       	mov    $0x0,%eax
  804968:	c9                   	leave  
  804969:	c3                   	ret    

0080496a <_ZL13devcons_writeP2FdPKvj>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  80496a:	55                   	push   %ebp
  80496b:	89 e5                	mov    %esp,%ebp
  80496d:	57                   	push   %edi
  80496e:	56                   	push   %esi
  80496f:	53                   	push   %ebx
  804970:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	size_t tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  804976:	bb 00 00 00 00       	mov    $0x0,%ebx
  80497b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80497f:	74 3e                	je     8049bf <_ZL13devcons_writeP2FdPKvj+0x55>
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  804981:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  804987:	8b 75 10             	mov    0x10(%ebp),%esi
  80498a:	29 de                	sub    %ebx,%esi
  80498c:	83 fe 7f             	cmp    $0x7f,%esi
  80498f:	b8 7f 00 00 00       	mov    $0x7f,%eax
  804994:	0f 47 f0             	cmova  %eax,%esi
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  804997:	89 74 24 08          	mov    %esi,0x8(%esp)
  80499b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80499e:	01 d8                	add    %ebx,%eax
  8049a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8049a4:	89 3c 24             	mov    %edi,(%esp)
  8049a7:	e8 e0 c8 ff ff       	call   80128c <memmove>
		sys_cputs(buf, m);
  8049ac:	89 74 24 04          	mov    %esi,0x4(%esp)
  8049b0:	89 3c 24             	mov    %edi,(%esp)
  8049b3:	e8 ec ca ff ff       	call   8014a4 <_Z9sys_cputsPKcj>
	size_t tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs,
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  8049b8:	01 f3                	add    %esi,%ebx
  8049ba:	39 5d 10             	cmp    %ebx,0x10(%ebp)
  8049bd:	77 c8                	ja     804987 <_ZL13devcons_writeP2FdPKvj+0x1d>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  8049bf:	89 d8                	mov    %ebx,%eax
  8049c1:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  8049c7:	5b                   	pop    %ebx
  8049c8:	5e                   	pop    %esi
  8049c9:	5f                   	pop    %edi
  8049ca:	5d                   	pop    %ebp
  8049cb:	c3                   	ret    

008049cc <_ZL12devcons_readP2FdPvj>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8049cc:	55                   	push   %ebp
  8049cd:	89 e5                	mov    %esp,%ebp
  8049cf:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
		return 0;
  8049d2:	b8 00 00 00 00       	mov    $0x0,%eax
static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
	int c;

	if (n == 0)
  8049d7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8049db:	75 07                	jne    8049e4 <_ZL12devcons_readP2FdPvj+0x18>
  8049dd:	eb 2a                	jmp    804a09 <_ZL12devcons_readP2FdPvj+0x3d>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8049df:	e8 b8 cb ff ff       	call   80159c <_Z9sys_yieldv>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8049e4:	e8 ee ca ff ff       	call   8014d7 <_Z9sys_cgetcv>
  8049e9:	85 c0                	test   %eax,%eax
  8049eb:	74 f2                	je     8049df <_ZL12devcons_readP2FdPvj+0x13>
  8049ed:	89 c2                	mov    %eax,%edx
		sys_yield();
	if (c < 0)
  8049ef:	85 c0                	test   %eax,%eax
  8049f1:	78 16                	js     804a09 <_ZL12devcons_readP2FdPvj+0x3d>
		return c;
	if (c == 0x04)	// ctl-d is eof
  8049f3:	83 f8 04             	cmp    $0x4,%eax
  8049f6:	74 0c                	je     804a04 <_ZL12devcons_readP2FdPvj+0x38>
		return 0;
	*(char*)vbuf = c;
  8049f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8049fb:	88 10                	mov    %dl,(%eax)
	return 1;
  8049fd:	b8 01 00 00 00       	mov    $0x1,%eax
  804a02:	eb 05                	jmp    804a09 <_ZL12devcons_readP2FdPvj+0x3d>
	while ((c = sys_cgetc()) == 0)
		sys_yield();
	if (c < 0)
		return c;
	if (c == 0x04)	// ctl-d is eof
		return 0;
  804a04:	b8 00 00 00 00       	mov    $0x0,%eax
	*(char*)vbuf = c;
	return 1;
}
  804a09:	c9                   	leave  
  804a0a:	c3                   	ret    

00804a0b <_Z8cputchari>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  804a0b:	55                   	push   %ebp
  804a0c:	89 e5                	mov    %esp,%ebp
  804a0e:	83 ec 28             	sub    $0x28,%esp
	char c = ch;
  804a11:	8b 45 08             	mov    0x8(%ebp),%eax
  804a14:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  804a17:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  804a1e:	00 
  804a1f:	8d 45 f7             	lea    -0x9(%ebp),%eax
  804a22:	89 04 24             	mov    %eax,(%esp)
  804a25:	e8 7a ca ff ff       	call   8014a4 <_Z9sys_cputsPKcj>
}
  804a2a:	c9                   	leave  
  804a2b:	c3                   	ret    

00804a2c <_Z7getcharv>:

int
getchar(void)
{
  804a2c:	55                   	push   %ebp
  804a2d:	89 e5                	mov    %esp,%ebp
  804a2f:	83 ec 28             	sub    $0x28,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  804a32:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  804a39:	00 
  804a3a:	8d 45 f7             	lea    -0x9(%ebp),%eax
  804a3d:	89 44 24 04          	mov    %eax,0x4(%esp)
  804a41:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804a48:	e8 e1 d9 ff ff       	call   80242e <_Z4readiPvj>
	if (r < 0)
  804a4d:	85 c0                	test   %eax,%eax
  804a4f:	78 0f                	js     804a60 <_Z7getcharv+0x34>
		return r;
	if (r < 1)
  804a51:	85 c0                	test   %eax,%eax
  804a53:	7e 06                	jle    804a5b <_Z7getcharv+0x2f>
		return -E_EOF;
	return c;
  804a55:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
  804a59:	eb 05                	jmp    804a60 <_Z7getcharv+0x34>
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
	if (r < 0)
		return r;
	if (r < 1)
		return -E_EOF;
  804a5b:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
	return c;
}
  804a60:	c9                   	leave  
  804a61:	c3                   	ret    

00804a62 <_Z6isconsi>:
	/* .dev_trunc = */	0
};

int
iscons(int fdnum)
{
  804a62:	55                   	push   %ebp
  804a63:	89 e5                	mov    %esp,%ebp
  804a65:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;
	if ((r = fd_lookup(fdnum, &fd, true)) < 0)
  804a68:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  804a6f:	00 
  804a70:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804a73:	89 44 24 04          	mov    %eax,0x4(%esp)
  804a77:	8b 45 08             	mov    0x8(%ebp),%eax
  804a7a:	89 04 24             	mov    %eax,(%esp)
  804a7d:	e8 ff d5 ff ff       	call   802081 <_Z9fd_lookupiPP2Fdb>
  804a82:	85 c0                	test   %eax,%eax
  804a84:	78 11                	js     804a97 <_Z6isconsi+0x35>
		return r;
	else
		return fd->fd_dev_id == devcons.dev_id;
  804a86:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804a89:	8b 15 58 80 81 00    	mov    0x818058,%edx
  804a8f:	39 10                	cmp    %edx,(%eax)
  804a91:	0f 94 c0             	sete   %al
  804a94:	0f b6 c0             	movzbl %al,%eax
}
  804a97:	c9                   	leave  
  804a98:	c3                   	ret    

00804a99 <_Z8openconsv>:

int
opencons(void)
{
  804a99:	55                   	push   %ebp
  804a9a:	89 e5                	mov    %esp,%ebp
  804a9c:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_find_unused(&fd)) < 0)
  804a9f:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804aa2:	89 04 24             	mov    %eax,(%esp)
  804aa5:	e8 8d d6 ff ff       	call   802137 <_Z14fd_find_unusedPP2Fd>
  804aaa:	85 c0                	test   %eax,%eax
  804aac:	78 3c                	js     804aea <_Z8openconsv+0x51>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  804aae:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  804ab5:	00 
  804ab6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804ab9:	89 44 24 04          	mov    %eax,0x4(%esp)
  804abd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804ac4:	e8 07 cb ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  804ac9:	85 c0                	test   %eax,%eax
  804acb:	78 1d                	js     804aea <_Z8openconsv+0x51>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  804acd:	8b 15 58 80 81 00    	mov    0x818058,%edx
  804ad3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804ad6:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  804ad8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  804adb:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  804ae2:	89 04 24             	mov    %eax,(%esp)
  804ae5:	e8 ea d5 ff ff       	call   8020d4 <_Z6fd2numP2Fd>
}
  804aea:	c9                   	leave  
  804aeb:	c3                   	ret    
  804aec:	00 00                	add    %al,(%eax)
	...

00804af0 <_pgfault_upcall>:
// The page fault handler function calls each user page fault handler in order.
// One of the page fault handlers should handle fault and call resume().
//
asmlinkage void
_pgfault_upcall(struct UTrapframe utf)
{
  804af0:	55                   	push   %ebp
  804af1:	89 e5                	mov    %esp,%ebp
  804af3:	56                   	push   %esi
  804af4:	53                   	push   %ebx
  804af5:	83 ec 20             	sub    $0x20,%esp
	int i;
	for (i = NUSER_HANDLERS - 1; i >= 0; --i)
  804af8:	bb 07 00 00 00       	mov    $0x7,%ebx
		if (user_handlers[i])
  804afd:	8b 04 9d 20 b0 81 00 	mov    0x81b020(,%ebx,4),%eax
  804b04:	85 c0                	test   %eax,%eax
  804b06:	74 08                	je     804b10 <_pgfault_upcall+0x20>
			user_handlers[i](&utf);
  804b08:	8d 55 08             	lea    0x8(%ebp),%edx
  804b0b:	89 14 24             	mov    %edx,(%esp)
  804b0e:	ff d0                	call   *%eax
//
asmlinkage void
_pgfault_upcall(struct UTrapframe utf)
{
	int i;
	for (i = NUSER_HANDLERS - 1; i >= 0; --i)
  804b10:	83 eb 01             	sub    $0x1,%ebx
  804b13:	83 fb ff             	cmp    $0xffffffff,%ebx
  804b16:	75 e5                	jne    804afd <_pgfault_upcall+0xd>
		if (user_handlers[i])
			user_handlers[i](&utf);

	panic("[%08x] unhandled page fault at va %08x from eip %08x\n",
  804b18:	8b 5d 38             	mov    0x38(%ebp),%ebx
  804b1b:	8b 75 08             	mov    0x8(%ebp),%esi
  804b1e:	e8 45 ca ff ff       	call   801568 <_Z12sys_getenvidv>
	      sys_getenvid(), utf.utf_fault_va, utf.utf_eip);
  804b23:	89 5c 24 14          	mov    %ebx,0x14(%esp)
  804b27:	89 74 24 10          	mov    %esi,0x10(%esp)
  804b2b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804b2f:	c7 44 24 08 ac 50 81 	movl   $0x8150ac,0x8(%esp)
  804b36:	00 
  804b37:	c7 44 24 04 34 00 00 	movl   $0x34,0x4(%esp)
  804b3e:	00 
  804b3f:	c7 04 24 2d 51 81 00 	movl   $0x81512d,(%esp)
  804b46:	e8 6d be ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

00804b4b <_Z19add_pgfault_handlerPFvP10UTrapframeE>:
// at UXSTACKTOP), and tell the kernel to call the
// _pgfault_upcall routine when a page fault occurs.
//
void
add_pgfault_handler(pgfault_handler_t handler)
{
  804b4b:	55                   	push   %ebp
  804b4c:	89 e5                	mov    %esp,%ebp
  804b4e:	56                   	push   %esi
  804b4f:	53                   	push   %ebx
  804b50:	83 ec 10             	sub    $0x10,%esp
  804b53:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
    envid_t envid = sys_getenvid();
  804b56:	e8 0d ca ff ff       	call   801568 <_Z12sys_getenvidv>
  804b5b:	89 c6                	mov    %eax,%esi
	if (!thisenv->env_pgfault_upcall) {
  804b5d:	a1 98 90 81 00       	mov    0x819098,%eax
  804b62:	8b 40 5c             	mov    0x5c(%eax),%eax
  804b65:	85 c0                	test   %eax,%eax
  804b67:	75 4c                	jne    804bb5 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x6a>
	    if(sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_W | PTE_U | PTE_P))
  804b69:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  804b70:	00 
  804b71:	c7 44 24 04 00 f0 ff 	movl   $0xeefff000,0x4(%esp)
  804b78:	ee 
  804b79:	89 34 24             	mov    %esi,(%esp)
  804b7c:	e8 4f ca ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
  804b81:	85 c0                	test   %eax,%eax
  804b83:	74 20                	je     804ba5 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x5a>
	        panic("[%08x] couldn't allocate UXSTACK\n", envid);
  804b85:	89 74 24 0c          	mov    %esi,0xc(%esp)
  804b89:	c7 44 24 08 e4 50 81 	movl   $0x8150e4,0x8(%esp)
  804b90:	00 
  804b91:	c7 44 24 04 1a 00 00 	movl   $0x1a,0x4(%esp)
  804b98:	00 
  804b99:	c7 04 24 2d 51 81 00 	movl   $0x81512d,(%esp)
  804ba0:	e8 13 be ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        sys_env_set_pgfault_upcall(envid, (void *)_pgfault_upcall);
  804ba5:	c7 44 24 04 f0 4a 80 	movl   $0x804af0,0x4(%esp)
  804bac:	00 
  804bad:	89 34 24             	mov    %esi,(%esp)
  804bb0:	e8 50 cc ff ff       	call   801805 <_Z26sys_env_set_pgfault_upcalliPv>
    }

	// Store handler pointer in our list of handlers.
	for (int i = 0; i < NUSER_HANDLERS; ++i)
		if (user_handlers[i] == handler || !user_handlers[i]) {
  804bb5:	a1 20 b0 81 00       	mov    0x81b020,%eax
  804bba:	39 d8                	cmp    %ebx,%eax
  804bbc:	74 1a                	je     804bd8 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x8d>
  804bbe:	85 c0                	test   %eax,%eax
  804bc0:	74 20                	je     804be2 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x97>
	        panic("[%08x] couldn't allocate UXSTACK\n", envid);
        sys_env_set_pgfault_upcall(envid, (void *)_pgfault_upcall);
    }

	// Store handler pointer in our list of handlers.
	for (int i = 0; i < NUSER_HANDLERS; ++i)
  804bc2:	b8 01 00 00 00       	mov    $0x1,%eax
		if (user_handlers[i] == handler || !user_handlers[i]) {
  804bc7:	8b 14 85 20 b0 81 00 	mov    0x81b020(,%eax,4),%edx
  804bce:	39 da                	cmp    %ebx,%edx
  804bd0:	74 15                	je     804be7 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x9c>
  804bd2:	85 d2                	test   %edx,%edx
  804bd4:	75 1f                	jne    804bf5 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0xaa>
  804bd6:	eb 0f                	jmp    804be7 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x9c>
	        panic("[%08x] couldn't allocate UXSTACK\n", envid);
        sys_env_set_pgfault_upcall(envid, (void *)_pgfault_upcall);
    }

	// Store handler pointer in our list of handlers.
	for (int i = 0; i < NUSER_HANDLERS; ++i)
  804bd8:	b8 00 00 00 00       	mov    $0x0,%eax
  804bdd:	8d 76 00             	lea    0x0(%esi),%esi
  804be0:	eb 05                	jmp    804be7 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x9c>
  804be2:	b8 00 00 00 00       	mov    $0x0,%eax
		if (user_handlers[i] == handler || !user_handlers[i]) {
			user_handlers[i] = handler;
  804be7:	89 1c 85 20 b0 81 00 	mov    %ebx,0x81b020(,%eax,4)
			return;
		}

	panic("[%08x] too many page fault handlers\n", envid);
}
  804bee:	83 c4 10             	add    $0x10,%esp
  804bf1:	5b                   	pop    %ebx
  804bf2:	5e                   	pop    %esi
  804bf3:	5d                   	pop    %ebp
  804bf4:	c3                   	ret    
	        panic("[%08x] couldn't allocate UXSTACK\n", envid);
        sys_env_set_pgfault_upcall(envid, (void *)_pgfault_upcall);
    }

	// Store handler pointer in our list of handlers.
	for (int i = 0; i < NUSER_HANDLERS; ++i)
  804bf5:	83 c0 01             	add    $0x1,%eax
  804bf8:	83 f8 08             	cmp    $0x8,%eax
  804bfb:	75 ca                	jne    804bc7 <_Z19add_pgfault_handlerPFvP10UTrapframeE+0x7c>
		if (user_handlers[i] == handler || !user_handlers[i]) {
			user_handlers[i] = handler;
			return;
		}

	panic("[%08x] too many page fault handlers\n", envid);
  804bfd:	89 74 24 0c          	mov    %esi,0xc(%esp)
  804c01:	c7 44 24 08 08 51 81 	movl   $0x815108,0x8(%esp)
  804c08:	00 
  804c09:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
  804c10:	00 
  804c11:	c7 04 24 2d 51 81 00 	movl   $0x81512d,(%esp)
  804c18:	e8 9b bd ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  804c1d:	00 00                	add    %al,(%eax)
	...

00804c20 <resume>:
.globl resume
resume:
	// This function is called from C, so uses the C calling convention.
	// The first word on the stack is the return address.
	// We have no plan to return so scrap it.
	addl $4, %esp
  804c20:	83 c4 04             	add    $0x4,%esp
	// Next on the stack is the function argument: a pointer to the UTF.
	// This instruction pops that pointer *into the stack pointer*,
	// which you will find useful.
	popl %esp
  804c23:	5c                   	pop    %esp
	//
	// Hint: Check out 'popal', 'popf', and 'popl'.

	// LAB 4: Your code here.

    addl $0x8, %esp
  804c24:	83 c4 08             	add    $0x8,%esp
    movl 40(%esp), %eax
  804c27:	8b 44 24 28          	mov    0x28(%esp),%eax
    movl 36(%esp), %ebx
  804c2b:	8b 5c 24 24          	mov    0x24(%esp),%ebx
    subl $4, %ebx
  804c2f:	83 eb 04             	sub    $0x4,%ebx
    movl %eax, (%ebx)
  804c32:	89 03                	mov    %eax,(%ebx)
    movl %ebx, 36(%esp)
  804c34:	89 5c 24 24          	mov    %ebx,0x24(%esp)
    popal
  804c38:	61                   	popa   
    popf
  804c39:	9d                   	popf   
    popl %esp
  804c3a:	5c                   	pop    %esp
    ret
  804c3b:	c3                   	ret    

00804c3c <spin>:

spin:	jmp spin
  804c3c:	eb fe                	jmp    804c3c <spin>
	...

00804c40 <_ZL10get_socketi>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  804c40:	55                   	push   %ebp
  804c41:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  804c43:	83 f8 1f             	cmp    $0x1f,%eax
  804c46:	76 11                	jbe    804c59 <_ZL10get_socketi+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  804c48:	c7 05 00 90 81 00 09 	movl   $0x9,0x819000
  804c4f:	00 00 00 
    return NULL;
  804c52:	b8 00 00 00 00       	mov    $0x0,%eax
  804c57:	eb 25                	jmp    804c7e <_ZL10get_socketi+0x3e>
  }

  sock = &sockets[s];

  if (!sock->conn) {
  804c59:	8d 14 80             	lea    (%eax,%eax,4),%edx
  804c5c:	83 3c 95 40 b0 81 00 	cmpl   $0x0,0x81b040(,%edx,4)
  804c63:	00 
  804c64:	74 09                	je     804c6f <_ZL10get_socketi+0x2f>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
    return NULL;
  }

  sock = &sockets[s];
  804c66:	8d 04 95 40 b0 81 00 	lea    0x81b040(,%edx,4),%eax
  804c6d:	eb 0f                	jmp    804c7e <_ZL10get_socketi+0x3e>

  if (!sock->conn) {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  804c6f:	c7 05 00 90 81 00 09 	movl   $0x9,0x819000
  804c76:	00 00 00 
    return NULL;
  804c79:	b8 00 00 00 00       	mov    $0x0,%eax
  }

  return sock;
}
  804c7e:	5d                   	pop    %ebp
  804c7f:	c3                   	ret    

00804c80 <_ZL24lwip_setsockopt_internalPv>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  804c80:	55                   	push   %ebp
  804c81:	89 e5                	mov    %esp,%ebp
  804c83:	53                   	push   %ebx
  804c84:	83 ec 14             	sub    $0x14,%esp
  804c87:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  804c8a:	85 c0                	test   %eax,%eax
  804c8c:	75 1c                	jne    804caa <_ZL24lwip_setsockopt_internalPv+0x2a>
  804c8e:	c7 44 24 08 3b 51 81 	movl   $0x81513b,0x8(%esp)
  804c95:	00 
  804c96:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  804c9d:	00 
  804c9e:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  804ca5:	e8 0e bd ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  804caa:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  804cac:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  804caf:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  804cb2:	8b 40 08             	mov    0x8(%eax),%eax
  804cb5:	83 f8 06             	cmp    $0x6,%eax
  804cb8:	0f 84 83 00 00 00    	je     804d41 <_ZL24lwip_setsockopt_internalPv+0xc1>
  804cbe:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  804cc3:	74 09                	je     804cce <_ZL24lwip_setsockopt_internalPv+0x4e>
  804cc5:	85 c0                	test   %eax,%eax
  804cc7:	74 56                	je     804d1f <_ZL24lwip_setsockopt_internalPv+0x9f>
  804cc9:	e9 ac 00 00 00       	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  804cce:	83 f9 20             	cmp    $0x20,%ecx
  804cd1:	74 11                	je     804ce4 <_ZL24lwip_setsockopt_internalPv+0x64>
  804cd3:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  804cd9:	74 29                	je     804d04 <_ZL24lwip_setsockopt_internalPv+0x84>
  804cdb:	83 f9 08             	cmp    $0x8,%ecx
  804cde:	0f 85 96 00 00 00    	jne    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  804ce4:	83 3b 00             	cmpl   $0x0,(%ebx)
  804ce7:	74 0e                	je     804cf7 <_ZL24lwip_setsockopt_internalPv+0x77>
        sock->conn->pcb.ip->so_options |= optname;
  804ce9:	8b 02                	mov    (%edx),%eax
  804ceb:	8b 40 08             	mov    0x8(%eax),%eax
  804cee:	66 09 48 08          	or     %cx,0x8(%eax)
  804cf2:	e9 83 00 00 00       	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  804cf7:	8b 02                	mov    (%edx),%eax
  804cf9:	8b 40 08             	mov    0x8(%eax),%eax
  804cfc:	f7 d1                	not    %ecx
  804cfe:	66 21 48 08          	and    %cx,0x8(%eax)
  804d02:	eb 76                	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  804d04:	83 3b 00             	cmpl   $0x0,(%ebx)
  804d07:	74 0b                	je     804d14 <_ZL24lwip_setsockopt_internalPv+0x94>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  804d09:	8b 02                	mov    (%edx),%eax
  804d0b:	8b 40 08             	mov    0x8(%eax),%eax
  804d0e:	80 48 10 01          	orb    $0x1,0x10(%eax)
  804d12:	eb 66                	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  804d14:	8b 02                	mov    (%edx),%eax
  804d16:	8b 40 08             	mov    0x8(%eax),%eax
  804d19:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  804d1d:	eb 5b                	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  804d1f:	83 f9 01             	cmp    $0x1,%ecx
  804d22:	74 11                	je     804d35 <_ZL24lwip_setsockopt_internalPv+0xb5>
  804d24:	83 f9 02             	cmp    $0x2,%ecx
  804d27:	75 51                	jne    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  804d29:	8b 02                	mov    (%edx),%eax
  804d2b:	8b 40 08             	mov    0x8(%eax),%eax
  804d2e:	8b 0b                	mov    (%ebx),%ecx
  804d30:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  804d33:	eb 45                	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  804d35:	8b 02                	mov    (%edx),%eax
  804d37:	8b 40 08             	mov    0x8(%eax),%eax
  804d3a:	8b 0b                	mov    (%ebx),%ecx
  804d3c:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
                  s, sock->conn->pcb.ip->tos));
      break;
  804d3f:	eb 39                	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  804d41:	83 f9 01             	cmp    $0x1,%ecx
  804d44:	74 0c                	je     804d52 <_ZL24lwip_setsockopt_internalPv+0xd2>
  804d46:	83 f9 02             	cmp    $0x2,%ecx
  804d49:	75 2f                	jne    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
  804d4b:	90                   	nop
  804d4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  804d50:	eb 1b                	jmp    804d6d <_ZL24lwip_setsockopt_internalPv+0xed>
    case TCP_NODELAY:
      if (*(int*)optval) {
  804d52:	83 3b 00             	cmpl   $0x0,(%ebx)
  804d55:	74 0b                	je     804d62 <_ZL24lwip_setsockopt_internalPv+0xe2>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  804d57:	8b 02                	mov    (%edx),%eax
  804d59:	8b 40 08             	mov    0x8(%eax),%eax
  804d5c:	80 48 20 40          	orb    $0x40,0x20(%eax)
  804d60:	eb 18                	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  804d62:	8b 02                	mov    (%edx),%eax
  804d64:	8b 40 08             	mov    0x8(%eax),%eax
  804d67:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  804d6b:	eb 0d                	jmp    804d7a <_ZL24lwip_setsockopt_internalPv+0xfa>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  804d6d:	8b 02                	mov    (%edx),%eax
  804d6f:	8b 40 08             	mov    0x8(%eax),%eax
  804d72:	8b 0b                	mov    (%ebx),%ecx
  804d74:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  804d7a:	8b 02                	mov    (%edx),%eax
  804d7c:	8b 40 10             	mov    0x10(%eax),%eax
  804d7f:	89 04 24             	mov    %eax,(%esp)
  804d82:	e8 18 a4 00 00       	call   80f19f <sys_sem_signal>
}
  804d87:	83 c4 14             	add    $0x14,%esp
  804d8a:	5b                   	pop    %ebx
  804d8b:	5d                   	pop    %ebp
  804d8c:	c3                   	ret    

00804d8d <_ZL24lwip_getsockopt_internalPv>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  804d8d:	55                   	push   %ebp
  804d8e:	89 e5                	mov    %esp,%ebp
  804d90:	53                   	push   %ebx
  804d91:	83 ec 14             	sub    $0x14,%esp
  804d94:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  804d97:	85 c0                	test   %eax,%eax
  804d99:	75 1c                	jne    804db7 <_ZL24lwip_getsockopt_internalPv+0x2a>
  804d9b:	c7 44 24 08 3b 51 81 	movl   $0x81513b,0x8(%esp)
  804da2:	00 
  804da3:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  804daa:	00 
  804dab:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  804db2:	e8 01 bc ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  804db7:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  804db9:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  804dbc:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  804dbf:	8b 40 08             	mov    0x8(%eax),%eax
  804dc2:	83 f8 06             	cmp    $0x6,%eax
  804dc5:	0f 84 0c 01 00 00    	je     804ed7 <_ZL24lwip_getsockopt_internalPv+0x14a>
  804dcb:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  804dd0:	74 0d                	je     804ddf <_ZL24lwip_getsockopt_internalPv+0x52>
  804dd2:	85 c0                	test   %eax,%eax
  804dd4:	0f 84 d9 00 00 00    	je     804eb3 <_ZL24lwip_getsockopt_internalPv+0x126>
  804dda:	e9 21 01 00 00       	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  804ddf:	83 f9 20             	cmp    $0x20,%ecx
  804de2:	74 38                	je     804e1c <_ZL24lwip_getsockopt_internalPv+0x8f>
  804de4:	83 f9 20             	cmp    $0x20,%ecx
  804de7:	7f 10                	jg     804df9 <_ZL24lwip_getsockopt_internalPv+0x6c>
  804de9:	83 f9 02             	cmp    $0x2,%ecx
  804dec:	74 2e                	je     804e1c <_ZL24lwip_getsockopt_internalPv+0x8f>
  804dee:	83 f9 08             	cmp    $0x8,%ecx
  804df1:	0f 85 09 01 00 00    	jne    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
  804df7:	eb 23                	jmp    804e1c <_ZL24lwip_getsockopt_internalPv+0x8f>
  804df9:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  804dff:	90                   	nop
  804e00:	74 2c                	je     804e2e <_ZL24lwip_getsockopt_internalPv+0xa1>
  804e02:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  804e08:	0f 84 92 00 00 00    	je     804ea0 <_ZL24lwip_getsockopt_internalPv+0x113>
  804e0e:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  804e14:	0f 85 e6 00 00 00    	jne    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
  804e1a:	eb 4f                	jmp    804e6b <_ZL24lwip_getsockopt_internalPv+0xde>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  804e1c:	8b 02                	mov    (%edx),%eax
  804e1e:	8b 40 08             	mov    0x8(%eax),%eax
  804e21:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  804e25:	21 c1                	and    %eax,%ecx
  804e27:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  804e29:	e9 d2 00 00 00       	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  804e2e:	8b 02                	mov    (%edx),%eax
  804e30:	8b 08                	mov    (%eax),%ecx
  804e32:	89 c8                	mov    %ecx,%eax
  804e34:	25 f0 00 00 00       	and    $0xf0,%eax
  804e39:	83 f8 20             	cmp    $0x20,%eax
  804e3c:	74 22                	je     804e60 <_ZL24lwip_getsockopt_internalPv+0xd3>
  804e3e:	83 f8 40             	cmp    $0x40,%eax
  804e41:	74 12                	je     804e55 <_ZL24lwip_getsockopt_internalPv+0xc8>
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
        break;
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  804e43:	83 f8 10             	cmp    $0x10,%eax
  804e46:	b8 01 00 00 00       	mov    $0x1,%eax
  804e4b:	0f 44 c8             	cmove  %eax,%ecx
  804e4e:	89 0b                	mov    %ecx,(%ebx)
  804e50:	e9 ab 00 00 00       	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
      break;

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  804e55:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  804e5b:	e9 a0 00 00 00       	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
        break;
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  804e60:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  804e66:	e9 95 00 00 00       	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  804e6b:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  804e6f:	75 21                	jne    804e92 <_ZL24lwip_getsockopt_internalPv+0x105>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  804e71:	8b 02                	mov    (%edx),%eax
  804e73:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  804e77:	f7 d9                	neg    %ecx
  804e79:	b8 05 00 00 00       	mov    $0x5,%eax
  804e7e:	83 f9 0e             	cmp    $0xe,%ecx
  804e81:	77 07                	ja     804e8a <_ZL24lwip_getsockopt_internalPv+0xfd>
  804e83:	8b 04 8d 00 52 81 00 	mov    0x815200(,%ecx,4),%eax
  804e8a:	89 42 10             	mov    %eax,0x10(%edx)
  804e8d:	a3 00 90 81 00       	mov    %eax,0x819000
      } 
      *(int *)optval = sock->err;
  804e92:	8b 42 10             	mov    0x10(%edx),%eax
  804e95:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  804e97:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  804e9e:	eb 60                	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  804ea0:	8b 02                	mov    (%edx),%eax
  804ea2:	8b 40 08             	mov    0x8(%eax),%eax
  804ea5:	f6 40 10 01          	testb  $0x1,0x10(%eax)
  804ea9:	0f 95 c0             	setne  %al
  804eac:	0f b6 c0             	movzbl %al,%eax
  804eaf:	89 03                	mov    %eax,(%ebx)
      break;
  804eb1:	eb 4d                	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  804eb3:	83 f9 01             	cmp    $0x1,%ecx
  804eb6:	74 12                	je     804eca <_ZL24lwip_getsockopt_internalPv+0x13d>
  804eb8:	83 f9 02             	cmp    $0x2,%ecx
  804ebb:	75 43                	jne    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  804ebd:	8b 02                	mov    (%edx),%eax
  804ebf:	8b 40 08             	mov    0x8(%eax),%eax
  804ec2:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  804ec6:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  804ec8:	eb 36                	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  804eca:	8b 02                	mov    (%edx),%eax
  804ecc:	8b 40 08             	mov    0x8(%eax),%eax
  804ecf:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  804ed3:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
                  s, *(int *)optval));
      break;
  804ed5:	eb 29                	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  804ed7:	83 f9 01             	cmp    $0x1,%ecx
  804eda:	74 07                	je     804ee3 <_ZL24lwip_getsockopt_internalPv+0x156>
  804edc:	83 f9 02             	cmp    $0x2,%ecx
  804edf:	75 1f                	jne    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
  804ee1:	eb 10                	jmp    804ef3 <_ZL24lwip_getsockopt_internalPv+0x166>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  804ee3:	8b 02                	mov    (%edx),%eax
  804ee5:	8b 40 08             	mov    0x8(%eax),%eax
  804ee8:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  804eec:	83 e0 40             	and    $0x40,%eax
  804eef:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  804ef1:	eb 0d                	jmp    804f00 <_ZL24lwip_getsockopt_internalPv+0x173>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  804ef3:	8b 02                	mov    (%edx),%eax
  804ef5:	8b 40 08             	mov    0x8(%eax),%eax
  804ef8:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  804efe:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  804f00:	8b 02                	mov    (%edx),%eax
  804f02:	8b 40 10             	mov    0x10(%eax),%eax
  804f05:	89 04 24             	mov    %eax,(%esp)
  804f08:	e8 92 a2 00 00       	call   80f19f <sys_sem_signal>
}
  804f0d:	83 c4 14             	add    $0x14,%esp
  804f10:	5b                   	pop    %ebx
  804f11:	5d                   	pop    %ebp
  804f12:	c3                   	ret    

00804f13 <_ZL12lwip_selscaniP6fd_setS0_S0_>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  804f13:	55                   	push   %ebp
  804f14:	89 e5                	mov    %esp,%ebp
  804f16:	57                   	push   %edi
  804f17:	56                   	push   %esi
  804f18:	53                   	push   %ebx
  804f19:	83 ec 4c             	sub    $0x4c,%esp
  804f1c:	89 45 d0             	mov    %eax,-0x30(%ebp)
  804f1f:	89 55 cc             	mov    %edx,-0x34(%ebp)
  804f22:	89 4d c8             	mov    %ecx,-0x38(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  804f25:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804f2c:	00 
  804f2d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804f34:	00 
  804f35:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804f38:	89 04 24             	mov    %eax,(%esp)
  804f3b:	e8 f1 c2 ff ff       	call   801231 <memset>
  FD_ZERO(&lwriteset);
  804f40:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804f47:	00 
  804f48:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804f4f:	00 
  804f50:	8d 45 e0             	lea    -0x20(%ebp),%eax
  804f53:	89 04 24             	mov    %eax,(%esp)
  804f56:	e8 d6 c2 ff ff       	call   801231 <memset>
  FD_ZERO(&lexceptset);
  804f5b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804f62:	00 
  804f63:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804f6a:	00 
  804f6b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  804f6e:	89 04 24             	mov    %eax,(%esp)
  804f71:	e8 bb c2 ff ff       	call   801231 <memset>
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  int i, nready = 0;
  804f76:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  804f7d:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  804f81:	0f 8e 8e 00 00 00    	jle    805015 <_ZL12lwip_selscaniP6fd_setS0_S0_+0x102>
  804f87:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (FD_ISSET(i, readset)) {
  804f8c:	8d 73 07             	lea    0x7(%ebx),%esi
  804f8f:	85 db                	test   %ebx,%ebx
  804f91:	0f 49 f3             	cmovns %ebx,%esi
  804f94:	c1 fe 03             	sar    $0x3,%esi
  804f97:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  804f9a:	89 df                	mov    %ebx,%edi
  804f9c:	83 e7 07             	and    $0x7,%edi
  804f9f:	8b 55 cc             	mov    -0x34(%ebp),%edx
  804fa2:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  804fa6:	0f a3 f8             	bt     %edi,%eax
  804fa9:	73 2c                	jae    804fd7 <_ZL12lwip_selscaniP6fd_setS0_S0_+0xc4>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  804fab:	89 d8                	mov    %ebx,%eax
  804fad:	e8 8e fc ff ff       	call   804c40 <_ZL10get_socketi>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  804fb2:	85 c0                	test   %eax,%eax
  804fb4:	74 21                	je     804fd7 <_ZL12lwip_selscaniP6fd_setS0_S0_+0xc4>
  804fb6:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  804fba:	75 07                	jne    804fc3 <_ZL12lwip_selscaniP6fd_setS0_S0_+0xb0>
  804fbc:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  804fc1:	74 14                	je     804fd7 <_ZL12lwip_selscaniP6fd_setS0_S0_+0xc4>
        FD_SET(i, &lreadset);
  804fc3:	b8 01 00 00 00       	mov    $0x1,%eax
  804fc8:	89 f9                	mov    %edi,%ecx
  804fca:	d3 e0                	shl    %cl,%eax
  804fcc:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  804fcf:	08 44 15 e4          	or     %al,-0x1c(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  804fd3:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  804fd7:	8b 4d c8             	mov    -0x38(%ebp),%ecx
  804fda:	0f b6 04 31          	movzbl (%ecx,%esi,1),%eax
  804fde:	0f a3 f8             	bt     %edi,%eax
  804fe1:	73 26                	jae    805009 <_ZL12lwip_selscaniP6fd_setS0_S0_+0xf6>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  804fe3:	89 d8                	mov    %ebx,%eax
  804fe5:	e8 56 fc ff ff       	call   804c40 <_ZL10get_socketi>
      if (p_sock && p_sock->sendevent) {
  804fea:	85 c0                	test   %eax,%eax
  804fec:	74 1b                	je     805009 <_ZL12lwip_selscaniP6fd_setS0_S0_+0xf6>
  804fee:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  804ff3:	74 14                	je     805009 <_ZL12lwip_selscaniP6fd_setS0_S0_+0xf6>
        FD_SET(i, &lwriteset);
  804ff5:	b8 01 00 00 00       	mov    $0x1,%eax
  804ffa:	89 f9                	mov    %edi,%ecx
  804ffc:	d3 e0                	shl    %cl,%eax
  804ffe:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  805001:	08 44 15 e0          	or     %al,-0x20(%ebp,%edx,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  805005:	83 45 c4 01          	addl   $0x1,-0x3c(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  805009:	83 c3 01             	add    $0x1,%ebx
  80500c:	39 5d d0             	cmp    %ebx,-0x30(%ebp)
  80500f:	0f 8f 77 ff ff ff    	jg     804f8c <_ZL12lwip_selscaniP6fd_setS0_S0_+0x79>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  805015:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805018:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  80501b:	89 01                	mov    %eax,(%ecx)
  *writeset = lwriteset;
  80501d:	8b 45 e0             	mov    -0x20(%ebp),%eax
  805020:	8b 55 c8             	mov    -0x38(%ebp),%edx
  805023:	89 02                	mov    %eax,(%edx)
  FD_ZERO(exceptset);
  805025:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80502c:	00 
  80502d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805034:	00 
  805035:	8b 45 08             	mov    0x8(%ebp),%eax
  805038:	89 04 24             	mov    %eax,(%esp)
  80503b:	e8 f1 c1 ff ff       	call   801231 <memset>
  
  return nready;
}
  805040:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  805043:	83 c4 4c             	add    $0x4c,%esp
  805046:	5b                   	pop    %ebx
  805047:	5e                   	pop    %esi
  805048:	5f                   	pop    %edi
  805049:	5d                   	pop    %ebp
  80504a:	c3                   	ret    

0080504b <_ZL16lwip_getaddrnameiP8sockaddrPjh>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  80504b:	55                   	push   %ebp
  80504c:	89 e5                	mov    %esp,%ebp
  80504e:	83 ec 58             	sub    $0x58,%esp
  805051:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805054:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805057:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80505a:	89 d7                	mov    %edx,%edi
  80505c:	89 ce                	mov    %ecx,%esi
  80505e:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  805062:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  805065:	e8 d6 fb ff ff       	call   804c40 <_ZL10get_socketi>
  80506a:	89 c3                	mov    %eax,%ebx
  if (!sock)
    return -1;
  80506c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  if (!sock)
  805071:	85 db                	test   %ebx,%ebx
  805073:	0f 84 8f 00 00 00    	je     805108 <_ZL16lwip_getaddrnameiP8sockaddrPjh+0xbd>
    return -1;

  memset(&sin, 0, sizeof(sin));
  805079:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  805080:	00 
  805081:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805088:	00 
  805089:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80508c:	89 04 24             	mov    %eax,(%esp)
  80508f:	e8 9d c1 ff ff       	call   801231 <memset>
  sin.sin_len = sizeof(sin);
  805094:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
  sin.sin_family = AF_INET;
  805098:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  80509c:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  8050a0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8050a4:	8d 45 d6             	lea    -0x2a(%ebp),%eax
  8050a7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8050ab:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8050ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  8050b2:	8b 03                	mov    (%ebx),%eax
  8050b4:	89 04 24             	mov    %eax,(%esp)
  8050b7:	e8 f5 b4 00 00       	call   8105b1 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  8050bc:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  8050c0:	89 04 24             	mov    %eax,(%esp)
  8050c3:	e8 f1 72 00 00       	call   80c3b9 <htons>
  8050c8:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  8050cc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8050cf:	89 45 d8             	mov    %eax,-0x28(%ebp)

  if (*namelen > sizeof(sin))
  8050d2:	83 3e 10             	cmpl   $0x10,(%esi)
  8050d5:	76 06                	jbe    8050dd <_ZL16lwip_getaddrnameiP8sockaddrPjh+0x92>
    *namelen = sizeof(sin);
  8050d7:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  8050dd:	8b 06                	mov    (%esi),%eax
  8050df:	89 44 24 08          	mov    %eax,0x8(%esp)
  8050e3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8050e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8050ea:	89 3c 24             	mov    %edi,(%esp)
  8050ed:	e8 15 c2 ff ff       	call   801307 <memcpy>
  sock_set_errno(sock, 0);
  8050f2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8050f9:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  805100:	00 00 00 
  return 0;
  805103:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805108:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80510b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80510e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805111:	89 ec                	mov    %ebp,%esp
  805113:	5d                   	pop    %ebp
  805114:	c3                   	ret    

00805115 <_ZL12alloc_socketP7netconn>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  805115:	55                   	push   %ebp
  805116:	89 e5                	mov    %esp,%ebp
  805118:	56                   	push   %esi
  805119:	53                   	push   %ebx
  80511a:	83 ec 10             	sub    $0x10,%esp
  80511d:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  80511f:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  805124:	89 04 24             	mov    %eax,(%esp)
  805127:	e8 8c 4a 00 00       	call   809bb8 <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  80512c:	83 3d 40 b0 81 00 00 	cmpl   $0x0,0x81b040
  805133:	74 11                	je     805146 <_ZL12alloc_socketP7netconn+0x31>
  805135:	b8 54 b0 81 00       	mov    $0x81b054,%eax

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  80513a:	bb 01 00 00 00       	mov    $0x1,%ebx
    if (!sockets[i].conn) {
  80513f:	83 38 00             	cmpl   $0x0,(%eax)
  805142:	75 64                	jne    8051a8 <_ZL12alloc_socketP7netconn+0x93>
  805144:	eb 05                	jmp    80514b <_ZL12alloc_socketP7netconn+0x36>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  805146:	bb 00 00 00 00       	mov    $0x0,%ebx
    if (!sockets[i].conn) {
      sockets[i].conn       = newconn;
  80514b:	8d 14 9d 00 00 00 00 	lea    0x0(,%ebx,4),%edx
  805152:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
  805155:	c1 e1 02             	shl    $0x2,%ecx
  805158:	89 b1 40 b0 81 00    	mov    %esi,0x81b040(%ecx)
      sockets[i].lastdata   = NULL;
  80515e:	c7 81 44 b0 81 00 00 	movl   $0x0,0x81b044(%ecx)
  805165:	00 00 00 
      sockets[i].lastoffset = 0;
  805168:	66 c7 81 48 b0 81 00 	movw   $0x0,0x81b048(%ecx)
  80516f:	00 00 
      sockets[i].rcvevent   = 0;
  805171:	66 c7 81 4a b0 81 00 	movw   $0x0,0x81b04a(%ecx)
  805178:	00 00 
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  80517a:	66 c7 81 4c b0 81 00 	movw   $0x1,0x81b04c(%ecx)
  805181:	01 00 
      sockets[i].flags      = 0;
  805183:	66 c7 81 4e b0 81 00 	movw   $0x0,0x81b04e(%ecx)
  80518a:	00 00 
      sockets[i].err        = 0;
  80518c:	01 da                	add    %ebx,%edx
  80518e:	c7 04 95 50 b0 81 00 	movl   $0x0,0x81b050(,%edx,4)
  805195:	00 00 00 00 
      sys_sem_signal(socksem);
  805199:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  80519e:	89 04 24             	mov    %eax,(%esp)
  8051a1:	e8 f9 9f 00 00       	call   80f19f <sys_sem_signal>
      return i;
  8051a6:	eb 1d                	jmp    8051c5 <_ZL12alloc_socketP7netconn+0xb0>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  8051a8:	83 c3 01             	add    $0x1,%ebx
  8051ab:	83 c0 14             	add    $0x14,%eax
  8051ae:	83 fb 20             	cmp    $0x20,%ebx
  8051b1:	75 8c                	jne    80513f <_ZL12alloc_socketP7netconn+0x2a>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  8051b3:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  8051b8:	89 04 24             	mov    %eax,(%esp)
  8051bb:	e8 df 9f 00 00       	call   80f19f <sys_sem_signal>
  return -1;
  8051c0:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}
  8051c5:	89 d8                	mov    %ebx,%eax
  8051c7:	83 c4 10             	add    $0x10,%esp
  8051ca:	5b                   	pop    %ebx
  8051cb:	5e                   	pop    %esi
  8051cc:	5d                   	pop    %ebp
  8051cd:	c3                   	ret    

008051ce <_ZL14event_callbackP7netconn11netconn_evtt>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  8051ce:	55                   	push   %ebp
  8051cf:	89 e5                	mov    %esp,%ebp
  8051d1:	57                   	push   %edi
  8051d2:	56                   	push   %esi
  8051d3:	53                   	push   %ebx
  8051d4:	83 ec 2c             	sub    $0x2c,%esp
  8051d7:	8b 75 08             	mov    0x8(%ebp),%esi
  8051da:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  8051dd:	85 f6                	test   %esi,%esi
  8051df:	0f 84 7b 01 00 00    	je     805360 <_ZL14event_callbackP7netconn11netconn_evtt+0x192>
    s = conn->socket;
  8051e5:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  8051e8:	85 db                	test   %ebx,%ebx
  8051ea:	79 3d                	jns    805229 <_ZL14event_callbackP7netconn11netconn_evtt+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  8051ec:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  8051f1:	89 04 24             	mov    %eax,(%esp)
  8051f4:	e8 bf 49 00 00       	call   809bb8 <sys_sem_wait>
      if (conn->socket < 0) {
  8051f9:	8b 46 1c             	mov    0x1c(%esi),%eax
  8051fc:	85 c0                	test   %eax,%eax
  8051fe:	79 1c                	jns    80521c <_ZL14event_callbackP7netconn11netconn_evtt+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  805200:	85 ff                	test   %edi,%edi
  805202:	75 06                	jne    80520a <_ZL14event_callbackP7netconn11netconn_evtt+0x3c>
          conn->socket--;
  805204:	83 e8 01             	sub    $0x1,%eax
  805207:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  80520a:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  80520f:	89 04 24             	mov    %eax,(%esp)
  805212:	e8 88 9f 00 00       	call   80f19f <sys_sem_signal>
        return;
  805217:	e9 44 01 00 00       	jmp    805360 <_ZL14event_callbackP7netconn11netconn_evtt+0x192>
      }
      sys_sem_signal(socksem);
  80521c:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  805221:	89 04 24             	mov    %eax,(%esp)
  805224:	e8 76 9f 00 00       	call   80f19f <sys_sem_signal>
    }

    sock = get_socket(s);
  805229:	89 d8                	mov    %ebx,%eax
  80522b:	e8 10 fa ff ff       	call   804c40 <_ZL10get_socketi>
  805230:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  805233:	85 c0                	test   %eax,%eax
  805235:	0f 84 25 01 00 00    	je     805360 <_ZL14event_callbackP7netconn11netconn_evtt+0x192>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  80523b:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  805240:	89 04 24             	mov    %eax,(%esp)
  805243:	e8 70 49 00 00       	call   809bb8 <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  805248:	83 ff 01             	cmp    $0x1,%edi
  80524b:	74 26                	je     805273 <_ZL14event_callbackP7netconn11netconn_evtt+0xa5>
  80524d:	83 ff 01             	cmp    $0x1,%edi
  805250:	7f 06                	jg     805258 <_ZL14event_callbackP7netconn11netconn_evtt+0x8a>
  805252:	85 ff                	test   %edi,%edi
  805254:	74 13                	je     805269 <_ZL14event_callbackP7netconn11netconn_evtt+0x9b>
  805256:	eb 3b                	jmp    805293 <_ZL14event_callbackP7netconn11netconn_evtt+0xc5>
  805258:	83 ff 02             	cmp    $0x2,%edi
  80525b:	90                   	nop
  80525c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  805260:	74 1b                	je     80527d <_ZL14event_callbackP7netconn11netconn_evtt+0xaf>
  805262:	83 ff 03             	cmp    $0x3,%edi
  805265:	75 2c                	jne    805293 <_ZL14event_callbackP7netconn11netconn_evtt+0xc5>
  805267:	eb 1f                	jmp    805288 <_ZL14event_callbackP7netconn11netconn_evtt+0xba>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  805269:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80526c:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  805271:	eb 3c                	jmp    8052af <_ZL14event_callbackP7netconn11netconn_evtt+0xe1>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  805273:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805276:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  80527b:	eb 32                	jmp    8052af <_ZL14event_callbackP7netconn11netconn_evtt+0xe1>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  80527d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805280:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  805286:	eb 27                	jmp    8052af <_ZL14event_callbackP7netconn11netconn_evtt+0xe1>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  805288:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80528b:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  805291:	eb 1c                	jmp    8052af <_ZL14event_callbackP7netconn11netconn_evtt+0xe1>
    default:
      LWIP_ASSERT("unknown event", 0);
  805293:	c7 44 24 08 5e 51 81 	movl   $0x81515e,0x8(%esp)
  80529a:	00 
  80529b:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  8052a2:	00 
  8052a3:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  8052aa:	e8 09 b7 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      break;
  }
  sys_sem_signal(selectsem);
  8052af:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  8052b4:	89 04 24             	mov    %eax,(%esp)
  8052b7:	e8 e3 9e 00 00       	call   80f19f <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8052bc:	8d 73 07             	lea    0x7(%ebx),%esi
  8052bf:	85 db                	test   %ebx,%ebx
  8052c1:	0f 49 f3             	cmovns %ebx,%esi
  8052c4:	c1 fe 03             	sar    $0x3,%esi
  8052c7:	89 d9                	mov    %ebx,%ecx
  8052c9:	83 e1 07             	and    $0x7,%ecx
  8052cc:	b8 01 00 00 00       	mov    $0x1,%eax
  8052d1:	89 c7                	mov    %eax,%edi
  8052d3:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  8052d5:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  8052da:	89 04 24             	mov    %eax,(%esp)
  8052dd:	e8 d6 48 00 00       	call   809bb8 <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  8052e2:	8b 1d c4 b2 81 00    	mov    0x81b2c4,%ebx
  8052e8:	85 db                	test   %ebx,%ebx
  8052ea:	74 67                	je     805353 <_ZL14event_callbackP7netconn11netconn_evtt+0x185>
      if (scb->sem_signalled == 0) {
  8052ec:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  8052f0:	75 32                	jne    805324 <_ZL14event_callbackP7netconn11netconn_evtt+0x156>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8052f2:	8b 43 04             	mov    0x4(%ebx),%eax
  8052f5:	85 c0                	test   %eax,%eax
  8052f7:	74 12                	je     80530b <_ZL14event_callbackP7netconn11netconn_evtt+0x13d>
  8052f9:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  8052fd:	85 f8                	test   %edi,%eax
  8052ff:	74 0a                	je     80530b <_ZL14event_callbackP7netconn11netconn_evtt+0x13d>
          if (sock->rcvevent)
  805301:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  805304:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  805309:	75 21                	jne    80532c <_ZL14event_callbackP7netconn11netconn_evtt+0x15e>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  80530b:	8b 43 08             	mov    0x8(%ebx),%eax
  80530e:	85 c0                	test   %eax,%eax
  805310:	74 12                	je     805324 <_ZL14event_callbackP7netconn11netconn_evtt+0x156>
  805312:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  805316:	85 f8                	test   %edi,%eax
  805318:	74 0a                	je     805324 <_ZL14event_callbackP7netconn11netconn_evtt+0x156>
          if (sock->sendevent)
  80531a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80531d:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  805322:	75 08                	jne    80532c <_ZL14event_callbackP7netconn11netconn_evtt+0x15e>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  805324:	8b 1b                	mov    (%ebx),%ebx
  805326:	85 db                	test   %ebx,%ebx
  805328:	75 c2                	jne    8052ec <_ZL14event_callbackP7netconn11netconn_evtt+0x11e>
  80532a:	eb 27                	jmp    805353 <_ZL14event_callbackP7netconn11netconn_evtt+0x185>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  80532c:	85 db                	test   %ebx,%ebx
  80532e:	66 90                	xchg   %ax,%ax
  805330:	74 21                	je     805353 <_ZL14event_callbackP7netconn11netconn_evtt+0x185>
      scb->sem_signalled = 1;
  805332:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  805339:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  80533e:	89 04 24             	mov    %eax,(%esp)
  805341:	e8 59 9e 00 00       	call   80f19f <sys_sem_signal>
      sys_sem_signal(scb->sem);
  805346:	8b 43 14             	mov    0x14(%ebx),%eax
  805349:	89 04 24             	mov    %eax,(%esp)
  80534c:	e8 4e 9e 00 00       	call   80f19f <sys_sem_signal>
     but to avoid a deadlock situation by releasing socksem before
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
  805351:	eb 82                	jmp    8052d5 <_ZL14event_callbackP7netconn11netconn_evtt+0x107>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  805353:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  805358:	89 04 24             	mov    %eax,(%esp)
  80535b:	e8 3f 9e 00 00       	call   80f19f <sys_sem_signal>
      break;
    }
  }
}
  805360:	83 c4 2c             	add    $0x2c,%esp
  805363:	5b                   	pop    %ebx
  805364:	5e                   	pop    %esi
  805365:	5f                   	pop    %edi
  805366:	5d                   	pop    %ebp
  805367:	c3                   	ret    

00805368 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  805368:	55                   	push   %ebp
  805369:	89 e5                	mov    %esp,%ebp
  80536b:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  80536e:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  805375:	e8 64 9a 00 00       	call   80edde <sys_sem_new>
  80537a:	a3 c8 b2 81 00       	mov    %eax,0x81b2c8
  selectsem = sys_sem_new(1);
  80537f:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  805386:	e8 53 9a 00 00       	call   80edde <sys_sem_new>
  80538b:	a3 c0 b2 81 00       	mov    %eax,0x81b2c0
}
  805390:	c9                   	leave  
  805391:	c3                   	ret    

00805392 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  805392:	55                   	push   %ebp
  805393:	89 e5                	mov    %esp,%ebp
  805395:	57                   	push   %edi
  805396:	56                   	push   %esi
  805397:	53                   	push   %ebx
  805398:	83 ec 4c             	sub    $0x4c,%esp
  80539b:	8b 75 10             	mov    0x10(%ebp),%esi
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  80539e:	8b 45 08             	mov    0x8(%ebp),%eax
  8053a1:	e8 9a f8 ff ff       	call   804c40 <_ZL10get_socketi>
  8053a6:	89 c7                	mov    %eax,%edi
  if (!sock)
  8053a8:	85 c0                	test   %eax,%eax
  8053aa:	0f 84 7e 01 00 00    	je     80552e <lwip_accept+0x19c>
    return -1;

  newconn = netconn_accept(sock->conn);
  8053b0:	8b 00                	mov    (%eax),%eax
  8053b2:	89 04 24             	mov    %eax,(%esp)
  8053b5:	e8 d3 b3 00 00       	call   81078d <netconn_accept>
  8053ba:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  8053bc:	85 c0                	test   %eax,%eax
  8053be:	75 2b                	jne    8053eb <lwip_accept+0x59>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  8053c0:	8b 07                	mov    (%edi),%eax
  8053c2:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  8053c6:	f7 da                	neg    %edx
  8053c8:	b8 05 00 00 00       	mov    $0x5,%eax
  8053cd:	83 fa 0e             	cmp    $0xe,%edx
  8053d0:	77 07                	ja     8053d9 <lwip_accept+0x47>
  8053d2:	8b 04 95 00 52 81 00 	mov    0x815200(,%edx,4),%eax
  8053d9:	89 47 10             	mov    %eax,0x10(%edi)
  8053dc:	a3 00 90 81 00       	mov    %eax,0x819000
    return -1;
  8053e1:	be ff ff ff ff       	mov    $0xffffffff,%esi
  8053e6:	e9 48 01 00 00       	jmp    805533 <lwip_accept+0x1a1>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  8053eb:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8053f2:	00 
  8053f3:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  8053f6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8053fa:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8053fd:	89 44 24 04          	mov    %eax,0x4(%esp)
  805401:	89 1c 24             	mov    %ebx,(%esp)
  805404:	e8 a8 b1 00 00       	call   8105b1 <netconn_getaddr>
  805409:	88 45 c7             	mov    %al,-0x39(%ebp)
  if (err != ERR_OK) {
  80540c:	84 c0                	test   %al,%al
  80540e:	74 31                	je     805441 <lwip_accept+0xaf>
    netconn_delete(newconn);
  805410:	89 1c 24             	mov    %ebx,(%esp)
  805413:	e8 2f b1 00 00       	call   810547 <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  805418:	0f be 55 c7          	movsbl -0x39(%ebp),%edx
  80541c:	f7 da                	neg    %edx
  80541e:	b8 05 00 00 00       	mov    $0x5,%eax
  805423:	83 fa 0e             	cmp    $0xe,%edx
  805426:	77 07                	ja     80542f <lwip_accept+0x9d>
  805428:	8b 04 95 00 52 81 00 	mov    0x815200(,%edx,4),%eax
  80542f:	89 47 10             	mov    %eax,0x10(%edi)
  805432:	a3 00 90 81 00       	mov    %eax,0x819000
    return -1;
  805437:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80543c:	e9 f2 00 00 00       	jmp    805533 <lwip_accept+0x1a1>
  }

  memset(&sin, 0, sizeof(sin));
  805441:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  805448:	00 
  805449:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805450:	00 
  805451:	8d 45 d0             	lea    -0x30(%ebp),%eax
  805454:	89 04 24             	mov    %eax,(%esp)
  805457:	e8 d5 bd ff ff       	call   801231 <memset>
  sin.sin_len = sizeof(sin);
  80545c:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  805460:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  805464:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  805468:	89 04 24             	mov    %eax,(%esp)
  80546b:	e8 49 6f 00 00       	call   80c3b9 <htons>
  805470:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  805474:	8b 45 e0             	mov    -0x20(%ebp),%eax
  805477:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  80547a:	83 3e 10             	cmpl   $0x10,(%esi)
  80547d:	76 06                	jbe    805485 <lwip_accept+0xf3>
    *addrlen = sizeof(sin);
  80547f:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(addr, &sin, *addrlen);
  805485:	8b 06                	mov    (%esi),%eax
  805487:	89 44 24 08          	mov    %eax,0x8(%esp)
  80548b:	8d 45 d0             	lea    -0x30(%ebp),%eax
  80548e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805492:	8b 45 0c             	mov    0xc(%ebp),%eax
  805495:	89 04 24             	mov    %eax,(%esp)
  805498:	e8 6a be ff ff       	call   801307 <memcpy>

  newsock = alloc_socket(newconn);
  80549d:	89 d8                	mov    %ebx,%eax
  80549f:	e8 71 fc ff ff       	call   805115 <_ZL12alloc_socketP7netconn>
  8054a4:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  8054a6:	83 f8 ff             	cmp    $0xffffffff,%eax
  8054a9:	75 1b                	jne    8054c6 <lwip_accept+0x134>
    netconn_delete(newconn);
  8054ab:	89 1c 24             	mov    %ebx,(%esp)
  8054ae:	e8 94 b0 00 00       	call   810547 <netconn_delete>
    sock_set_errno(sock, ENFILE);
  8054b3:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  8054ba:	c7 05 00 90 81 00 17 	movl   $0x17,0x819000
  8054c1:	00 00 00 
    return -1;
  8054c4:	eb 6d                	jmp    805533 <lwip_accept+0x1a1>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  8054c6:	83 f8 1f             	cmp    $0x1f,%eax
  8054c9:	76 1c                	jbe    8054e7 <lwip_accept+0x155>
  8054cb:	c7 44 24 08 6c 51 81 	movl   $0x81516c,0x8(%esp)
  8054d2:	00 
  8054d3:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  8054da:	00 
  8054db:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  8054e2:	e8 d1 b4 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  newconn->callback = event_callback;
  8054e7:	c7 43 2c ce 51 80 00 	movl   $0x8051ce,0x2c(%ebx)
  nsock = &sockets[newsock];
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);

  sys_sem_wait(socksem);
  8054ee:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  8054f3:	89 04 24             	mov    %eax,(%esp)
  8054f6:	e8 bd 46 00 00       	call   809bb8 <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  8054fb:	8d 04 b6             	lea    (%esi,%esi,4),%eax
  8054fe:	8b 53 1c             	mov    0x1c(%ebx),%edx
  805501:	f7 d2                	not    %edx
  805503:	66 01 14 85 4a b0 81 	add    %dx,0x81b04a(,%eax,4)
  80550a:	00 
  newconn->socket = newsock;
  80550b:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  80550e:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  805513:	89 04 24             	mov    %eax,(%esp)
  805516:	e8 84 9c 00 00       	call   80f19f <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  80551b:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  805522:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  805529:	00 00 00 
  return newsock;
  80552c:	eb 05                	jmp    805533 <lwip_accept+0x1a1>
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  if (!sock)
    return -1;
  80552e:	be ff ff ff ff       	mov    $0xffffffff,%esi
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  return newsock;
}
  805533:	89 f0                	mov    %esi,%eax
  805535:	83 c4 4c             	add    $0x4c,%esp
  805538:	5b                   	pop    %ebx
  805539:	5e                   	pop    %esi
  80553a:	5f                   	pop    %edi
  80553b:	5d                   	pop    %ebp
  80553c:	c3                   	ret    

0080553d <lwip_bind>:

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  80553d:	55                   	push   %ebp
  80553e:	89 e5                	mov    %esp,%ebp
  805540:	56                   	push   %esi
  805541:	53                   	push   %ebx
  805542:	83 ec 20             	sub    $0x20,%esp
  805545:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  805548:	8b 45 08             	mov    0x8(%ebp),%eax
  80554b:	e8 f0 f6 ff ff       	call   804c40 <_ZL10get_socketi>
  805550:	89 c3                	mov    %eax,%ebx
  if (!sock)
  805552:	85 c0                	test   %eax,%eax
  805554:	0f 84 94 00 00 00    	je     8055ee <lwip_bind+0xb1>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  80555a:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  80555e:	75 06                	jne    805566 <lwip_bind+0x29>
  805560:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  805564:	74 1c                	je     805582 <lwip_bind+0x45>
  805566:	c7 44 24 08 81 51 81 	movl   $0x815181,0x8(%esp)
  80556d:	00 
  80556e:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  805575:	00 
  805576:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  80557d:	e8 36 b4 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  805582:	8b 46 04             	mov    0x4(%esi),%eax
  805585:	89 45 f4             	mov    %eax,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  805588:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  80558c:	89 04 24             	mov    %eax,(%esp)
  80558f:	e8 32 6e 00 00       	call   80c3c6 <ntohs>
  805594:	0f b7 c0             	movzwl %ax,%eax
  805597:	89 44 24 08          	mov    %eax,0x8(%esp)
  80559b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80559e:	89 44 24 04          	mov    %eax,0x4(%esp)
  8055a2:	8b 03                	mov    (%ebx),%eax
  8055a4:	89 04 24             	mov    %eax,(%esp)
  8055a7:	e8 a1 b0 00 00       	call   81064d <netconn_bind>

  if (err != ERR_OK) {
  8055ac:	84 c0                	test   %al,%al
  8055ae:	74 26                	je     8055d6 <lwip_bind+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8055b0:	0f be c0             	movsbl %al,%eax
  8055b3:	f7 d8                	neg    %eax
  8055b5:	ba 05 00 00 00       	mov    $0x5,%edx
  8055ba:	83 f8 0e             	cmp    $0xe,%eax
  8055bd:	77 07                	ja     8055c6 <lwip_bind+0x89>
  8055bf:	8b 14 85 00 52 81 00 	mov    0x815200(,%eax,4),%edx
  8055c6:	89 53 10             	mov    %edx,0x10(%ebx)
  8055c9:	89 15 00 90 81 00    	mov    %edx,0x819000
    return -1;
  8055cf:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8055d4:	eb 1d                	jmp    8055f3 <lwip_bind+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  8055d6:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8055dd:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  8055e4:	00 00 00 
  return 0;
  8055e7:	b8 00 00 00 00       	mov    $0x0,%eax
  8055ec:	eb 05                	jmp    8055f3 <lwip_bind+0xb6>
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  8055ee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  8055f3:	83 c4 20             	add    $0x20,%esp
  8055f6:	5b                   	pop    %ebx
  8055f7:	5e                   	pop    %esi
  8055f8:	5d                   	pop    %ebp
  8055f9:	c3                   	ret    

008055fa <lwip_close>:

int
lwip_close(int s)
{
  8055fa:	55                   	push   %ebp
  8055fb:	89 e5                	mov    %esp,%ebp
  8055fd:	53                   	push   %ebx
  8055fe:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  805601:	8b 45 08             	mov    0x8(%ebp),%eax
  805604:	e8 37 f6 ff ff       	call   804c40 <_ZL10get_socketi>
  805609:	89 c3                	mov    %eax,%ebx
  if (!sock) {
    return -1;
  80560b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  if (!sock) {
  805610:	85 db                	test   %ebx,%ebx
  805612:	74 5c                	je     805670 <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  805614:	8b 03                	mov    (%ebx),%eax
  805616:	89 04 24             	mov    %eax,(%esp)
  805619:	e8 29 af 00 00       	call   810547 <netconn_delete>

  sys_sem_wait(socksem);
  80561e:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  805623:	89 04 24             	mov    %eax,(%esp)
  805626:	e8 8d 45 00 00       	call   809bb8 <sys_sem_wait>
  if (sock->lastdata) {
  80562b:	8b 43 04             	mov    0x4(%ebx),%eax
  80562e:	85 c0                	test   %eax,%eax
  805630:	74 08                	je     80563a <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  805632:	89 04 24             	mov    %eax,(%esp)
  805635:	e8 ba 14 00 00       	call   806af4 <netbuf_delete>
  }
  sock->lastdata   = NULL;
  80563a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  805641:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  805647:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  80564d:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  805654:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  80565b:	00 00 00 
  sys_sem_signal(socksem);
  80565e:	a1 c8 b2 81 00       	mov    0x81b2c8,%eax
  805663:	89 04 24             	mov    %eax,(%esp)
  805666:	e8 34 9b 00 00       	call   80f19f <sys_sem_signal>
  return 0;
  80566b:	b8 00 00 00 00       	mov    $0x0,%eax
}
  805670:	83 c4 14             	add    $0x14,%esp
  805673:	5b                   	pop    %ebx
  805674:	5d                   	pop    %ebp
  805675:	c3                   	ret    

00805676 <lwip_connect>:

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  805676:	55                   	push   %ebp
  805677:	89 e5                	mov    %esp,%ebp
  805679:	56                   	push   %esi
  80567a:	53                   	push   %ebx
  80567b:	83 ec 20             	sub    $0x20,%esp
  80567e:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  805681:	8b 45 08             	mov    0x8(%ebp),%eax
  805684:	e8 b7 f5 ff ff       	call   804c40 <_ZL10get_socketi>
  805689:	89 c3                	mov    %eax,%ebx
  if (!sock)
  80568b:	85 c0                	test   %eax,%eax
  80568d:	0f 84 94 00 00 00    	je     805727 <lwip_connect+0xb1>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  805693:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  805697:	75 06                	jne    80569f <lwip_connect+0x29>
  805699:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  80569d:	74 1c                	je     8056bb <lwip_connect+0x45>
  80569f:	c7 44 24 08 9c 51 81 	movl   $0x81519c,0x8(%esp)
  8056a6:	00 
  8056a7:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  8056ae:	00 
  8056af:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  8056b6:	e8 fd b2 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  8056bb:	8b 46 04             	mov    0x4(%esi),%eax
  8056be:	89 45 f4             	mov    %eax,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  8056c1:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8056c5:	89 04 24             	mov    %eax,(%esp)
  8056c8:	e8 f9 6c 00 00       	call   80c3c6 <ntohs>
  8056cd:	0f b7 c0             	movzwl %ax,%eax
  8056d0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8056d4:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8056d7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8056db:	8b 03                	mov    (%ebx),%eax
  8056dd:	89 04 24             	mov    %eax,(%esp)
  8056e0:	e8 bf af 00 00       	call   8106a4 <netconn_connect>
  }

  if (err != ERR_OK) {
  8056e5:	84 c0                	test   %al,%al
  8056e7:	74 26                	je     80570f <lwip_connect+0x99>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  8056e9:	0f be c0             	movsbl %al,%eax
  8056ec:	f7 d8                	neg    %eax
  8056ee:	ba 05 00 00 00       	mov    $0x5,%edx
  8056f3:	83 f8 0e             	cmp    $0xe,%eax
  8056f6:	77 07                	ja     8056ff <lwip_connect+0x89>
  8056f8:	8b 14 85 00 52 81 00 	mov    0x815200(,%eax,4),%edx
  8056ff:	89 53 10             	mov    %edx,0x10(%ebx)
  805702:	89 15 00 90 81 00    	mov    %edx,0x819000
    return -1;
  805708:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80570d:	eb 1d                	jmp    80572c <lwip_connect+0xb6>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  80570f:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  805716:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  80571d:	00 00 00 
  return 0;
  805720:	b8 00 00 00 00       	mov    $0x0,%eax
  805725:	eb 05                	jmp    80572c <lwip_connect+0xb6>
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  if (!sock)
    return -1;
  805727:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  return 0;
}
  80572c:	83 c4 20             	add    $0x20,%esp
  80572f:	5b                   	pop    %ebx
  805730:	5e                   	pop    %esi
  805731:	5d                   	pop    %ebp
  805732:	c3                   	ret    

00805733 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  805733:	55                   	push   %ebp
  805734:	89 e5                	mov    %esp,%ebp
  805736:	56                   	push   %esi
  805737:	53                   	push   %ebx
  805738:	83 ec 10             	sub    $0x10,%esp
  80573b:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  80573e:	8b 45 08             	mov    0x8(%ebp),%eax
  805741:	e8 fa f4 ff ff       	call   804c40 <_ZL10get_socketi>
  805746:	89 c3                	mov    %eax,%ebx
  if (!sock)
    return -1;
  805748:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  if (!sock)
  80574d:	85 db                	test   %ebx,%ebx
  80574f:	74 69                	je     8057ba <lwip_listen+0x87>
  805751:	85 f6                	test   %esi,%esi
  805753:	b8 00 00 00 00       	mov    $0x0,%eax
  805758:	0f 48 f0             	cmovs  %eax,%esi
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  80575b:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  805761:	b0 ff                	mov    $0xff,%al
  805763:	0f 4f f0             	cmovg  %eax,%esi
  805766:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80576c:	89 74 24 04          	mov    %esi,0x4(%esp)
  805770:	8b 03                	mov    (%ebx),%eax
  805772:	89 04 24             	mov    %eax,(%esp)
  805775:	e8 ca af 00 00       	call   810744 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  80577a:	84 c0                	test   %al,%al
  80577c:	74 26                	je     8057a4 <lwip_listen+0x71>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  80577e:	0f be c0             	movsbl %al,%eax
  805781:	f7 d8                	neg    %eax
  805783:	ba 05 00 00 00       	mov    $0x5,%edx
  805788:	83 f8 0e             	cmp    $0xe,%eax
  80578b:	77 07                	ja     805794 <lwip_listen+0x61>
  80578d:	8b 14 85 00 52 81 00 	mov    0x815200(,%eax,4),%edx
  805794:	89 53 10             	mov    %edx,0x10(%ebx)
  805797:	89 15 00 90 81 00    	mov    %edx,0x819000
    return -1;
  80579d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8057a2:	eb 16                	jmp    8057ba <lwip_listen+0x87>
  }

  sock_set_errno(sock, 0);
  8057a4:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8057ab:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  8057b2:	00 00 00 
  return 0;
  8057b5:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8057ba:	83 c4 10             	add    $0x10,%esp
  8057bd:	5b                   	pop    %ebx
  8057be:	5e                   	pop    %esi
  8057bf:	5d                   	pop    %ebp
  8057c0:	c3                   	ret    

008057c1 <lwip_recvfrom>:

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  8057c1:	55                   	push   %ebp
  8057c2:	89 e5                	mov    %esp,%ebp
  8057c4:	57                   	push   %edi
  8057c5:	56                   	push   %esi
  8057c6:	53                   	push   %ebx
  8057c7:	83 ec 5c             	sub    $0x5c,%esp
  8057ca:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  8057cd:	8b 45 08             	mov    0x8(%ebp),%eax
  8057d0:	e8 6b f4 ff ff       	call   804c40 <_ZL10get_socketi>
  8057d5:	89 c3                	mov    %eax,%ebx
  if (!sock)
    return -1;
  8057d7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
  8057dc:	85 db                	test   %ebx,%ebx
  8057de:	0f 84 0f 02 00 00    	je     8059f3 <lwip_recvfrom+0x232>
  8057e4:	66 c7 45 c6 00 00    	movw   $0x0,-0x3a(%ebp)
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8057ea:	89 f0                	mov    %esi,%eax
  8057ec:	83 e0 08             	and    $0x8,%eax
  8057ef:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8057f2:	83 e6 01             	and    $0x1,%esi
  8057f5:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8057f8:	8b 73 04             	mov    0x4(%ebx),%esi
  8057fb:	85 f6                	test   %esi,%esi
  8057fd:	75 7d                	jne    80587c <lwip_recvfrom+0xbb>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8057ff:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  805803:	75 06                	jne    80580b <lwip_recvfrom+0x4a>
  805805:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  805809:	74 22                	je     80582d <lwip_recvfrom+0x6c>
  80580b:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  805810:	75 1b                	jne    80582d <lwip_recvfrom+0x6c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  805812:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  805819:	c7 05 00 90 81 00 0b 	movl   $0xb,0x819000
  805820:	00 00 00 
        return -1;
  805823:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805828:	e9 c6 01 00 00       	jmp    8059f3 <lwip_recvfrom+0x232>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  80582d:	8b 03                	mov    (%ebx),%eax
  80582f:	89 04 24             	mov    %eax,(%esp)
  805832:	e8 e0 af 00 00       	call   810817 <netconn_recv>
  805837:	89 c6                	mov    %eax,%esi
  805839:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  80583c:	85 c0                	test   %eax,%eax
  80583e:	75 3c                	jne    80587c <lwip_recvfrom+0xbb>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  805840:	8b 13                	mov    (%ebx),%edx
  805842:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  805846:	74 0b                	je     805853 <lwip_recvfrom+0x92>
  805848:	b8 6e 00 00 00       	mov    $0x6e,%eax
  80584d:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  805851:	74 17                	je     80586a <lwip_recvfrom+0xa9>
  805853:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  805857:	f7 da                	neg    %edx
  805859:	b8 05 00 00 00       	mov    $0x5,%eax
  80585e:	83 fa 0e             	cmp    $0xe,%edx
  805861:	77 07                	ja     80586a <lwip_recvfrom+0xa9>
  805863:	8b 04 95 00 52 81 00 	mov    0x815200(,%edx,4),%eax
  80586a:	89 43 10             	mov    %eax,0x10(%ebx)
  80586d:	a3 00 90 81 00       	mov    %eax,0x819000
        return 0;
  805872:	b8 00 00 00 00       	mov    $0x0,%eax
  805877:	e9 77 01 00 00       	jmp    8059f3 <lwip_recvfrom+0x232>
      }
    }

    buflen = netbuf_len(buf);
  80587c:	8b 06                	mov    (%esi),%eax
  80587e:	0f b7 78 08          	movzwl 0x8(%eax),%edi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  805882:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  805886:	66 29 d7             	sub    %dx,%di

    if (len > buflen) {
  805889:	0f b7 cf             	movzwl %di,%ecx
  80588c:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  80588f:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  805892:	0f 4e 7d 10          	cmovle 0x10(%ebp),%edi
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  805896:	0f b7 cf             	movzwl %di,%ecx
  805899:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  80589c:	0f b7 d2             	movzwl %dx,%edx
  80589f:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8058a3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8058a7:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
  8058ab:	03 55 0c             	add    0xc(%ebp),%edx
  8058ae:	89 54 24 04          	mov    %edx,0x4(%esp)
  8058b2:	89 04 24             	mov    %eax,(%esp)
  8058b5:	e8 6a 41 00 00       	call   809a24 <pbuf_copy_partial>

    off += copylen;
  8058ba:	66 01 7d c6          	add    %di,-0x3a(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8058be:	8b 03                	mov    (%ebx),%eax
  8058c0:	89 04 24             	mov    %eax,(%esp)
  8058c3:	e8 bc ac 00 00       	call   810584 <netconn_type>
      len -= copylen;
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
        done = 1;
      }
    } else {
      done = 1;
  8058c8:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);

    off += copylen;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8058cc:	83 f8 10             	cmp    $0x10,%eax
  8058cf:	75 1d                	jne    8058ee <lwip_recvfrom+0x12d>
      len -= copylen;
  8058d1:	8b 45 c0             	mov    -0x40(%ebp),%eax
  8058d4:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  8058d7:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8058db:	7e 11                	jle    8058ee <lwip_recvfrom+0x12d>
  8058dd:	8b 06                	mov    (%esi),%eax
  8058df:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  8058e3:	75 09                	jne    8058ee <lwip_recvfrom+0x12d>
  8058e5:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8058ea:	0f 94 45 bb          	sete   -0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8058ee:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8058f2:	75 39                	jne    80592d <lwip_recvfrom+0x16c>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8058f4:	8b 03                	mov    (%ebx),%eax
  8058f6:	83 38 10             	cmpl   $0x10,(%eax)
  8058f9:	75 13                	jne    80590e <lwip_recvfrom+0x14d>
  8058fb:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8058fe:	2b 45 c0             	sub    -0x40(%ebp),%eax
  805901:	85 c0                	test   %eax,%eax
  805903:	7e 09                	jle    80590e <lwip_recvfrom+0x14d>
        sock->lastdata = buf;
  805905:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  805908:	66 01 7b 08          	add    %di,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
  80590c:	eb 15                	jmp    805923 <lwip_recvfrom+0x162>
      } else {
        sock->lastdata = NULL;
  80590e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  805915:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  80591b:	89 34 24             	mov    %esi,(%esp)
  80591e:	e8 d1 11 00 00       	call   806af4 <netbuf_delete>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  if (!sock)
    return -1;

  do {
  805923:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  805927:	0f 84 cb fe ff ff    	je     8057f8 <lwip_recvfrom+0x37>
      done = 1;
    }
  } while (!done);

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  80592d:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  805931:	0f 84 a7 00 00 00    	je     8059de <lwip_recvfrom+0x21d>
  805937:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80593b:	0f 84 9d 00 00 00    	je     8059de <lwip_recvfrom+0x21d>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  805941:	8b 03                	mov    (%ebx),%eax
  805943:	89 04 24             	mov    %eax,(%esp)
  805946:	e8 39 ac 00 00       	call   810584 <netconn_type>
  80594b:	83 f8 10             	cmp    $0x10,%eax
  80594e:	75 22                	jne    805972 <lwip_recvfrom+0x1b1>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  805950:	8d 7d d8             	lea    -0x28(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  805953:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80595a:	00 
  80595b:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  80595e:	89 44 24 08          	mov    %eax,0x8(%esp)
  805962:	89 7c 24 04          	mov    %edi,0x4(%esp)
  805966:	8b 03                	mov    (%ebx),%eax
  805968:	89 04 24             	mov    %eax,(%esp)
  80596b:	e8 41 ac 00 00       	call   8105b1 <netconn_getaddr>
  805970:	eb 0b                	jmp    80597d <lwip_recvfrom+0x1bc>
    } else {
      addr = netbuf_fromaddr(buf);
  805972:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  805975:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  805979:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  80597d:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  805984:	00 
  805985:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80598c:	00 
  80598d:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  805990:	89 04 24             	mov    %eax,(%esp)
  805993:	e8 99 b8 ff ff       	call   801231 <memset>
    sin.sin_len = sizeof(sin);
  805998:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  80599c:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  8059a0:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8059a4:	89 04 24             	mov    %eax,(%esp)
  8059a7:	e8 0d 6a 00 00       	call   80c3b9 <htons>
  8059ac:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  8059b0:	8b 07                	mov    (%edi),%eax
  8059b2:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  8059b5:	8b 55 1c             	mov    0x1c(%ebp),%edx
  8059b8:	83 3a 10             	cmpl   $0x10,(%edx)
  8059bb:	76 06                	jbe    8059c3 <lwip_recvfrom+0x202>
      *fromlen = sizeof(sin);
  8059bd:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  8059c3:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  8059c6:	8b 01                	mov    (%ecx),%eax
  8059c8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8059cc:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  8059cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8059d3:	8b 45 18             	mov    0x18(%ebp),%eax
  8059d6:	89 04 24             	mov    %eax,(%esp)
  8059d9:	e8 29 b9 ff ff       	call   801307 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  8059de:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  8059e5:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  8059ec:	00 00 00 
  return off;
  8059ef:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
}
  8059f3:	83 c4 5c             	add    $0x5c,%esp
  8059f6:	5b                   	pop    %ebx
  8059f7:	5e                   	pop    %esi
  8059f8:	5f                   	pop    %edi
  8059f9:	5d                   	pop    %ebp
  8059fa:	c3                   	ret    

008059fb <lwip_read>:

int
lwip_read(int s, void *mem, int len)
{
  8059fb:	55                   	push   %ebp
  8059fc:	89 e5                	mov    %esp,%ebp
  8059fe:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  805a01:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  805a08:	00 
  805a09:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  805a10:	00 
  805a11:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805a18:	00 
  805a19:	8b 45 10             	mov    0x10(%ebp),%eax
  805a1c:	89 44 24 08          	mov    %eax,0x8(%esp)
  805a20:	8b 45 0c             	mov    0xc(%ebp),%eax
  805a23:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a27:	8b 45 08             	mov    0x8(%ebp),%eax
  805a2a:	89 04 24             	mov    %eax,(%esp)
  805a2d:	e8 8f fd ff ff       	call   8057c1 <lwip_recvfrom>
}
  805a32:	c9                   	leave  
  805a33:	c3                   	ret    

00805a34 <lwip_recv>:

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  805a34:	55                   	push   %ebp
  805a35:	89 e5                	mov    %esp,%ebp
  805a37:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  805a3a:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  805a41:	00 
  805a42:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  805a49:	00 
  805a4a:	8b 45 14             	mov    0x14(%ebp),%eax
  805a4d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  805a51:	8b 45 10             	mov    0x10(%ebp),%eax
  805a54:	89 44 24 08          	mov    %eax,0x8(%esp)
  805a58:	8b 45 0c             	mov    0xc(%ebp),%eax
  805a5b:	89 44 24 04          	mov    %eax,0x4(%esp)
  805a5f:	8b 45 08             	mov    0x8(%ebp),%eax
  805a62:	89 04 24             	mov    %eax,(%esp)
  805a65:	e8 57 fd ff ff       	call   8057c1 <lwip_recvfrom>
}
  805a6a:	c9                   	leave  
  805a6b:	c3                   	ret    

00805a6c <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  805a6c:	55                   	push   %ebp
  805a6d:	89 e5                	mov    %esp,%ebp
  805a6f:	57                   	push   %edi
  805a70:	56                   	push   %esi
  805a71:	53                   	push   %ebx
  805a72:	83 ec 3c             	sub    $0x3c,%esp
  805a75:	8b 75 10             	mov    0x10(%ebp),%esi
  805a78:	8b 7d 18             	mov    0x18(%ebp),%edi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  805a7b:	8b 45 08             	mov    0x8(%ebp),%eax
  805a7e:	e8 bd f1 ff ff       	call   804c40 <_ZL10get_socketi>
  805a83:	89 c3                	mov    %eax,%ebx
  if (!sock)
  805a85:	85 c0                	test   %eax,%eax
  805a87:	0f 84 34 01 00 00    	je     805bc1 <lwip_sendto+0x155>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  805a8d:	8b 00                	mov    (%eax),%eax
  805a8f:	83 38 10             	cmpl   $0x10,(%eax)
  805a92:	75 24                	jne    805ab8 <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  805a94:	8b 45 14             	mov    0x14(%ebp),%eax
  805a97:	89 44 24 0c          	mov    %eax,0xc(%esp)
  805a9b:	89 74 24 08          	mov    %esi,0x8(%esp)
  805a9f:	8b 45 0c             	mov    0xc(%ebp),%eax
  805aa2:	89 44 24 04          	mov    %eax,0x4(%esp)
  805aa6:	8b 45 08             	mov    0x8(%ebp),%eax
  805aa9:	89 04 24             	mov    %eax,(%esp)
  805aac:	e8 1f 01 00 00       	call   805bd0 <lwip_send>
  805ab1:	89 c6                	mov    %eax,%esi
  805ab3:	e9 0e 01 00 00       	jmp    805bc6 <lwip_sendto+0x15a>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  805ab8:	81 fe ff ff 00 00    	cmp    $0xffff,%esi
  805abe:	76 1c                	jbe    805adc <lwip_sendto+0x70>
  805ac0:	c7 44 24 08 d8 51 81 	movl   $0x8151d8,0x8(%esp)
  805ac7:	00 
  805ac8:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  805acf:	00 
  805ad0:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  805ad7:	e8 dc ae ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  805adc:	85 ff                	test   %edi,%edi
  805ade:	0f 95 c0             	setne  %al
  805ae1:	75 06                	jne    805ae9 <lwip_sendto+0x7d>
  805ae3:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  805ae7:	74 28                	je     805b11 <lwip_sendto+0xa5>
  805ae9:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  805aed:	75 06                	jne    805af5 <lwip_sendto+0x89>
  805aef:	80 7f 01 02          	cmpb   $0x2,0x1(%edi)
  805af3:	74 1c                	je     805b11 <lwip_sendto+0xa5>
  805af5:	c7 44 24 08 ba 51 81 	movl   $0x8151ba,0x8(%esp)
  805afc:	00 
  805afd:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  805b04:	00 
  805b05:	c7 04 24 47 51 81 00 	movl   $0x815147,(%esp)
  805b0c:	e8 a7 ae ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  805b11:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  805b18:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  805b1f:	84 c0                	test   %al,%al
  805b21:	74 1e                	je     805b41 <lwip_sendto+0xd5>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  805b23:	8b 47 04             	mov    0x4(%edi),%eax
  805b26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  805b29:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  805b2d:	89 04 24             	mov    %eax,(%esp)
  805b30:	e8 91 68 00 00       	call   80c3c6 <ntohs>
    buf.addr         = &remote_addr;
  805b35:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  805b38:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  805b3b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  805b3f:	eb 14                	jmp    805b55 <lwip_sendto+0xe9>
  } else {
    remote_addr.addr = 0;
  805b41:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  805b48:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  805b4f:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  805b55:	0f b7 c6             	movzwl %si,%eax
  805b58:	89 44 24 08          	mov    %eax,0x8(%esp)
  805b5c:	8b 45 0c             	mov    0xc(%ebp),%eax
  805b5f:	89 44 24 04          	mov    %eax,0x4(%esp)
  805b63:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  805b66:	89 04 24             	mov    %eax,(%esp)
  805b69:	e8 a4 10 00 00       	call   806c12 <netbuf_ref>
  805b6e:	0f be f8             	movsbl %al,%edi
  805b71:	85 ff                	test   %edi,%edi
  805b73:	75 14                	jne    805b89 <lwip_sendto+0x11d>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  805b75:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  805b78:	89 44 24 04          	mov    %eax,0x4(%esp)
  805b7c:	8b 03                	mov    (%ebx),%eax
  805b7e:	89 04 24             	mov    %eax,(%esp)
  805b81:	e8 2d ae 00 00       	call   8109b3 <netconn_send>
  805b86:	0f be f8             	movsbl %al,%edi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  805b89:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  805b8c:	85 c0                	test   %eax,%eax
  805b8e:	74 08                	je     805b98 <lwip_sendto+0x12c>
    pbuf_free(buf.p);
  805b90:	89 04 24             	mov    %eax,(%esp)
  805b93:	e8 6b 36 00 00       	call   809203 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  805b98:	89 fa                	mov    %edi,%edx
  805b9a:	f7 da                	neg    %edx
  805b9c:	b8 05 00 00 00       	mov    $0x5,%eax
  805ba1:	83 fa 0e             	cmp    $0xe,%edx
  805ba4:	77 07                	ja     805bad <lwip_sendto+0x141>
  805ba6:	8b 04 95 00 52 81 00 	mov    0x815200(,%edx,4),%eax
  805bad:	89 43 10             	mov    %eax,0x10(%ebx)
  805bb0:	a3 00 90 81 00       	mov    %eax,0x819000
  return (err==ERR_OK?size:-1);
  805bb5:	85 ff                	test   %edi,%edi
  805bb7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805bbc:	0f 45 f0             	cmovne %eax,%esi
  805bbf:	eb 05                	jmp    805bc6 <lwip_sendto+0x15a>
  u16_t remote_port;
#endif

  sock = get_socket(s);
  if (!sock)
    return -1;
  805bc1:	be ff ff ff ff       	mov    $0xffffffff,%esi
    pbuf_free(buf.p);
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  805bc6:	89 f0                	mov    %esi,%eax
  805bc8:	83 c4 3c             	add    $0x3c,%esp
  805bcb:	5b                   	pop    %ebx
  805bcc:	5e                   	pop    %esi
  805bcd:	5f                   	pop    %edi
  805bce:	5d                   	pop    %ebp
  805bcf:	c3                   	ret    

00805bd0 <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  805bd0:	55                   	push   %ebp
  805bd1:	89 e5                	mov    %esp,%ebp
  805bd3:	83 ec 38             	sub    $0x38,%esp
  805bd6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805bd9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805bdc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  805bdf:	8b 7d 08             	mov    0x8(%ebp),%edi
  805be2:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  805be5:	89 f8                	mov    %edi,%eax
  805be7:	e8 54 f0 ff ff       	call   804c40 <_ZL10get_socketi>
  805bec:	89 c3                	mov    %eax,%ebx
  if (!sock)
  805bee:	85 c0                	test   %eax,%eax
  805bf0:	0f 84 88 00 00 00    	je     805c7e <lwip_send+0xae>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  805bf6:	8b 00                	mov    (%eax),%eax
  805bf8:	83 38 10             	cmpl   $0x10,(%eax)
  805bfb:	74 2e                	je     805c2b <lwip_send+0x5b>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  805bfd:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  805c04:	00 
  805c05:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  805c0c:	00 
  805c0d:	8b 45 14             	mov    0x14(%ebp),%eax
  805c10:	89 44 24 0c          	mov    %eax,0xc(%esp)
  805c14:	89 74 24 08          	mov    %esi,0x8(%esp)
  805c18:	8b 55 0c             	mov    0xc(%ebp),%edx
  805c1b:	89 54 24 04          	mov    %edx,0x4(%esp)
  805c1f:	89 3c 24             	mov    %edi,(%esp)
  805c22:	e8 45 fe ff ff       	call   805a6c <lwip_sendto>
  805c27:	89 c6                	mov    %eax,%esi
  805c29:	eb 58                	jmp    805c83 <lwip_send+0xb3>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  805c2b:	8b 55 14             	mov    0x14(%ebp),%edx
  805c2e:	83 e2 10             	and    $0x10,%edx
  805c31:	83 fa 01             	cmp    $0x1,%edx
  805c34:	19 d2                	sbb    %edx,%edx
  805c36:	83 e2 fe             	and    $0xfffffffe,%edx
  805c39:	83 c2 03             	add    $0x3,%edx
  805c3c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  805c40:	89 74 24 08          	mov    %esi,0x8(%esp)
  805c44:	8b 55 0c             	mov    0xc(%ebp),%edx
  805c47:	89 54 24 04          	mov    %edx,0x4(%esp)
  805c4b:	89 04 24             	mov    %eax,(%esp)
  805c4e:	e8 e0 ad 00 00       	call   810a33 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  805c53:	0f be c8             	movsbl %al,%ecx
  805c56:	f7 d9                	neg    %ecx
  805c58:	ba 05 00 00 00       	mov    $0x5,%edx
  805c5d:	83 f9 0e             	cmp    $0xe,%ecx
  805c60:	77 07                	ja     805c69 <lwip_send+0x99>
  805c62:	8b 14 8d 00 52 81 00 	mov    0x815200(,%ecx,4),%edx
  805c69:	89 53 10             	mov    %edx,0x10(%ebx)
  805c6c:	89 15 00 90 81 00    	mov    %edx,0x819000
  return (err==ERR_OK?size:-1);
  805c72:	84 c0                	test   %al,%al
  805c74:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805c79:	0f 45 f0             	cmovne %eax,%esi
  805c7c:	eb 05                	jmp    805c83 <lwip_send+0xb3>
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  if (!sock)
    return -1;
  805c7e:	be ff ff ff ff       	mov    $0xffffffff,%esi
  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  return (err==ERR_OK?size:-1);
}
  805c83:	89 f0                	mov    %esi,%eax
  805c85:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805c88:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805c8b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805c8e:	89 ec                	mov    %ebp,%esp
  805c90:	5d                   	pop    %ebp
  805c91:	c3                   	ret    

00805c92 <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  805c92:	55                   	push   %ebp
  805c93:	89 e5                	mov    %esp,%ebp
  805c95:	56                   	push   %esi
  805c96:	53                   	push   %ebx
  805c97:	83 ec 10             	sub    $0x10,%esp
  805c9a:	8b 45 0c             	mov    0xc(%ebp),%eax
  805c9d:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  805ca0:	83 f8 02             	cmp    $0x2,%eax
  805ca3:	74 2c                	je     805cd1 <lwip_socket+0x3f>
  805ca5:	83 f8 03             	cmp    $0x3,%eax
  805ca8:	74 08                	je     805cb2 <lwip_socket+0x20>
  805caa:	83 f8 01             	cmp    $0x1,%eax
  805cad:	75 6d                	jne    805d1c <lwip_socket+0x8a>
  805caf:	90                   	nop
  805cb0:	eb 4a                	jmp    805cfc <lwip_socket+0x6a>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  805cb2:	c7 44 24 08 ce 51 80 	movl   $0x8051ce,0x8(%esp)
  805cb9:	00 
  805cba:	0f b6 d2             	movzbl %dl,%edx
  805cbd:	89 54 24 04          	mov    %edx,0x4(%esp)
  805cc1:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  805cc8:	e8 73 a7 00 00       	call   810440 <netconn_new_with_proto_and_callback>
  805ccd:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  805ccf:	eb 5c                	jmp    805d2d <lwip_socket+0x9b>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  805cd1:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  805cd7:	0f 94 c0             	sete   %al
  805cda:	0f b6 c0             	movzbl %al,%eax
  805cdd:	83 c0 20             	add    $0x20,%eax
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
  805ce0:	c7 44 24 08 ce 51 80 	movl   $0x8051ce,0x8(%esp)
  805ce7:	00 
  805ce8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805cef:	00 
  805cf0:	89 04 24             	mov    %eax,(%esp)
  805cf3:	e8 48 a7 00 00       	call   810440 <netconn_new_with_proto_and_callback>
  805cf8:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  805cfa:	eb 31                	jmp    805d2d <lwip_socket+0x9b>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  805cfc:	c7 44 24 08 ce 51 80 	movl   $0x8051ce,0x8(%esp)
  805d03:	00 
  805d04:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805d0b:	00 
  805d0c:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  805d13:	e8 28 a7 00 00       	call   810440 <netconn_new_with_proto_and_callback>
  805d18:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  805d1a:	eb 11                	jmp    805d2d <lwip_socket+0x9b>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  805d1c:	c7 05 00 90 81 00 16 	movl   $0x16,0x819000
  805d23:	00 00 00 
    return -1;
  805d26:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  805d2b:	eb 44                	jmp    805d71 <lwip_socket+0xdf>
  }

  if (!conn) {
  805d2d:	85 f6                	test   %esi,%esi
  805d2f:	75 11                	jne    805d42 <lwip_socket+0xb0>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  805d31:	c7 05 00 90 81 00 69 	movl   $0x69,0x819000
  805d38:	00 00 00 
    return -1;
  805d3b:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  805d40:	eb 2f                	jmp    805d71 <lwip_socket+0xdf>
  }

  i = alloc_socket(conn);
  805d42:	89 f0                	mov    %esi,%eax
  805d44:	e8 cc f3 ff ff       	call   805115 <_ZL12alloc_socketP7netconn>
  805d49:	89 c3                	mov    %eax,%ebx

  if (i == -1) {
  805d4b:	83 f8 ff             	cmp    $0xffffffff,%eax
  805d4e:	75 14                	jne    805d64 <lwip_socket+0xd2>
    netconn_delete(conn);
  805d50:	89 34 24             	mov    %esi,(%esp)
  805d53:	e8 ef a7 00 00       	call   810547 <netconn_delete>
    set_errno(ENFILE);
  805d58:	c7 05 00 90 81 00 17 	movl   $0x17,0x819000
  805d5f:	00 00 00 
    return -1;
  805d62:	eb 0d                	jmp    805d71 <lwip_socket+0xdf>
  }
  conn->socket = i;
  805d64:	89 46 1c             	mov    %eax,0x1c(%esi)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  805d67:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  805d6e:	00 00 00 
  return i;
}
  805d71:	89 d8                	mov    %ebx,%eax
  805d73:	83 c4 10             	add    $0x10,%esp
  805d76:	5b                   	pop    %ebx
  805d77:	5e                   	pop    %esi
  805d78:	5d                   	pop    %ebp
  805d79:	c3                   	ret    

00805d7a <lwip_write>:

int
lwip_write(int s, const void *data, int size)
{
  805d7a:	55                   	push   %ebp
  805d7b:	89 e5                	mov    %esp,%ebp
  805d7d:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  805d80:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  805d87:	00 
  805d88:	8b 45 10             	mov    0x10(%ebp),%eax
  805d8b:	89 44 24 08          	mov    %eax,0x8(%esp)
  805d8f:	8b 45 0c             	mov    0xc(%ebp),%eax
  805d92:	89 44 24 04          	mov    %eax,0x4(%esp)
  805d96:	8b 45 08             	mov    0x8(%ebp),%eax
  805d99:	89 04 24             	mov    %eax,(%esp)
  805d9c:	e8 2f fe ff ff       	call   805bd0 <lwip_send>
}
  805da1:	c9                   	leave  
  805da2:	c3                   	ret    

00805da3 <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  805da3:	55                   	push   %ebp
  805da4:	89 e5                	mov    %esp,%ebp
  805da6:	57                   	push   %edi
  805da7:	56                   	push   %esi
  805da8:	53                   	push   %ebx
  805da9:	83 ec 5c             	sub    $0x5c,%esp
  805dac:	8b 7d 0c             	mov    0xc(%ebp),%edi
  805daf:	8b 75 10             	mov    0x10(%ebp),%esi
  805db2:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  805db5:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  805dbc:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  805dbf:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  805dc2:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  805dc5:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  805dcc:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  805dd1:	89 04 24             	mov    %eax,(%esp)
  805dd4:	e8 df 3d 00 00       	call   809bb8 <sys_sem_wait>

  if (readset)
  805dd9:	85 ff                	test   %edi,%edi
  805ddb:	74 07                	je     805de4 <lwip_select+0x41>
    lreadset = *readset;
  805ddd:	8b 07                	mov    (%edi),%eax
  805ddf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  805de2:	eb 1b                	jmp    805dff <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  805de4:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805deb:	00 
  805dec:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805df3:	00 
  805df4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  805df7:	89 04 24             	mov    %eax,(%esp)
  805dfa:	e8 32 b4 ff ff       	call   801231 <memset>
  if (writeset)
  805dff:	85 f6                	test   %esi,%esi
  805e01:	74 07                	je     805e0a <lwip_select+0x67>
    lwriteset = *writeset;
  805e03:	8b 06                	mov    (%esi),%eax
  805e05:	89 45 e0             	mov    %eax,-0x20(%ebp)
  805e08:	eb 1b                	jmp    805e25 <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  805e0a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805e11:	00 
  805e12:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805e19:	00 
  805e1a:	8d 45 e0             	lea    -0x20(%ebp),%eax
  805e1d:	89 04 24             	mov    %eax,(%esp)
  805e20:	e8 0c b4 ff ff       	call   801231 <memset>
  if (exceptset)
  805e25:	85 db                	test   %ebx,%ebx
  805e27:	74 07                	je     805e30 <lwip_select+0x8d>
    lexceptset = *exceptset;
  805e29:	8b 03                	mov    (%ebx),%eax
  805e2b:	89 45 dc             	mov    %eax,-0x24(%ebp)
  805e2e:	eb 1b                	jmp    805e4b <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  805e30:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805e37:	00 
  805e38:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805e3f:	00 
  805e40:	8d 45 dc             	lea    -0x24(%ebp),%eax
  805e43:	89 04 24             	mov    %eax,(%esp)
  805e46:	e8 e6 b3 ff ff       	call   801231 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  805e4b:	8d 45 dc             	lea    -0x24(%ebp),%eax
  805e4e:	89 04 24             	mov    %eax,(%esp)
  805e51:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  805e54:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  805e57:	8b 45 08             	mov    0x8(%ebp),%eax
  805e5a:	e8 b4 f0 ff ff       	call   804f13 <_ZL12lwip_selscaniP6fd_setS0_S0_>
  805e5f:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  805e62:	85 c0                	test   %eax,%eax
  805e64:	0f 85 2f 02 00 00    	jne    806099 <lwip_select+0x2f6>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  805e6a:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  805e6e:	0f 84 86 00 00 00    	je     805efa <lwip_select+0x157>
  805e74:	8b 45 18             	mov    0x18(%ebp),%eax
  805e77:	83 38 00             	cmpl   $0x0,(%eax)
  805e7a:	0f 85 56 02 00 00    	jne    8060d6 <lwip_select+0x333>
  805e80:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  805e84:	0f 85 4c 02 00 00    	jne    8060d6 <lwip_select+0x333>
      sys_sem_signal(selectsem);
  805e8a:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  805e8f:	89 04 24             	mov    %eax,(%esp)
  805e92:	e8 08 93 00 00       	call   80f19f <sys_sem_signal>
      if (readset)
  805e97:	85 ff                	test   %edi,%edi
  805e99:	74 18                	je     805eb3 <lwip_select+0x110>
        FD_ZERO(readset);
  805e9b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805ea2:	00 
  805ea3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805eaa:	00 
  805eab:	89 3c 24             	mov    %edi,(%esp)
  805eae:	e8 7e b3 ff ff       	call   801231 <memset>
      if (writeset)
  805eb3:	85 f6                	test   %esi,%esi
  805eb5:	74 18                	je     805ecf <lwip_select+0x12c>
        FD_ZERO(writeset);
  805eb7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805ebe:	00 
  805ebf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805ec6:	00 
  805ec7:	89 34 24             	mov    %esi,(%esp)
  805eca:	e8 62 b3 ff ff       	call   801231 <memset>
      if (exceptset)
  805ecf:	85 db                	test   %ebx,%ebx
  805ed1:	74 18                	je     805eeb <lwip_select+0x148>
        FD_ZERO(exceptset);
  805ed3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805eda:	00 
  805edb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805ee2:	00 
  805ee3:	89 1c 24             	mov    %ebx,(%esp)
  805ee6:	e8 46 b3 ff ff       	call   801231 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  805eeb:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  805ef2:	00 00 00 
  
      return 0;
  805ef5:	e9 d1 01 00 00       	jmp    8060cb <lwip_select+0x328>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  805efa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805f01:	e8 d8 8e 00 00       	call   80edde <sys_sem_new>
  805f06:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  805f09:	a1 c4 b2 81 00       	mov    0x81b2c4,%eax
  805f0e:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  805f11:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  805f14:	a3 c4 b2 81 00       	mov    %eax,0x81b2c4
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  805f19:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  805f1e:	89 04 24             	mov    %eax,(%esp)
  805f21:	e8 79 92 00 00       	call   80f19f <sys_sem_signal>
    
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
  805f26:	ba 00 00 00 00       	mov    $0x0,%edx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  805f2b:	89 54 24 04          	mov    %edx,0x4(%esp)
  805f2f:	8b 45 d8             	mov    -0x28(%ebp),%eax
  805f32:	89 04 24             	mov    %eax,(%esp)
  805f35:	e8 6c 3e 00 00       	call   809da6 <sys_sem_wait_timeout>
  805f3a:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  805f3d:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  805f42:	89 04 24             	mov    %eax,(%esp)
  805f45:	e8 6e 3c 00 00       	call   809bb8 <sys_sem_wait>
    if (select_cb_list == &select_cb)
  805f4a:	8b 15 c4 b2 81 00    	mov    0x81b2c4,%edx
  805f50:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  805f53:	39 c2                	cmp    %eax,%edx
  805f55:	75 26                	jne    805f7d <lwip_select+0x1da>
      select_cb_list = select_cb.next;
  805f57:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  805f5a:	a3 c4 b2 81 00       	mov    %eax,0x81b2c4
  805f5f:	eb 2c                	jmp    805f8d <lwip_select+0x1ea>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  805f61:	8b 10                	mov    (%eax),%edx
  805f63:	39 ca                	cmp    %ecx,%edx
  805f65:	74 0f                	je     805f76 <lwip_select+0x1d3>
  805f67:	89 d0                	mov    %edx,%eax
  805f69:	eb 03                	jmp    805f6e <lwip_select+0x1cb>
  805f6b:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  805f6e:	85 c0                	test   %eax,%eax
  805f70:	75 ef                	jne    805f61 <lwip_select+0x1be>
  805f72:	eb 19                	jmp    805f8d <lwip_select+0x1ea>
        if (p_selcb->next == &select_cb) {
  805f74:	89 d0                	mov    %edx,%eax
          p_selcb->next = select_cb.next;
  805f76:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  805f79:	89 10                	mov    %edx,(%eax)
          break;
  805f7b:	eb 10                	jmp    805f8d <lwip_select+0x1ea>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  805f7d:	85 d2                	test   %edx,%edx
  805f7f:	90                   	nop
  805f80:	74 0b                	je     805f8d <lwip_select+0x1ea>
        if (p_selcb->next == &select_cb) {
  805f82:	8b 02                	mov    (%edx),%eax
  805f84:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
  805f87:	39 c8                	cmp    %ecx,%eax
  805f89:	75 e0                	jne    805f6b <lwip_select+0x1c8>
  805f8b:	eb e7                	jmp    805f74 <lwip_select+0x1d1>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  805f8d:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  805f92:	89 04 24             	mov    %eax,(%esp)
  805f95:	e8 05 92 00 00       	call   80f19f <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  805f9a:	8b 45 d8             	mov    -0x28(%ebp),%eax
  805f9d:	89 04 24             	mov    %eax,(%esp)
  805fa0:	e8 fc 8e 00 00       	call   80eea1 <sys_sem_free>
    if (i == 0)  {
  805fa5:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  805fa9:	75 63                	jne    80600e <lwip_select+0x26b>
      /* Timeout */
      if (readset)
  805fab:	85 ff                	test   %edi,%edi
  805fad:	74 18                	je     805fc7 <lwip_select+0x224>
        FD_ZERO(readset);
  805faf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805fb6:	00 
  805fb7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805fbe:	00 
  805fbf:	89 3c 24             	mov    %edi,(%esp)
  805fc2:	e8 6a b2 ff ff       	call   801231 <memset>
      if (writeset)
  805fc7:	85 f6                	test   %esi,%esi
  805fc9:	74 18                	je     805fe3 <lwip_select+0x240>
        FD_ZERO(writeset);
  805fcb:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805fd2:	00 
  805fd3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805fda:	00 
  805fdb:	89 34 24             	mov    %esi,(%esp)
  805fde:	e8 4e b2 ff ff       	call   801231 <memset>
      if (exceptset)
  805fe3:	85 db                	test   %ebx,%ebx
  805fe5:	74 18                	je     805fff <lwip_select+0x25c>
        FD_ZERO(exceptset);
  805fe7:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  805fee:	00 
  805fef:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805ff6:	00 
  805ff7:	89 1c 24             	mov    %ebx,(%esp)
  805ffa:	e8 32 b2 ff ff       	call   801231 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  805fff:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  806006:	00 00 00 
  
      return 0;
  806009:	e9 bd 00 00 00       	jmp    8060cb <lwip_select+0x328>
    }
    
    if (readset)
  80600e:	85 ff                	test   %edi,%edi
  806010:	74 07                	je     806019 <lwip_select+0x276>
      lreadset = *readset;
  806012:	8b 07                	mov    (%edi),%eax
  806014:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806017:	eb 1b                	jmp    806034 <lwip_select+0x291>
    else
      FD_ZERO(&lreadset);
  806019:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  806020:	00 
  806021:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806028:	00 
  806029:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80602c:	89 04 24             	mov    %eax,(%esp)
  80602f:	e8 fd b1 ff ff       	call   801231 <memset>
    if (writeset)
  806034:	85 f6                	test   %esi,%esi
  806036:	74 07                	je     80603f <lwip_select+0x29c>
      lwriteset = *writeset;
  806038:	8b 06                	mov    (%esi),%eax
  80603a:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80603d:	eb 1b                	jmp    80605a <lwip_select+0x2b7>
    else
      FD_ZERO(&lwriteset);
  80603f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  806046:	00 
  806047:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80604e:	00 
  80604f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806052:	89 04 24             	mov    %eax,(%esp)
  806055:	e8 d7 b1 ff ff       	call   801231 <memset>
    if (exceptset)
  80605a:	85 db                	test   %ebx,%ebx
  80605c:	74 07                	je     806065 <lwip_select+0x2c2>
      lexceptset = *exceptset;
  80605e:	8b 03                	mov    (%ebx),%eax
  806060:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806063:	eb 1b                	jmp    806080 <lwip_select+0x2dd>
    else
      FD_ZERO(&lexceptset);
  806065:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80606c:	00 
  80606d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806074:	00 
  806075:	8d 45 dc             	lea    -0x24(%ebp),%eax
  806078:	89 04 24             	mov    %eax,(%esp)
  80607b:	e8 b1 b1 ff ff       	call   801231 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  806080:	8d 45 dc             	lea    -0x24(%ebp),%eax
  806083:	89 04 24             	mov    %eax,(%esp)
  806086:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  806089:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80608c:	8b 45 08             	mov    0x8(%ebp),%eax
  80608f:	e8 7f ee ff ff       	call   804f13 <_ZL12lwip_selscaniP6fd_setS0_S0_>
  806094:	89 45 b0             	mov    %eax,-0x50(%ebp)
  806097:	eb 0d                	jmp    8060a6 <lwip_select+0x303>
  } else
    sys_sem_signal(selectsem);
  806099:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  80609e:	89 04 24             	mov    %eax,(%esp)
  8060a1:	e8 f9 90 00 00       	call   80f19f <sys_sem_signal>
  
  if (readset)
  8060a6:	85 ff                	test   %edi,%edi
  8060a8:	74 05                	je     8060af <lwip_select+0x30c>
    *readset = lreadset;
  8060aa:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8060ad:	89 07                	mov    %eax,(%edi)
  if (writeset)
  8060af:	85 f6                	test   %esi,%esi
  8060b1:	74 05                	je     8060b8 <lwip_select+0x315>
    *writeset = lwriteset;
  8060b3:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8060b6:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  8060b8:	85 db                	test   %ebx,%ebx
  8060ba:	74 05                	je     8060c1 <lwip_select+0x31e>
    *exceptset = lexceptset;
  8060bc:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8060bf:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  8060c1:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  8060c8:	00 00 00 
  
  return nready;
}
  8060cb:	8b 45 b0             	mov    -0x50(%ebp),%eax
  8060ce:	83 c4 5c             	add    $0x5c,%esp
  8060d1:	5b                   	pop    %ebx
  8060d2:	5e                   	pop    %esi
  8060d3:	5f                   	pop    %edi
  8060d4:	5d                   	pop    %ebp
  8060d5:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8060d6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8060dd:	e8 fc 8c 00 00       	call   80edde <sys_sem_new>
  8060e2:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8060e5:	a1 c4 b2 81 00       	mov    0x81b2c4,%eax
  8060ea:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  8060ed:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  8060f0:	a3 c4 b2 81 00       	mov    %eax,0x81b2c4
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  8060f5:	a1 c0 b2 81 00       	mov    0x81b2c0,%eax
  8060fa:	89 04 24             	mov    %eax,(%esp)
  8060fd:	e8 9d 90 00 00       	call   80f19f <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  806102:	8b 45 18             	mov    0x18(%ebp),%eax
  806105:	8b 48 04             	mov    0x4(%eax),%ecx
  806108:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  80610e:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  806113:	89 c8                	mov    %ecx,%eax
  806115:	f7 ea                	imul   %edx
  806117:	c1 fa 06             	sar    $0x6,%edx
  80611a:	c1 f9 1f             	sar    $0x1f,%ecx
  80611d:	29 ca                	sub    %ecx,%edx
  80611f:	8b 4d 18             	mov    0x18(%ebp),%ecx
  806122:	69 01 e8 03 00 00    	imul   $0x3e8,(%ecx),%eax
      if(msectimeout == 0)
  806128:	01 c2                	add    %eax,%edx
        msectimeout = 1;
  80612a:	b8 01 00 00 00       	mov    $0x1,%eax
  80612f:	0f 44 d0             	cmove  %eax,%edx
  806132:	e9 f4 fd ff ff       	jmp    805f2b <lwip_select+0x188>

00806137 <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  806137:	55                   	push   %ebp
  806138:	89 e5                	mov    %esp,%ebp
  80613a:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  80613d:	8b 45 08             	mov    0x8(%ebp),%eax
  806140:	89 04 24             	mov    %eax,(%esp)
  806143:	e8 b2 f4 ff ff       	call   8055fa <lwip_close>
}
  806148:	c9                   	leave  
  806149:	c3                   	ret    

0080614a <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  80614a:	55                   	push   %ebp
  80614b:	89 e5                	mov    %esp,%ebp
  80614d:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  806150:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806157:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80615a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80615d:	8b 45 08             	mov    0x8(%ebp),%eax
  806160:	e8 e6 ee ff ff       	call   80504b <_ZL16lwip_getaddrnameiP8sockaddrPjh>
}
  806165:	c9                   	leave  
  806166:	c3                   	ret    

00806167 <lwip_getsockname>:

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  806167:	55                   	push   %ebp
  806168:	89 e5                	mov    %esp,%ebp
  80616a:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  80616d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  806174:	8b 4d 10             	mov    0x10(%ebp),%ecx
  806177:	8b 55 0c             	mov    0xc(%ebp),%edx
  80617a:	8b 45 08             	mov    0x8(%ebp),%eax
  80617d:	e8 c9 ee ff ff       	call   80504b <_ZL16lwip_getaddrnameiP8sockaddrPjh>
}
  806182:	c9                   	leave  
  806183:	c3                   	ret    

00806184 <lwip_getsockopt>:

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  806184:	55                   	push   %ebp
  806185:	89 e5                	mov    %esp,%ebp
  806187:	57                   	push   %edi
  806188:	56                   	push   %esi
  806189:	53                   	push   %ebx
  80618a:	83 ec 3c             	sub    $0x3c,%esp
  80618d:	8b 75 0c             	mov    0xc(%ebp),%esi
  806190:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  806193:	8b 45 08             	mov    0x8(%ebp),%eax
  806196:	e8 a5 ea ff ff       	call   804c40 <_ZL10get_socketi>
  80619b:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  80619d:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8061a2:	85 db                	test   %ebx,%ebx
  8061a4:	0f 84 8d 01 00 00    	je     806337 <lwip_getsockopt+0x1b3>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  8061aa:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  8061ae:	74 04                	je     8061b4 <lwip_getsockopt+0x30>
  8061b0:	85 ff                	test   %edi,%edi
  8061b2:	75 1b                	jne    8061cf <lwip_getsockopt+0x4b>
    sock_set_errno(sock, EFAULT);
  8061b4:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  8061bb:	c7 05 00 90 81 00 0e 	movl   $0xe,0x819000
  8061c2:	00 00 00 
    return -1;
  8061c5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8061ca:	e9 68 01 00 00       	jmp    806337 <lwip_getsockopt+0x1b3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8061cf:	83 fe 06             	cmp    $0x6,%esi
  8061d2:	0f 84 ab 00 00 00    	je     806283 <lwip_getsockopt+0xff>
  8061d8:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  8061de:	74 0d                	je     8061ed <lwip_getsockopt+0x69>
  8061e0:	85 f6                	test   %esi,%esi
  8061e2:	0f 84 7f 00 00 00    	je     806267 <lwip_getsockopt+0xe3>
  8061e8:	e9 c2 00 00 00       	jmp    8062af <lwip_getsockopt+0x12b>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8061ed:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8061f1:	74 3d                	je     806230 <lwip_getsockopt+0xac>
  8061f3:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8061f7:	7f 12                	jg     80620b <lwip_getsockopt+0x87>
  8061f9:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  8061fd:	74 31                	je     806230 <lwip_getsockopt+0xac>
  8061ff:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  806203:	0f 85 ad 00 00 00    	jne    8062b6 <lwip_getsockopt+0x132>
  806209:	eb 25                	jmp    806230 <lwip_getsockopt+0xac>
  80620b:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  806212:	0f 8c 9e 00 00 00    	jl     8062b6 <lwip_getsockopt+0x132>
  806218:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  80621f:	7e 0f                	jle    806230 <lwip_getsockopt+0xac>
  806221:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  806228:	0f 85 88 00 00 00    	jne    8062b6 <lwip_getsockopt+0x132>
  80622e:	eb 15                	jmp    806245 <lwip_getsockopt+0xc1>
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  806230:	b8 16 00 00 00       	mov    $0x16,%eax
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  806235:	83 3f 03             	cmpl   $0x3,(%edi)
  806238:	0f 86 88 00 00 00    	jbe    8062c6 <lwip_getsockopt+0x142>
  80623e:	66 90                	xchg   %ax,%ax
  806240:	e9 93 00 00 00       	jmp    8062d8 <lwip_getsockopt+0x154>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  806245:	83 3f 04             	cmpl   $0x4,(%edi)
  806248:	19 c0                	sbb    %eax,%eax
  80624a:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80624d:	8b 13                	mov    (%ebx),%edx
  80624f:	83 3a 20             	cmpl   $0x20,(%edx)
  806252:	0f 85 e7 00 00 00    	jne    80633f <lwip_getsockopt+0x1bb>
  806258:	8b 52 08             	mov    0x8(%edx),%edx
  80625b:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  80625f:	0f 85 e1 00 00 00    	jne    806346 <lwip_getsockopt+0x1c2>
  806265:	eb 5b                	jmp    8062c2 <lwip_getsockopt+0x13e>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  806267:	8b 55 10             	mov    0x10(%ebp),%edx
  80626a:	83 ea 01             	sub    $0x1,%edx
#endif /* LWIP_IGMP */

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  80626d:	b8 5c 00 00 00       	mov    $0x5c,%eax
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  806272:	83 fa 01             	cmp    $0x1,%edx
  806275:	77 4b                	ja     8062c2 <lwip_getsockopt+0x13e>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
        err = EINVAL;
  806277:	b8 16 00 00 00       	mov    $0x16,%eax
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  80627c:	83 3f 03             	cmpl   $0x3,(%edi)
  80627f:	76 45                	jbe    8062c6 <lwip_getsockopt+0x142>
  806281:	eb 55                	jmp    8062d8 <lwip_getsockopt+0x154>
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
      err = EINVAL;
  806283:	b8 16 00 00 00       	mov    $0x16,%eax
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  806288:	83 3f 03             	cmpl   $0x3,(%edi)
  80628b:	76 39                	jbe    8062c6 <lwip_getsockopt+0x142>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80628d:	8b 13                	mov    (%ebx),%edx
      return 0;
  80628f:	b8 00 00 00 00       	mov    $0x0,%eax
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  806294:	83 3a 10             	cmpl   $0x10,(%edx)
  806297:	0f 85 9a 00 00 00    	jne    806337 <lwip_getsockopt+0x1b3>
      return 0;

    switch (optname) {
  80629d:	8b 55 10             	mov    0x10(%ebp),%edx
  8062a0:	83 ea 01             	sub    $0x1,%edx
      break;
       
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8062a3:	b8 5c 00 00 00       	mov    $0x5c,%eax
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;

    switch (optname) {
  8062a8:	83 fa 01             	cmp    $0x1,%edx
  8062ab:	77 19                	ja     8062c6 <lwip_getsockopt+0x142>
  8062ad:	eb 0e                	jmp    8062bd <lwip_getsockopt+0x139>
#endif /* LWIP_UDP && LWIP_UDPLITE*/
/* UNDEFINED LEVEL */
  default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                                  s, level, optname));
      err = ENOPROTOOPT;
  8062af:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8062b4:	eb 0c                	jmp    8062c2 <lwip_getsockopt+0x13e>
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                                  s, optname));
      err = ENOPROTOOPT;
  8062b6:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8062bb:	eb 05                	jmp    8062c2 <lwip_getsockopt+0x13e>
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  err_t err = ERR_OK;
  8062bd:	b8 00 00 00 00       	mov    $0x0,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  8062c2:	84 c0                	test   %al,%al
  8062c4:	74 12                	je     8062d8 <lwip_getsockopt+0x154>
    sock_set_errno(sock, err);
  8062c6:	0f be c0             	movsbl %al,%eax
  8062c9:	89 43 10             	mov    %eax,0x10(%ebx)
  8062cc:	a3 00 90 81 00       	mov    %eax,0x819000
    return -1;
  8062d1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8062d6:	eb 5f                	jmp    806337 <lwip_getsockopt+0x1b3>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  8062d8:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  8062db:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  8062de:	8b 45 10             	mov    0x10(%ebp),%eax
  8062e1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  8062e4:	8b 45 14             	mov    0x14(%ebp),%eax
  8062e7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  data.optlen = optlen;
  8062ea:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  8062ed:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  8062f1:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8062f8:	00 
  8062f9:	8d 45 cc             	lea    -0x34(%ebp),%eax
  8062fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  806300:	c7 04 24 8d 4d 80 00 	movl   $0x804d8d,(%esp)
  806307:	e8 cf 05 00 00       	call   8068db <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80630c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806313:	00 
  806314:	8b 03                	mov    (%ebx),%eax
  806316:	8b 40 10             	mov    0x10(%eax),%eax
  806319:	89 04 24             	mov    %eax,(%esp)
  80631c:	e8 e3 8e 00 00       	call   80f204 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  806321:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  806325:	0f be d0             	movsbl %al,%edx
  806328:	89 53 10             	mov    %edx,0x10(%ebx)
  80632b:	89 15 00 90 81 00    	mov    %edx,0x819000
  return err ? -1 : 0;
  806331:	3c 01                	cmp    $0x1,%al
  806333:	19 c0                	sbb    %eax,%eax
  806335:	f7 d0                	not    %eax
}
  806337:	83 c4 3c             	add    $0x3c,%esp
  80633a:	5b                   	pop    %ebx
  80633b:	5e                   	pop    %esi
  80633c:	5f                   	pop    %edi
  80633d:	5d                   	pop    %ebp
  80633e:	c3                   	ret    
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  80633f:	b8 61 00 00 00       	mov    $0x61,%eax
  806344:	eb 80                	jmp    8062c6 <lwip_getsockopt+0x142>
  806346:	b8 61 00 00 00       	mov    $0x61,%eax
  80634b:	e9 76 ff ff ff       	jmp    8062c6 <lwip_getsockopt+0x142>

00806350 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  806350:	55                   	push   %ebp
  806351:	89 e5                	mov    %esp,%ebp
  806353:	57                   	push   %edi
  806354:	56                   	push   %esi
  806355:	53                   	push   %ebx
  806356:	83 ec 3c             	sub    $0x3c,%esp
  806359:	8b 75 0c             	mov    0xc(%ebp),%esi
  80635c:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  80635f:	8b 45 08             	mov    0x8(%ebp),%eax
  806362:	e8 d9 e8 ff ff       	call   804c40 <_ZL10get_socketi>
  806367:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
    return -1;
  806369:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  80636e:	85 db                	test   %ebx,%ebx
  806370:	0f 84 3d 01 00 00    	je     8064b3 <lwip_setsockopt+0x163>
    return -1;

  if (NULL == optval) {
  806376:	85 ff                	test   %edi,%edi
  806378:	75 16                	jne    806390 <lwip_setsockopt+0x40>
    sock_set_errno(sock, EFAULT);
  80637a:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  806381:	c7 05 00 90 81 00 0e 	movl   $0xe,0x819000
  806388:	00 00 00 
    return -1;
  80638b:	e9 23 01 00 00       	jmp    8064b3 <lwip_setsockopt+0x163>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  806390:	83 fe 06             	cmp    $0x6,%esi
  806393:	74 7c                	je     806411 <lwip_setsockopt+0xc1>
  806395:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  80639b:	74 09                	je     8063a6 <lwip_setsockopt+0x56>
  80639d:	85 f6                	test   %esi,%esi
  80639f:	74 56                	je     8063f7 <lwip_setsockopt+0xa7>
  8063a1:	e9 92 00 00 00       	jmp    806438 <lwip_setsockopt+0xe8>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8063a6:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8063aa:	74 18                	je     8063c4 <lwip_setsockopt+0x74>
  8063ac:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  8063b3:	74 1f                	je     8063d4 <lwip_setsockopt+0x84>
#endif /* LWIP_UDP */
      break;
    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, SOL_SOCKET, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  8063b5:	b8 5c 00 00 00       	mov    $0x5c,%eax
  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8063ba:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8063be:	0f 85 80 00 00 00    	jne    806444 <lwip_setsockopt+0xf4>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
        err = EINVAL;
  8063c4:	b8 16 00 00 00       	mov    $0x16,%eax
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  8063c9:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  8063cd:	76 79                	jbe    806448 <lwip_setsockopt+0xf8>
  8063cf:	e9 83 00 00 00       	jmp    806457 <lwip_setsockopt+0x107>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  8063d4:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  8063d8:	19 c0                	sbb    %eax,%eax
  8063da:	83 e0 16             	and    $0x16,%eax
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  8063dd:	8b 13                	mov    (%ebx),%edx
  8063df:	83 3a 20             	cmpl   $0x20,(%edx)
  8063e2:	0f 85 d3 00 00 00    	jne    8064bb <lwip_setsockopt+0x16b>
  8063e8:	8b 52 08             	mov    0x8(%edx),%edx
  8063eb:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  8063ef:	0f 85 cd 00 00 00    	jne    8064c2 <lwip_setsockopt+0x172>
  8063f5:	eb 4d                	jmp    806444 <lwip_setsockopt+0xf4>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  8063f7:	8b 55 10             	mov    0x10(%ebp),%edx
  8063fa:	83 ea 01             	sub    $0x1,%edx
      break;
#endif /* LWIP_IGMP */
      default:
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, UNIMPL: optname=0x%x, ..)\n",
                    s, optname));
        err = ENOPROTOOPT;
  8063fd:	b8 5c 00 00 00       	mov    $0x5c,%eax
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  806402:	83 fa 01             	cmp    $0x1,%edx
  806405:	77 3d                	ja     806444 <lwip_setsockopt+0xf4>
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
        err = EINVAL;
  806407:	b0 16                	mov    $0x16,%al
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  806409:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80640d:	76 39                	jbe    806448 <lwip_setsockopt+0xf8>
  80640f:	eb 46                	jmp    806457 <lwip_setsockopt+0x107>

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
      err = EINVAL;
  806411:	b8 16 00 00 00       	mov    $0x16,%eax
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  806416:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80641a:	76 2c                	jbe    806448 <lwip_setsockopt+0xf8>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80641c:	8b 13                	mov    (%ebx),%edx
      return 0;
  80641e:	b0 00                	mov    $0x0,%al
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  806420:	83 3a 10             	cmpl   $0x10,(%edx)
  806423:	0f 85 8a 00 00 00    	jne    8064b3 <lwip_setsockopt+0x163>
      return 0;

    switch (optname) {
  806429:	8b 55 10             	mov    0x10(%ebp),%edx
  80642c:	83 ea 01             	sub    $0x1,%edx
      break;

    default:
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, UNIMPL: optname=0x%x, ..)\n",
                  s, optname));
      err = ENOPROTOOPT;
  80642f:	b0 5c                	mov    $0x5c,%al

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
      return 0;

    switch (optname) {
  806431:	83 fa 01             	cmp    $0x1,%edx
  806434:	77 12                	ja     806448 <lwip_setsockopt+0xf8>
  806436:	eb 07                	jmp    80643f <lwip_setsockopt+0xef>
#endif /* LWIP_UDP && LWIP_UDPLITE */
/* UNDEFINED LEVEL */
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, level=0x%x, UNIMPL: optname=0x%x, ..)\n",
                s, level, optname));
    err = ENOPROTOOPT;
  806438:	b8 5c 00 00 00       	mov    $0x5c,%eax
  80643d:	eb 05                	jmp    806444 <lwip_setsockopt+0xf4>

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  struct lwip_socket *sock = get_socket(s);
  int err = ERR_OK;
  80643f:	b8 00 00 00 00       	mov    $0x0,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  806444:	85 c0                	test   %eax,%eax
  806446:	74 0f                	je     806457 <lwip_setsockopt+0x107>
    sock_set_errno(sock, err);
  806448:	89 43 10             	mov    %eax,0x10(%ebx)
  80644b:	a3 00 90 81 00       	mov    %eax,0x819000
    return -1;
  806450:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806455:	eb 5c                	jmp    8064b3 <lwip_setsockopt+0x163>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  806457:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  80645a:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  80645d:	8b 45 10             	mov    0x10(%ebp),%eax
  806460:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  806463:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  806466:	8d 45 18             	lea    0x18(%ebp),%eax
  806469:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  80646c:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  806470:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  806477:	00 
  806478:	8d 45 cc             	lea    -0x34(%ebp),%eax
  80647b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80647f:	c7 04 24 80 4c 80 00 	movl   $0x804c80,(%esp)
  806486:	e8 50 04 00 00       	call   8068db <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  80648b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806492:	00 
  806493:	8b 03                	mov    (%ebx),%eax
  806495:	8b 40 10             	mov    0x10(%eax),%eax
  806498:	89 04 24             	mov    %eax,(%esp)
  80649b:	e8 64 8d 00 00       	call   80f204 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  8064a0:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  8064a4:	89 43 10             	mov    %eax,0x10(%ebx)
  8064a7:	a3 00 90 81 00       	mov    %eax,0x819000
  return err ? -1 : 0;
  8064ac:	83 f8 01             	cmp    $0x1,%eax
  8064af:	19 c0                	sbb    %eax,%eax
  8064b1:	f7 d0                	not    %eax
}
  8064b3:	83 c4 3c             	add    $0x3c,%esp
  8064b6:	5b                   	pop    %ebx
  8064b7:	5e                   	pop    %esi
  8064b8:	5f                   	pop    %edi
  8064b9:	5d                   	pop    %ebp
  8064ba:	c3                   	ret    
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
        /* this flag is only available for UDP, not for UDP lite */
        err = EAFNOSUPPORT;
  8064bb:	b8 61 00 00 00       	mov    $0x61,%eax
  8064c0:	eb 86                	jmp    806448 <lwip_setsockopt+0xf8>
  8064c2:	b8 61 00 00 00       	mov    $0x61,%eax
  8064c7:	e9 7c ff ff ff       	jmp    806448 <lwip_setsockopt+0xf8>

008064cc <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8064cc:	55                   	push   %ebp
  8064cd:	89 e5                	mov    %esp,%ebp
  8064cf:	56                   	push   %esi
  8064d0:	53                   	push   %ebx
  8064d1:	8b 75 0c             	mov    0xc(%ebp),%esi
  8064d4:	8b 5d 10             	mov    0x10(%ebp),%ebx
  struct lwip_socket *sock = get_socket(s);
  8064d7:	8b 45 08             	mov    0x8(%ebp),%eax
  8064da:	e8 61 e7 ff ff       	call   804c40 <_ZL10get_socketi>
  u16_t buflen = 0;

  if (!sock)
    return -1;
  8064df:	ba ff ff ff ff       	mov    $0xffffffff,%edx
lwip_ioctl(int s, long cmd, void *argp)
{
  struct lwip_socket *sock = get_socket(s);
  u16_t buflen = 0;

  if (!sock)
  8064e4:	85 c0                	test   %eax,%eax
  8064e6:	0f 84 a1 00 00 00    	je     80658d <lwip_ioctl+0xc1>
    return -1;

  switch (cmd) {
  8064ec:	81 fe 7e 66 04 80    	cmp    $0x8004667e,%esi
  8064f2:	74 54                	je     806548 <lwip_ioctl+0x7c>
  8064f4:	81 fe 7f 66 04 40    	cmp    $0x4004667f,%esi
  8064fa:	75 7b                	jne    806577 <lwip_ioctl+0xab>
  case FIONREAD:
    if (!argp) {
  8064fc:	85 db                	test   %ebx,%ebx
  8064fe:	75 13                	jne    806513 <lwip_ioctl+0x47>
      sock_set_errno(sock, EINVAL);
  806500:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  806507:	c7 05 00 90 81 00 16 	movl   $0x16,0x819000
  80650e:	00 00 00 
      return -1;
  806511:	eb 7a                	jmp    80658d <lwip_ioctl+0xc1>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  806513:	8b 10                	mov    (%eax),%edx
  806515:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  806519:	66 89 13             	mov    %dx,(%ebx)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  80651c:	8b 48 04             	mov    0x4(%eax),%ecx
  80651f:	85 c9                	test   %ecx,%ecx
  806521:	74 0d                	je     806530 <lwip_ioctl+0x64>
      buflen = netbuf_len(sock->lastdata);
  806523:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;
  806525:	66 03 51 08          	add    0x8(%ecx),%dx

      *((u16_t*)argp) += buflen;
  806529:	66 2b 50 08          	sub    0x8(%eax),%dx
  80652d:	66 89 13             	mov    %dx,(%ebx)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  806530:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  806537:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  80653e:	00 00 00 
    return 0;
  806541:	ba 00 00 00 00       	mov    $0x0,%edx
  806546:	eb 45                	jmp    80658d <lwip_ioctl+0xc1>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  806548:	85 db                	test   %ebx,%ebx
  80654a:	74 0d                	je     806559 <lwip_ioctl+0x8d>
  80654c:	83 3b 00             	cmpl   $0x0,(%ebx)
  80654f:	74 08                	je     806559 <lwip_ioctl+0x8d>
      sock->flags |= O_NONBLOCK;
  806551:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
  806557:	eb 06                	jmp    80655f <lwip_ioctl+0x93>
    else
      sock->flags &= ~O_NONBLOCK;
  806559:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  80655f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  806566:	c7 05 00 90 81 00 00 	movl   $0x0,0x819000
  80656d:	00 00 00 
    return 0;
  806570:	ba 00 00 00 00       	mov    $0x0,%edx
  806575:	eb 16                	jmp    80658d <lwip_ioctl+0xc1>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  806577:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  80657e:	c7 05 00 90 81 00 26 	movl   $0x26,0x819000
  806585:	00 00 00 
    return -1;
  806588:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  } /* switch (cmd) */
}
  80658d:	89 d0                	mov    %edx,%eax
  80658f:	5b                   	pop    %ebx
  806590:	5e                   	pop    %esi
  806591:	5d                   	pop    %ebp
  806592:	c3                   	ret    
	...

008065a0 <_ZL13pbuf_free_intPv>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  8065a0:	55                   	push   %ebp
  8065a1:	89 e5                	mov    %esp,%ebp
  8065a3:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = (struct pbuf *) p;
  pbuf_free(q);
  8065a6:	8b 45 08             	mov    0x8(%ebp),%eax
  8065a9:	89 04 24             	mov    %eax,(%esp)
  8065ac:	e8 52 2c 00 00       	call   809203 <pbuf_free>
}
  8065b1:	c9                   	leave  
  8065b2:	c3                   	ret    

008065b3 <_ZL12tcpip_threadPv>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  8065b3:	55                   	push   %ebp
  8065b4:	89 e5                	mov    %esp,%ebp
  8065b6:	53                   	push   %ebx
  8065b7:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8065ba:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8065c1:	00 
  8065c2:	c7 44 24 04 ad 67 80 	movl   $0x8067ad,0x4(%esp)
  8065c9:	00 
  8065ca:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  8065d1:	e8 6f 36 00 00       	call   809c45 <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  8065d6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8065dd:	00 
  8065de:	c7 44 24 04 84 67 80 	movl   $0x806784,0x4(%esp)
  8065e5:	00 
  8065e6:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8065ed:	e8 53 36 00 00       	call   809c45 <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8065f2:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8065f9:	00 
  8065fa:	c7 44 24 04 5b 67 80 	movl   $0x80675b,0x4(%esp)
  806601:	00 
  806602:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  806609:	e8 37 36 00 00       	call   809c45 <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80660e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806615:	00 
  806616:	c7 44 24 04 32 67 80 	movl   $0x806732,0x4(%esp)
  80661d:	00 
  80661e:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  806625:	e8 1b 36 00 00       	call   809c45 <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  80662a:	a1 cc b2 81 00       	mov    0x81b2cc,%eax
  80662f:	85 c0                	test   %eax,%eax
  806631:	74 0b                	je     80663e <_ZL12tcpip_threadPv+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  806633:	8b 15 d0 b2 81 00    	mov    0x81b2d0,%edx
  806639:	89 14 24             	mov    %edx,(%esp)
  80663c:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void **)&msg);
  80663e:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  806641:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806645:	a1 74 80 81 00       	mov    0x818074,%eax
  80664a:	89 04 24             	mov    %eax,(%esp)
  80664d:	e8 cb 34 00 00       	call   809b1d <sys_mbox_fetch>
    switch (msg->type) {
  806652:	8b 55 f4             	mov    -0xc(%ebp),%edx
  806655:	8b 02                	mov    (%edx),%eax
  806657:	83 f8 01             	cmp    $0x1,%eax
  80665a:	74 2a                	je     806686 <_ZL12tcpip_threadPv+0xd3>
  80665c:	83 f8 01             	cmp    $0x1,%eax
  80665f:	7f 06                	jg     806667 <_ZL12tcpip_threadPv+0xb4>
  806661:	85 c0                	test   %eax,%eax
  806663:	74 14                	je     806679 <_ZL12tcpip_threadPv+0xc6>
  806665:	eb da                	jmp    806641 <_ZL12tcpip_threadPv+0x8e>
  806667:	83 f8 02             	cmp    $0x2,%eax
  80666a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  806670:	74 55                	je     8066c7 <_ZL12tcpip_threadPv+0x114>
  806672:	83 f8 03             	cmp    $0x3,%eax
  806675:	75 ca                	jne    806641 <_ZL12tcpip_threadPv+0x8e>
  806677:	eb 6f                	jmp    8066e8 <_ZL12tcpip_threadPv+0x135>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  806679:	8b 42 08             	mov    0x8(%edx),%eax
  80667c:	8d 50 04             	lea    0x4(%eax),%edx
  80667f:	89 14 24             	mov    %edx,(%esp)
  806682:	ff 10                	call   *(%eax)
      break;
  806684:	eb bb                	jmp    806641 <_ZL12tcpip_threadPv+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  806686:	8b 42 0c             	mov    0xc(%edx),%eax
  806689:	f6 40 2e 20          	testb  $0x20,0x2e(%eax)
  80668d:	74 11                	je     8066a0 <_ZL12tcpip_threadPv+0xed>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  80668f:	89 44 24 04          	mov    %eax,0x4(%esp)
  806693:	8b 42 08             	mov    0x8(%edx),%eax
  806696:	89 04 24             	mov    %eax,(%esp)
  806699:	e8 95 84 00 00       	call   80eb33 <ethernet_input>
  80669e:	eb 0f                	jmp    8066af <_ZL12tcpip_threadPv+0xfc>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  8066a0:	89 44 24 04          	mov    %eax,0x4(%esp)
  8066a4:	8b 42 08             	mov    0x8(%edx),%eax
  8066a7:	89 04 24             	mov    %eax,(%esp)
  8066aa:	e8 ca 49 00 00       	call   80b079 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8066af:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8066b2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8066b6:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8066bd:	e8 7f 27 00 00       	call   808e41 <memp_free>
      break;
  8066c2:	e9 7a ff ff ff       	jmp    806641 <_ZL12tcpip_threadPv+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  8066c7:	8b 42 0c             	mov    0xc(%edx),%eax
  8066ca:	89 04 24             	mov    %eax,(%esp)
  8066cd:	ff 52 08             	call   *0x8(%edx)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8066d0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8066d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8066d7:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8066de:	e8 5e 27 00 00       	call   808e41 <memp_free>
      break;
  8066e3:	e9 59 ff ff ff       	jmp    806641 <_ZL12tcpip_threadPv+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  8066e8:	8b 42 08             	mov    0x8(%edx),%eax
  8066eb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8066ee:	74 18                	je     806708 <_ZL12tcpip_threadPv+0x155>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  8066f0:	8b 4a 10             	mov    0x10(%edx),%ecx
  8066f3:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  8066f7:	8b 52 0c             	mov    0xc(%edx),%edx
  8066fa:	89 54 24 04          	mov    %edx,0x4(%esp)
  8066fe:	89 04 24             	mov    %eax,(%esp)
  806701:	e8 3f 35 00 00       	call   809c45 <sys_timeout>
  806706:	eb 12                	jmp    80671a <_ZL12tcpip_threadPv+0x167>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  806708:	8b 42 10             	mov    0x10(%edx),%eax
  80670b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80670f:	8b 42 0c             	mov    0xc(%edx),%eax
  806712:	89 04 24             	mov    %eax,(%esp)
  806715:	e8 03 36 00 00       	call   809d1d <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  80671a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80671d:	89 44 24 04          	mov    %eax,0x4(%esp)
  806721:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  806728:	e8 14 27 00 00       	call   808e41 <memp_free>
  80672d:	e9 0f ff ff ff       	jmp    806641 <_ZL12tcpip_threadPv+0x8e>

00806732 <_ZL15dhcp_timer_finePv>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  806732:	55                   	push   %ebp
  806733:	89 e5                	mov    %esp,%ebp
  806735:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  806738:	e8 3d 1e 00 00       	call   80857a <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  80673d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806744:	00 
  806745:	c7 44 24 04 32 67 80 	movl   $0x806732,0x4(%esp)
  80674c:	00 
  80674d:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  806754:	e8 ec 34 00 00       	call   809c45 <sys_timeout>
}
  806759:	c9                   	leave  
  80675a:	c3                   	ret    

0080675b <_ZL17dhcp_timer_coarsePv>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  80675b:	55                   	push   %ebp
  80675c:	89 e5                	mov    %esp,%ebp
  80675e:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  806761:	e8 2c 1c 00 00       	call   808392 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  806766:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80676d:	00 
  80676e:	c7 44 24 04 5b 67 80 	movl   $0x80675b,0x4(%esp)
  806775:	00 
  806776:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80677d:	e8 c3 34 00 00       	call   809c45 <sys_timeout>
}
  806782:	c9                   	leave  
  806783:	c3                   	ret    

00806784 <_ZL9arp_timerPv>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  806784:	55                   	push   %ebp
  806785:	89 e5                	mov    %esp,%ebp
  806787:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  80678a:	e8 0c 7c 00 00       	call   80e39b <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  80678f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806796:	00 
  806797:	c7 44 24 04 84 67 80 	movl   $0x806784,0x4(%esp)
  80679e:	00 
  80679f:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  8067a6:	e8 9a 34 00 00       	call   809c45 <sys_timeout>
}
  8067ab:	c9                   	leave  
  8067ac:	c3                   	ret    

008067ad <_ZL14ip_reass_timerPv>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  8067ad:	55                   	push   %ebp
  8067ae:	89 e5                	mov    %esp,%ebp
  8067b0:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  8067b3:	e8 c3 4f 00 00       	call   80b77b <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  8067b8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8067bf:	00 
  8067c0:	c7 44 24 04 ad 67 80 	movl   $0x8067ad,0x4(%esp)
  8067c7:	00 
  8067c8:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  8067cf:	e8 71 34 00 00       	call   809c45 <sys_timeout>
}
  8067d4:	c9                   	leave  
  8067d5:	c3                   	ret    

008067d6 <_ZL15tcpip_tcp_timerPv>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  8067d6:	55                   	push   %ebp
  8067d7:	89 e5                	mov    %esp,%ebp
  8067d9:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  8067dc:	e8 ed 42 00 00       	call   80aace <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  8067e1:	83 3d dc a3 b3 00 00 	cmpl   $0x0,0xb3a3dc
  8067e8:	75 09                	jne    8067f3 <_ZL15tcpip_tcp_timerPv+0x1d>
  8067ea:	83 3d e0 a3 b3 00 00 	cmpl   $0x0,0xb3a3e0
  8067f1:	74 1e                	je     806811 <_ZL15tcpip_tcp_timerPv+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  8067f3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8067fa:	00 
  8067fb:	c7 44 24 04 d6 67 80 	movl   $0x8067d6,0x4(%esp)
  806802:	00 
  806803:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80680a:	e8 36 34 00 00       	call   809c45 <sys_timeout>
  80680f:	eb 0a                	jmp    80681b <_ZL15tcpip_tcp_timerPv+0x45>
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  806811:	c7 05 d4 b2 81 00 00 	movl   $0x0,0x81b2d4
  806818:	00 00 00 
  }
}
  80681b:	c9                   	leave  
  80681c:	c3                   	ret    

0080681d <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  80681d:	55                   	push   %ebp
  80681e:	89 e5                	mov    %esp,%ebp
  806820:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  806823:	83 3d d4 b2 81 00 00 	cmpl   $0x0,0x81b2d4
  80682a:	75 38                	jne    806864 <tcp_timer_needed+0x47>
  80682c:	83 3d dc a3 b3 00 00 	cmpl   $0x0,0xb3a3dc
  806833:	75 09                	jne    80683e <tcp_timer_needed+0x21>
  806835:	83 3d e0 a3 b3 00 00 	cmpl   $0x0,0xb3a3e0
  80683c:	74 26                	je     806864 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80683e:	c7 05 d4 b2 81 00 01 	movl   $0x1,0x81b2d4
  806845:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  806848:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80684f:	00 
  806850:	c7 44 24 04 d6 67 80 	movl   $0x8067d6,0x4(%esp)
  806857:	00 
  806858:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80685f:	e8 e1 33 00 00       	call   809c45 <sys_timeout>
  }
}
  806864:	c9                   	leave  
  806865:	c3                   	ret    

00806866 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  806866:	55                   	push   %ebp
  806867:	89 e5                	mov    %esp,%ebp
  806869:	53                   	push   %ebx
  80686a:	83 ec 14             	sub    $0x14,%esp
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
  80686d:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  806872:	83 3d 74 80 81 00 ff 	cmpl   $0xffffffff,0x818074
  806879:	74 5a                	je     8068d5 <tcpip_input+0x6f>
    msg = (struct tcpip_msg *) memp_malloc(MEMP_TCPIP_MSG_INPKT);
  80687b:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  806882:	e8 5a 25 00 00       	call   808de1 <memp_malloc>
  806887:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
      return ERR_MEM;
  806889:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = (struct tcpip_msg *) memp_malloc(MEMP_TCPIP_MSG_INPKT);
    if (msg == NULL) {
  80688e:	85 db                	test   %ebx,%ebx
  806890:	74 43                	je     8068d5 <tcpip_input+0x6f>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  806892:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
    msg->msg.inp.p = p;
  806898:	8b 45 08             	mov    0x8(%ebp),%eax
  80689b:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  80689e:	8b 45 0c             	mov    0xc(%ebp),%eax
  8068a1:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  8068a4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8068a8:	a1 74 80 81 00       	mov    0x818074,%eax
  8068ad:	89 04 24             	mov    %eax,(%esp)
  8068b0:	e8 95 8a 00 00       	call   80f34a <sys_mbox_trypost>
  8068b5:	84 c0                	test   %al,%al
  8068b7:	74 17                	je     8068d0 <tcpip_input+0x6a>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  8068b9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8068bd:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  8068c4:	e8 78 25 00 00       	call   808e41 <memp_free>
      return ERR_MEM;
  8068c9:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8068ce:	eb 05                	jmp    8068d5 <tcpip_input+0x6f>
    }
    return ERR_OK;
  8068d0:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  8068d5:	83 c4 14             	add    $0x14,%esp
  8068d8:	5b                   	pop    %ebx
  8068d9:	5d                   	pop    %ebp
  8068da:	c3                   	ret    

008068db <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  8068db:	55                   	push   %ebp
  8068dc:	89 e5                	mov    %esp,%ebp
  8068de:	83 ec 18             	sub    $0x18,%esp
  8068e1:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8068e4:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8068e7:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
        return ERR_MEM;
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
  8068eb:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8068f0:	83 3d 74 80 81 00 ff 	cmpl   $0xffffffff,0x818074
  8068f7:	74 76                	je     80696f <tcpip_callback_with_block+0x94>
    msg =  (struct tcpip_msg *) memp_malloc(MEMP_TCPIP_MSG_API);
  8068f9:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  806900:	e8 dc 24 00 00       	call   808de1 <memp_malloc>
  806905:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
      return ERR_MEM;
  806907:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg =  (struct tcpip_msg *) memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
  80690c:	85 f6                	test   %esi,%esi
  80690e:	74 5f                	je     80696f <tcpip_callback_with_block+0x94>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  806910:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
    msg->msg.cb.f = f;
  806916:	8b 45 08             	mov    0x8(%ebp),%eax
  806919:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  80691c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80691f:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  806922:	84 db                	test   %bl,%bl
  806924:	74 18                	je     80693e <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  806926:	89 74 24 04          	mov    %esi,0x4(%esp)
  80692a:	a1 74 80 81 00       	mov    0x818074,%eax
  80692f:	89 04 24             	mov    %eax,(%esp)
  806932:	e8 db 8a 00 00       	call   80f412 <sys_mbox_post>
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
        memp_free(MEMP_TCPIP_MSG_API, msg);
        return ERR_MEM;
      }
    }
    return ERR_OK;
  806937:	b8 00 00 00 00       	mov    $0x0,%eax
  80693c:	eb 31                	jmp    80696f <tcpip_callback_with_block+0x94>
    msg->msg.cb.f = f;
    msg->msg.cb.ctx = ctx;
    if (block) {
      sys_mbox_post(mbox, msg);
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  80693e:	89 74 24 04          	mov    %esi,0x4(%esp)
  806942:	a1 74 80 81 00       	mov    0x818074,%eax
  806947:	89 04 24             	mov    %eax,(%esp)
  80694a:	e8 fb 89 00 00       	call   80f34a <sys_mbox_trypost>
  80694f:	84 c0                	test   %al,%al
  806951:	74 17                	je     80696a <tcpip_callback_with_block+0x8f>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  806953:	89 74 24 04          	mov    %esi,0x4(%esp)
  806957:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80695e:	e8 de 24 00 00       	call   808e41 <memp_free>
        return ERR_MEM;
  806963:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806968:	eb 05                	jmp    80696f <tcpip_callback_with_block+0x94>
      }
    }
    return ERR_OK;
  80696a:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  80696f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806972:	8b 75 fc             	mov    -0x4(%ebp),%esi
  806975:	89 ec                	mov    %ebp,%esp
  806977:	5d                   	pop    %ebp
  806978:	c3                   	ret    

00806979 <tcpip_timeout>:

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  806979:	55                   	push   %ebp
  80697a:	89 e5                	mov    %esp,%ebp
  80697c:	83 ec 18             	sub    $0x18,%esp
    msg->msg.tmo.h = h;
    msg->msg.tmo.arg = arg;
    sys_mbox_post(mbox, msg);
    return ERR_OK;
  }
  return ERR_VAL;
  80697f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  806984:	83 3d 74 80 81 00 ff 	cmpl   $0xffffffff,0x818074
  80698b:	74 45                	je     8069d2 <tcpip_timeout+0x59>
    msg = (struct tcpip_msg *) memp_malloc(MEMP_TCPIP_MSG_API);
  80698d:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  806994:	e8 48 24 00 00       	call   808de1 <memp_malloc>
  806999:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
      return ERR_MEM;
  80699b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
{
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
    msg = (struct tcpip_msg *) memp_malloc(MEMP_TCPIP_MSG_API);
    if (msg == NULL) {
  8069a0:	85 d2                	test   %edx,%edx
  8069a2:	74 2e                	je     8069d2 <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8069a4:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  8069aa:	8b 45 08             	mov    0x8(%ebp),%eax
  8069ad:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  8069b0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8069b3:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  8069b6:	8b 45 10             	mov    0x10(%ebp),%eax
  8069b9:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  8069bc:	89 54 24 04          	mov    %edx,0x4(%esp)
  8069c0:	a1 74 80 81 00       	mov    0x818074,%eax
  8069c5:	89 04 24             	mov    %eax,(%esp)
  8069c8:	e8 45 8a 00 00       	call   80f412 <sys_mbox_post>
    return ERR_OK;
  8069cd:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  8069d2:	c9                   	leave  
  8069d3:	c3                   	ret    

008069d4 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  8069d4:	55                   	push   %ebp
  8069d5:	89 e5                	mov    %esp,%ebp
  8069d7:	53                   	push   %ebx
  8069d8:	83 ec 34             	sub    $0x34,%esp
  8069db:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8069de:	8b 15 74 80 81 00    	mov    0x818074,%edx
    msg.msg.apimsg = apimsg;
    sys_mbox_post(mbox, &msg);
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
    return ERR_OK;
  }
  return ERR_VAL;
  8069e4:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  8069e9:	83 fa ff             	cmp    $0xffffffff,%edx
  8069ec:	74 34                	je     806a22 <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  8069ee:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  8069f5:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  8069f8:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8069fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8069ff:	89 14 24             	mov    %edx,(%esp)
  806a02:	e8 0b 8a 00 00       	call   80f412 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  806a07:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806a0e:	00 
  806a0f:	8b 43 04             	mov    0x4(%ebx),%eax
  806a12:	8b 40 10             	mov    0x10(%eax),%eax
  806a15:	89 04 24             	mov    %eax,(%esp)
  806a18:	e8 e7 87 00 00       	call   80f204 <sys_arch_sem_wait>
    return ERR_OK;
  806a1d:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return ERR_VAL;
}
  806a22:	83 c4 34             	add    $0x34,%esp
  806a25:	5b                   	pop    %ebx
  806a26:	5d                   	pop    %ebp
  806a27:	c3                   	ret    

00806a28 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  806a28:	55                   	push   %ebp
  806a29:	89 e5                	mov    %esp,%ebp
  806a2b:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  806a2e:	e8 fd 03 00 00       	call   806e30 <lwip_init>

  tcpip_init_done = initfunc;
  806a33:	8b 45 08             	mov    0x8(%ebp),%eax
  806a36:	a3 cc b2 81 00       	mov    %eax,0x81b2cc
  tcpip_init_done_arg = arg;
  806a3b:	8b 45 0c             	mov    0xc(%ebp),%eax
  806a3e:	a3 d0 b2 81 00       	mov    %eax,0x81b2d0
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  806a43:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806a4a:	e8 ed 85 00 00       	call   80f03c <sys_mbox_new>
  806a4f:	a3 74 80 81 00       	mov    %eax,0x818074
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  806a54:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  806a5b:	00 
  806a5c:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  806a63:	00 
  806a64:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806a6b:	00 
  806a6c:	c7 44 24 04 b3 65 80 	movl   $0x8065b3,0x4(%esp)
  806a73:	00 
  806a74:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  806a7b:	e8 ff 8a 00 00       	call   80f57f <sys_thread_new>
}
  806a80:	c9                   	leave  
  806a81:	c3                   	ret    

00806a82 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  806a82:	55                   	push   %ebp
  806a83:	89 e5                	mov    %esp,%ebp
  806a85:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  806a88:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806a8f:	00 
  806a90:	8b 45 08             	mov    0x8(%ebp),%eax
  806a93:	89 44 24 04          	mov    %eax,0x4(%esp)
  806a97:	c7 04 24 a0 65 80 00 	movl   $0x8065a0,(%esp)
  806a9e:	e8 38 fe ff ff       	call   8068db <tcpip_callback_with_block>
}
  806aa3:	c9                   	leave  
  806aa4:	c3                   	ret    

00806aa5 <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  806aa5:	55                   	push   %ebp
  806aa6:	89 e5                	mov    %esp,%ebp
  806aa8:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  806aab:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806ab2:	00 
  806ab3:	8b 45 08             	mov    0x8(%ebp),%eax
  806ab6:	89 44 24 04          	mov    %eax,0x4(%esp)
  806aba:	c7 04 24 48 88 80 00 	movl   $0x808848,(%esp)
  806ac1:	e8 15 fe ff ff       	call   8068db <tcpip_callback_with_block>
}
  806ac6:	c9                   	leave  
  806ac7:	c3                   	ret    

00806ac8 <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  806ac8:	55                   	push   %ebp
  806ac9:	89 e5                	mov    %esp,%ebp
  806acb:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = (struct netbuf *) memp_malloc(MEMP_NETBUF);
  806ace:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  806ad5:	e8 07 23 00 00       	call   808de1 <memp_malloc>
  if (buf != NULL) {
  806ada:	85 c0                	test   %eax,%eax
  806adc:	74 14                	je     806af2 <netbuf_new+0x2a>
    buf->p = NULL;
  806ade:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  806ae4:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  806aeb:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  806af2:	c9                   	leave  
  806af3:	c3                   	ret    

00806af4 <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  806af4:	55                   	push   %ebp
  806af5:	89 e5                	mov    %esp,%ebp
  806af7:	53                   	push   %ebx
  806af8:	83 ec 14             	sub    $0x14,%esp
  806afb:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  806afe:	85 db                	test   %ebx,%ebx
  806b00:	74 2b                	je     806b2d <netbuf_delete+0x39>
    if (buf->p != NULL) {
  806b02:	8b 03                	mov    (%ebx),%eax
  806b04:	85 c0                	test   %eax,%eax
  806b06:	74 15                	je     806b1d <netbuf_delete+0x29>
      pbuf_free(buf->p);
  806b08:	89 04 24             	mov    %eax,(%esp)
  806b0b:	e8 f3 26 00 00       	call   809203 <pbuf_free>
      buf->p = buf->ptr = NULL;
  806b10:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  806b17:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  806b1d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  806b21:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  806b28:	e8 14 23 00 00       	call   808e41 <memp_free>
  }
}
  806b2d:	83 c4 14             	add    $0x14,%esp
  806b30:	5b                   	pop    %ebx
  806b31:	5d                   	pop    %ebp
  806b32:	c3                   	ret    

00806b33 <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  806b33:	55                   	push   %ebp
  806b34:	89 e5                	mov    %esp,%ebp
  806b36:	56                   	push   %esi
  806b37:	53                   	push   %ebx
  806b38:	83 ec 10             	sub    $0x10,%esp
  806b3b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806b3e:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  806b42:	85 db                	test   %ebx,%ebx
  806b44:	75 1c                	jne    806b62 <netbuf_alloc+0x2f>
  806b46:	c7 44 24 08 49 52 81 	movl   $0x815249,0x8(%esp)
  806b4d:	00 
  806b4e:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  806b55:	00 
  806b56:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806b5d:	e8 56 9e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  806b62:	8b 03                	mov    (%ebx),%eax
  806b64:	85 c0                	test   %eax,%eax
  806b66:	74 08                	je     806b70 <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  806b68:	89 04 24             	mov    %eax,(%esp)
  806b6b:	e8 93 26 00 00       	call   809203 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  806b70:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806b77:	00 
  806b78:	0f b7 c6             	movzwl %si,%eax
  806b7b:	89 44 24 04          	mov    %eax,0x4(%esp)
  806b7f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806b86:	e8 9a 28 00 00       	call   809425 <pbuf_alloc>
  806b8b:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  806b8d:	85 c0                	test   %eax,%eax
  806b8f:	74 2a                	je     806bbb <netbuf_alloc+0x88>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  806b91:	66 3b 70 0a          	cmp    0xa(%eax),%si
  806b95:	76 1c                	jbe    806bb3 <netbuf_alloc+0x80>
  806b97:	c7 44 24 08 30 53 81 	movl   $0x815330,0x8(%esp)
  806b9e:	00 
  806b9f:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  806ba6:	00 
  806ba7:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806bae:	e8 05 9e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  806bb3:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  806bb6:	8b 40 04             	mov    0x4(%eax),%eax
  806bb9:	eb 05                	jmp    806bc0 <netbuf_alloc+0x8d>
  if (buf->p != NULL) {
    pbuf_free(buf->p);
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  if (buf->p == NULL) {
     return NULL;
  806bbb:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  LWIP_ASSERT("check that first pbuf can hold size",
             (buf->p->len >= size));
  buf->ptr = buf->p;
  return buf->p->payload;
}
  806bc0:	83 c4 10             	add    $0x10,%esp
  806bc3:	5b                   	pop    %ebx
  806bc4:	5e                   	pop    %esi
  806bc5:	5d                   	pop    %ebp
  806bc6:	c3                   	ret    

00806bc7 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  806bc7:	55                   	push   %ebp
  806bc8:	89 e5                	mov    %esp,%ebp
  806bca:	53                   	push   %ebx
  806bcb:	83 ec 14             	sub    $0x14,%esp
  806bce:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  806bd1:	85 db                	test   %ebx,%ebx
  806bd3:	75 1c                	jne    806bf1 <netbuf_free+0x2a>
  806bd5:	c7 44 24 08 79 52 81 	movl   $0x815279,0x8(%esp)
  806bdc:	00 
  806bdd:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  806be4:	00 
  806be5:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806bec:	e8 c7 9d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (buf->p != NULL) {
  806bf1:	8b 03                	mov    (%ebx),%eax
  806bf3:	85 c0                	test   %eax,%eax
  806bf5:	74 08                	je     806bff <netbuf_free+0x38>
    pbuf_free(buf->p);
  806bf7:	89 04 24             	mov    %eax,(%esp)
  806bfa:	e8 04 26 00 00       	call   809203 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  806bff:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  806c06:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  806c0c:	83 c4 14             	add    $0x14,%esp
  806c0f:	5b                   	pop    %ebx
  806c10:	5d                   	pop    %ebp
  806c11:	c3                   	ret    

00806c12 <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  806c12:	55                   	push   %ebp
  806c13:	89 e5                	mov    %esp,%ebp
  806c15:	56                   	push   %esi
  806c16:	53                   	push   %ebx
  806c17:	83 ec 10             	sub    $0x10,%esp
  806c1a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806c1d:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  806c21:	85 db                	test   %ebx,%ebx
  806c23:	75 1c                	jne    806c41 <netbuf_ref+0x2f>
  806c25:	c7 44 24 08 92 52 81 	movl   $0x815292,0x8(%esp)
  806c2c:	00 
  806c2d:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  806c34:	00 
  806c35:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806c3c:	e8 77 9d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (buf->p != NULL) {
  806c41:	8b 03                	mov    (%ebx),%eax
  806c43:	85 c0                	test   %eax,%eax
  806c45:	74 08                	je     806c4f <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  806c47:	89 04 24             	mov    %eax,(%esp)
  806c4a:	e8 b4 25 00 00       	call   809203 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  806c4f:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  806c56:	00 
  806c57:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806c5e:	00 
  806c5f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806c66:	e8 ba 27 00 00       	call   809425 <pbuf_alloc>
  806c6b:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  806c6d:	85 c0                	test   %eax,%eax
  806c6f:	75 0e                	jne    806c7f <netbuf_ref+0x6d>
    buf->ptr = NULL;
  806c71:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    return ERR_MEM;
  806c78:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  806c7d:	eb 1a                	jmp    806c99 <netbuf_ref+0x87>
  }
  buf->p->payload = (void*)dataptr;
  806c7f:	8b 55 0c             	mov    0xc(%ebp),%edx
  806c82:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  806c85:	8b 03                	mov    (%ebx),%eax
  806c87:	66 89 70 08          	mov    %si,0x8(%eax)
  806c8b:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  806c8f:	8b 03                	mov    (%ebx),%eax
  806c91:	89 43 04             	mov    %eax,0x4(%ebx)
  return ERR_OK;
  806c94:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806c99:	83 c4 10             	add    $0x10,%esp
  806c9c:	5b                   	pop    %ebx
  806c9d:	5e                   	pop    %esi
  806c9e:	5d                   	pop    %ebp
  806c9f:	c3                   	ret    

00806ca0 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  806ca0:	55                   	push   %ebp
  806ca1:	89 e5                	mov    %esp,%ebp
  806ca3:	83 ec 18             	sub    $0x18,%esp
  806ca6:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806ca9:	89 75 fc             	mov    %esi,-0x4(%ebp)
  806cac:	8b 5d 08             	mov    0x8(%ebp),%ebx
  806caf:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  806cb2:	85 db                	test   %ebx,%ebx
  806cb4:	75 1c                	jne    806cd2 <netbuf_chain+0x32>
  806cb6:	c7 44 24 08 aa 52 81 	movl   $0x8152aa,0x8(%esp)
  806cbd:	00 
  806cbe:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  806cc5:	00 
  806cc6:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806ccd:	e8 e6 9c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  806cd2:	85 f6                	test   %esi,%esi
  806cd4:	75 1c                	jne    806cf2 <netbuf_chain+0x52>
  806cd6:	c7 44 24 08 c3 52 81 	movl   $0x8152c3,0x8(%esp)
  806cdd:	00 
  806cde:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  806ce5:	00 
  806ce6:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806ced:	e8 c6 9c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  pbuf_chain(head->p, tail->p);
  806cf2:	8b 06                	mov    (%esi),%eax
  806cf4:	89 44 24 04          	mov    %eax,0x4(%esp)
  806cf8:	8b 03                	mov    (%ebx),%eax
  806cfa:	89 04 24             	mov    %eax,(%esp)
  806cfd:	e8 a3 2a 00 00       	call   8097a5 <pbuf_chain>
  head->ptr = head->p;
  806d02:	8b 03                	mov    (%ebx),%eax
  806d04:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  806d07:	89 74 24 04          	mov    %esi,0x4(%esp)
  806d0b:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  806d12:	e8 2a 21 00 00       	call   808e41 <memp_free>
}
  806d17:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806d1a:	8b 75 fc             	mov    -0x4(%ebp),%esi
  806d1d:	89 ec                	mov    %ebp,%esp
  806d1f:	5d                   	pop    %ebp
  806d20:	c3                   	ret    

00806d21 <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  806d21:	55                   	push   %ebp
  806d22:	89 e5                	mov    %esp,%ebp
  806d24:	56                   	push   %esi
  806d25:	53                   	push   %ebx
  806d26:	83 ec 10             	sub    $0x10,%esp
  806d29:	8b 55 08             	mov    0x8(%ebp),%edx
  806d2c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  806d2f:	8b 4d 10             	mov    0x10(%ebp),%ecx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  806d32:	85 d2                	test   %edx,%edx
  806d34:	75 1c                	jne    806d52 <netbuf_data+0x31>
  806d36:	c7 44 24 08 de 52 81 	movl   $0x8152de,0x8(%esp)
  806d3d:	00 
  806d3e:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  806d45:	00 
  806d46:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806d4d:	e8 66 9c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  806d52:	85 db                	test   %ebx,%ebx
  806d54:	75 1c                	jne    806d72 <netbuf_data+0x51>
  806d56:	c7 44 24 08 f7 52 81 	movl   $0x8152f7,0x8(%esp)
  806d5d:	00 
  806d5e:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  806d65:	00 
  806d66:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806d6d:	e8 46 9c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  806d72:	85 c9                	test   %ecx,%ecx
  806d74:	75 1c                	jne    806d92 <netbuf_data+0x71>
  806d76:	c7 44 24 08 14 53 81 	movl   $0x815314,0x8(%esp)
  806d7d:	00 
  806d7e:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  806d85:	00 
  806d86:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806d8d:	e8 26 9c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  if (buf->ptr == NULL) {
  806d92:	8b 72 04             	mov    0x4(%edx),%esi
    return ERR_BUF;
  806d95:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
{
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);

  if (buf->ptr == NULL) {
  806d9a:	85 f6                	test   %esi,%esi
  806d9c:	74 14                	je     806db2 <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  806d9e:	8b 46 04             	mov    0x4(%esi),%eax
  806da1:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  806da3:	8b 42 04             	mov    0x4(%edx),%eax
  806da6:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  806daa:	66 89 01             	mov    %ax,(%ecx)
  return ERR_OK;
  806dad:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806db2:	83 c4 10             	add    $0x10,%esp
  806db5:	5b                   	pop    %ebx
  806db6:	5e                   	pop    %esi
  806db7:	5d                   	pop    %ebp
  806db8:	c3                   	ret    

00806db9 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  806db9:	55                   	push   %ebp
  806dba:	89 e5                	mov    %esp,%ebp
  806dbc:	83 ec 18             	sub    $0x18,%esp
  806dbf:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  806dc2:	85 d2                	test   %edx,%edx
  806dc4:	75 1c                	jne    806de2 <netbuf_next+0x29>
  806dc6:	c7 44 24 08 79 52 81 	movl   $0x815279,0x8(%esp)
  806dcd:	00 
  806dce:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  806dd5:	00 
  806dd6:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806ddd:	e8 d6 9b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (buf->ptr->next == NULL) {
  806de2:	8b 42 04             	mov    0x4(%edx),%eax
  806de5:	8b 08                	mov    (%eax),%ecx
    return -1;
  806de7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  if (buf->ptr->next == NULL) {
  806dec:	85 c9                	test   %ecx,%ecx
  806dee:	74 09                	je     806df9 <netbuf_next+0x40>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  806df0:	89 4a 04             	mov    %ecx,0x4(%edx)
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
  806df3:	83 39 00             	cmpl   $0x0,(%ecx)
  806df6:	0f 94 c0             	sete   %al
}
  806df9:	c9                   	leave  
  806dfa:	c3                   	ret    

00806dfb <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  806dfb:	55                   	push   %ebp
  806dfc:	89 e5                	mov    %esp,%ebp
  806dfe:	83 ec 18             	sub    $0x18,%esp
  806e01:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  806e04:	85 c0                	test   %eax,%eax
  806e06:	75 1c                	jne    806e24 <netbuf_first+0x29>
  806e08:	c7 44 24 08 79 52 81 	movl   $0x815279,0x8(%esp)
  806e0f:	00 
  806e10:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  806e17:	00 
  806e18:	c7 04 24 63 52 81 00 	movl   $0x815263,(%esp)
  806e1f:	e8 94 9b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  buf->ptr = buf->p;
  806e24:	8b 10                	mov    (%eax),%edx
  806e26:	89 50 04             	mov    %edx,0x4(%eax)
}
  806e29:	c9                   	leave  
  806e2a:	c3                   	ret    
  806e2b:	00 00                	add    %al,(%eax)
  806e2d:	00 00                	add    %al,(%eax)
	...

00806e30 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  806e30:	55                   	push   %ebp
  806e31:	89 e5                	mov    %esp,%ebp
  806e33:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  806e36:	e8 59 7e 00 00       	call   80ec94 <sys_init>
  mem_init();
  806e3b:	e8 a0 19 00 00       	call   8087e0 <mem_init>
  memp_init();
  806e40:	e8 23 1f 00 00       	call   808d68 <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  806e45:	e8 1e e5 ff ff       	call   805368 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  806e4a:	c9                   	leave  
  806e4b:	c3                   	ret    
  806e4c:	00 00                	add    %al,(%eax)
	...

00806e50 <_ZL14dhcp_set_stateP4dhcph>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  806e50:	55                   	push   %ebp
  806e51:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  806e53:	38 10                	cmp    %dl,(%eax)
  806e55:	74 06                	je     806e5d <_ZL14dhcp_set_stateP4dhcph+0xd>
    dhcp->state = new_state;
  806e57:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  806e59:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  806e5d:	5d                   	pop    %ebp
  806e5e:	c3                   	ret    

00806e5f <_ZL19dhcp_get_option_ptrP4dhcph>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  806e5f:	55                   	push   %ebp
  806e60:	89 e5                	mov    %esp,%ebp
  806e62:	57                   	push   %edi
  806e63:	56                   	push   %esi
  806e64:	53                   	push   %ebx
  806e65:	83 ec 08             	sub    $0x8,%esp
  806e68:	89 45 ec             	mov    %eax,-0x14(%ebp)
  806e6b:	88 55 f3             	mov    %dl,-0xd(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  806e6e:	8b 58 14             	mov    0x14(%eax),%ebx
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  806e71:	b8 00 00 00 00       	mov    $0x0,%eax
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  806e76:	85 db                	test   %ebx,%ebx
  806e78:	0f 84 de 00 00 00    	je     806f5c <_ZL19dhcp_get_option_ptrP4dhcph+0xfd>
  806e7e:	8b 45 ec             	mov    -0x14(%ebp),%eax
  806e81:	0f b7 70 18          	movzwl 0x18(%eax),%esi
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  806e85:	b8 00 00 00 00       	mov    $0x0,%eax

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
  806e8a:	ba 00 00 00 00       	mov    $0x0,%edx
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  u8_t overload = DHCP_OVERLOAD_NONE;
  806e8f:	bf 00 00 00 00       	mov    $0x0,%edi

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  806e94:	66 85 f6             	test   %si,%si
  806e97:	75 2b                	jne    806ec4 <_ZL19dhcp_get_option_ptrP4dhcph+0x65>
  806e99:	e9 be 00 00 00       	jmp    806f5c <_ZL19dhcp_get_option_ptrP4dhcph+0xfd>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  806e9e:	8d 42 02             	lea    0x2(%edx),%eax
        overload = options[offset++];
  806ea1:	0f b7 c0             	movzwl %ax,%eax
  806ea4:	0f b6 3c 03          	movzbl (%ebx,%eax,1),%edi
  806ea8:	83 c2 03             	add    $0x3,%edx
  806eab:	eb 17                	jmp    806ec4 <_ZL19dhcp_get_option_ptrP4dhcph+0x65>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  806ead:	3a 4d f3             	cmp    -0xd(%ebp),%cl
  806eb0:	0f 84 a6 00 00 00    	je     806f5c <_ZL19dhcp_get_option_ptrP4dhcph+0xfd>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  806eb6:	8d 42 01             	lea    0x1(%edx),%eax
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  806eb9:	0f b7 c0             	movzwl %ax,%eax
  806ebc:	0f b6 04 03          	movzbl (%ebx,%eax,1),%eax
  806ec0:	8d 54 02 02          	lea    0x2(%edx,%eax,1),%edx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  806ec4:	66 39 f2             	cmp    %si,%dx
  806ec7:	0f 83 97 00 00 00    	jae    806f64 <_ZL19dhcp_get_option_ptrP4dhcph+0x105>
  806ecd:	0f b7 c2             	movzwl %dx,%eax
  806ed0:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  806ed3:	0f b6 08             	movzbl (%eax),%ecx
  806ed6:	80 f9 ff             	cmp    $0xff,%cl
  806ed9:	0f 84 85 00 00 00    	je     806f64 <_ZL19dhcp_get_option_ptrP4dhcph+0x105>
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  806edf:	80 f9 34             	cmp    $0x34,%cl
  806ee2:	75 c9                	jne    806ead <_ZL19dhcp_get_option_ptrP4dhcph+0x4e>
  806ee4:	eb b8                	jmp    806e9e <_ZL19dhcp_get_option_ptrP4dhcph+0x3f>
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  806ee6:	89 f8                	mov    %edi,%eax
  806ee8:	3c 01                	cmp    $0x1,%al
  806eea:	75 10                	jne    806efc <_ZL19dhcp_get_option_ptrP4dhcph+0x9d>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  806eec:	8b 45 ec             	mov    -0x14(%ebp),%eax
  806eef:	8b 48 10             	mov    0x10(%eax),%ecx
  806ef2:	83 c1 6c             	add    $0x6c,%ecx
        field_len = DHCP_FILE_LEN;
  806ef5:	bb 80 00 00 00       	mov    $0x80,%ebx
  806efa:	eb 24                	jmp    806f20 <_ZL19dhcp_get_option_ptrP4dhcph+0xc1>
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  806efc:	89 f8                	mov    %edi,%eax
  806efe:	3c 02                	cmp    $0x2,%al
  806f00:	75 10                	jne    806f12 <_ZL19dhcp_get_option_ptrP4dhcph+0xb3>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  806f02:	8b 45 ec             	mov    -0x14(%ebp),%eax
  806f05:	8b 48 10             	mov    0x10(%eax),%ecx
  806f08:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_SNAME_LEN;
  806f0b:	bb 40 00 00 00       	mov    $0x40,%ebx
  806f10:	eb 0e                	jmp    806f20 <_ZL19dhcp_get_option_ptrP4dhcph+0xc1>
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  806f12:	8b 45 ec             	mov    -0x14(%ebp),%eax
  806f15:	8b 48 10             	mov    0x10(%eax),%ecx
  806f18:	83 c1 2c             	add    $0x2c,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
  806f1b:	bb c0 00 00 00       	mov    $0xc0,%ebx
      }
      offset = 0;
  806f20:	ba 00 00 00 00       	mov    $0x0,%edx

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  806f25:	eb 0e                	jmp    806f35 <_ZL19dhcp_get_option_ptrP4dhcph+0xd6>
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  806f27:	8d 42 01             	lea    0x1(%edx),%eax
          offset += 1 + options[offset];
  806f2a:	0f b7 c0             	movzwl %ax,%eax
  806f2d:	0f b6 04 01          	movzbl (%ecx,%eax,1),%eax
  806f31:	8d 54 02 02          	lea    0x2(%edx,%eax,1),%edx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  806f35:	66 39 da             	cmp    %bx,%dx
  806f38:	73 16                	jae    806f50 <_ZL19dhcp_get_option_ptrP4dhcph+0xf1>
  806f3a:	0f b7 f2             	movzwl %dx,%esi
  806f3d:	8d 34 31             	lea    (%ecx,%esi,1),%esi
  806f40:	0f b6 06             	movzbl (%esi),%eax
  806f43:	3c ff                	cmp    $0xff,%al
  806f45:	74 10                	je     806f57 <_ZL19dhcp_get_option_ptrP4dhcph+0xf8>
        if (options[offset] == option_type) {
  806f47:	38 45 f3             	cmp    %al,-0xd(%ebp)
  806f4a:	75 db                	jne    806f27 <_ZL19dhcp_get_option_ptrP4dhcph+0xc8>
  806f4c:	89 f0                	mov    %esi,%eax
  806f4e:	eb 0c                	jmp    806f5c <_ZL19dhcp_get_option_ptrP4dhcph+0xfd>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  806f50:	b8 00 00 00 00       	mov    $0x0,%eax
  806f55:	eb 05                	jmp    806f5c <_ZL19dhcp_get_option_ptrP4dhcph+0xfd>
  806f57:	b8 00 00 00 00       	mov    $0x0,%eax
}
  806f5c:	83 c4 08             	add    $0x8,%esp
  806f5f:	5b                   	pop    %ebx
  806f60:	5e                   	pop    %esi
  806f61:	5f                   	pop    %edi
  806f62:	5d                   	pop    %ebp
  806f63:	c3                   	ret    
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  806f64:	89 f8                	mov    %edi,%eax
  806f66:	84 c0                	test   %al,%al
  806f68:	0f 85 78 ff ff ff    	jne    806ee6 <_ZL19dhcp_get_option_ptrP4dhcph+0x87>
          offset += 1 + options[offset];
        }
      }
    }
  }
  return NULL;
  806f6e:	b8 00 00 00 00       	mov    $0x0,%eax
  806f73:	eb e7                	jmp    806f5c <_ZL19dhcp_get_option_ptrP4dhcph+0xfd>

00806f75 <_ZL20dhcp_get_option_bytePh>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  806f75:	55                   	push   %ebp
  806f76:	89 e5                	mov    %esp,%ebp
  806f78:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  806f7b:	5d                   	pop    %ebp
  806f7c:	c3                   	ret    

00806f7d <_ZL20dhcp_get_option_longPh>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  806f7d:	55                   	push   %ebp
  806f7e:	89 e5                	mov    %esp,%ebp
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  806f80:	0f b6 10             	movzbl (%eax),%edx
  806f83:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  806f86:	0f b6 48 01          	movzbl 0x1(%eax),%ecx
  806f8a:	c1 e1 10             	shl    $0x10,%ecx
  806f8d:	09 d1                	or     %edx,%ecx
  value |= (u32_t)(*ptr++) << 8;
  806f8f:	0f b6 50 02          	movzbl 0x2(%eax),%edx
  806f93:	c1 e2 08             	shl    $0x8,%edx
  806f96:	09 d1                	or     %edx,%ecx
  value |= (u32_t)(*ptr++);
  806f98:	0f b6 50 03          	movzbl 0x3(%eax),%edx
  806f9c:	89 c8                	mov    %ecx,%eax
  806f9e:	09 d0                	or     %edx,%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  806fa0:	5d                   	pop    %ebp
  806fa1:	c3                   	ret    

00806fa2 <_ZL11dhcp_optionP4dhcphh>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  806fa2:	55                   	push   %ebp
  806fa3:	89 e5                	mov    %esp,%ebp
  806fa5:	83 ec 48             	sub    $0x48,%esp
  806fa8:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806fab:	89 75 f8             	mov    %esi,-0x8(%ebp)
  806fae:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806fb1:	89 d6                	mov    %edx,%esi
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  806fb3:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  806fb7:	0f b7 fb             	movzwl %bx,%edi
  806fba:	88 4d d7             	mov    %cl,-0x29(%ebp)
  806fbd:	8d 4c 39 02          	lea    0x2(%ecx,%edi,1),%ecx
  806fc1:	83 f9 44             	cmp    $0x44,%ecx
  806fc4:	76 1c                	jbe    806fe2 <_ZL11dhcp_optionP4dhcphh+0x40>
  806fc6:	c7 44 24 08 54 53 81 	movl   $0x815354,0x8(%esp)
  806fcd:	00 
  806fce:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  806fd5:	00 
  806fd6:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  806fdd:	e8 d6 99 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  806fe2:	0f b7 d3             	movzwl %bx,%edx
  806fe5:	89 f1                	mov    %esi,%ecx
  806fe7:	8b 78 20             	mov    0x20(%eax),%edi
  806fea:	88 8c 17 f0 00 00 00 	mov    %cl,0xf0(%edi,%edx,1)
  806ff1:	8d 4b 01             	lea    0x1(%ebx),%ecx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  806ff4:	8b 70 20             	mov    0x20(%eax),%esi
  806ff7:	0f b7 c9             	movzwl %cx,%ecx
  806ffa:	0f b6 55 d7          	movzbl -0x29(%ebp),%edx
  806ffe:	88 94 0e f0 00 00 00 	mov    %dl,0xf0(%esi,%ecx,1)
  807005:	83 c3 02             	add    $0x2,%ebx
  807008:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  80700c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80700f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807012:	8b 7d fc             	mov    -0x4(%ebp),%edi
  807015:	89 ec                	mov    %ebp,%esp
  807017:	5d                   	pop    %ebp
  807018:	c3                   	ret    

00807019 <_ZL16dhcp_option_byteP4dhcph>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  807019:	55                   	push   %ebp
  80701a:	89 e5                	mov    %esp,%ebp
  80701c:	83 ec 18             	sub    $0x18,%esp
  80701f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  807022:	89 75 fc             	mov    %esi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  807025:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  807029:	66 83 f9 43          	cmp    $0x43,%cx
  80702d:	76 1c                	jbe    80704b <_ZL16dhcp_option_byteP4dhcph+0x32>
  80702f:	c7 44 24 08 9c 53 81 	movl   $0x81539c,0x8(%esp)
  807036:	00 
  807037:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  80703e:	00 
  80703f:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807046:	e8 6d 99 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  80704b:	8b 70 20             	mov    0x20(%eax),%esi
  80704e:	0f b7 d9             	movzwl %cx,%ebx
  807051:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  807058:	83 c1 01             	add    $0x1,%ecx
  80705b:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  80705f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  807062:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807065:	89 ec                	mov    %ebp,%esp
  807067:	5d                   	pop    %ebp
  807068:	c3                   	ret    

00807069 <_ZL19dhcp_option_trailerP4dhcp>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  807069:	55                   	push   %ebp
  80706a:	89 e5                	mov    %esp,%ebp
  80706c:	53                   	push   %ebx
  80706d:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  807070:	85 c0                	test   %eax,%eax
  807072:	75 1c                	jne    807090 <_ZL19dhcp_option_trailerP4dhcp+0x27>
  807074:	c7 44 24 08 d8 53 81 	movl   $0x8153d8,0x8(%esp)
  80707b:	00 
  80707c:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  807083:	00 
  807084:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  80708b:	e8 28 99 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  807090:	8b 48 20             	mov    0x20(%eax),%ecx
  807093:	85 c9                	test   %ecx,%ecx
  807095:	75 1c                	jne    8070b3 <_ZL19dhcp_option_trailerP4dhcp+0x4a>
  807097:	c7 44 24 08 fc 53 81 	movl   $0x8153fc,0x8(%esp)
  80709e:	00 
  80709f:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  8070a6:	00 
  8070a7:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8070ae:	e8 05 99 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8070b3:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  8070b7:	66 83 fa 43          	cmp    $0x43,%dx
  8070bb:	76 1c                	jbe    8070d9 <_ZL19dhcp_option_trailerP4dhcp+0x70>
  8070bd:	c7 44 24 08 28 54 81 	movl   $0x815428,0x8(%esp)
  8070c4:	00 
  8070c5:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  8070cc:	00 
  8070cd:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8070d4:	e8 df 98 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  8070d9:	0f b7 da             	movzwl %dx,%ebx
  8070dc:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  8070e3:	ff 
  8070e4:	83 c2 01             	add    $0x1,%edx
  8070e7:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  8070eb:	eb 31                	jmp    80711e <_ZL19dhcp_option_trailerP4dhcp+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8070ed:	c7 44 24 08 28 54 81 	movl   $0x815428,0x8(%esp)
  8070f4:	00 
  8070f5:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  8070fc:	00 
  8070fd:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807104:	e8 af 98 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  807109:	8b 58 20             	mov    0x20(%eax),%ebx
  80710c:	0f b7 ca             	movzwl %dx,%ecx
  80710f:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  807116:	00 
  807117:	83 c2 01             	add    $0x1,%edx
  80711a:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  80711e:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  807122:	66 83 fa 43          	cmp    $0x43,%dx
  807126:	76 e1                	jbe    807109 <_ZL19dhcp_option_trailerP4dhcp+0xa0>
  807128:	f6 c2 03             	test   $0x3,%dl
  80712b:	75 c0                	jne    8070ed <_ZL19dhcp_option_trailerP4dhcp+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  80712d:	83 c4 14             	add    $0x14,%esp
  807130:	5b                   	pop    %ebx
  807131:	5d                   	pop    %ebp
  807132:	c3                   	ret    

00807133 <_ZL17dhcp_option_shortP4dhcpt>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  807133:	55                   	push   %ebp
  807134:	89 e5                	mov    %esp,%ebp
  807136:	83 ec 48             	sub    $0x48,%esp
  807139:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80713c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80713f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  807142:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  807146:	0f b7 d9             	movzwl %cx,%ebx
  807149:	83 c3 02             	add    $0x2,%ebx
  80714c:	83 fb 44             	cmp    $0x44,%ebx
  80714f:	76 1c                	jbe    80716d <_ZL17dhcp_option_shortP4dhcpt+0x3a>
  807151:	c7 44 24 08 68 54 81 	movl   $0x815468,0x8(%esp)
  807158:	00 
  807159:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  807160:	00 
  807161:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807168:	e8 4b 98 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  80716d:	0f b7 d9             	movzwl %cx,%ebx
  807170:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  807173:	89 d6                	mov    %edx,%esi
  807175:	66 c1 ee 08          	shr    $0x8,%si
  807179:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  80717d:	0f b6 5d d6          	movzbl -0x2a(%ebp),%ebx
  807181:	8b 78 20             	mov    0x20(%eax),%edi
  807184:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807187:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  80718e:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  807191:	8b 70 20             	mov    0x20(%eax),%esi
  807194:	0f b7 db             	movzwl %bx,%ebx
  807197:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  80719e:	83 c1 02             	add    $0x2,%ecx
  8071a1:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  8071a5:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8071a8:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8071ab:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8071ae:	89 ec                	mov    %ebp,%esp
  8071b0:	5d                   	pop    %ebp
  8071b1:	c3                   	ret    

008071b2 <_ZL16dhcp_option_longP4dhcpj>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  8071b2:	55                   	push   %ebp
  8071b3:	89 e5                	mov    %esp,%ebp
  8071b5:	83 ec 48             	sub    $0x48,%esp
  8071b8:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8071bb:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8071be:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  8071c1:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8071c5:	0f b7 d9             	movzwl %cx,%ebx
  8071c8:	83 c3 04             	add    $0x4,%ebx
  8071cb:	83 fb 44             	cmp    $0x44,%ebx
  8071ce:	76 1c                	jbe    8071ec <_ZL16dhcp_option_longP4dhcpj+0x3a>
  8071d0:	c7 44 24 08 ac 54 81 	movl   $0x8154ac,0x8(%esp)
  8071d7:	00 
  8071d8:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  8071df:	00 
  8071e0:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8071e7:	e8 cc 97 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  8071ec:	0f b7 d9             	movzwl %cx,%ebx
  8071ef:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  8071f2:	89 d6                	mov    %edx,%esi
  8071f4:	c1 ee 18             	shr    $0x18,%esi
  8071f7:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  8071fa:	0f b6 5d d4          	movzbl -0x2c(%ebp),%ebx
  8071fe:	8b 78 20             	mov    0x20(%eax),%edi
  807201:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807204:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  80720b:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  80720e:	0f b7 db             	movzwl %bx,%ebx
  807211:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  807214:	89 d3                	mov    %edx,%ebx
  807216:	c1 eb 10             	shr    $0x10,%ebx
  807219:	8b 78 20             	mov    0x20(%eax),%edi
  80721c:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80721f:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  807226:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  807229:	0f b7 db             	movzwl %bx,%ebx
  80722c:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80722f:	0f b6 de             	movzbl %dh,%ebx
  807232:	8b 78 20             	mov    0x20(%eax),%edi
  807235:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  807238:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  80723f:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  807242:	8b 70 20             	mov    0x20(%eax),%esi
  807245:	0f b7 db             	movzwl %bx,%ebx
  807248:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  80724f:	83 c1 04             	add    $0x4,%ecx
  807252:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  807256:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807259:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80725c:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80725f:	89 ec                	mov    %ebp,%esp
  807261:	5d                   	pop    %ebp
  807262:	c3                   	ret    

00807263 <_ZL19dhcp_delete_requestP5netif>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  807263:	55                   	push   %ebp
  807264:	89 e5                	mov    %esp,%ebp
  807266:	53                   	push   %ebx
  807267:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  80726a:	85 c0                	test   %eax,%eax
  80726c:	75 1c                	jne    80728a <_ZL19dhcp_delete_requestP5netif+0x27>
  80726e:	c7 44 24 08 ec 54 81 	movl   $0x8154ec,0x8(%esp)
  807275:	00 
  807276:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  80727d:	00 
  80727e:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807285:	e8 2e 97 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp = netif->dhcp;
  80728a:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  80728d:	85 db                	test   %ebx,%ebx
  80728f:	75 1c                	jne    8072ad <_ZL19dhcp_delete_requestP5netif+0x4a>
  807291:	c7 44 24 08 10 55 81 	movl   $0x815510,0x8(%esp)
  807298:	00 
  807299:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  8072a0:	00 
  8072a1:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8072a8:	e8 0b 97 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  8072ad:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8072b0:	85 c0                	test   %eax,%eax
  8072b2:	75 1c                	jne    8072d0 <_ZL19dhcp_delete_requestP5netif+0x6d>
  8072b4:	c7 44 24 08 34 55 81 	movl   $0x815534,0x8(%esp)
  8072bb:	00 
  8072bc:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  8072c3:	00 
  8072c4:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8072cb:	e8 e8 96 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  8072d0:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8072d4:	75 1c                	jne    8072f2 <_ZL19dhcp_delete_requestP5netif+0x8f>
  8072d6:	c7 44 24 08 60 55 81 	movl   $0x815560,0x8(%esp)
  8072dd:	00 
  8072de:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  8072e5:	00 
  8072e6:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8072ed:	e8 c6 96 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  8072f2:	89 04 24             	mov    %eax,(%esp)
  8072f5:	e8 09 1f 00 00       	call   809203 <pbuf_free>
  }
  dhcp->p_out = NULL;
  8072fa:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  807301:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  807308:	83 c4 14             	add    $0x14,%esp
  80730b:	5b                   	pop    %ebx
  80730c:	5d                   	pop    %ebp
  80730d:	c3                   	ret    

0080730e <_ZL15dhcp_free_replyP4dhcp>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  80730e:	55                   	push   %ebp
  80730f:	89 e5                	mov    %esp,%ebp
  807311:	53                   	push   %ebx
  807312:	83 ec 14             	sub    $0x14,%esp
  807315:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  807317:	8b 40 10             	mov    0x10(%eax),%eax
  80731a:	85 c0                	test   %eax,%eax
  80731c:	74 0f                	je     80732d <_ZL15dhcp_free_replyP4dhcp+0x1f>
    mem_free((void *)dhcp->msg_in);
  80731e:	89 04 24             	mov    %eax,(%esp)
  807321:	e8 22 15 00 00       	call   808848 <mem_free>
    dhcp->msg_in = NULL;
  807326:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  80732d:	8b 43 14             	mov    0x14(%ebx),%eax
  807330:	85 c0                	test   %eax,%eax
  807332:	74 15                	je     807349 <_ZL15dhcp_free_replyP4dhcp+0x3b>
    mem_free((void *)dhcp->options_in);
  807334:	89 04 24             	mov    %eax,(%esp)
  807337:	e8 0c 15 00 00       	call   808848 <mem_free>
    dhcp->options_in = NULL;
  80733c:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  807343:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  807349:	83 c4 14             	add    $0x14,%esp
  80734c:	5b                   	pop    %ebx
  80734d:	5d                   	pop    %ebp
  80734e:	c3                   	ret    

0080734f <_ZL19dhcp_create_requestP5netif>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  80734f:	55                   	push   %ebp
  807350:	89 e5                	mov    %esp,%ebp
  807352:	57                   	push   %edi
  807353:	56                   	push   %esi
  807354:	53                   	push   %ebx
  807355:	83 ec 2c             	sub    $0x2c,%esp
  807358:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  80735a:	85 c0                	test   %eax,%eax
  80735c:	75 1c                	jne    80737a <_ZL19dhcp_create_requestP5netif+0x2b>
  80735e:	c7 44 24 08 8c 55 81 	movl   $0x81558c,0x8(%esp)
  807365:	00 
  807366:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  80736d:	00 
  80736e:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807375:	e8 3e 96 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp = netif->dhcp;
  80737a:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  80737d:	85 db                	test   %ebx,%ebx
  80737f:	75 1c                	jne    80739d <_ZL19dhcp_create_requestP5netif+0x4e>
  807381:	c7 44 24 08 b0 55 81 	movl   $0x8155b0,0x8(%esp)
  807388:	00 
  807389:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  807390:	00 
  807391:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807398:	e8 1b 96 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  80739d:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  8073a1:	74 1c                	je     8073bf <_ZL19dhcp_create_requestP5netif+0x70>
  8073a3:	c7 44 24 08 d4 55 81 	movl   $0x8155d4,0x8(%esp)
  8073aa:	00 
  8073ab:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  8073b2:	00 
  8073b3:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8073ba:	e8 f9 95 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  8073bf:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  8073c3:	74 1c                	je     8073e1 <_ZL19dhcp_create_requestP5netif+0x92>
  8073c5:	c7 44 24 08 00 56 81 	movl   $0x815600,0x8(%esp)
  8073cc:	00 
  8073cd:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  8073d4:	00 
  8073d5:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8073dc:	e8 d7 95 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  8073e1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8073e8:	00 
  8073e9:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  8073f0:	00 
  8073f1:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8073f8:	e8 28 20 00 00       	call   809425 <pbuf_alloc>
  8073fd:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  807400:	85 c0                	test   %eax,%eax
  807402:	0f 84 2f 01 00 00    	je     807537 <_ZL19dhcp_create_requestP5netif+0x1e8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  807408:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  80740e:	77 1c                	ja     80742c <_ZL19dhcp_create_requestP5netif+0xdd>
  807410:	c7 44 24 08 2c 56 81 	movl   $0x81562c,0x8(%esp)
  807417:	00 
  807418:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  80741f:	00 
  807420:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807427:	e8 8c 95 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  80742c:	8b 15 78 80 81 00    	mov    0x818078,%edx
  807432:	89 53 04             	mov    %edx,0x4(%ebx)
  807435:	83 c2 01             	add    $0x1,%edx
  807438:	89 15 78 80 81 00    	mov    %edx,0x818078
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  80743e:	8b 40 04             	mov    0x4(%eax),%eax
  807441:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  807444:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  807447:	8b 43 20             	mov    0x20(%ebx),%eax
  80744a:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  80744e:	8b 43 20             	mov    0x20(%ebx),%eax
  807451:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  807455:	8b 43 20             	mov    0x20(%ebx),%eax
  807458:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  80745c:	8b 73 20             	mov    0x20(%ebx),%esi
  80745f:	8b 43 04             	mov    0x4(%ebx),%eax
  807462:	89 04 24             	mov    %eax,(%esp)
  807465:	e8 70 4f 00 00       	call   80c3da <htonl>
  80746a:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  80746d:	8b 43 20             	mov    0x20(%ebx),%eax
  807470:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  807476:	8b 43 20             	mov    0x20(%ebx),%eax
  807479:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  80747f:	8b 43 20             	mov    0x20(%ebx),%eax
  807482:	8b 57 04             	mov    0x4(%edi),%edx
  807485:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  807488:	8b 43 20             	mov    0x20(%ebx),%eax
  80748b:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  807492:	8b 43 20             	mov    0x20(%ebx),%eax
  807495:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  80749c:	8b 43 20             	mov    0x20(%ebx),%eax
  80749f:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  8074a6:	b8 00 00 00 00       	mov    $0x0,%eax
  8074ab:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  8074ae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8074b1:	8b 5a 20             	mov    0x20(%edx),%ebx
  8074b4:	89 c1                	mov    %eax,%ecx
  8074b6:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  8074ba:	ba 00 00 00 00       	mov    $0x0,%edx
  8074bf:	66 39 c6             	cmp    %ax,%si
  8074c2:	76 05                	jbe    8074c9 <_ZL19dhcp_create_requestP5netif+0x17a>
  8074c4:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  8074c9:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  8074cd:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  8074d0:	83 f8 10             	cmp    $0x10,%eax
  8074d3:	75 d9                	jne    8074ae <_ZL19dhcp_create_requestP5netif+0x15f>
  8074d5:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8074d8:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  8074da:	8b 53 20             	mov    0x20(%ebx),%edx
  8074dd:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  8074e2:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  8074e5:	83 f8 40             	cmp    $0x40,%eax
  8074e8:	75 f0                	jne    8074da <_ZL19dhcp_create_requestP5netif+0x18b>
  8074ea:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  8074ec:	8b 53 20             	mov    0x20(%ebx),%edx
  8074ef:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  8074f4:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  8074f7:	3d 80 00 00 00       	cmp    $0x80,%eax
  8074fc:	75 ee                	jne    8074ec <_ZL19dhcp_create_requestP5netif+0x19d>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  8074fe:	8b 73 20             	mov    0x20(%ebx),%esi
  807501:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  807508:	e8 cd 4e 00 00       	call   80c3da <htonl>
  80750d:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  807513:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  807519:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  80751e:	8b 53 20             	mov    0x20(%ebx),%edx
  807521:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  807528:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  80752b:	83 f8 44             	cmp    $0x44,%eax
  80752e:	75 ee                	jne    80751e <_ZL19dhcp_create_requestP5netif+0x1cf>
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
  807530:	b8 00 00 00 00       	mov    $0x0,%eax
  807535:	eb 05                	jmp    80753c <_ZL19dhcp_create_requestP5netif+0x1ed>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  if (dhcp->p_out == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  807537:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  80753c:	83 c4 2c             	add    $0x2c,%esp
  80753f:	5b                   	pop    %ebx
  807540:	5e                   	pop    %esi
  807541:	5f                   	pop    %edi
  807542:	5d                   	pop    %ebp
  807543:	c3                   	ret    

00807544 <_ZL13dhcp_discoverP5netif>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  807544:	55                   	push   %ebp
  807545:	89 e5                	mov    %esp,%ebp
  807547:	57                   	push   %edi
  807548:	56                   	push   %esi
  807549:	53                   	push   %ebx
  80754a:	83 ec 2c             	sub    $0x2c,%esp
  80754d:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80754f:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  807552:	a1 84 5f 81 00       	mov    0x815f84,%eax
  807557:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80755a:	89 f8                	mov    %edi,%eax
  80755c:	e8 ee fd ff ff       	call   80734f <_ZL19dhcp_create_requestP5netif>
  807561:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  807563:	84 c0                	test   %al,%al
  807565:	0f 85 f0 00 00 00    	jne    80765b <_ZL13dhcp_discoverP5netif+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80756b:	b9 01 00 00 00       	mov    $0x1,%ecx
  807570:	ba 35 00 00 00       	mov    $0x35,%edx
  807575:	89 d8                	mov    %ebx,%eax
  807577:	e8 26 fa ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  80757c:	ba 01 00 00 00       	mov    $0x1,%edx
  807581:	89 d8                	mov    %ebx,%eax
  807583:	e8 91 fa ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  807588:	b9 02 00 00 00       	mov    $0x2,%ecx
  80758d:	ba 39 00 00 00       	mov    $0x39,%edx
  807592:	89 d8                	mov    %ebx,%eax
  807594:	e8 09 fa ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_short(dhcp, 576);
  807599:	ba 40 02 00 00       	mov    $0x240,%edx
  80759e:	89 d8                	mov    %ebx,%eax
  8075a0:	e8 8e fb ff ff       	call   807133 <_ZL17dhcp_option_shortP4dhcpt>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8075a5:	b9 04 00 00 00       	mov    $0x4,%ecx
  8075aa:	ba 37 00 00 00       	mov    $0x37,%edx
  8075af:	89 d8                	mov    %ebx,%eax
  8075b1:	e8 ec f9 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  8075b6:	ba 01 00 00 00       	mov    $0x1,%edx
  8075bb:	89 d8                	mov    %ebx,%eax
  8075bd:	e8 57 fa ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  8075c2:	ba 03 00 00 00       	mov    $0x3,%edx
  8075c7:	89 d8                	mov    %ebx,%eax
  8075c9:	e8 4b fa ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8075ce:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8075d3:	89 d8                	mov    %ebx,%eax
  8075d5:	e8 3f fa ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8075da:	ba 06 00 00 00       	mov    $0x6,%edx
  8075df:	89 d8                	mov    %ebx,%eax
  8075e1:	e8 33 fa ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option_trailer(dhcp);
  8075e6:	89 d8                	mov    %ebx,%eax
  8075e8:	e8 7c fa ff ff       	call   807069 <_ZL19dhcp_option_trailerP4dhcp>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8075ed:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8075f1:	66 05 f0 00          	add    $0xf0,%ax
  8075f5:	0f b7 c0             	movzwl %ax,%eax
  8075f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8075fc:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8075ff:	89 04 24             	mov    %eax,(%esp)
  807602:	e8 d8 1c 00 00       	call   8092df <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  807607:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80760e:	00 
  80760f:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  807616:	00 
  807617:	8b 43 08             	mov    0x8(%ebx),%eax
  80761a:	89 04 24             	mov    %eax,(%esp)
  80761d:	e8 d5 67 00 00       	call   80ddf7 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  807622:	89 7c 24 10          	mov    %edi,0x10(%esp)
  807626:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80762d:	00 
  80762e:	c7 44 24 08 88 5f 81 	movl   $0x815f88,0x8(%esp)
  807635:	00 
  807636:	8b 43 1c             	mov    0x1c(%ebx),%eax
  807639:	89 44 24 04          	mov    %eax,0x4(%esp)
  80763d:	8b 43 08             	mov    0x8(%ebx),%eax
  807640:	89 04 24             	mov    %eax,(%esp)
  807643:	e8 85 65 00 00       	call   80dbcd <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  807648:	89 f8                	mov    %edi,%eax
  80764a:	e8 14 fc ff ff       	call   807263 <_ZL19dhcp_delete_requestP5netif>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  80764f:	ba 06 00 00 00       	mov    $0x6,%edx
  807654:	89 d8                	mov    %ebx,%eax
  807656:	e8 f5 f7 ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80765b:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  80765f:	83 c1 01             	add    $0x1,%ecx
  807662:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  807665:	ba 10 27 00 00       	mov    $0x2710,%edx
  80766a:	80 f9 03             	cmp    $0x3,%cl
  80766d:	77 0b                	ja     80767a <_ZL13dhcp_discoverP5netif+0x136>
  80766f:	0f b6 d1             	movzbl %cl,%edx
  807672:	83 c2 01             	add    $0x1,%edx
  807675:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80767a:	0f b7 d2             	movzwl %dx,%edx
  80767d:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  807683:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  807688:	89 d0                	mov    %edx,%eax
  80768a:	f7 e9                	imul   %ecx
  80768c:	c1 fa 05             	sar    $0x5,%edx
  80768f:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  807693:	89 f0                	mov    %esi,%eax
  807695:	83 c4 2c             	add    $0x2c,%esp
  807698:	5b                   	pop    %ebx
  807699:	5e                   	pop    %esi
  80769a:	5f                   	pop    %edi
  80769b:	5d                   	pop    %ebp
  80769c:	c3                   	ret    

0080769d <_ZL11dhcp_rebindP5netif>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  80769d:	55                   	push   %ebp
  80769e:	89 e5                	mov    %esp,%ebp
  8076a0:	83 ec 38             	sub    $0x38,%esp
  8076a3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8076a6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8076a9:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8076ac:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8076ae:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  8076b1:	ba 04 00 00 00       	mov    $0x4,%edx
  8076b6:	89 d8                	mov    %ebx,%eax
  8076b8:	e8 93 f7 ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8076bd:	89 f8                	mov    %edi,%eax
  8076bf:	e8 8b fc ff ff       	call   80734f <_ZL19dhcp_create_requestP5netif>
  8076c4:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8076c6:	84 c0                	test   %al,%al
  8076c8:	0f 85 a3 00 00 00    	jne    807771 <_ZL11dhcp_rebindP5netif+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8076ce:	b9 01 00 00 00       	mov    $0x1,%ecx
  8076d3:	ba 35 00 00 00       	mov    $0x35,%edx
  8076d8:	89 d8                	mov    %ebx,%eax
  8076da:	e8 c3 f8 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8076df:	ba 03 00 00 00       	mov    $0x3,%edx
  8076e4:	89 d8                	mov    %ebx,%eax
  8076e6:	e8 2e f9 ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8076eb:	b9 02 00 00 00       	mov    $0x2,%ecx
  8076f0:	ba 39 00 00 00       	mov    $0x39,%edx
  8076f5:	89 d8                	mov    %ebx,%eax
  8076f7:	e8 a6 f8 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_short(dhcp, 576);
  8076fc:	ba 40 02 00 00       	mov    $0x240,%edx
  807701:	89 d8                	mov    %ebx,%eax
  807703:	e8 2b fa ff ff       	call   807133 <_ZL17dhcp_option_shortP4dhcpt>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  807708:	89 d8                	mov    %ebx,%eax
  80770a:	e8 5a f9 ff ff       	call   807069 <_ZL19dhcp_option_trailerP4dhcp>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80770f:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  807713:	66 05 f0 00          	add    $0xf0,%ax
  807717:	0f b7 c0             	movzwl %ax,%eax
  80771a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80771e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  807721:	89 04 24             	mov    %eax,(%esp)
  807724:	e8 b6 1b 00 00       	call   8092df <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  807729:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  807730:	00 
  807731:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  807738:	00 
  807739:	8b 43 08             	mov    0x8(%ebx),%eax
  80773c:	89 04 24             	mov    %eax,(%esp)
  80773f:	e8 b3 66 00 00       	call   80ddf7 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  807744:	89 7c 24 10          	mov    %edi,0x10(%esp)
  807748:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80774f:	00 
  807750:	c7 44 24 08 88 5f 81 	movl   $0x815f88,0x8(%esp)
  807757:	00 
  807758:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80775b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80775f:	8b 43 08             	mov    0x8(%ebx),%eax
  807762:	89 04 24             	mov    %eax,(%esp)
  807765:	e8 63 64 00 00       	call   80dbcd <udp_sendto_if>
    dhcp_delete_request(netif);
  80776a:	89 f8                	mov    %edi,%eax
  80776c:	e8 f2 fa ff ff       	call   807263 <_ZL19dhcp_delete_requestP5netif>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  807771:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  807775:	83 c1 01             	add    $0x1,%ecx
  807778:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80777b:	ba 10 27 00 00       	mov    $0x2710,%edx
  807780:	80 f9 09             	cmp    $0x9,%cl
  807783:	77 08                	ja     80778d <_ZL11dhcp_rebindP5netif+0xf0>
  807785:	0f b6 c9             	movzbl %cl,%ecx
  807788:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80778d:	0f b7 d2             	movzwl %dx,%edx
  807790:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  807796:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80779b:	89 d0                	mov    %edx,%eax
  80779d:	f7 e9                	imul   %ecx
  80779f:	c1 fa 05             	sar    $0x5,%edx
  8077a2:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8077a6:	89 f0                	mov    %esi,%eax
  8077a8:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8077ab:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8077ae:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8077b1:	89 ec                	mov    %ebp,%esp
  8077b3:	5d                   	pop    %ebp
  8077b4:	c3                   	ret    

008077b5 <_ZL11dhcp_selectP5netif>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  8077b5:	55                   	push   %ebp
  8077b6:	89 e5                	mov    %esp,%ebp
  8077b8:	57                   	push   %edi
  8077b9:	56                   	push   %esi
  8077ba:	53                   	push   %ebx
  8077bb:	83 ec 2c             	sub    $0x2c,%esp
  8077be:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  8077c0:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  8077c3:	e8 87 fb ff ff       	call   80734f <_ZL19dhcp_create_requestP5netif>
  8077c8:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8077ca:	84 c0                	test   %al,%al
  8077cc:	0f 85 3a 01 00 00    	jne    80790c <_ZL11dhcp_selectP5netif+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8077d2:	b9 01 00 00 00       	mov    $0x1,%ecx
  8077d7:	ba 35 00 00 00       	mov    $0x35,%edx
  8077dc:	89 d8                	mov    %ebx,%eax
  8077de:	e8 bf f7 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8077e3:	ba 03 00 00 00       	mov    $0x3,%edx
  8077e8:	89 d8                	mov    %ebx,%eax
  8077ea:	e8 2a f8 ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8077ef:	b9 02 00 00 00       	mov    $0x2,%ecx
  8077f4:	ba 39 00 00 00       	mov    $0x39,%edx
  8077f9:	89 d8                	mov    %ebx,%eax
  8077fb:	e8 a2 f7 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_short(dhcp, 576);
  807800:	ba 40 02 00 00       	mov    $0x240,%edx
  807805:	89 d8                	mov    %ebx,%eax
  807807:	e8 27 f9 ff ff       	call   807133 <_ZL17dhcp_option_shortP4dhcpt>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  80780c:	b9 04 00 00 00       	mov    $0x4,%ecx
  807811:	ba 32 00 00 00       	mov    $0x32,%edx
  807816:	89 d8                	mov    %ebx,%eax
  807818:	e8 85 f7 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  80781d:	8b 43 30             	mov    0x30(%ebx),%eax
  807820:	89 04 24             	mov    %eax,(%esp)
  807823:	e8 11 4e 00 00       	call   80c639 <ntohl>
  807828:	89 c2                	mov    %eax,%edx
  80782a:	89 d8                	mov    %ebx,%eax
  80782c:	e8 81 f9 ff ff       	call   8071b2 <_ZL16dhcp_option_longP4dhcpj>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  807831:	b9 04 00 00 00       	mov    $0x4,%ecx
  807836:	ba 36 00 00 00       	mov    $0x36,%edx
  80783b:	89 d8                	mov    %ebx,%eax
  80783d:	e8 60 f7 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  807842:	8b 43 2c             	mov    0x2c(%ebx),%eax
  807845:	89 04 24             	mov    %eax,(%esp)
  807848:	e8 ec 4d 00 00       	call   80c639 <ntohl>
  80784d:	89 c2                	mov    %eax,%edx
  80784f:	89 d8                	mov    %ebx,%eax
  807851:	e8 5c f9 ff ff       	call   8071b2 <_ZL16dhcp_option_longP4dhcpj>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  807856:	b9 04 00 00 00       	mov    $0x4,%ecx
  80785b:	ba 37 00 00 00       	mov    $0x37,%edx
  807860:	89 d8                	mov    %ebx,%eax
  807862:	e8 3b f7 ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  807867:	ba 01 00 00 00       	mov    $0x1,%edx
  80786c:	89 d8                	mov    %ebx,%eax
  80786e:	e8 a6 f7 ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  807873:	ba 03 00 00 00       	mov    $0x3,%edx
  807878:	89 d8                	mov    %ebx,%eax
  80787a:	e8 9a f7 ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  80787f:	ba 1c 00 00 00       	mov    $0x1c,%edx
  807884:	89 d8                	mov    %ebx,%eax
  807886:	e8 8e f7 ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  80788b:	ba 06 00 00 00       	mov    $0x6,%edx
  807890:	89 d8                	mov    %ebx,%eax
  807892:	e8 82 f7 ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  807897:	89 d8                	mov    %ebx,%eax
  807899:	e8 cb f7 ff ff       	call   807069 <_ZL19dhcp_option_trailerP4dhcp>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80789e:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8078a2:	66 05 f0 00          	add    $0xf0,%ax
  8078a6:	0f b7 c0             	movzwl %ax,%eax
  8078a9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8078ad:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8078b0:	89 04 24             	mov    %eax,(%esp)
  8078b3:	e8 27 1a 00 00       	call   8092df <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8078b8:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8078bc:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8078c3:	00 
  8078c4:	c7 44 24 08 88 5f 81 	movl   $0x815f88,0x8(%esp)
  8078cb:	00 
  8078cc:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8078cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8078d3:	8b 43 08             	mov    0x8(%ebx),%eax
  8078d6:	89 04 24             	mov    %eax,(%esp)
  8078d9:	e8 ef 62 00 00       	call   80dbcd <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8078de:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8078e5:	00 
  8078e6:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  8078ed:	00 
  8078ee:	8b 43 08             	mov    0x8(%ebx),%eax
  8078f1:	89 04 24             	mov    %eax,(%esp)
  8078f4:	e8 fe 64 00 00       	call   80ddf7 <udp_connect>
    dhcp_delete_request(netif);
  8078f9:	89 f8                	mov    %edi,%eax
  8078fb:	e8 63 f9 ff ff       	call   807263 <_ZL19dhcp_delete_requestP5netif>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  807900:	ba 01 00 00 00       	mov    $0x1,%edx
  807905:	89 d8                	mov    %ebx,%eax
  807907:	e8 44 f5 ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80790c:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  807910:	83 c1 01             	add    $0x1,%ecx
  807913:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  807916:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  80791b:	80 f9 03             	cmp    $0x3,%cl
  80791e:	77 08                	ja     807928 <_ZL11dhcp_selectP5netif+0x173>
  807920:	0f b6 c9             	movzbl %cl,%ecx
  807923:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  807928:	0f b7 d2             	movzwl %dx,%edx
  80792b:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  807931:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  807936:	89 d0                	mov    %edx,%eax
  807938:	f7 e9                	imul   %ecx
  80793a:	c1 fa 05             	sar    $0x5,%edx
  80793d:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  807941:	89 f0                	mov    %esi,%eax
  807943:	83 c4 2c             	add    $0x2c,%esp
  807946:	5b                   	pop    %ebx
  807947:	5e                   	pop    %esi
  807948:	5f                   	pop    %edi
  807949:	5d                   	pop    %ebp
  80794a:	c3                   	ret    

0080794b <_ZL10dhcp_checkP5netif>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  80794b:	55                   	push   %ebp
  80794c:	89 e5                	mov    %esp,%ebp
  80794e:	53                   	push   %ebx
  80794f:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  807952:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  807955:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80795c:	00 
  80795d:	8d 53 30             	lea    0x30(%ebx),%edx
  807960:	89 54 24 04          	mov    %edx,0x4(%esp)
  807964:	89 04 24             	mov    %eax,(%esp)
  807967:	e8 8c 6e 00 00       	call   80e7f8 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  80796c:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  807970:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  807976:	ba 08 00 00 00       	mov    $0x8,%edx
  80797b:	89 d8                	mov    %ebx,%eax
  80797d:	e8 ce f4 ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>
}
  807982:	83 c4 14             	add    $0x14,%esp
  807985:	5b                   	pop    %ebx
  807986:	5d                   	pop    %ebp
  807987:	c3                   	ret    

00807988 <_ZL9dhcp_bindP5netif>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  807988:	55                   	push   %ebp
  807989:	89 e5                	mov    %esp,%ebp
  80798b:	57                   	push   %edi
  80798c:	56                   	push   %esi
  80798d:	53                   	push   %ebx
  80798e:	83 ec 2c             	sub    $0x2c,%esp
  807991:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  807993:	85 c0                	test   %eax,%eax
  807995:	75 1c                	jne    8079b3 <_ZL9dhcp_bindP5netif+0x2b>
  807997:	c7 44 24 08 b7 56 81 	movl   $0x8156b7,0x8(%esp)
  80799e:	00 
  80799f:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  8079a6:	00 
  8079a7:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8079ae:	e8 05 90 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp = netif->dhcp;
  8079b3:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  8079b6:	85 db                	test   %ebx,%ebx
  8079b8:	75 1c                	jne    8079d6 <_ZL9dhcp_bindP5netif+0x4e>
  8079ba:	c7 44 24 08 d0 56 81 	movl   $0x8156d0,0x8(%esp)
  8079c1:	00 
  8079c2:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  8079c9:	00 
  8079ca:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  8079d1:	e8 e2 8f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  8079d6:	8b 53 50             	mov    0x50(%ebx),%edx
  8079d9:	83 fa ff             	cmp    $0xffffffff,%edx
  8079dc:	74 2c                	je     807a0a <_ZL9dhcp_bindP5netif+0x82>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  8079de:	83 c2 1e             	add    $0x1e,%edx
  8079e1:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  8079e6:	89 d0                	mov    %edx,%eax
  8079e8:	f7 e1                	mul    %ecx
  8079ea:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  8079ed:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  8079f3:	b8 ff ff 00 00       	mov    $0xffff,%eax
  8079f8:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t1_timeout == 0) {
      dhcp->t1_timeout = 1;
  8079fb:	66 85 d2             	test   %dx,%dx
  8079fe:	b8 01 00 00 00       	mov    $0x1,%eax
  807a03:	0f 44 d0             	cmove  %eax,%edx
  807a06:	66 89 53 28          	mov    %dx,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  807a0a:	8b 53 54             	mov    0x54(%ebx),%edx
  807a0d:	83 fa ff             	cmp    $0xffffffff,%edx
  807a10:	74 2c                	je     807a3e <_ZL9dhcp_bindP5netif+0xb6>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  807a12:	83 c2 1e             	add    $0x1e,%edx
  807a15:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  807a1a:	89 d0                	mov    %edx,%eax
  807a1c:	f7 e1                	mul    %ecx
  807a1e:	c1 ea 05             	shr    $0x5,%edx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  807a21:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  807a27:	b8 ff ff 00 00       	mov    $0xffff,%eax
  807a2c:	0f 47 d0             	cmova  %eax,%edx
    if (dhcp->t2_timeout == 0) {
      dhcp->t2_timeout = 1;
  807a2f:	66 85 d2             	test   %dx,%dx
  807a32:	b8 01 00 00 00       	mov    $0x1,%eax
  807a37:	0f 44 d0             	cmove  %eax,%edx
  807a3a:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  807a3e:	83 fb cc             	cmp    $0xffffffcc,%ebx
  807a41:	0f 84 c4 00 00 00    	je     807b0b <_ZL9dhcp_bindP5netif+0x183>
  807a47:	8b 43 34             	mov    0x34(%ebx),%eax
  807a4a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  807a4d:	85 c0                	test   %eax,%eax
  807a4f:	75 48                	jne    807a99 <_ZL9dhcp_bindP5netif+0x111>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  807a51:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  807a58:	e8 dc 4b 00 00       	call   80c639 <ntohl>
  807a5d:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  807a60:	84 c0                	test   %al,%al
  807a62:	78 11                	js     807a75 <_ZL9dhcp_bindP5netif+0xed>
      sn_mask.addr = htonl(0xff000000);
  807a64:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  807a6b:	e8 6a 49 00 00       	call   80c3da <htonl>
  807a70:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807a73:	eb 24                	jmp    807a99 <_ZL9dhcp_bindP5netif+0x111>
    } else if (first_octet >= 192) {
  807a75:	3c bf                	cmp    $0xbf,%al
  807a77:	76 11                	jbe    807a8a <_ZL9dhcp_bindP5netif+0x102>
      sn_mask.addr = htonl(0xffffff00);
  807a79:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  807a80:	e8 55 49 00 00       	call   80c3da <htonl>
  807a85:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  807a88:	eb 0f                	jmp    807a99 <_ZL9dhcp_bindP5netif+0x111>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  807a8a:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  807a91:	e8 44 49 00 00       	call   80c3da <htonl>
  807a96:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  807a99:	83 fb c8             	cmp    $0xffffffc8,%ebx
  807a9c:	74 0a                	je     807aa8 <_ZL9dhcp_bindP5netif+0x120>
  807a9e:	8b 43 38             	mov    0x38(%ebx),%eax
  807aa1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  807aa4:	85 c0                	test   %eax,%eax
  807aa6:	75 1a                	jne    807ac2 <_ZL9dhcp_bindP5netif+0x13a>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  807aa8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  807aab:	23 7b 30             	and    0x30(%ebx),%edi
  807aae:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  807ab1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  807ab8:	e8 1d 49 00 00       	call   80c3da <htonl>
  807abd:	09 c7                	or     %eax,%edi
  807abf:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  807ac2:	8d 43 30             	lea    0x30(%ebx),%eax
  807ac5:	89 44 24 04          	mov    %eax,0x4(%esp)
  807ac9:	89 34 24             	mov    %esi,(%esp)
  807acc:	e8 fe 13 00 00       	call   808ecf <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  807ad1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  807ad4:	89 44 24 04          	mov    %eax,0x4(%esp)
  807ad8:	89 34 24             	mov    %esi,(%esp)
  807adb:	e8 86 14 00 00       	call   808f66 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  807ae0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  807ae3:	89 44 24 04          	mov    %eax,0x4(%esp)
  807ae7:	89 34 24             	mov    %esi,(%esp)
  807aea:	e8 5e 14 00 00       	call   808f4d <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  807aef:	89 34 24             	mov    %esi,(%esp)
  807af2:	e8 b5 15 00 00       	call   8090ac <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  807af7:	ba 0a 00 00 00       	mov    $0xa,%edx
  807afc:	89 d8                	mov    %ebx,%eax
  807afe:	e8 4d f3 ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>
}
  807b03:	83 c4 2c             	add    $0x2c,%esp
  807b06:	5b                   	pop    %ebx
  807b07:	5e                   	pop    %esi
  807b08:	5f                   	pop    %edi
  807b09:	5d                   	pop    %ebp
  807b0a:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  807b0b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  807b12:	e9 3a ff ff ff       	jmp    807a51 <_ZL9dhcp_bindP5netif+0xc9>

00807b17 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  807b17:	55                   	push   %ebp
  807b18:	89 e5                	mov    %esp,%ebp
  807b1a:	57                   	push   %edi
  807b1b:	56                   	push   %esi
  807b1c:	53                   	push   %ebx
  807b1d:	83 ec 3c             	sub    $0x3c,%esp
  struct netif *netif = (struct netif *)arg;
  struct dhcp *dhcp = netif->dhcp;
  807b20:	8b 45 08             	mov    0x8(%ebp),%eax
  807b23:	8b 40 20             	mov    0x20(%eax),%eax
  807b26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  807b29:	8b 55 10             	mov    0x10(%ebp),%edx
  807b2c:	8b 52 04             	mov    0x4(%edx),%edx
  807b2f:	89 55 e0             	mov    %edx,-0x20(%ebp)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  807b32:	8b 4d 10             	mov    0x10(%ebp),%ecx
  807b35:	89 48 0c             	mov    %ecx,0xc(%eax)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  807b38:	80 3a 02             	cmpb   $0x2,(%edx)
  807b3b:	0f 85 3d 04 00 00    	jne    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  807b41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807b44:	0f b6 7b 24          	movzbl 0x24(%ebx),%edi
  807b48:	89 f8                	mov    %edi,%eax
  807b4a:	84 c0                	test   %al,%al
  807b4c:	74 3e                	je     807b8c <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x75>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  807b4e:	0f b6 52 1c          	movzbl 0x1c(%edx),%edx
  807b52:	38 53 25             	cmp    %dl,0x25(%ebx)
  807b55:	0f 85 23 04 00 00    	jne    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
  807b5b:	89 d9                	mov    %ebx,%ecx
  807b5d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807b60:	b8 00 00 00 00       	mov    $0x0,%eax
  807b65:	eb 1c                	jmp    807b83 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x6c>
  807b67:	0f b6 71 26          	movzbl 0x26(%ecx),%esi
  807b6b:	0f b6 5a 1d          	movzbl 0x1d(%edx),%ebx
  807b6f:	88 5d d7             	mov    %bl,-0x29(%ebp)
  807b72:	83 c1 01             	add    $0x1,%ecx
  807b75:	83 c2 01             	add    $0x1,%edx
  807b78:	89 f3                	mov    %esi,%ebx
  807b7a:	3a 5d d7             	cmp    -0x29(%ebp),%bl
  807b7d:	0f 85 fb 03 00 00    	jne    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  807b83:	83 c0 01             	add    $0x1,%eax
  807b86:	89 fb                	mov    %edi,%ebx
  807b88:	38 d8                	cmp    %bl,%al
  807b8a:	72 db                	jb     807b67 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x50>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  807b8c:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807b8f:	8b 42 04             	mov    0x4(%edx),%eax
  807b92:	89 04 24             	mov    %eax,(%esp)
  807b95:	e8 9f 4a 00 00       	call   80c639 <ntohl>
  807b9a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807b9d:	3b 41 04             	cmp    0x4(%ecx),%eax
  807ba0:	0f 85 d8 03 00 00    	jne    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  807ba6:	85 c9                	test   %ecx,%ecx
  807ba8:	75 1c                	jne    807bc6 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0xaf>
  807baa:	c7 44 24 08 db 56 81 	movl   $0x8156db,0x8(%esp)
  807bb1:	00 
  807bb2:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  807bb9:	00 
  807bba:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807bc1:	e8 f2 8d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  807bc6:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  807bc9:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  807bcd:	75 1c                	jne    807beb <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0xd4>
  807bcf:	c7 44 24 08 e8 56 81 	movl   $0x8156e8,0x8(%esp)
  807bd6:	00 
  807bd7:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  807bde:	00 
  807bdf:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807be6:	e8 cd 8d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  807beb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807bee:	e8 1b f7 ff ff       	call   80730e <_ZL15dhcp_free_replyP4dhcp>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  807bf3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807bf6:	8b 42 0c             	mov    0xc(%edx),%eax
  807bf9:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  807bfd:	66 3d f0 00          	cmp    $0xf0,%ax
  807c01:	76 21                	jbe    807c24 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x10d>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  807c03:	66 2d f0 00          	sub    $0xf0,%ax
  807c07:	66 89 42 18          	mov    %ax,0x18(%edx)
    dhcp->options_in = (struct dhcp_msg *) mem_malloc(dhcp->options_in_len);
  807c0b:	0f b7 c0             	movzwl %ax,%eax
  807c0e:	89 04 24             	mov    %eax,(%esp)
  807c11:	e8 2d 0f 00 00       	call   808b43 <mem_malloc>
  807c16:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807c19:	89 41 14             	mov    %eax,0x14(%ecx)
    if (dhcp->options_in == NULL) {
  807c1c:	85 c0                	test   %eax,%eax
  807c1e:	0f 84 5a 03 00 00    	je     807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = (struct dhcp_msg *) mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  807c24:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  807c2b:	e8 13 0f 00 00       	call   808b43 <mem_malloc>
  807c30:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  807c33:	89 43 10             	mov    %eax,0x10(%ebx)
  if (dhcp->msg_in == NULL) {
  807c36:	85 c0                	test   %eax,%eax
  807c38:	75 17                	jne    807c51 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x13a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  807c3a:	8b 43 14             	mov    0x14(%ebx),%eax
  807c3d:	89 04 24             	mov    %eax,(%esp)
  807c40:	e8 03 0c 00 00       	call   808848 <mem_free>
    dhcp->options_in = NULL;
  807c45:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
  807c4c:	e9 2d 03 00 00       	jmp    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  807c51:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  807c58:	00 
  807c59:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  807c60:	00 
  807c61:	89 44 24 04          	mov    %eax,0x4(%esp)
  807c65:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807c68:	8b 42 0c             	mov    0xc(%edx),%eax
  807c6b:	89 04 24             	mov    %eax,(%esp)
  807c6e:	e8 b1 1d 00 00       	call   809a24 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  807c73:	66 3d f0 00          	cmp    $0xf0,%ax
  807c77:	74 1c                	je     807c95 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x17e>
  807c79:	c7 44 24 08 70 56 81 	movl   $0x815670,0x8(%esp)
  807c80:	00 
  807c81:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  807c88:	00 
  807c89:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807c90:	e8 23 8d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  807c95:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807c98:	8b 41 14             	mov    0x14(%ecx),%eax
  807c9b:	85 c0                	test   %eax,%eax
  807c9d:	0f 84 f8 02 00 00    	je     807f9b <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x484>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  807ca3:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  807caa:	00 
  807cab:	0f b7 51 18          	movzwl 0x18(%ecx),%edx
  807caf:	89 54 24 08          	mov    %edx,0x8(%esp)
  807cb3:	89 44 24 04          	mov    %eax,0x4(%esp)
  807cb7:	8b 41 0c             	mov    0xc(%ecx),%eax
  807cba:	89 04 24             	mov    %eax,(%esp)
  807cbd:	e8 62 1d 00 00       	call   809a24 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  807cc2:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  807cc5:	66 3b 43 18          	cmp    0x18(%ebx),%ax
  807cc9:	0f 84 cc 02 00 00    	je     807f9b <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x484>
  807ccf:	c7 44 24 08 f8 56 81 	movl   $0x8156f8,0x8(%esp)
  807cd6:	00 
  807cd7:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  807cde:	00 
  807cdf:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  807ce6:	e8 cd 8c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  807ceb:	83 c0 02             	add    $0x2,%eax
  807cee:	e8 82 f2 ff ff       	call   806f75 <_ZL20dhcp_get_option_bytePh>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  807cf3:	3c 05                	cmp    $0x5,%al
  807cf5:	0f 85 a5 01 00 00    	jne    807ea0 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x389>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  807cfb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807cfe:	0f b6 02             	movzbl (%edx),%eax
  807d01:	3c 01                	cmp    $0x1,%al
  807d03:	0f 85 76 01 00 00    	jne    807e7f <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x368>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  807d09:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807d0c:	8b 59 20             	mov    0x20(%ecx),%ebx
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  807d0f:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  dhcp->offered_gw_addr.addr = 0;
  807d16:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_bc_addr.addr = 0;
  807d1d:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  807d24:	ba 33 00 00 00       	mov    $0x33,%edx
  807d29:	89 d8                	mov    %ebx,%eax
  807d2b:	e8 2f f1 ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  if (option_ptr != NULL) {
  807d30:	85 c0                	test   %eax,%eax
  807d32:	74 0b                	je     807d3f <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x228>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  807d34:	83 c0 02             	add    $0x2,%eax
  807d37:	e8 41 f2 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807d3c:	89 43 4c             	mov    %eax,0x4c(%ebx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  807d3f:	ba 3a 00 00 00       	mov    $0x3a,%edx
  807d44:	89 d8                	mov    %ebx,%eax
  807d46:	e8 14 f1 ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  if (option_ptr != NULL) {
  807d4b:	85 c0                	test   %eax,%eax
  807d4d:	74 0d                	je     807d5c <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x245>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  807d4f:	83 c0 02             	add    $0x2,%eax
  807d52:	e8 26 f2 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807d57:	89 43 50             	mov    %eax,0x50(%ebx)
  807d5a:	eb 08                	jmp    807d64 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x24d>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  807d5c:	8b 43 4c             	mov    0x4c(%ebx),%eax
  807d5f:	d1 e8                	shr    %eax
  807d61:	89 43 50             	mov    %eax,0x50(%ebx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  807d64:	ba 3b 00 00 00       	mov    $0x3b,%edx
  807d69:	89 d8                	mov    %ebx,%eax
  807d6b:	e8 ef f0 ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  if (option_ptr != NULL) {
  807d70:	85 c0                	test   %eax,%eax
  807d72:	74 0d                	je     807d81 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x26a>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  807d74:	83 c0 02             	add    $0x2,%eax
  807d77:	e8 01 f2 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807d7c:	89 43 54             	mov    %eax,0x54(%ebx)
  807d7f:	eb 06                	jmp    807d87 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x270>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  807d81:	8b 43 4c             	mov    0x4c(%ebx),%eax
  807d84:	89 43 54             	mov    %eax,0x54(%ebx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  807d87:	8b 53 10             	mov    0x10(%ebx),%edx
  807d8a:	b8 00 00 00 00       	mov    $0x0,%eax
  807d8f:	83 fa f0             	cmp    $0xfffffff0,%edx
  807d92:	74 03                	je     807d97 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x280>
  807d94:	8b 42 10             	mov    0x10(%edx),%eax
  807d97:	89 43 30             	mov    %eax,0x30(%ebx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  807d9a:	ba 01 00 00 00       	mov    $0x1,%edx
  807d9f:	89 d8                	mov    %ebx,%eax
  807da1:	e8 b9 f0 ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  807da6:	85 c0                	test   %eax,%eax
  807da8:	74 13                	je     807dbd <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x2a6>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  807daa:	83 c0 02             	add    $0x2,%eax
  807dad:	e8 cb f1 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807db2:	89 04 24             	mov    %eax,(%esp)
  807db5:	e8 20 46 00 00       	call   80c3da <htonl>
  807dba:	89 43 34             	mov    %eax,0x34(%ebx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  807dbd:	ba 03 00 00 00       	mov    $0x3,%edx
  807dc2:	89 d8                	mov    %ebx,%eax
  807dc4:	e8 96 f0 ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  if (option_ptr != NULL) {
  807dc9:	85 c0                	test   %eax,%eax
  807dcb:	74 13                	je     807de0 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x2c9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  807dcd:	83 c0 02             	add    $0x2,%eax
  807dd0:	e8 a8 f1 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807dd5:	89 04 24             	mov    %eax,(%esp)
  807dd8:	e8 fd 45 00 00       	call   80c3da <htonl>
  807ddd:	89 43 38             	mov    %eax,0x38(%ebx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  807de0:	ba 1c 00 00 00       	mov    $0x1c,%edx
  807de5:	89 d8                	mov    %ebx,%eax
  807de7:	e8 73 f0 ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  if (option_ptr != NULL) {
  807dec:	85 c0                	test   %eax,%eax
  807dee:	74 13                	je     807e03 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x2ec>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  807df0:	83 c0 02             	add    $0x2,%eax
  807df3:	e8 85 f1 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807df8:	89 04 24             	mov    %eax,(%esp)
  807dfb:	e8 da 45 00 00       	call   80c3da <htonl>
  807e00:	89 43 3c             	mov    %eax,0x3c(%ebx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  807e03:	ba 06 00 00 00       	mov    $0x6,%edx
  807e08:	89 d8                	mov    %ebx,%eax
  807e0a:	e8 50 f0 ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  807e0f:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  807e11:	85 c0                	test   %eax,%eax
  807e13:	74 54                	je     807e69 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x352>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  807e15:	8d 40 01             	lea    0x1(%eax),%eax
  807e18:	e8 58 f1 ff ff       	call   806f75 <_ZL20dhcp_get_option_bytePh>
  807e1d:	c0 e8 02             	shr    $0x2,%al
  807e20:	0f b6 c0             	movzbl %al,%eax
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
  807e23:	83 f8 03             	cmp    $0x3,%eax
  807e26:	ba 02 00 00 00       	mov    $0x2,%edx
  807e2b:	0f 43 c2             	cmovae %edx,%eax
  807e2e:	89 43 40             	mov    %eax,0x40(%ebx)
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  807e31:	bf 00 00 00 00       	mov    $0x0,%edi
  807e36:	89 f8                	mov    %edi,%eax
  807e38:	89 f7                	mov    %esi,%edi
  807e3a:	89 de                	mov    %ebx,%esi
  807e3c:	89 c3                	mov    %eax,%ebx
  807e3e:	eb 21                	jmp    807e61 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x34a>
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  807e40:	0f b6 c3             	movzbl %bl,%eax
  807e43:	89 45 e0             	mov    %eax,-0x20(%ebp)
  807e46:	8d 44 87 02          	lea    0x2(%edi,%eax,4),%eax
  807e4a:	e8 2e f1 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807e4f:	89 04 24             	mov    %eax,(%esp)
  807e52:	e8 83 45 00 00       	call   80c3da <htonl>
  807e57:	8b 55 e0             	mov    -0x20(%ebp),%edx
  807e5a:	89 44 96 44          	mov    %eax,0x44(%esi,%edx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  807e5e:	83 c3 01             	add    $0x1,%ebx
  807e61:	0f b6 c3             	movzbl %bl,%eax
  807e64:	3b 46 40             	cmp    0x40(%esi),%eax
  807e67:	72 d7                	jb     807e40 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x329>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  807e69:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807e6c:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  807e72:	8b 45 08             	mov    0x8(%ebp),%eax
  807e75:	e8 d1 fa ff ff       	call   80794b <_ZL10dhcp_checkP5netif>
  807e7a:	e9 ff 00 00 00       	jmp    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  807e7f:	83 e8 03             	sub    $0x3,%eax
  807e82:	3c 02                	cmp    $0x2,%al
  807e84:	0f 87 f4 00 00 00    	ja     807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
      dhcp->request_timeout = 0;
  807e8a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  807e8d:	66 c7 43 26 00 00    	movw   $0x0,0x26(%ebx)
      dhcp_bind(netif);
  807e93:	8b 45 08             	mov    0x8(%ebp),%eax
  807e96:	e8 ed fa ff ff       	call   807988 <_ZL9dhcp_bindP5netif>
  807e9b:	e9 de 00 00 00       	jmp    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  807ea0:	3c 06                	cmp    $0x6,%al
  807ea2:	0f 85 0a 01 00 00    	jne    807fb2 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x49b>
  807ea8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807eab:	0f b6 02             	movzbl (%edx),%eax
  807eae:	3c 03                	cmp    $0x3,%al
  807eb0:	74 14                	je     807ec6 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x3af>
  807eb2:	3c 01                	cmp    $0x1,%al
  807eb4:	74 10                	je     807ec6 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x3af>
  807eb6:	3c 04                	cmp    $0x4,%al
  807eb8:	74 0c                	je     807ec6 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x3af>
  807eba:	3c 05                	cmp    $0x5,%al
  807ebc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807ec0:	0f 85 b8 00 00 00    	jne    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  807ec6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  807ec9:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  807ecf:	8b 45 08             	mov    0x8(%ebp),%eax
  807ed2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  807ed5:	89 04 24             	mov    %eax,(%esp)
  807ed8:	e8 05 12 00 00       	call   8090e2 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  807edd:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  807ee4:	00 
  807ee5:	8b 55 08             	mov    0x8(%ebp),%edx
  807ee8:	89 14 24             	mov    %edx,(%esp)
  807eeb:	e8 df 0f 00 00       	call   808ecf <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  807ef0:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  807ef7:	00 
  807ef8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807efb:	89 0c 24             	mov    %ecx,(%esp)
  807efe:	e8 4a 10 00 00       	call   808f4d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  807f03:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  807f0a:	00 
  807f0b:	8b 45 08             	mov    0x8(%ebp),%eax
  807f0e:	89 04 24             	mov    %eax,(%esp)
  807f11:	e8 50 10 00 00       	call   808f66 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  807f16:	ba 0c 00 00 00       	mov    $0xc,%edx
  807f1b:	89 d8                	mov    %ebx,%eax
  807f1d:	e8 2e ef ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  807f22:	8b 45 08             	mov    0x8(%ebp),%eax
  807f25:	e8 1a f6 ff ff       	call   807544 <_ZL13dhcp_discoverP5netif>
  807f2a:	eb 52                	jmp    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  807f2c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807f2f:	80 3a 06             	cmpb   $0x6,(%edx)
  807f32:	75 4a                	jne    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  807f34:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  807f3a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  807f3d:	8b 59 20             	mov    0x20(%ecx),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  807f40:	ba 36 00 00 00       	mov    $0x36,%edx
  807f45:	89 d8                	mov    %ebx,%eax
  807f47:	e8 13 ef ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  807f4c:	85 c0                	test   %eax,%eax
  807f4e:	74 2e                	je     807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  807f50:	83 c0 02             	add    $0x2,%eax
  807f53:	e8 25 f0 ff ff       	call   806f7d <_ZL20dhcp_get_option_longPh>
  807f58:	89 04 24             	mov    %eax,(%esp)
  807f5b:	e8 7a 44 00 00       	call   80c3da <htonl>
  807f60:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  807f63:	8b 53 10             	mov    0x10(%ebx),%edx
  807f66:	b8 00 00 00 00       	mov    $0x0,%eax
  807f6b:	83 fa f0             	cmp    $0xfffffff0,%edx
  807f6e:	74 03                	je     807f73 <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x45c>
  807f70:	8b 42 10             	mov    0x10(%edx),%eax
  807f73:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  807f76:	8b 45 08             	mov    0x8(%ebp),%eax
  807f79:	e8 37 f8 ff ff       	call   8077b5 <_ZL11dhcp_selectP5netif>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  807f7e:	8b 5d 10             	mov    0x10(%ebp),%ebx
  807f81:	89 1c 24             	mov    %ebx,(%esp)
  807f84:	e8 7a 12 00 00       	call   809203 <pbuf_free>
  dhcp->p = NULL;
  807f89:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807f8c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  807f93:	83 c4 3c             	add    $0x3c,%esp
  807f96:	5b                   	pop    %ebx
  807f97:	5e                   	pop    %esi
  807f98:	5f                   	pop    %edi
  807f99:	5d                   	pop    %ebp
  807f9a:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  807f9b:	ba 35 00 00 00       	mov    $0x35,%edx
  807fa0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  807fa3:	e8 b7 ee ff ff       	call   806e5f <_ZL19dhcp_get_option_ptrP4dhcph>
  if (options_ptr == NULL) {
  807fa8:	85 c0                	test   %eax,%eax
  807faa:	0f 85 3b fd ff ff    	jne    807ceb <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x1d4>
  807fb0:	eb cc                	jmp    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  807fb2:	3c 02                	cmp    $0x2,%al
  807fb4:	75 c8                	jne    807f7e <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x467>
  807fb6:	e9 71 ff ff ff       	jmp    807f2c <_ZL9dhcp_recvPvP7udp_pcbP4pbufP7ip_addrt+0x415>

00807fbb <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  807fbb:	55                   	push   %ebp
  807fbc:	89 e5                	mov    %esp,%ebp
  807fbe:	83 ec 38             	sub    $0x38,%esp
  807fc1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  807fc4:	89 75 f8             	mov    %esi,-0x8(%ebp)
  807fc7:	89 7d fc             	mov    %edi,-0x4(%ebp)
  807fca:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  807fcd:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp =(struct dhcp *) mem_malloc(sizeof(struct dhcp));
  807fd0:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  807fd7:	e8 67 0b 00 00       	call   808b43 <mem_malloc>
  807fdc:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  807fde:	85 c0                	test   %eax,%eax
  807fe0:	0f 84 3d 01 00 00    	je     808123 <dhcp_inform+0x168>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  807fe6:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  807fe9:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  807ff0:	00 
  807ff1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807ff8:	00 
  807ff9:	89 04 24             	mov    %eax,(%esp)
  807ffc:	e8 30 92 ff ff       	call   801231 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  808001:	e8 f4 5e 00 00       	call   80defa <udp_new>
  808006:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  808009:	85 c0                	test   %eax,%eax
  80800b:	75 0d                	jne    80801a <dhcp_inform+0x5f>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  80800d:	89 1c 24             	mov    %ebx,(%esp)
  808010:	e8 33 08 00 00       	call   808848 <mem_free>
    return;
  808015:	e9 09 01 00 00       	jmp    808123 <dhcp_inform+0x168>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80801a:	89 f0                	mov    %esi,%eax
  80801c:	e8 2e f3 ff ff       	call   80734f <_ZL19dhcp_create_requestP5netif>
  if (result == ERR_OK) {
  808021:	84 c0                	test   %al,%al
  808023:	0f 85 d9 00 00 00    	jne    808102 <dhcp_inform+0x147>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  808029:	b9 01 00 00 00       	mov    $0x1,%ecx
  80802e:	ba 35 00 00 00       	mov    $0x35,%edx
  808033:	89 d8                	mov    %ebx,%eax
  808035:	e8 68 ef ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  80803a:	ba 08 00 00 00       	mov    $0x8,%edx
  80803f:	89 d8                	mov    %ebx,%eax
  808041:	e8 d3 ef ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  808046:	b9 02 00 00 00       	mov    $0x2,%ecx
  80804b:	ba 39 00 00 00       	mov    $0x39,%edx
  808050:	89 d8                	mov    %ebx,%eax
  808052:	e8 4b ef ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  808057:	ba 40 02 00 00       	mov    $0x240,%edx
  80805c:	89 d8                	mov    %ebx,%eax
  80805e:	e8 d0 f0 ff ff       	call   807133 <_ZL17dhcp_option_shortP4dhcpt>

    dhcp_option_trailer(dhcp);
  808063:	89 d8                	mov    %ebx,%eax
  808065:	e8 ff ef ff ff       	call   807069 <_ZL19dhcp_option_trailerP4dhcp>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  80806a:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80806e:	66 05 f0 00          	add    $0xf0,%ax
  808072:	0f b7 c0             	movzwl %ax,%eax
  808075:	89 44 24 04          	mov    %eax,0x4(%esp)
  808079:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80807c:	89 04 24             	mov    %eax,(%esp)
  80807f:	e8 5b 12 00 00       	call   8092df <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  808084:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  80808b:	00 
  80808c:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  808093:	00 
  808094:	8b 43 08             	mov    0x8(%ebx),%eax
  808097:	89 04 24             	mov    %eax,(%esp)
  80809a:	e8 55 5a 00 00       	call   80daf4 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  80809f:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8080a6:	00 
  8080a7:	c7 44 24 04 88 5f 81 	movl   $0x815f88,0x4(%esp)
  8080ae:	00 
  8080af:	8b 43 08             	mov    0x8(%ebx),%eax
  8080b2:	89 04 24             	mov    %eax,(%esp)
  8080b5:	e8 3d 5d 00 00       	call   80ddf7 <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8080ba:	89 74 24 10          	mov    %esi,0x10(%esp)
  8080be:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8080c5:	00 
  8080c6:	c7 44 24 08 88 5f 81 	movl   $0x815f88,0x8(%esp)
  8080cd:	00 
  8080ce:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8080d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8080d5:	8b 43 08             	mov    0x8(%ebx),%eax
  8080d8:	89 04 24             	mov    %eax,(%esp)
  8080db:	e8 ed 5a 00 00       	call   80dbcd <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8080e0:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8080e7:	00 
  8080e8:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  8080ef:	00 
  8080f0:	8b 43 08             	mov    0x8(%ebx),%eax
  8080f3:	89 04 24             	mov    %eax,(%esp)
  8080f6:	e8 fc 5c 00 00       	call   80ddf7 <udp_connect>
    dhcp_delete_request(netif);
  8080fb:	89 f0                	mov    %esi,%eax
  8080fd:	e8 61 f1 ff ff       	call   807263 <_ZL19dhcp_delete_requestP5netif>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  808102:	8b 43 08             	mov    0x8(%ebx),%eax
  808105:	85 c0                	test   %eax,%eax
  808107:	74 08                	je     808111 <dhcp_inform+0x156>
      udp_remove(dhcp->pcb);
  808109:	89 04 24             	mov    %eax,(%esp)
  80810c:	e8 9d 5d 00 00       	call   80deae <udp_remove>
    }
    dhcp->pcb = NULL;
  808111:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  808118:	89 1c 24             	mov    %ebx,(%esp)
  80811b:	e8 28 07 00 00       	call   808848 <mem_free>
    netif->dhcp = old_dhcp;
  808120:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  808123:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  808126:	8b 75 f8             	mov    -0x8(%ebp),%esi
  808129:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80812c:	89 ec                	mov    %ebp,%esp
  80812e:	5d                   	pop    %ebp
  80812f:	c3                   	ret    

00808130 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  808130:	55                   	push   %ebp
  808131:	89 e5                	mov    %esp,%ebp
  808133:	83 ec 28             	sub    $0x28,%esp
  808136:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808139:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80813c:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80813f:	85 f6                	test   %esi,%esi
  808141:	75 1c                	jne    80815f <dhcp_arp_reply+0x2f>
  808143:	c7 44 24 08 c2 56 81 	movl   $0x8156c2,0x8(%esp)
  80814a:	00 
  80814b:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  808152:	00 
  808153:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  80815a:	e8 59 88 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  80815f:	8b 5e 20             	mov    0x20(%esi),%ebx
  808162:	85 db                	test   %ebx,%ebx
  808164:	0f 84 04 01 00 00    	je     80826e <dhcp_arp_reply+0x13e>
  80816a:	80 3b 08             	cmpb   $0x8,(%ebx)
  80816d:	0f 85 fb 00 00 00    	jne    80826e <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  808173:	8b 45 0c             	mov    0xc(%ebp),%eax
  808176:	8b 53 30             	mov    0x30(%ebx),%edx
  808179:	39 10                	cmp    %edx,(%eax)
  80817b:	0f 85 ed 00 00 00    	jne    80826e <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  808181:	ba 0c 00 00 00       	mov    $0xc,%edx
  808186:	89 d8                	mov    %ebx,%eax
  808188:	e8 c3 ec ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80818d:	89 f0                	mov    %esi,%eax
  80818f:	e8 bb f1 ff ff       	call   80734f <_ZL19dhcp_create_requestP5netif>
  if (result == ERR_OK) {
  808194:	84 c0                	test   %al,%al
  808196:	0f 85 c8 00 00 00    	jne    808264 <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80819c:	b9 01 00 00 00       	mov    $0x1,%ecx
  8081a1:	ba 35 00 00 00       	mov    $0x35,%edx
  8081a6:	89 d8                	mov    %ebx,%eax
  8081a8:	e8 f5 ed ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  8081ad:	ba 04 00 00 00       	mov    $0x4,%edx
  8081b2:	89 d8                	mov    %ebx,%eax
  8081b4:	e8 60 ee ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8081b9:	b9 02 00 00 00       	mov    $0x2,%ecx
  8081be:	ba 39 00 00 00       	mov    $0x39,%edx
  8081c3:	89 d8                	mov    %ebx,%eax
  8081c5:	e8 d8 ed ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_short(dhcp, 576);
  8081ca:	ba 40 02 00 00       	mov    $0x240,%edx
  8081cf:	89 d8                	mov    %ebx,%eax
  8081d1:	e8 5d ef ff ff       	call   807133 <_ZL17dhcp_option_shortP4dhcpt>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8081d6:	b9 04 00 00 00       	mov    $0x4,%ecx
  8081db:	ba 32 00 00 00       	mov    $0x32,%edx
  8081e0:	89 d8                	mov    %ebx,%eax
  8081e2:	e8 bb ed ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8081e7:	8b 43 30             	mov    0x30(%ebx),%eax
  8081ea:	89 04 24             	mov    %eax,(%esp)
  8081ed:	e8 47 44 00 00       	call   80c639 <ntohl>
  8081f2:	89 c2                	mov    %eax,%edx
  8081f4:	89 d8                	mov    %ebx,%eax
  8081f6:	e8 b7 ef ff ff       	call   8071b2 <_ZL16dhcp_option_longP4dhcpj>

    dhcp_option_trailer(dhcp);
  8081fb:	89 d8                	mov    %ebx,%eax
  8081fd:	e8 67 ee ff ff       	call   807069 <_ZL19dhcp_option_trailerP4dhcp>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  808202:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  808206:	66 05 f0 00          	add    $0xf0,%ax
  80820a:	0f b7 c0             	movzwl %ax,%eax
  80820d:	89 44 24 04          	mov    %eax,0x4(%esp)
  808211:	8b 43 1c             	mov    0x1c(%ebx),%eax
  808214:	89 04 24             	mov    %eax,(%esp)
  808217:	e8 c3 10 00 00       	call   8092df <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80821c:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  808223:	00 
  808224:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  80822b:	00 
  80822c:	8b 43 08             	mov    0x8(%ebx),%eax
  80822f:	89 04 24             	mov    %eax,(%esp)
  808232:	e8 c0 5b 00 00       	call   80ddf7 <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  808237:	89 74 24 10          	mov    %esi,0x10(%esp)
  80823b:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  808242:	00 
  808243:	c7 44 24 08 88 5f 81 	movl   $0x815f88,0x8(%esp)
  80824a:	00 
  80824b:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80824e:	89 44 24 04          	mov    %eax,0x4(%esp)
  808252:	8b 43 08             	mov    0x8(%ebx),%eax
  808255:	89 04 24             	mov    %eax,(%esp)
  808258:	e8 70 59 00 00       	call   80dbcd <udp_sendto_if>
    dhcp_delete_request(netif);
  80825d:	89 f0                	mov    %esi,%eax
  80825f:	e8 ff ef ff ff       	call   807263 <_ZL19dhcp_delete_requestP5netif>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  808264:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  808268:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  80826e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808271:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808274:	89 ec                	mov    %ebp,%esp
  808276:	5d                   	pop    %ebp
  808277:	c3                   	ret    

00808278 <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  808278:	55                   	push   %ebp
  808279:	89 e5                	mov    %esp,%ebp
  80827b:	83 ec 48             	sub    $0x48,%esp
  80827e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  808281:	89 75 f8             	mov    %esi,-0x8(%ebp)
  808284:	89 7d fc             	mov    %edi,-0x4(%ebp)
  808287:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  80828a:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  80828d:	ba 05 00 00 00       	mov    $0x5,%edx
  808292:	89 d8                	mov    %ebx,%eax
  808294:	e8 b7 eb ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  808299:	89 f8                	mov    %edi,%eax
  80829b:	e8 af f0 ff ff       	call   80734f <_ZL19dhcp_create_requestP5netif>
  8082a0:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  8082a2:	84 c0                	test   %al,%al
  8082a4:	0f 85 a4 00 00 00    	jne    80834e <dhcp_renew+0xd6>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8082aa:	b9 01 00 00 00       	mov    $0x1,%ecx
  8082af:	ba 35 00 00 00       	mov    $0x35,%edx
  8082b4:	89 d8                	mov    %ebx,%eax
  8082b6:	e8 e7 ec ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8082bb:	ba 03 00 00 00       	mov    $0x3,%edx
  8082c0:	89 d8                	mov    %ebx,%eax
  8082c2:	e8 52 ed ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8082c7:	b9 02 00 00 00       	mov    $0x2,%ecx
  8082cc:	ba 39 00 00 00       	mov    $0x39,%edx
  8082d1:	89 d8                	mov    %ebx,%eax
  8082d3:	e8 ca ec ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  8082d8:	ba 40 02 00 00       	mov    $0x240,%edx
  8082dd:	89 d8                	mov    %ebx,%eax
  8082df:	e8 4f ee ff ff       	call   807133 <_ZL17dhcp_option_shortP4dhcpt>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  8082e4:	89 d8                	mov    %ebx,%eax
  8082e6:	e8 7e ed ff ff       	call   807069 <_ZL19dhcp_option_trailerP4dhcp>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8082eb:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8082ef:	66 05 f0 00          	add    $0xf0,%ax
  8082f3:	0f b7 c0             	movzwl %ax,%eax
  8082f6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8082fa:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8082fd:	89 04 24             	mov    %eax,(%esp)
  808300:	e8 da 0f 00 00       	call   8092df <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  808305:	8d 43 2c             	lea    0x2c(%ebx),%eax
  808308:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80830b:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  808312:	00 
  808313:	89 44 24 04          	mov    %eax,0x4(%esp)
  808317:	8b 43 08             	mov    0x8(%ebx),%eax
  80831a:	89 04 24             	mov    %eax,(%esp)
  80831d:	e8 d5 5a 00 00       	call   80ddf7 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  808322:	89 7c 24 10          	mov    %edi,0x10(%esp)
  808326:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80832d:	00 
  80832e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  808331:	89 44 24 08          	mov    %eax,0x8(%esp)
  808335:	8b 43 1c             	mov    0x1c(%ebx),%eax
  808338:	89 44 24 04          	mov    %eax,0x4(%esp)
  80833c:	8b 43 08             	mov    0x8(%ebx),%eax
  80833f:	89 04 24             	mov    %eax,(%esp)
  808342:	e8 86 58 00 00       	call   80dbcd <udp_sendto_if>
    dhcp_delete_request(netif);
  808347:	89 f8                	mov    %edi,%eax
  808349:	e8 15 ef ff ff       	call   807263 <_ZL19dhcp_delete_requestP5netif>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80834e:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  808352:	83 c1 01             	add    $0x1,%ecx
  808355:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  808358:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  80835d:	80 f9 09             	cmp    $0x9,%cl
  808360:	77 08                	ja     80836a <dhcp_renew+0xf2>
  808362:	0f b6 c9             	movzbl %cl,%ecx
  808365:	66 69 d1 d0 07       	imul   $0x7d0,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80836a:	0f b7 d2             	movzwl %dx,%edx
  80836d:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  808373:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  808378:	89 d0                	mov    %edx,%eax
  80837a:	f7 e9                	imul   %ecx
  80837c:	c1 fa 05             	sar    $0x5,%edx
  80837f:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  808383:	89 f0                	mov    %esi,%eax
  808385:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  808388:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80838b:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80838e:	89 ec                	mov    %ebp,%esp
  808390:	5d                   	pop    %ebp
  808391:	c3                   	ret    

00808392 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  808392:	55                   	push   %ebp
  808393:	89 e5                	mov    %esp,%ebp
  808395:	53                   	push   %ebx
  808396:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  808399:	8b 1d c4 a3 b3 00    	mov    0xb3a3c4,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  80839f:	85 db                	test   %ebx,%ebx
  8083a1:	74 68                	je     80840b <dhcp_coarse_tmr+0x79>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8083a3:	8b 43 20             	mov    0x20(%ebx),%eax
  8083a6:	85 c0                	test   %eax,%eax
  8083a8:	74 5b                	je     808405 <dhcp_coarse_tmr+0x73>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  8083aa:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  8083ae:	8d 4a ff             	lea    -0x1(%edx),%ecx
  8083b1:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  8083b5:	66 83 fa 01          	cmp    $0x1,%dx
  8083b9:	75 1c                	jne    8083d7 <dhcp_coarse_tmr+0x45>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8083bb:	8b 43 20             	mov    0x20(%ebx),%eax
  8083be:	0f b6 00             	movzbl (%eax),%eax
  8083c1:	3c 01                	cmp    $0x1,%al
  8083c3:	74 08                	je     8083cd <dhcp_coarse_tmr+0x3b>
  8083c5:	3c 0a                	cmp    $0xa,%al
  8083c7:	74 04                	je     8083cd <dhcp_coarse_tmr+0x3b>
  8083c9:	3c 05                	cmp    $0x5,%al
  8083cb:	75 38                	jne    808405 <dhcp_coarse_tmr+0x73>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  8083cd:	89 d8                	mov    %ebx,%eax
  8083cf:	90                   	nop
  8083d0:	e8 c8 f2 ff ff       	call   80769d <_ZL11dhcp_rebindP5netif>
  8083d5:	eb 2e                	jmp    808405 <dhcp_coarse_tmr+0x73>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  8083d7:	8b 53 20             	mov    0x20(%ebx),%edx
  8083da:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  8083de:	8d 48 ff             	lea    -0x1(%eax),%ecx
  8083e1:	66 89 4a 28          	mov    %cx,0x28(%edx)
  8083e5:	66 83 f8 01          	cmp    $0x1,%ax
  8083e9:	75 1a                	jne    808405 <dhcp_coarse_tmr+0x73>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8083eb:	8b 43 20             	mov    0x20(%ebx),%eax
  8083ee:	0f b6 00             	movzbl (%eax),%eax
  8083f1:	3c 01                	cmp    $0x1,%al
  8083f3:	74 08                	je     8083fd <dhcp_coarse_tmr+0x6b>
  8083f5:	3c 0a                	cmp    $0xa,%al
  8083f7:	74 04                	je     8083fd <dhcp_coarse_tmr+0x6b>
  8083f9:	3c 05                	cmp    $0x5,%al
  8083fb:	75 08                	jne    808405 <dhcp_coarse_tmr+0x73>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  8083fd:	89 1c 24             	mov    %ebx,(%esp)
  808400:	e8 73 fe ff ff       	call   808278 <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  808405:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  808407:	85 db                	test   %ebx,%ebx
  808409:	75 98                	jne    8083a3 <dhcp_coarse_tmr+0x11>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  80840b:	83 c4 14             	add    $0x14,%esp
  80840e:	5b                   	pop    %ebx
  80840f:	5d                   	pop    %ebp
  808410:	c3                   	ret    

00808411 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  808411:	55                   	push   %ebp
  808412:	89 e5                	mov    %esp,%ebp
  808414:	57                   	push   %edi
  808415:	56                   	push   %esi
  808416:	53                   	push   %ebx
  808417:	83 ec 3c             	sub    $0x3c,%esp
  80841a:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80841d:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  808420:	ba 0d 00 00 00       	mov    $0xd,%edx
  808425:	89 d8                	mov    %ebx,%eax
  808427:	e8 24 ea ff ff       	call   806e50 <_ZL14dhcp_set_stateP4dhcph>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  80842c:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  808433:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  80843a:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  808441:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  808448:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  80844f:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  808456:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  80845d:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  808464:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80846b:	89 f0                	mov    %esi,%eax
  80846d:	e8 dd ee ff ff       	call   80734f <_ZL19dhcp_create_requestP5netif>
  808472:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  808474:	84 c0                	test   %al,%al
  808476:	0f 85 87 00 00 00    	jne    808503 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80847c:	b9 01 00 00 00       	mov    $0x1,%ecx
  808481:	ba 35 00 00 00       	mov    $0x35,%edx
  808486:	89 d8                	mov    %ebx,%eax
  808488:	e8 15 eb ff ff       	call   806fa2 <_ZL11dhcp_optionP4dhcphh>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  80848d:	ba 07 00 00 00       	mov    $0x7,%edx
  808492:	89 d8                	mov    %ebx,%eax
  808494:	e8 80 eb ff ff       	call   807019 <_ZL16dhcp_option_byteP4dhcph>

    dhcp_option_trailer(dhcp);
  808499:	89 d8                	mov    %ebx,%eax
  80849b:	e8 c9 eb ff ff       	call   807069 <_ZL19dhcp_option_trailerP4dhcp>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8084a0:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8084a4:	66 05 f0 00          	add    $0xf0,%ax
  8084a8:	0f b7 c0             	movzwl %ax,%eax
  8084ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8084af:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8084b2:	89 04 24             	mov    %eax,(%esp)
  8084b5:	e8 25 0e 00 00       	call   8092df <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  8084ba:	8d 43 2c             	lea    0x2c(%ebx),%eax
  8084bd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8084c0:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8084c7:	00 
  8084c8:	89 44 24 04          	mov    %eax,0x4(%esp)
  8084cc:	8b 43 08             	mov    0x8(%ebx),%eax
  8084cf:	89 04 24             	mov    %eax,(%esp)
  8084d2:	e8 20 59 00 00       	call   80ddf7 <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8084d7:	89 74 24 10          	mov    %esi,0x10(%esp)
  8084db:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8084e2:	00 
  8084e3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8084e6:	89 44 24 08          	mov    %eax,0x8(%esp)
  8084ea:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8084ed:	89 44 24 04          	mov    %eax,0x4(%esp)
  8084f1:	8b 43 08             	mov    0x8(%ebx),%eax
  8084f4:	89 04 24             	mov    %eax,(%esp)
  8084f7:	e8 d1 56 00 00       	call   80dbcd <udp_sendto_if>
    dhcp_delete_request(netif);
  8084fc:	89 f0                	mov    %esi,%eax
  8084fe:	e8 60 ed ff ff       	call   807263 <_ZL19dhcp_delete_requestP5netif>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  808503:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  808507:	83 c1 01             	add    $0x1,%ecx
  80850a:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80850d:	ba 10 27 00 00       	mov    $0x2710,%edx
  808512:	80 f9 09             	cmp    $0x9,%cl
  808515:	77 08                	ja     80851f <dhcp_release+0x10e>
  808517:	0f b6 c9             	movzbl %cl,%ecx
  80851a:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80851f:	0f b7 d2             	movzwl %dx,%edx
  808522:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  808528:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80852d:	89 d0                	mov    %edx,%eax
  80852f:	f7 e9                	imul   %ecx
  808531:	c1 fa 05             	sar    $0x5,%edx
  808534:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  808538:	89 34 24             	mov    %esi,(%esp)
  80853b:	e8 a2 0b 00 00       	call   8090e2 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  808540:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  808547:	00 
  808548:	89 34 24             	mov    %esi,(%esp)
  80854b:	e8 7f 09 00 00       	call   808ecf <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  808550:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  808557:	00 
  808558:	89 34 24             	mov    %esi,(%esp)
  80855b:	e8 ed 09 00 00       	call   808f4d <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  808560:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  808567:	00 
  808568:	89 34 24             	mov    %esi,(%esp)
  80856b:	e8 f6 09 00 00       	call   808f66 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  808570:	89 f8                	mov    %edi,%eax
  808572:	83 c4 3c             	add    $0x3c,%esp
  808575:	5b                   	pop    %ebx
  808576:	5e                   	pop    %esi
  808577:	5f                   	pop    %edi
  808578:	5d                   	pop    %ebp
  808579:	c3                   	ret    

0080857a <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  80857a:	55                   	push   %ebp
  80857b:	89 e5                	mov    %esp,%ebp
  80857d:	53                   	push   %ebx
  80857e:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  808581:	8b 1d c4 a3 b3 00    	mov    0xb3a3c4,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  808587:	85 db                	test   %ebx,%ebx
  808589:	0f 84 cc 00 00 00    	je     80865b <dhcp_fine_tmr+0xe1>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80858f:	8b 43 20             	mov    0x20(%ebx),%eax
  808592:	85 c0                	test   %eax,%eax
  808594:	0f 84 b7 00 00 00    	je     808651 <dhcp_fine_tmr+0xd7>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  80859a:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  80859e:	66 83 fa 01          	cmp    $0x1,%dx
  8085a2:	76 0c                	jbe    8085b0 <dhcp_fine_tmr+0x36>
        netif->dhcp->request_timeout--;
  8085a4:	83 ea 01             	sub    $0x1,%edx
  8085a7:	66 89 50 26          	mov    %dx,0x26(%eax)
  8085ab:	e9 a1 00 00 00       	jmp    808651 <dhcp_fine_tmr+0xd7>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8085b0:	66 83 fa 01          	cmp    $0x1,%dx
  8085b4:	0f 85 97 00 00 00    	jne    808651 <dhcp_fine_tmr+0xd7>
        netif->dhcp->request_timeout--;
  8085ba:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  8085c0:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  8085c3:	0f b6 02             	movzbl (%edx),%eax
  8085c6:	3c 0c                	cmp    $0xc,%al
  8085c8:	74 04                	je     8085ce <dhcp_fine_tmr+0x54>
  8085ca:	3c 06                	cmp    $0x6,%al
  8085cc:	75 09                	jne    8085d7 <dhcp_fine_tmr+0x5d>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  8085ce:	89 d8                	mov    %ebx,%eax
  8085d0:	e8 6f ef ff ff       	call   807544 <_ZL13dhcp_discoverP5netif>
  8085d5:	eb 7a                	jmp    808651 <dhcp_fine_tmr+0xd7>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  8085d7:	3c 01                	cmp    $0x1,%al
  8085d9:	75 21                	jne    8085fc <dhcp_fine_tmr+0x82>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  8085db:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  8085df:	90                   	nop
  8085e0:	77 09                	ja     8085eb <dhcp_fine_tmr+0x71>
      dhcp_select(netif);
  8085e2:	89 d8                	mov    %ebx,%eax
  8085e4:	e8 cc f1 ff ff       	call   8077b5 <_ZL11dhcp_selectP5netif>
  8085e9:	eb 66                	jmp    808651 <dhcp_fine_tmr+0xd7>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  8085eb:	89 1c 24             	mov    %ebx,(%esp)
  8085ee:	e8 1e fe ff ff       	call   808411 <dhcp_release>
      dhcp_discover(netif);
  8085f3:	89 d8                	mov    %ebx,%eax
  8085f5:	e8 4a ef ff ff       	call   807544 <_ZL13dhcp_discoverP5netif>
  8085fa:	eb 55                	jmp    808651 <dhcp_fine_tmr+0xd7>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  8085fc:	3c 08                	cmp    $0x8,%al
  8085fe:	66 90                	xchg   %ax,%ax
  808600:	75 19                	jne    80861b <dhcp_fine_tmr+0xa1>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  808602:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  808606:	77 0a                	ja     808612 <dhcp_fine_tmr+0x98>
      dhcp_check(netif);
  808608:	89 d8                	mov    %ebx,%eax
  80860a:	e8 3c f3 ff ff       	call   80794b <_ZL10dhcp_checkP5netif>
  80860f:	90                   	nop
  808610:	eb 3f                	jmp    808651 <dhcp_fine_tmr+0xd7>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  808612:	89 d8                	mov    %ebx,%eax
  808614:	e8 6f f3 ff ff       	call   807988 <_ZL9dhcp_bindP5netif>
  808619:	eb 36                	jmp    808651 <dhcp_fine_tmr+0xd7>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  80861b:	3c 05                	cmp    $0x5,%al
  80861d:	8d 76 00             	lea    0x0(%esi),%esi
  808620:	75 0a                	jne    80862c <dhcp_fine_tmr+0xb2>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  808622:	89 1c 24             	mov    %ebx,(%esp)
  808625:	e8 4e fc ff ff       	call   808278 <dhcp_renew>
  80862a:	eb 25                	jmp    808651 <dhcp_fine_tmr+0xd7>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  80862c:	3c 04                	cmp    $0x4,%al
  80862e:	66 90                	xchg   %ax,%ax
  808630:	75 1f                	jne    808651 <dhcp_fine_tmr+0xd7>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  808632:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  808636:	77 0a                	ja     808642 <dhcp_fine_tmr+0xc8>
      dhcp_rebind(netif);
  808638:	89 d8                	mov    %ebx,%eax
  80863a:	e8 5e f0 ff ff       	call   80769d <_ZL11dhcp_rebindP5netif>
  80863f:	90                   	nop
  808640:	eb 0f                	jmp    808651 <dhcp_fine_tmr+0xd7>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  808642:	89 1c 24             	mov    %ebx,(%esp)
  808645:	e8 c7 fd ff ff       	call   808411 <dhcp_release>
      dhcp_discover(netif);
  80864a:	89 d8                	mov    %ebx,%eax
  80864c:	e8 f3 ee ff ff       	call   807544 <_ZL13dhcp_discoverP5netif>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  808651:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  808653:	85 db                	test   %ebx,%ebx
  808655:	0f 85 34 ff ff ff    	jne    80858f <dhcp_fine_tmr+0x15>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  80865b:	83 c4 14             	add    $0x14,%esp
  80865e:	5b                   	pop    %ebx
  80865f:	5d                   	pop    %ebp
  808660:	c3                   	ret    

00808661 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  808661:	55                   	push   %ebp
  808662:	89 e5                	mov    %esp,%ebp
  808664:	56                   	push   %esi
  808665:	53                   	push   %ebx
  808666:	83 ec 10             	sub    $0x10,%esp
  808669:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  80866c:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  80866f:	85 f6                	test   %esi,%esi
  808671:	75 1c                	jne    80868f <dhcp_stop+0x2e>
  808673:	c7 44 24 08 14 57 81 	movl   $0x815714,0x8(%esp)
  80867a:	00 
  80867b:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  808682:	00 
  808683:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  80868a:	e8 29 83 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80868f:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  808693:	85 db                	test   %ebx,%ebx
  808695:	74 42                	je     8086d9 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  808697:	8b 43 08             	mov    0x8(%ebx),%eax
  80869a:	85 c0                	test   %eax,%eax
  80869c:	74 0f                	je     8086ad <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  80869e:	89 04 24             	mov    %eax,(%esp)
  8086a1:	e8 08 58 00 00       	call   80deae <udp_remove>
      dhcp->pcb = NULL;
  8086a6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  8086ad:	8b 43 0c             	mov    0xc(%ebx),%eax
  8086b0:	85 c0                	test   %eax,%eax
  8086b2:	74 0f                	je     8086c3 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  8086b4:	89 04 24             	mov    %eax,(%esp)
  8086b7:	e8 47 0b 00 00       	call   809203 <pbuf_free>
      dhcp->p = NULL;
  8086bc:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  8086c3:	89 d8                	mov    %ebx,%eax
  8086c5:	e8 44 ec ff ff       	call   80730e <_ZL15dhcp_free_replyP4dhcp>
    mem_free((void *)dhcp);
  8086ca:	89 1c 24             	mov    %ebx,(%esp)
  8086cd:	e8 76 01 00 00       	call   808848 <mem_free>
    netif->dhcp = NULL;
  8086d2:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  8086d9:	83 c4 10             	add    $0x10,%esp
  8086dc:	5b                   	pop    %ebx
  8086dd:	5e                   	pop    %esi
  8086de:	5d                   	pop    %ebp
  8086df:	c3                   	ret    

008086e0 <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  8086e0:	55                   	push   %ebp
  8086e1:	89 e5                	mov    %esp,%ebp
  8086e3:	56                   	push   %esi
  8086e4:	53                   	push   %ebx
  8086e5:	83 ec 10             	sub    $0x10,%esp
  8086e8:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  8086eb:	85 f6                	test   %esi,%esi
  8086ed:	75 1c                	jne    80870b <dhcp_start+0x2b>
  8086ef:	c7 44 24 08 c2 56 81 	movl   $0x8156c2,0x8(%esp)
  8086f6:	00 
  8086f7:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8086fe:	00 
  8086ff:	c7 04 24 a2 56 81 00 	movl   $0x8156a2,(%esp)
  808706:	e8 ad 82 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  dhcp = netif->dhcp;
  80870b:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80870e:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  808712:	85 db                	test   %ebx,%ebx
  808714:	75 1e                	jne    808734 <dhcp_start+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
  808716:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  80871d:	e8 21 04 00 00       	call   808b43 <mem_malloc>
  808722:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
  808724:	b8 ff ff ff ff       	mov    $0xffffffff,%eax

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = (struct dhcp *)mem_malloc(sizeof(struct dhcp));
    if (dhcp == NULL) {
  808729:	85 db                	test   %ebx,%ebx
  80872b:	0f 84 a5 00 00 00    	je     8087d6 <dhcp_start+0xf6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  808731:	89 5e 20             	mov    %ebx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  808734:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80873b:	00 
  80873c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808743:	00 
  808744:	89 1c 24             	mov    %ebx,(%esp)
  808747:	e8 e5 8a ff ff       	call   801231 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  80874c:	e8 a9 57 00 00       	call   80defa <udp_new>
  808751:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  808754:	85 c0                	test   %eax,%eax
  808756:	75 16                	jne    80876e <dhcp_start+0x8e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  808758:	89 1c 24             	mov    %ebx,(%esp)
  80875b:	e8 e8 00 00 00       	call   808848 <mem_free>
    netif->dhcp = dhcp = NULL;
  808760:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
    return ERR_MEM;
  808767:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80876c:	eb 68                	jmp    8087d6 <dhcp_start+0xf6>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  80876e:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  808775:	00 
  808776:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  80877d:	00 
  80877e:	89 04 24             	mov    %eax,(%esp)
  808781:	e8 6e 53 00 00       	call   80daf4 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  808786:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80878d:	00 
  80878e:	c7 44 24 04 84 5f 81 	movl   $0x815f84,0x4(%esp)
  808795:	00 
  808796:	8b 43 08             	mov    0x8(%ebx),%eax
  808799:	89 04 24             	mov    %eax,(%esp)
  80879c:	e8 56 56 00 00       	call   80ddf7 <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  8087a1:	89 74 24 08          	mov    %esi,0x8(%esp)
  8087a5:	c7 44 24 04 17 7b 80 	movl   $0x807b17,0x4(%esp)
  8087ac:	00 
  8087ad:	8b 43 08             	mov    0x8(%ebx),%eax
  8087b0:	89 04 24             	mov    %eax,(%esp)
  8087b3:	e8 e2 56 00 00       	call   80de9a <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  8087b8:	89 f0                	mov    %esi,%eax
  8087ba:	e8 85 ed ff ff       	call   807544 <_ZL13dhcp_discoverP5netif>
  if (result != ERR_OK) {
  8087bf:	84 c0                	test   %al,%al
  8087c1:	74 0f                	je     8087d2 <dhcp_start+0xf2>
    /* free resources allocated above */
    dhcp_stop(netif);
  8087c3:	89 34 24             	mov    %esi,(%esp)
  8087c6:	e8 96 fe ff ff       	call   808661 <dhcp_stop>
    return ERR_MEM;
  8087cb:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8087d0:	eb 04                	jmp    8087d6 <dhcp_start+0xf6>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  8087d2:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
}
  8087d6:	83 c4 10             	add    $0x10,%esp
  8087d9:	5b                   	pop    %ebx
  8087da:	5e                   	pop    %esi
  8087db:	5d                   	pop    %ebp
  8087dc:	c3                   	ret    
  8087dd:	00 00                	add    %al,(%eax)
	...

008087e0 <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  8087e0:	55                   	push   %ebp
  8087e1:	89 e5                	mov    %esp,%ebp
  8087e3:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = (u8_t *) LWIP_MEM_ALIGN(ram_heap);
  8087e6:	b8 03 b3 81 00       	mov    $0x81b303,%eax
  8087eb:	83 e0 fc             	and    $0xfffffffc,%eax
  8087ee:	a3 e8 b2 81 00       	mov    %eax,0x81b2e8
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  8087f3:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  8087f9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  808800:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  808804:	8d 90 00 00 22 00    	lea    0x220000(%eax),%edx
  80880a:	89 15 ec b2 81 00    	mov    %edx,0x81b2ec
  ram_end->used = 1;
  808810:	c6 80 08 00 22 00 01 	movb   $0x1,0x220008(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  808817:	c7 80 00 00 22 00 00 	movl   $0x220000,0x220000(%eax)
  80881e:	00 22 00 
  ram_end->prev = MEM_SIZE_ALIGNED;
  808821:	c7 80 04 00 22 00 00 	movl   $0x220000,0x220004(%eax)
  808828:	00 22 00 

  mem_sem = sys_sem_new(1);
  80882b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  808832:	e8 a7 65 00 00       	call   80edde <sys_sem_new>
  808837:	a3 e0 b2 81 00       	mov    %eax,0x81b2e0

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80883c:	a1 e8 b2 81 00       	mov    0x81b2e8,%eax
  808841:	a3 e4 b2 81 00       	mov    %eax,0x81b2e4

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  808846:	c9                   	leave  
  808847:	c3                   	ret    

00808848 <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  808848:	55                   	push   %ebp
  808849:	89 e5                	mov    %esp,%ebp
  80884b:	83 ec 18             	sub    $0x18,%esp
  80884e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808851:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808854:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  808857:	85 db                	test   %ebx,%ebx
  808859:	0f 84 76 01 00 00    	je     8089d5 <mem_free+0x18d>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  80885f:	f6 c3 03             	test   $0x3,%bl
  808862:	74 1c                	je     808880 <mem_free+0x38>
  808864:	c7 44 24 08 30 57 81 	movl   $0x815730,0x8(%esp)
  80886b:	00 
  80886c:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  808873:	00 
  808874:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  80887b:	e8 38 81 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  808880:	3b 1d e8 b2 81 00    	cmp    0x81b2e8,%ebx
  808886:	72 08                	jb     808890 <mem_free+0x48>
  808888:	3b 1d ec b2 81 00    	cmp    0x81b2ec,%ebx
  80888e:	72 1c                	jb     8088ac <mem_free+0x64>
  808890:	c7 44 24 08 3b 58 81 	movl   $0x81583b,0x8(%esp)
  808897:	00 
  808898:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  80889f:	00 
  8088a0:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  8088a7:	e8 0c 81 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8088ac:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8088b3:	00 
  8088b4:	a1 e0 b2 81 00       	mov    0x81b2e0,%eax
  8088b9:	89 04 24             	mov    %eax,(%esp)
  8088bc:	e8 43 69 00 00       	call   80f204 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8088c1:	8d 43 f4             	lea    -0xc(%ebx),%eax
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  8088c4:	80 78 08 00          	cmpb   $0x0,0x8(%eax)
  8088c8:	75 1c                	jne    8088e6 <mem_free+0x9e>
  8088ca:	c7 44 24 08 52 58 81 	movl   $0x815852,0x8(%esp)
  8088d1:	00 
  8088d2:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  8088d9:	00 
  8088da:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  8088e1:	e8 d2 80 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* ... and is now unused. */
  mem->used = 0;
  8088e6:	c6 40 08 00          	movb   $0x0,0x8(%eax)

  if (mem < lfree) {
  8088ea:	3b 05 e4 b2 81 00    	cmp    0x81b2e4,%eax
  8088f0:	73 05                	jae    8088f7 <mem_free+0xaf>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  8088f2:	a3 e4 b2 81 00       	mov    %eax,0x81b2e4
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  8088f7:	8b 0d e8 b2 81 00    	mov    0x81b2e8,%ecx
  8088fd:	39 c8                	cmp    %ecx,%eax
  8088ff:	73 1c                	jae    80891d <mem_free+0xd5>
  808901:	c7 44 24 08 66 58 81 	movl   $0x815866,0x8(%esp)
  808908:	00 
  808909:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  808910:	00 
  808911:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808918:	e8 9b 80 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  80891d:	8b 35 ec b2 81 00    	mov    0x81b2ec,%esi
  808923:	39 f0                	cmp    %esi,%eax
  808925:	72 1c                	jb     808943 <mem_free+0xfb>
  808927:	c7 44 24 08 7d 58 81 	movl   $0x81587d,0x8(%esp)
  80892e:	00 
  80892f:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  808936:	00 
  808937:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  80893e:	e8 75 80 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  808943:	8b 53 f4             	mov    -0xc(%ebx),%edx
  808946:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80894c:	76 1c                	jbe    80896a <mem_free+0x122>
  80894e:	c7 44 24 08 54 57 81 	movl   $0x815754,0x8(%esp)
  808955:	00 
  808956:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  80895d:	00 
  80895e:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808965:	e8 4e 80 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  nmem = (struct mem *)&ram[mem->next];
  80896a:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  80896d:	39 d0                	cmp    %edx,%eax
  80896f:	74 26                	je     808997 <mem_free+0x14f>
  808971:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  808975:	75 20                	jne    808997 <mem_free+0x14f>
  808977:	39 d6                	cmp    %edx,%esi
  808979:	74 1c                	je     808997 <mem_free+0x14f>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  80897b:	3b 15 e4 b2 81 00    	cmp    0x81b2e4,%edx
  808981:	75 05                	jne    808988 <mem_free+0x140>
      lfree = mem;
  808983:	a3 e4 b2 81 00       	mov    %eax,0x81b2e4
    }
    mem->next = nmem->next;
  808988:	8b 32                	mov    (%edx),%esi
  80898a:	89 73 f4             	mov    %esi,-0xc(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  80898d:	8b 12                	mov    (%edx),%edx
  80898f:	89 c6                	mov    %eax,%esi
  808991:	29 ce                	sub    %ecx,%esi
  808993:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  808997:	8b 0d e8 b2 81 00    	mov    0x81b2e8,%ecx
  80899d:	89 ca                	mov    %ecx,%edx
  80899f:	03 50 04             	add    0x4(%eax),%edx
  if (pmem != mem && pmem->used == 0) {
  8089a2:	39 d0                	cmp    %edx,%eax
  8089a4:	74 22                	je     8089c8 <mem_free+0x180>
  8089a6:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8089aa:	75 1c                	jne    8089c8 <mem_free+0x180>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8089ac:	3b 05 e4 b2 81 00    	cmp    0x81b2e4,%eax
  8089b2:	75 06                	jne    8089ba <mem_free+0x172>
      lfree = pmem;
  8089b4:	89 15 e4 b2 81 00    	mov    %edx,0x81b2e4
    }
    pmem->next = mem->next;
  8089ba:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8089bd:	89 02                	mov    %eax,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8089bf:	8b 43 f4             	mov    -0xc(%ebx),%eax
  8089c2:	29 ca                	sub    %ecx,%edx
  8089c4:	89 54 01 04          	mov    %edx,0x4(%ecx,%eax,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8089c8:	a1 e0 b2 81 00       	mov    0x81b2e0,%eax
  8089cd:	89 04 24             	mov    %eax,(%esp)
  8089d0:	e8 ca 67 00 00       	call   80f19f <sys_sem_signal>
}
  8089d5:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8089d8:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8089db:	89 ec                	mov    %ebp,%esp
  8089dd:	5d                   	pop    %ebp
  8089de:	c3                   	ret    

008089df <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8089df:	55                   	push   %ebp
  8089e0:	89 e5                	mov    %esp,%ebp
  8089e2:	83 ec 38             	sub    $0x38,%esp
  8089e5:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8089e8:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8089eb:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8089ee:	8b 5d 08             	mov    0x8(%ebp),%ebx
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8089f1:	8b 75 0c             	mov    0xc(%ebp),%esi
  8089f4:	83 c6 03             	add    $0x3,%esi
  8089f7:	83 e6 fc             	and    $0xfffffffc,%esi

  if(newsize < MIN_SIZE_ALIGNED) {
  8089fa:	83 fe 0b             	cmp    $0xb,%esi
  8089fd:	76 0e                	jbe    808a0d <mem_realloc+0x2e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  8089ff:	81 fe 00 00 22 00    	cmp    $0x220000,%esi
  808a05:	0f 87 24 01 00 00    	ja     808b2f <mem_realloc+0x150>
  808a0b:	eb 05                	jmp    808a12 <mem_realloc+0x33>
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);

  if(newsize < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  808a0d:	be 0c 00 00 00       	mov    $0xc,%esi

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  808a12:	a1 e8 b2 81 00       	mov    0x81b2e8,%eax
  808a17:	39 c3                	cmp    %eax,%ebx
  808a19:	72 08                	jb     808a23 <mem_realloc+0x44>
  808a1b:	3b 1d ec b2 81 00    	cmp    0x81b2ec,%ebx
  808a21:	72 1c                	jb     808a3f <mem_realloc+0x60>
  808a23:	c7 44 24 08 97 58 81 	movl   $0x815897,0x8(%esp)
  808a2a:	00 
  808a2b:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  808a32:	00 
  808a33:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808a3a:	e8 79 7f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  808a3f:	8d 7b f4             	lea    -0xc(%ebx),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  808a42:	89 fa                	mov    %edi,%edx
  808a44:	29 c2                	sub    %eax,%edx
  808a46:	89 55 e0             	mov    %edx,-0x20(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  808a49:	8b 43 f4             	mov    -0xc(%ebx),%eax
  808a4c:	83 e8 0c             	sub    $0xc,%eax
  808a4f:	29 d0                	sub    %edx,%eax
  808a51:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  808a54:	39 f0                	cmp    %esi,%eax
  808a56:	73 1c                	jae    808a74 <mem_realloc+0x95>
  808a58:	c7 44 24 08 80 57 81 	movl   $0x815780,0x8(%esp)
  808a5f:	00 
  808a60:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  808a67:	00 
  808a68:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808a6f:	e8 44 7f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  808a74:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  808a77:	0f 84 b7 00 00 00    	je     808b34 <mem_realloc+0x155>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  808a7d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808a84:	00 
  808a85:	a1 e0 b2 81 00       	mov    0x81b2e0,%eax
  808a8a:	89 04 24             	mov    %eax,(%esp)
  808a8d:	e8 72 67 00 00       	call   80f204 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  808a92:	a1 e8 b2 81 00       	mov    0x81b2e8,%eax
  808a97:	89 c2                	mov    %eax,%edx
  808a99:	03 17                	add    (%edi),%edx
  if(mem2->used == 0) {
  808a9b:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  808a9f:	75 41                	jne    808ae2 <mem_realloc+0x103>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  808aa1:	8b 0a                	mov    (%edx),%ecx
  808aa3:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  808aa6:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  808aa9:	8d 74 0e 0c          	lea    0xc(%esi,%ecx,1),%esi
    if (lfree == mem2) {
  808aad:	39 15 e4 b2 81 00    	cmp    %edx,0x81b2e4
  808ab3:	75 09                	jne    808abe <mem_realloc+0xdf>
      lfree = (struct mem *)&ram[ptr2];
  808ab5:	8d 14 30             	lea    (%eax,%esi,1),%edx
  808ab8:	89 15 e4 b2 81 00    	mov    %edx,0x81b2e4
    }
    mem2 = (struct mem *)&ram[ptr2];
  808abe:	8d 14 30             	lea    (%eax,%esi,1),%edx
    mem2->used = 0;
  808ac1:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  808ac5:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  808ac8:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  808aca:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  808acd:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  808ad0:	89 37                	mov    %esi,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  808ad2:	8b 12                	mov    (%edx),%edx
  808ad4:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  808ada:	74 44                	je     808b20 <mem_realloc+0x141>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  808adc:	89 74 10 04          	mov    %esi,0x4(%eax,%edx,1)
  808ae0:	eb 3e                	jmp    808b20 <mem_realloc+0x141>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  808ae2:	8d 56 18             	lea    0x18(%esi),%edx
  808ae5:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  808ae8:	72 36                	jb     808b20 <mem_realloc+0x141>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  808aea:	8b 55 e0             	mov    -0x20(%ebp),%edx
  808aed:	8d 4c 16 0c          	lea    0xc(%esi,%edx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  808af1:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  808af4:	3b 15 e4 b2 81 00    	cmp    0x81b2e4,%edx
  808afa:	73 06                	jae    808b02 <mem_realloc+0x123>
      lfree = mem2;
  808afc:	89 15 e4 b2 81 00    	mov    %edx,0x81b2e4
    }
    mem2->used = 0;
  808b02:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  808b06:	8b 37                	mov    (%edi),%esi
  808b08:	89 32                	mov    %esi,(%edx)
    mem2->prev = ptr;
  808b0a:	8b 75 e0             	mov    -0x20(%ebp),%esi
  808b0d:	89 72 04             	mov    %esi,0x4(%edx)
    mem->next = ptr2;
  808b10:	89 0f                	mov    %ecx,(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  808b12:	8b 12                	mov    (%edx),%edx
  808b14:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  808b1a:	74 04                	je     808b20 <mem_realloc+0x141>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  808b1c:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  808b20:	a1 e0 b2 81 00       	mov    0x81b2e0,%eax
  808b25:	89 04 24             	mov    %eax,(%esp)
  808b28:	e8 72 66 00 00       	call   80f19f <sys_sem_signal>
  return rmem;
  808b2d:	eb 05                	jmp    808b34 <mem_realloc+0x155>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
    return NULL;
  808b2f:	bb 00 00 00 00       	mov    $0x0,%ebx
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  return rmem;
}
  808b34:	89 d8                	mov    %ebx,%eax
  808b36:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  808b39:	8b 75 f8             	mov    -0x8(%ebp),%esi
  808b3c:	8b 7d fc             	mov    -0x4(%ebp),%edi
  808b3f:	89 ec                	mov    %ebp,%esp
  808b41:	5d                   	pop    %ebp
  808b42:	c3                   	ret    

00808b43 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  808b43:	55                   	push   %ebp
  808b44:	89 e5                	mov    %esp,%ebp
  808b46:	83 ec 38             	sub    $0x38,%esp
  808b49:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  808b4c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  808b4f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  808b52:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
    return NULL;
  808b55:	b8 00 00 00 00       	mov    $0x0,%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  808b5a:	85 d2                	test   %edx,%edx
  808b5c:	0f 84 a2 01 00 00    	je     808d04 <mem_malloc+0x1c1>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  808b62:	83 c2 03             	add    $0x3,%edx
  808b65:	83 e2 fc             	and    $0xfffffffc,%edx
  808b68:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  808b6b:	83 fa 0b             	cmp    $0xb,%edx
  808b6e:	76 0e                	jbe    808b7e <mem_malloc+0x3b>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  808b70:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  808b76:	0f 87 83 01 00 00    	ja     808cff <mem_malloc+0x1bc>
  808b7c:	eb 07                	jmp    808b85 <mem_malloc+0x42>
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);

  if(size < MIN_SIZE_ALIGNED) {
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  808b7e:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  808b85:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808b8c:	00 
  808b8d:	a1 e0 b2 81 00       	mov    0x81b2e0,%eax
  808b92:	89 04 24             	mov    %eax,(%esp)
  808b95:	e8 6a 66 00 00       	call   80f204 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  808b9a:	8b 15 e8 b2 81 00    	mov    0x81b2e8,%edx
  808ba0:	a1 e4 b2 81 00       	mov    0x81b2e4,%eax
  808ba5:	29 d0                	sub    %edx,%eax
  808ba7:	b9 00 00 22 00       	mov    $0x220000,%ecx
  808bac:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
  808baf:	39 c8                	cmp    %ecx,%eax
  808bb1:	0f 83 34 01 00 00    	jae    808ceb <mem_malloc+0x1a8>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  808bb7:	89 d7                	mov    %edx,%edi
  808bb9:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  808bbc:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  808bc0:	0f 85 1b 01 00 00    	jne    808ce1 <mem_malloc+0x19e>
  808bc6:	8b 33                	mov    (%ebx),%esi
  808bc8:	83 ee 0c             	sub    $0xc,%esi
  808bcb:	29 c6                	sub    %eax,%esi
  808bcd:	3b 75 e4             	cmp    -0x1c(%ebp),%esi
  808bd0:	0f 82 0b 01 00 00    	jb     808ce1 <mem_malloc+0x19e>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  808bd6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808bd9:	83 c2 18             	add    $0x18,%edx
  808bdc:	39 d6                	cmp    %edx,%esi
  808bde:	72 2a                	jb     808c0a <mem_malloc+0xc7>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  808be0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808be3:	8d 4c 02 0c          	lea    0xc(%edx,%eax,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  808be7:	8d 14 0f             	lea    (%edi,%ecx,1),%edx
          mem2->used = 0;
  808bea:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  808bee:	8b 33                	mov    (%ebx),%esi
  808bf0:	89 32                	mov    %esi,(%edx)
          mem2->prev = ptr;
  808bf2:	89 42 04             	mov    %eax,0x4(%edx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  808bf5:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  808bf7:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  808bfb:	8b 02                	mov    (%edx),%eax
  808bfd:	3d 00 00 22 00       	cmp    $0x220000,%eax
  808c02:	74 0a                	je     808c0e <mem_malloc+0xcb>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  808c04:	89 4c 07 04          	mov    %ecx,0x4(%edi,%eax,1)
  808c08:	eb 04                	jmp    808c0e <mem_malloc+0xcb>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  808c0a:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  808c0e:	3b 1d e4 b2 81 00    	cmp    0x81b2e4,%ebx
  808c14:	75 4f                	jne    808c65 <mem_malloc+0x122>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  808c16:	8b 0d ec b2 81 00    	mov    0x81b2ec,%ecx
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  808c1c:	8b 35 e8 b2 81 00    	mov    0x81b2e8,%esi
  808c22:	89 d8                	mov    %ebx,%eax
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  808c24:	0f b6 50 08          	movzbl 0x8(%eax),%edx
  808c28:	84 d2                	test   %dl,%dl
  808c2a:	0f 84 e1 00 00 00    	je     808d11 <mem_malloc+0x1ce>
  808c30:	39 c1                	cmp    %eax,%ecx
  808c32:	75 0a                	jne    808c3e <mem_malloc+0xfb>
  808c34:	a3 e4 b2 81 00       	mov    %eax,0x81b2e4
  808c39:	e9 d8 00 00 00       	jmp    808d16 <mem_malloc+0x1d3>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  808c3e:	8b 00                	mov    (%eax),%eax
  808c40:	8d 04 06             	lea    (%esi,%eax,1),%eax
  808c43:	eb df                	jmp    808c24 <mem_malloc+0xe1>
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  808c45:	84 d2                	test   %dl,%dl
  808c47:	74 1c                	je     808c65 <mem_malloc+0x122>
  808c49:	c7 44 24 08 b1 58 81 	movl   $0x8158b1,0x8(%esp)
  808c50:	00 
  808c51:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  808c58:	00 
  808c59:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808c60:	e8 53 7d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  808c65:	a1 e0 b2 81 00       	mov    0x81b2e0,%eax
  808c6a:	89 04 24             	mov    %eax,(%esp)
  808c6d:	e8 2d 65 00 00       	call   80f19f <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  808c72:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  808c75:	8d 44 13 0c          	lea    0xc(%ebx,%edx,1),%eax
  808c79:	39 05 ec b2 81 00    	cmp    %eax,0x81b2ec
  808c7f:	73 1c                	jae    808c9d <mem_malloc+0x15a>
  808c81:	c7 44 24 08 a4 57 81 	movl   $0x8157a4,0x8(%esp)
  808c88:	00 
  808c89:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  808c90:	00 
  808c91:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808c98:	e8 1b 7d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  808c9d:	8d 43 0c             	lea    0xc(%ebx),%eax
  808ca0:	a8 03                	test   $0x3,%al
  808ca2:	74 1c                	je     808cc0 <mem_malloc+0x17d>
  808ca4:	c7 44 24 08 d4 57 81 	movl   $0x8157d4,0x8(%esp)
  808cab:	00 
  808cac:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  808cb3:	00 
  808cb4:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808cbb:	e8 f8 7c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  808cc0:	f6 c3 03             	test   $0x3,%bl
  808cc3:	74 3f                	je     808d04 <mem_malloc+0x1c1>
  808cc5:	c7 44 24 08 04 58 81 	movl   $0x815804,0x8(%esp)
  808ccc:	00 
  808ccd:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  808cd4:	00 
  808cd5:	c7 04 24 27 58 81 00 	movl   $0x815827,(%esp)
  808cdc:	e8 d7 7c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  808ce1:	8b 03                	mov    (%ebx),%eax
  808ce3:	39 c1                	cmp    %eax,%ecx
  808ce5:	0f 87 cc fe ff ff    	ja     808bb7 <mem_malloc+0x74>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  808ceb:	a1 e0 b2 81 00       	mov    0x81b2e0,%eax
  808cf0:	89 04 24             	mov    %eax,(%esp)
  808cf3:	e8 a7 64 00 00       	call   80f19f <sys_sem_signal>
  return NULL;
  808cf8:	b8 00 00 00 00       	mov    $0x0,%eax
  808cfd:	eb 05                	jmp    808d04 <mem_malloc+0x1c1>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
    return NULL;
  808cff:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
}
  808d04:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  808d07:	8b 75 f8             	mov    -0x8(%ebp),%esi
  808d0a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  808d0d:	89 ec                	mov    %ebp,%esp
  808d0f:	5d                   	pop    %ebp
  808d10:	c3                   	ret    
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
  808d11:	a3 e4 b2 81 00       	mov    %eax,0x81b2e4
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  808d16:	39 05 ec b2 81 00    	cmp    %eax,0x81b2ec
  808d1c:	0f 85 23 ff ff ff    	jne    808c45 <mem_malloc+0x102>
  808d22:	e9 3e ff ff ff       	jmp    808c65 <mem_malloc+0x122>

00808d27 <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  808d27:	55                   	push   %ebp
  808d28:	89 e5                	mov    %esp,%ebp
  808d2a:	83 ec 18             	sub    $0x18,%esp
  808d2d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808d30:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  808d33:	8b 75 0c             	mov    0xc(%ebp),%esi
  808d36:	0f af 75 08          	imul   0x8(%ebp),%esi
  808d3a:	89 34 24             	mov    %esi,(%esp)
  808d3d:	e8 01 fe ff ff       	call   808b43 <mem_malloc>
  808d42:	89 c3                	mov    %eax,%ebx
  if (p) {
  808d44:	85 c0                	test   %eax,%eax
  808d46:	74 14                	je     808d5c <mem_calloc+0x35>
    /* zero the memory */
    memset(p, 0, count * size);
  808d48:	89 74 24 08          	mov    %esi,0x8(%esp)
  808d4c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  808d53:	00 
  808d54:	89 04 24             	mov    %eax,(%esp)
  808d57:	e8 d5 84 ff ff       	call   801231 <memset>
  }
  return p;
}
  808d5c:	89 d8                	mov    %ebx,%eax
  808d5e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808d61:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808d64:	89 ec                	mov    %ebp,%esp
  808d66:	5d                   	pop    %ebp
  808d67:	c3                   	ret    

00808d68 <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  808d68:	55                   	push   %ebp
  808d69:	89 e5                	mov    %esp,%ebp
  808d6b:	57                   	push   %edi
  808d6c:	56                   	push   %esi
  808d6d:	53                   	push   %ebx
  808d6e:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = (struct memp *) LWIP_MEM_ALIGN(memp_memory);
  808d71:	b8 63 b3 a3 00       	mov    $0xa3b363,%eax
  808d76:	83 e0 fc             	and    $0xfffffffc,%eax
  808d79:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  808d80:	8b 55 f0             	mov    -0x10(%ebp),%edx
  808d83:	c7 84 12 20 b3 a3 00 	movl   $0x0,0xa3b320(%edx,%edx,1)
  808d8a:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  808d8e:	66 83 ba 5c 59 81 00 	cmpw   $0x0,0x81595c(%edx)
  808d95:	00 
  808d96:	74 37                	je     808dcf <memp_init+0x67>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  808d98:	0f b7 ba 40 59 81 00 	movzwl 0x815940(%edx),%edi
  memp = (struct memp *) LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  808d9f:	0f b7 b2 5c 59 81 00 	movzwl 0x81595c(%edx),%esi
  808da6:	bb 00 00 00 00       	mov    $0x0,%ebx
  808dab:	ba 00 00 00 00       	mov    $0x0,%edx
  808db0:	eb 04                	jmp    808db6 <memp_init+0x4e>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
  808db2:	89 c3                	mov    %eax,%ebx
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  808db4:	89 c8                	mov    %ecx,%eax
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  808db6:	89 18                	mov    %ebx,(%eax)
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  808db8:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
  memp = (struct memp *) LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  808dbb:	83 c2 01             	add    $0x1,%edx
  808dbe:	66 39 d6             	cmp    %dx,%si
  808dc1:	77 ef                	ja     808db2 <memp_init+0x4a>
  808dc3:	8b 55 f0             	mov    -0x10(%ebp),%edx
  808dc6:	89 84 12 20 b3 a3 00 	mov    %eax,0xa3b320(%edx,%edx,1)
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  808dcd:	89 c8                	mov    %ecx,%eax
  memp = (struct memp *) LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  808dcf:	83 45 f0 02          	addl   $0x2,-0x10(%ebp)
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = (struct memp *) LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  808dd3:	83 7d f0 1c          	cmpl   $0x1c,-0x10(%ebp)
  808dd7:	75 a7                	jne    808d80 <memp_init+0x18>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  808dd9:	83 c4 04             	add    $0x4,%esp
  808ddc:	5b                   	pop    %ebx
  808ddd:	5e                   	pop    %esi
  808dde:	5f                   	pop    %edi
  808ddf:	5d                   	pop    %ebp
  808de0:	c3                   	ret    

00808de1 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  808de1:	55                   	push   %ebp
  808de2:	89 e5                	mov    %esp,%ebp
  808de4:	83 ec 18             	sub    $0x18,%esp
  808de7:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  808dea:	83 fa 0d             	cmp    $0xd,%edx
  808ded:	7e 1c                	jle    808e0b <memp_malloc+0x2a>
  808def:	c7 44 24 08 ca 58 81 	movl   $0x8158ca,0x8(%esp)
  808df6:	00 
  808df7:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  808dfe:	00 
  808dff:	c7 04 24 e7 58 81 00 	movl   $0x8158e7,(%esp)
  808e06:	e8 ad 7b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  808e0b:	8b 04 95 20 b3 a3 00 	mov    0xa3b320(,%edx,4),%eax
  
  if (memp != NULL) {    
  808e12:	85 c0                	test   %eax,%eax
  808e14:	74 29                	je     808e3f <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  808e16:	8b 08                	mov    (%eax),%ecx
  808e18:	89 0c 95 20 b3 a3 00 	mov    %ecx,0xa3b320(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  808e1f:	a8 03                	test   $0x3,%al
  808e21:	74 1c                	je     808e3f <memp_malloc+0x5e>
  808e23:	c7 44 24 08 fc 58 81 	movl   $0x8158fc,0x8(%esp)
  808e2a:	00 
  808e2b:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  808e32:	00 
  808e33:	c7 04 24 e7 58 81 00 	movl   $0x8158e7,(%esp)
  808e3a:	e8 79 7b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  808e3f:	c9                   	leave  
  808e40:	c3                   	ret    

00808e41 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  808e41:	55                   	push   %ebp
  808e42:	89 e5                	mov    %esp,%ebp
  808e44:	83 ec 18             	sub    $0x18,%esp
  808e47:	8b 55 08             	mov    0x8(%ebp),%edx
  808e4a:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  808e4d:	85 c0                	test   %eax,%eax
  808e4f:	74 30                	je     808e81 <memp_free+0x40>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  808e51:	a8 03                	test   $0x3,%al
  808e53:	74 1c                	je     808e71 <memp_free+0x30>
  808e55:	c7 44 24 08 20 59 81 	movl   $0x815920,0x8(%esp)
  808e5c:	00 
  808e5d:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  808e64:	00 
  808e65:	c7 04 24 e7 58 81 00 	movl   $0x8158e7,(%esp)
  808e6c:	e8 47 7b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  808e71:	8b 0c 95 20 b3 a3 00 	mov    0xa3b320(,%edx,4),%ecx
  808e78:	89 08                	mov    %ecx,(%eax)
  memp_tab[type] = memp;
  808e7a:	89 04 95 20 b3 a3 00 	mov    %eax,0xa3b320(,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  808e81:	c9                   	leave  
  808e82:	c3                   	ret    
	...

00808e90 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  808e90:	55                   	push   %ebp
  808e91:	89 e5                	mov    %esp,%ebp
  808e93:	53                   	push   %ebx
  808e94:	8b 55 08             	mov    0x8(%ebp),%edx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
    return NULL;
  808e97:	b8 00 00 00 00       	mov    $0x0,%eax
netif_find(char *name)
{
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  808e9c:	85 d2                	test   %edx,%edx
  808e9e:	74 2c                	je     808ecc <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';
  808ea0:	0f b6 4a 02          	movzbl 0x2(%edx),%ecx
  808ea4:	83 e9 30             	sub    $0x30,%ecx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  808ea7:	a1 c4 a3 b3 00       	mov    0xb3a3c4,%eax
  808eac:	85 c0                	test   %eax,%eax
  808eae:	74 1c                	je     808ecc <netif_find+0x3c>
    if (num == netif->num &&
  808eb0:	38 48 31             	cmp    %cl,0x31(%eax)
  808eb3:	75 11                	jne    808ec6 <netif_find+0x36>
  808eb5:	0f b6 58 2f          	movzbl 0x2f(%eax),%ebx
  808eb9:	38 1a                	cmp    %bl,(%edx)
  808ebb:	75 09                	jne    808ec6 <netif_find+0x36>
  808ebd:	0f b6 58 30          	movzbl 0x30(%eax),%ebx
  808ec1:	38 5a 01             	cmp    %bl,0x1(%edx)
  808ec4:	74 06                	je     808ecc <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  808ec6:	8b 00                	mov    (%eax),%eax
  808ec8:	85 c0                	test   %eax,%eax
  808eca:	75 e4                	jne    808eb0 <netif_find+0x20>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  808ecc:	5b                   	pop    %ebx
  808ecd:	5d                   	pop    %ebp
  808ece:	c3                   	ret    

00808ecf <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  808ecf:	55                   	push   %ebp
  808ed0:	89 e5                	mov    %esp,%ebp
  808ed2:	57                   	push   %edi
  808ed3:	56                   	push   %esi
  808ed4:	53                   	push   %ebx
  808ed5:	83 ec 1c             	sub    $0x1c,%esp
  808ed8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808edb:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  808ede:	8b 43 04             	mov    0x4(%ebx),%eax
  808ee1:	39 06                	cmp    %eax,(%esi)
  808ee3:	74 52                	je     808f37 <netif_set_ipaddr+0x68>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  808ee5:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
    while (pcb != NULL) {
  808eea:	85 c0                	test   %eax,%eax
  808eec:	74 1d                	je     808f0b <netif_set_ipaddr+0x3c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  808eee:	8b 53 04             	mov    0x4(%ebx),%edx
  808ef1:	39 10                	cmp    %edx,(%eax)
  808ef3:	75 0f                	jne    808f04 <netif_set_ipaddr+0x35>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  808ef5:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  808ef8:	89 04 24             	mov    %eax,(%esp)
  808efb:	e8 6e 16 00 00       	call   80a56e <tcp_abort>
        pcb = next;
  808f00:	89 f8                	mov    %edi,%eax
  808f02:	eb 03                	jmp    808f07 <netif_set_ipaddr+0x38>
      } else {
        pcb = pcb->next;
  808f04:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  808f07:	85 c0                	test   %eax,%eax
  808f09:	75 e3                	jne    808eee <netif_set_ipaddr+0x1f>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  808f0b:	a1 d8 a3 b3 00       	mov    0xb3a3d8,%eax
  808f10:	85 c0                	test   %eax,%eax
  808f12:	74 23                	je     808f37 <netif_set_ipaddr+0x68>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  808f14:	85 c0                	test   %eax,%eax
  808f16:	74 18                	je     808f30 <netif_set_ipaddr+0x61>
  808f18:	8b 10                	mov    (%eax),%edx
  808f1a:	85 d2                	test   %edx,%edx
  808f1c:	74 12                	je     808f30 <netif_set_ipaddr+0x61>
  808f1e:	3b 53 04             	cmp    0x4(%ebx),%edx
  808f21:	75 0d                	jne    808f30 <netif_set_ipaddr+0x61>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  808f23:	ba 00 00 00 00       	mov    $0x0,%edx
  808f28:	85 f6                	test   %esi,%esi
  808f2a:	74 02                	je     808f2e <netif_set_ipaddr+0x5f>
  808f2c:	8b 16                	mov    (%esi),%edx
  808f2e:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  808f30:	8b 40 0c             	mov    0xc(%eax),%eax
  808f33:	85 c0                	test   %eax,%eax
  808f35:	75 dd                	jne    808f14 <netif_set_ipaddr+0x45>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  808f37:	b8 00 00 00 00       	mov    $0x0,%eax
  808f3c:	85 f6                	test   %esi,%esi
  808f3e:	74 02                	je     808f42 <netif_set_ipaddr+0x73>
  808f40:	8b 06                	mov    (%esi),%eax
  808f42:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  808f45:	83 c4 1c             	add    $0x1c,%esp
  808f48:	5b                   	pop    %ebx
  808f49:	5e                   	pop    %esi
  808f4a:	5f                   	pop    %edi
  808f4b:	5d                   	pop    %ebp
  808f4c:	c3                   	ret    

00808f4d <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  808f4d:	55                   	push   %ebp
  808f4e:	89 e5                	mov    %esp,%ebp
  808f50:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  808f53:	b8 00 00 00 00       	mov    $0x0,%eax
  808f58:	85 d2                	test   %edx,%edx
  808f5a:	74 02                	je     808f5e <netif_set_gw+0x11>
  808f5c:	8b 02                	mov    (%edx),%eax
  808f5e:	8b 55 08             	mov    0x8(%ebp),%edx
  808f61:	89 42 0c             	mov    %eax,0xc(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  808f64:	5d                   	pop    %ebp
  808f65:	c3                   	ret    

00808f66 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  808f66:	55                   	push   %ebp
  808f67:	89 e5                	mov    %esp,%ebp
  808f69:	8b 55 0c             	mov    0xc(%ebp),%edx
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  808f6c:	b8 00 00 00 00       	mov    $0x0,%eax
  808f71:	85 d2                	test   %edx,%edx
  808f73:	74 02                	je     808f77 <netif_set_netmask+0x11>
  808f75:	8b 02                	mov    (%edx),%eax
  808f77:	8b 55 08             	mov    0x8(%ebp),%edx
  808f7a:	89 42 08             	mov    %eax,0x8(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  808f7d:	5d                   	pop    %ebp
  808f7e:	c3                   	ret    

00808f7f <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  808f7f:	55                   	push   %ebp
  808f80:	89 e5                	mov    %esp,%ebp
  808f82:	53                   	push   %ebx
  808f83:	83 ec 14             	sub    $0x14,%esp
  808f86:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  808f89:	8b 45 0c             	mov    0xc(%ebp),%eax
  808f8c:	89 44 24 04          	mov    %eax,0x4(%esp)
  808f90:	89 1c 24             	mov    %ebx,(%esp)
  808f93:	e8 37 ff ff ff       	call   808ecf <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  808f98:	8b 45 10             	mov    0x10(%ebp),%eax
  808f9b:	89 44 24 04          	mov    %eax,0x4(%esp)
  808f9f:	89 1c 24             	mov    %ebx,(%esp)
  808fa2:	e8 bf ff ff ff       	call   808f66 <netif_set_netmask>
  netif_set_gw(netif, gw);
  808fa7:	8b 45 14             	mov    0x14(%ebp),%eax
  808faa:	89 44 24 04          	mov    %eax,0x4(%esp)
  808fae:	89 1c 24             	mov    %ebx,(%esp)
  808fb1:	e8 97 ff ff ff       	call   808f4d <netif_set_gw>
}
  808fb6:	83 c4 14             	add    $0x14,%esp
  808fb9:	5b                   	pop    %ebx
  808fba:	5d                   	pop    %ebp
  808fbb:	c3                   	ret    

00808fbc <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  808fbc:	55                   	push   %ebp
  808fbd:	89 e5                	mov    %esp,%ebp
  808fbf:	53                   	push   %ebx
  808fc0:	83 ec 14             	sub    $0x14,%esp
  808fc3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  808fc6:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  808fcd:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  808fd4:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  808fdb:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  808fdf:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  808fe6:	8b 45 18             	mov    0x18(%ebp),%eax
  808fe9:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  808fec:	0f b6 05 cc a3 b3 00 	movzbl 0xb3a3cc,%eax
  808ff3:	88 43 31             	mov    %al,0x31(%ebx)
  808ff6:	83 c0 01             	add    $0x1,%eax
  808ff9:	a2 cc a3 b3 00       	mov    %al,0xb3a3cc
  netif->input = input;
  808ffe:	8b 45 20             	mov    0x20(%ebp),%eax
  809001:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  809004:	8b 45 14             	mov    0x14(%ebp),%eax
  809007:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80900b:	8b 45 10             	mov    0x10(%ebp),%eax
  80900e:	89 44 24 08          	mov    %eax,0x8(%esp)
  809012:	8b 45 0c             	mov    0xc(%ebp),%eax
  809015:	89 44 24 04          	mov    %eax,0x4(%esp)
  809019:	89 1c 24             	mov    %ebx,(%esp)
  80901c:	e8 5e ff ff ff       	call   808f7f <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  809021:	89 1c 24             	mov    %ebx,(%esp)
  809024:	ff 55 1c             	call   *0x1c(%ebp)
  809027:	84 c0                	test   %al,%al
  809029:	75 0f                	jne    80903a <netif_add+0x7e>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  80902b:	a1 c4 a3 b3 00       	mov    0xb3a3c4,%eax
  809030:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  809032:	89 1d c4 a3 b3 00    	mov    %ebx,0xb3a3c4
  LWIP_DEBUGF(NETIF_DEBUG, (" netmask "));
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
  809038:	eb 05                	jmp    80903f <netif_add+0x83>

  netif_set_addr(netif, ipaddr, netmask, gw);

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
    return NULL;
  80903a:	bb 00 00 00 00       	mov    $0x0,%ebx
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  80903f:	89 d8                	mov    %ebx,%eax
  809041:	83 c4 14             	add    $0x14,%esp
  809044:	5b                   	pop    %ebx
  809045:	5d                   	pop    %ebp
  809046:	c3                   	ret    

00809047 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  809047:	55                   	push   %ebp
  809048:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  80904a:	8b 45 08             	mov    0x8(%ebp),%eax
  80904d:	a3 c8 a3 b3 00       	mov    %eax,0xb3a3c8
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  809052:	5d                   	pop    %ebp
  809053:	c3                   	ret    

00809054 <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  809054:	55                   	push   %ebp
  809055:	89 e5                	mov    %esp,%ebp
  809057:	83 ec 04             	sub    $0x4,%esp
  80905a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  80905d:	85 c9                	test   %ecx,%ecx
  80905f:	74 49                	je     8090aa <netif_remove+0x56>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  809061:	8b 15 c4 a3 b3 00    	mov    0xb3a3c4,%edx
  809067:	39 ca                	cmp    %ecx,%edx
  809069:	75 1f                	jne    80908a <netif_remove+0x36>
    netif_list = netif->next;
  80906b:	8b 02                	mov    (%edx),%eax
  80906d:	a3 c4 a3 b3 00       	mov    %eax,0xb3a3c4
  809072:	eb 22                	jmp    809096 <netif_remove+0x42>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  809074:	8b 10                	mov    (%eax),%edx
  809076:	39 ca                	cmp    %ecx,%edx
  809078:	74 0a                	je     809084 <netif_remove+0x30>
  80907a:	89 d0                	mov    %edx,%eax
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80907c:	85 c0                	test   %eax,%eax
  80907e:	75 f4                	jne    809074 <netif_remove+0x20>
  809080:	eb 28                	jmp    8090aa <netif_remove+0x56>
      if (tmpNetif->next == netif) {
  809082:	89 d0                	mov    %edx,%eax
        tmpNetif->next = netif->next;
  809084:	8b 11                	mov    (%ecx),%edx
  809086:	89 10                	mov    %edx,(%eax)
  809088:	eb 0c                	jmp    809096 <netif_remove+0x42>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  80908a:	85 d2                	test   %edx,%edx
  80908c:	74 1c                	je     8090aa <netif_remove+0x56>
      if (tmpNetif->next == netif) {
  80908e:	8b 02                	mov    (%edx),%eax
  809090:	39 c8                	cmp    %ecx,%eax
  809092:	75 e8                	jne    80907c <netif_remove+0x28>
  809094:	eb ec                	jmp    809082 <netif_remove+0x2e>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  809096:	39 0d c8 a3 b3 00    	cmp    %ecx,0xb3a3c8
  80909c:	75 0c                	jne    8090aa <netif_remove+0x56>
    /* reset default netif */
    netif_set_default(NULL);
  80909e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8090a5:	e8 9d ff ff ff       	call   809047 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  8090aa:	c9                   	leave  
  8090ab:	c3                   	ret    

008090ac <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  8090ac:	55                   	push   %ebp
  8090ad:	89 e5                	mov    %esp,%ebp
  8090af:	83 ec 18             	sub    $0x18,%esp
  8090b2:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  8090b5:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  8090b9:	f6 c2 01             	test   $0x1,%dl
  8090bc:	75 22                	jne    8090e0 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  8090be:	83 ca 01             	or     $0x1,%edx
  8090c1:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  8090c4:	f6 c2 20             	test   $0x20,%dl
  8090c7:	74 17                	je     8090e0 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  8090c9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8090d0:	00 
  8090d1:	8d 50 04             	lea    0x4(%eax),%edx
  8090d4:	89 54 24 04          	mov    %edx,0x4(%esp)
  8090d8:	89 04 24             	mov    %eax,(%esp)
  8090db:	e8 18 57 00 00       	call   80e7f8 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  8090e0:	c9                   	leave  
  8090e1:	c3                   	ret    

008090e2 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  8090e2:	55                   	push   %ebp
  8090e3:	89 e5                	mov    %esp,%ebp
  8090e5:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  8090e8:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  8090ec:	f6 c2 01             	test   $0x1,%dl
  8090ef:	74 06                	je     8090f7 <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  8090f1:	83 e2 fe             	and    $0xfffffffe,%edx
  8090f4:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  8090f7:	5d                   	pop    %ebp
  8090f8:	c3                   	ret    

008090f9 <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  8090f9:	55                   	push   %ebp
  8090fa:	89 e5                	mov    %esp,%ebp
  return (netif->flags & NETIF_FLAG_UP)?1:0;
  8090fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8090ff:	f6 40 2e 01          	testb  $0x1,0x2e(%eax)
  809103:	0f 95 c0             	setne  %al
}
  809106:	5d                   	pop    %ebp
  809107:	c3                   	ret    
	...

00809110 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  809110:	55                   	push   %ebp
  809111:	89 e5                	mov    %esp,%ebp
  809113:	83 ec 18             	sub    $0x18,%esp
  809116:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  809119:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80911c:	8b 55 08             	mov    0x8(%ebp),%edx
  80911f:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  809123:	85 d2                	test   %edx,%edx
  809125:	75 1c                	jne    809143 <pbuf_header+0x33>
  809127:	c7 44 24 08 f2 59 81 	movl   $0x8159f2,0x8(%esp)
  80912e:	00 
  80912f:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  809136:	00 
  809137:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80913e:	e8 75 78 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if ((header_size_increment == 0) || (p == NULL))
  809143:	66 85 c9             	test   %cx,%cx
  809146:	0f 84 a8 00 00 00    	je     8091f4 <pbuf_header+0xe4>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  80914c:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  80914e:	66 85 c9             	test   %cx,%cx
  809151:	79 24                	jns    809177 <pbuf_header+0x67>
    increment_magnitude = -header_size_increment;
  809153:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  809155:	66 3b 72 0a          	cmp    0xa(%edx),%si
  809159:	76 1c                	jbe    809177 <pbuf_header+0x67>
  80915b:	c7 44 24 08 8d 59 81 	movl   $0x81598d,0x8(%esp)
  809162:	00 
  809163:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  80916a:	00 
  80916b:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809172:	e8 41 78 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  809177:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  80917b:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  80917e:	66 85 c0             	test   %ax,%ax
  809181:	74 06                	je     809189 <pbuf_header+0x79>
  809183:	66 83 f8 03          	cmp    $0x3,%ax
  809187:	75 1d                	jne    8091a6 <pbuf_header+0x96>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  809189:	0f bf c1             	movswl %cx,%eax
  80918c:	89 de                	mov    %ebx,%esi
  80918e:	29 c6                	sub    %eax,%esi
  809190:	89 f0                	mov    %esi,%eax
  809192:	89 72 04             	mov    %esi,0x4(%edx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  809195:	8d 72 10             	lea    0x10(%edx),%esi
  809198:	39 f0                	cmp    %esi,%eax
  80919a:	73 49                	jae    8091e5 <pbuf_header+0xd5>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  80919c:	89 5a 04             	mov    %ebx,0x4(%edx)
      /* bail out unsuccesfully */
      return 1;
  80919f:	b8 01 00 00 00       	mov    $0x1,%eax
  8091a4:	eb 53                	jmp    8091f9 <pbuf_header+0xe9>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  8091a6:	83 e8 01             	sub    $0x1,%eax
  8091a9:	66 83 f8 01          	cmp    $0x1,%ax
  8091ad:	77 1a                	ja     8091c9 <pbuf_header+0xb9>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
    } else {
      /* cannot expand payload to front (yet!)
       * bail out unsuccesfully */
      return 1;
  8091af:	b8 01 00 00 00       	mov    $0x1,%eax
      return 1;
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  8091b4:	66 85 c9             	test   %cx,%cx
  8091b7:	79 40                	jns    8091f9 <pbuf_header+0xe9>
  8091b9:	66 3b 72 0a          	cmp    0xa(%edx),%si
  8091bd:	77 3a                	ja     8091f9 <pbuf_header+0xe9>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  8091bf:	0f bf c1             	movswl %cx,%eax
  8091c2:	29 c3                	sub    %eax,%ebx
  8091c4:	89 5a 04             	mov    %ebx,0x4(%edx)
  8091c7:	eb 1c                	jmp    8091e5 <pbuf_header+0xd5>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  8091c9:	c7 44 24 08 ab 59 81 	movl   $0x8159ab,0x8(%esp)
  8091d0:	00 
  8091d1:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  8091d8:	00 
  8091d9:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8091e0:	e8 d3 77 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  8091e5:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  8091e9:	66 01 4a 08          	add    %cx,0x8(%edx)

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  8091ed:	b8 00 00 00 00       	mov    $0x0,%eax
  8091f2:	eb 05                	jmp    8091f9 <pbuf_header+0xe9>
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
  8091f4:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
}
  8091f9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8091fc:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8091ff:	89 ec                	mov    %ebp,%esp
  809201:	5d                   	pop    %ebp
  809202:	c3                   	ret    

00809203 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  809203:	55                   	push   %ebp
  809204:	89 e5                	mov    %esp,%ebp
  809206:	56                   	push   %esi
  809207:	53                   	push   %ebx
  809208:	83 ec 10             	sub    $0x10,%esp
  80920b:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  80920e:	85 c0                	test   %eax,%eax
  809210:	75 1c                	jne    80922e <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  809212:	c7 44 24 08 f2 59 81 	movl   $0x8159f2,0x8(%esp)
  809219:	00 
  80921a:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  809221:	00 
  809222:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809229:	e8 8a 77 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  80922e:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  809232:	0f 86 84 00 00 00    	jbe    8092bc <pbuf_free+0xb9>
  809238:	c7 44 24 08 b9 59 81 	movl   $0x8159b9,0x8(%esp)
  80923f:	00 
  809240:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  809247:	00 
  809248:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80924f:	e8 64 77 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  809254:	c7 44 24 08 ce 59 81 	movl   $0x8159ce,0x8(%esp)
  80925b:	00 
  80925c:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  809263:	00 
  809264:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80926b:	e8 48 77 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  809270:	8b 18                	mov    (%eax),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  809272:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  809276:	66 83 fa 03          	cmp    $0x3,%dx
  80927a:	75 12                	jne    80928e <pbuf_free+0x8b>
        memp_free(MEMP_PBUF_POOL, p);
  80927c:	89 44 24 04          	mov    %eax,0x4(%esp)
  809280:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  809287:	e8 b5 fb ff ff       	call   808e41 <memp_free>
  80928c:	eb 23                	jmp    8092b1 <pbuf_free+0xae>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  80928e:	83 ea 01             	sub    $0x1,%edx
  809291:	66 83 fa 01          	cmp    $0x1,%dx
  809295:	77 12                	ja     8092a9 <pbuf_free+0xa6>
        memp_free(MEMP_PBUF, p);
  809297:	89 44 24 04          	mov    %eax,0x4(%esp)
  80929b:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  8092a2:	e8 9a fb ff ff       	call   808e41 <memp_free>
  8092a7:	eb 08                	jmp    8092b1 <pbuf_free+0xae>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  8092a9:	89 04 24             	mov    %eax,(%esp)
  8092ac:	e8 97 f5 ff ff       	call   808848 <mem_free>
      }
      count++;
  8092b1:	83 c6 01             	add    $0x1,%esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  8092b4:	85 db                	test   %ebx,%ebx
  8092b6:	74 1e                	je     8092d6 <pbuf_free+0xd3>
      } else {
        mem_free(p);
      }
      count++;
      /* proceed to next pbuf */
      p = q;
  8092b8:	89 d8                	mov    %ebx,%eax
  8092ba:	eb 05                	jmp    8092c1 <pbuf_free+0xbe>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  8092bc:	be 00 00 00 00       	mov    $0x0,%esi
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  8092c1:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  8092c5:	66 85 d2             	test   %dx,%dx
  8092c8:	74 8a                	je     809254 <pbuf_free+0x51>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  8092ca:	83 ea 01             	sub    $0x1,%edx
  8092cd:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  8092d1:	66 85 d2             	test   %dx,%dx
  8092d4:	74 9a                	je     809270 <pbuf_free+0x6d>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  8092d6:	89 f0                	mov    %esi,%eax
  8092d8:	83 c4 10             	add    $0x10,%esp
  8092db:	5b                   	pop    %ebx
  8092dc:	5e                   	pop    %esi
  8092dd:	5d                   	pop    %ebp
  8092de:	c3                   	ret    

008092df <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  8092df:	55                   	push   %ebp
  8092e0:	89 e5                	mov    %esp,%ebp
  8092e2:	56                   	push   %esi
  8092e3:	53                   	push   %ebx
  8092e4:	83 ec 10             	sub    $0x10,%esp
  8092e7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8092ea:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  8092ee:	85 db                	test   %ebx,%ebx
  8092f0:	75 1c                	jne    80930e <pbuf_realloc+0x2f>
  8092f2:	c7 44 24 08 e4 59 81 	movl   $0x8159e4,0x8(%esp)
  8092f9:	00 
  8092fa:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  809301:	00 
  809302:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809309:	e8 aa 76 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80930e:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  809312:	3c 03                	cmp    $0x3,%al
  809314:	0f 84 f7 00 00 00    	je     809411 <pbuf_realloc+0x132>
  80931a:	3c 01                	cmp    $0x1,%al
  80931c:	0f 84 ef 00 00 00    	je     809411 <pbuf_realloc+0x132>
  809322:	84 c0                	test   %al,%al
  809324:	0f 84 e7 00 00 00    	je     809411 <pbuf_realloc+0x132>
  80932a:	3c 02                	cmp    $0x2,%al
  80932c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  809330:	0f 84 db 00 00 00    	je     809411 <pbuf_realloc+0x132>
  809336:	c7 44 24 08 fc 59 81 	movl   $0x8159fc,0x8(%esp)
  80933d:	00 
  80933e:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  809345:	00 
  809346:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80934d:	e8 66 76 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  809352:	0f b7 d6             	movzwl %si,%edx
  809355:	0f b7 c0             	movzwl %ax,%eax
  809358:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  80935a:	eb 4d                	jmp    8093a9 <pbuf_realloc+0xca>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  80935c:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  809362:	7e 1c                	jle    809380 <pbuf_realloc+0xa1>
  809364:	c7 44 24 08 17 5a 81 	movl   $0x815a17,0x8(%esp)
  80936b:	00 
  80936c:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  809373:	00 
  809374:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80937b:	e8 38 76 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    q->tot_len += (u16_t)grow;
  809380:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  809384:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  809386:	85 db                	test   %ebx,%ebx
  809388:	75 1c                	jne    8093a6 <pbuf_realloc+0xc7>
  80938a:	c7 44 24 08 28 5a 81 	movl   $0x815a28,0x8(%esp)
  809391:	00 
  809392:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  809399:	00 
  80939a:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8093a1:	e8 12 76 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  8093a6:	66 29 c6             	sub    %ax,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8093a9:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8093ad:	66 39 c6             	cmp    %ax,%si
  8093b0:	77 aa                	ja     80935c <pbuf_realloc+0x7d>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  8093b2:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  8093b6:	75 3b                	jne    8093f3 <pbuf_realloc+0x114>
  8093b8:	66 39 f0             	cmp    %si,%ax
  8093bb:	74 36                	je     8093f3 <pbuf_realloc+0x114>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = (struct pbuf *) mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  8093bd:	0f b7 c6             	movzwl %si,%eax
  8093c0:	03 43 04             	add    0x4(%ebx),%eax
  8093c3:	29 d8                	sub    %ebx,%eax
  8093c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8093c9:	89 1c 24             	mov    %ebx,(%esp)
  8093cc:	e8 0e f6 ff ff       	call   8089df <mem_realloc>
  8093d1:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  8093d3:	85 c0                	test   %eax,%eax
  8093d5:	75 1c                	jne    8093f3 <pbuf_realloc+0x114>
  8093d7:	c7 44 24 08 40 5a 81 	movl   $0x815a40,0x8(%esp)
  8093de:	00 
  8093df:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  8093e6:	00 
  8093e7:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8093ee:	e8 c5 75 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  8093f3:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  8093f7:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  8093fb:	8b 03                	mov    (%ebx),%eax
  8093fd:	85 c0                	test   %eax,%eax
  8093ff:	74 08                	je     809409 <pbuf_realloc+0x12a>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  809401:	89 04 24             	mov    %eax,(%esp)
  809404:	e8 fa fd ff ff       	call   809203 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  809409:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80940f:	eb 0d                	jmp    80941e <pbuf_realloc+0x13f>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  809411:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809415:	66 39 f0             	cmp    %si,%ax
  809418:	0f 87 34 ff ff ff    	ja     809352 <pbuf_realloc+0x73>
    pbuf_free(q->next);
  }
  /* q is last packet in chain */
  q->next = NULL;

}
  80941e:	83 c4 10             	add    $0x10,%esp
  809421:	5b                   	pop    %ebx
  809422:	5e                   	pop    %esi
  809423:	5d                   	pop    %ebp
  809424:	c3                   	ret    

00809425 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  809425:	55                   	push   %ebp
  809426:	89 e5                	mov    %esp,%ebp
  809428:	57                   	push   %edi
  809429:	56                   	push   %esi
  80942a:	53                   	push   %ebx
  80942b:	83 ec 2c             	sub    $0x2c,%esp
  80942e:	8b 45 08             	mov    0x8(%ebp),%eax
  809431:	8b 7d 10             	mov    0x10(%ebp),%edi
  809434:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  809438:	83 f8 01             	cmp    $0x1,%eax
  80943b:	74 1c                	je     809459 <pbuf_alloc+0x34>
  80943d:	83 f8 01             	cmp    $0x1,%eax
  809440:	7f 0b                	jg     80944d <pbuf_alloc+0x28>
  case PBUF_TRANSPORT:
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
  809442:	ba 14 00 00 00       	mov    $0x14,%edx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  809447:	85 c0                	test   %eax,%eax
  809449:	74 13                	je     80945e <pbuf_alloc+0x39>
  80944b:	eb 24                	jmp    809471 <pbuf_alloc+0x4c>
  80944d:	83 f8 02             	cmp    $0x2,%eax
  809450:	74 11                	je     809463 <pbuf_alloc+0x3e>
  809452:	83 f8 03             	cmp    $0x3,%eax
  809455:	75 1a                	jne    809471 <pbuf_alloc+0x4c>
  809457:	eb 34                	jmp    80948d <pbuf_alloc+0x68>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  809459:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  80945e:	8d 42 14             	lea    0x14(%edx),%eax
  809461:	eb 05                	jmp    809468 <pbuf_alloc+0x43>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  809463:	b8 00 00 00 00       	mov    $0x0,%eax
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  809468:	83 c0 0e             	add    $0xe,%eax
  80946b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    break;
  80946f:	eb 22                	jmp    809493 <pbuf_alloc+0x6e>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  809471:	c7 44 24 08 5b 5a 81 	movl   $0x815a5b,0x8(%esp)
  809478:	00 
  809479:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  809480:	00 
  809481:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809488:	e8 2b 75 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  u16_t offset;
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  80948d:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
    return NULL;
  }

  switch (type) {
  809493:	83 ff 02             	cmp    $0x2,%edi
  809496:	7f 16                	jg     8094ae <pbuf_alloc+0x89>
  809498:	83 ff 01             	cmp    $0x1,%edi
  80949b:	0f 8d d2 01 00 00    	jge    809673 <pbuf_alloc+0x24e>
  8094a1:	85 ff                	test   %edi,%edi
  8094a3:	0f 84 7f 01 00 00    	je     809628 <pbuf_alloc+0x203>
  8094a9:	e9 f3 01 00 00       	jmp    8096a1 <pbuf_alloc+0x27c>
  8094ae:	83 ff 03             	cmp    $0x3,%edi
  8094b1:	0f 85 ea 01 00 00    	jne    8096a1 <pbuf_alloc+0x27c>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = (struct pbuf *) memp_malloc(MEMP_PBUF_POOL);
  8094b7:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  8094be:	e8 1e f9 ff ff       	call   808de1 <memp_malloc>
  8094c3:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  8094c5:	85 c0                	test   %eax,%eax
  8094c7:	0f 84 fa 01 00 00    	je     8096c7 <pbuf_alloc+0x2a2>
      return NULL;
    }
    p->type = type;
  8094cd:	89 f8                	mov    %edi,%eax
  8094cf:	88 45 e3             	mov    %al,-0x1d(%ebp)
  8094d2:	88 46 0c             	mov    %al,0xc(%esi)
    p->next = NULL;
  8094d5:	c7 06 00 00 00 00    	movl   $0x0,(%esi)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  8094db:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8094df:	8d 4c 06 13          	lea    0x13(%esi,%eax,1),%ecx
  8094e3:	83 e1 fc             	and    $0xfffffffc,%ecx
  8094e6:	89 4e 04             	mov    %ecx,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  8094e9:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  8094ed:	0f b7 db             	movzwl %bx,%ebx
  8094f0:	83 c0 03             	add    $0x3,%eax
  8094f3:	83 e0 fc             	and    $0xfffffffc,%eax
  8094f6:	ba d0 07 00 00       	mov    $0x7d0,%edx
  8094fb:	29 c2                	sub    %eax,%edx
  8094fd:	39 da                	cmp    %ebx,%edx
  8094ff:	0f 4f d3             	cmovg  %ebx,%edx
  809502:	89 d0                	mov    %edx,%eax
  809504:	66 89 56 0a          	mov    %dx,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  809508:	8d 96 e0 07 00 00    	lea    0x7e0(%esi),%edx
  80950e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  809511:	0f b7 d0             	movzwl %ax,%edx
  809514:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  809517:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80951a:	73 1c                	jae    809538 <pbuf_alloc+0x113>
  80951c:	c7 44 24 08 0c 5b 81 	movl   $0x815b0c,0x8(%esp)
  809523:	00 
  809524:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  80952b:	00 
  80952c:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809533:	e8 80 74 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  809538:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80953e:	0f b7 c0             	movzwl %ax,%eax
  809541:	29 c3                	sub    %eax,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  809543:	85 db                	test   %ebx,%ebx
  809545:	0f 8e 72 01 00 00    	jle    8096bd <pbuf_alloc+0x298>
    p->ref = 1;

    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
  80954b:	89 f7                	mov    %esi,%edi
  80954d:	eb 02                	jmp    809551 <pbuf_alloc+0x12c>
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
      /* remember this pbuf for linkage in next iteration */
      r = q;
  80954f:	89 c7                	mov    %eax,%edi
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
      q = (struct pbuf *) memp_malloc(MEMP_PBUF_POOL);
  809551:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  809558:	e8 84 f8 ff ff       	call   808de1 <memp_malloc>
      if (q == NULL) {
  80955d:	85 c0                	test   %eax,%eax
  80955f:	75 12                	jne    809573 <pbuf_alloc+0x14e>
        /* free chain so far allocated */
        pbuf_free(p);
  809561:	89 34 24             	mov    %esi,(%esp)
  809564:	e8 9a fc ff ff       	call   809203 <pbuf_free>
        /* bail out unsuccesfully */
        return NULL;
  809569:	be 00 00 00 00       	mov    $0x0,%esi
  80956e:	e9 54 01 00 00       	jmp    8096c7 <pbuf_alloc+0x2a2>
      }
      q->type = type;
  809573:	0f b6 55 e3          	movzbl -0x1d(%ebp),%edx
  809577:	88 50 0c             	mov    %dl,0xc(%eax)
      q->flags = 0;
  80957a:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  80957e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  809584:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  809586:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  80958c:	7e 1c                	jle    8095aa <pbuf_alloc+0x185>
  80958e:	c7 44 24 08 76 5a 81 	movl   $0x815a76,0x8(%esp)
  809595:	00 
  809596:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  80959d:	00 
  80959e:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8095a5:	e8 0e 74 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      q->tot_len = (u16_t)rem_len;
  8095aa:	89 d9                	mov    %ebx,%ecx
  8095ac:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  8095b0:	66 81 fb d0 07       	cmp    $0x7d0,%bx
  8095b5:	ba d0 07 00 00       	mov    $0x7d0,%edx
  8095ba:	0f 47 ca             	cmova  %edx,%ecx
  8095bd:	66 89 48 0a          	mov    %cx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  8095c1:	8d 50 10             	lea    0x10(%eax),%edx
  8095c4:	89 50 04             	mov    %edx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  8095c7:	f6 c2 03             	test   $0x3,%dl
  8095ca:	74 1c                	je     8095e8 <pbuf_alloc+0x1c3>
  8095cc:	c7 44 24 08 40 5b 81 	movl   $0x815b40,0x8(%esp)
  8095d3:	00 
  8095d4:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  8095db:	00 
  8095dc:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8095e3:	e8 d0 73 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8095e8:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8095ec:	03 56 04             	add    0x4(%esi),%edx
  8095ef:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8095f2:	73 1c                	jae    809610 <pbuf_alloc+0x1eb>
  8095f4:	c7 44 24 08 0c 5b 81 	movl   $0x815b0c,0x8(%esp)
  8095fb:	00 
  8095fc:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  809603:	00 
  809604:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80960b:	e8 a8 73 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  809610:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  809616:	0f b7 c9             	movzwl %cx,%ecx
  809619:	29 cb                	sub    %ecx,%ebx
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  80961b:	85 db                	test   %ebx,%ebx
  80961d:	0f 8f 2c ff ff ff    	jg     80954f <pbuf_alloc+0x12a>
  809623:	e9 95 00 00 00       	jmp    8096bd <pbuf_alloc+0x298>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  809628:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80962c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80962f:	89 c2                	mov    %eax,%edx
  809631:	83 c2 13             	add    $0x13,%edx
  809634:	83 e2 fc             	and    $0xfffffffc,%edx
  809637:	0f b7 c3             	movzwl %bx,%eax
  80963a:	83 c0 03             	add    $0x3,%eax
  80963d:	83 e0 fc             	and    $0xfffffffc,%eax
  809640:	8d 04 02             	lea    (%edx,%eax,1),%eax
  809643:	89 04 24             	mov    %eax,(%esp)
  809646:	e8 f8 f4 ff ff       	call   808b43 <mem_malloc>
  80964b:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  80964d:	85 c0                	test   %eax,%eax
  80964f:	74 76                	je     8096c7 <pbuf_alloc+0x2a2>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  809651:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  809654:	8d 44 10 13          	lea    0x13(%eax,%edx,1),%eax
  809658:	83 e0 fc             	and    $0xfffffffc,%eax
  80965b:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  80965e:	66 89 5e 08          	mov    %bx,0x8(%esi)
  809662:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  809666:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  80966c:	89 f8                	mov    %edi,%eax
  80966e:	88 46 0c             	mov    %al,0xc(%esi)
  809671:	eb 4a                	jmp    8096bd <pbuf_alloc+0x298>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = (struct pbuf *) memp_malloc(MEMP_PBUF);
  809673:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  80967a:	e8 62 f7 ff ff       	call   808de1 <memp_malloc>
  80967f:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  809681:	85 c0                	test   %eax,%eax
  809683:	74 42                	je     8096c7 <pbuf_alloc+0x2a2>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  809685:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  80968c:	66 89 58 08          	mov    %bx,0x8(%eax)
  809690:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  809694:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  80969a:	89 fa                	mov    %edi,%edx
  80969c:	88 50 0c             	mov    %dl,0xc(%eax)
    break;
  80969f:	eb 1c                	jmp    8096bd <pbuf_alloc+0x298>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  8096a1:	c7 44 24 08 8a 5a 81 	movl   $0x815a8a,0x8(%esp)
  8096a8:	00 
  8096a9:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  8096b0:	00 
  8096b1:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8096b8:	e8 fb 72 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  8096bd:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  8096c3:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  8096c7:	89 f0                	mov    %esi,%eax
  8096c9:	83 c4 2c             	add    $0x2c,%esp
  8096cc:	5b                   	pop    %ebx
  8096cd:	5e                   	pop    %esi
  8096ce:	5f                   	pop    %edi
  8096cf:	5d                   	pop    %ebp
  8096d0:	c3                   	ret    

008096d1 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  8096d1:	55                   	push   %ebp
  8096d2:	89 e5                	mov    %esp,%ebp
  8096d4:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  8096d7:	b8 00 00 00 00       	mov    $0x0,%eax
  while (p != NULL) {
  8096dc:	85 d2                	test   %edx,%edx
  8096de:	74 09                	je     8096e9 <pbuf_clen+0x18>
    ++len;
  8096e0:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  8096e3:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  8096e5:	85 d2                	test   %edx,%edx
  8096e7:	75 f7                	jne    8096e0 <pbuf_clen+0xf>
    ++len;
    p = p->next;
  }
  return len;
}
  8096e9:	5d                   	pop    %ebp
  8096ea:	c3                   	ret    

008096eb <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  8096eb:	55                   	push   %ebp
  8096ec:	89 e5                	mov    %esp,%ebp
  8096ee:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  8096f1:	85 c0                	test   %eax,%eax
  8096f3:	74 05                	je     8096fa <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  8096f5:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  8096fa:	5d                   	pop    %ebp
  8096fb:	c3                   	ret    

008096fc <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  8096fc:	55                   	push   %ebp
  8096fd:	89 e5                	mov    %esp,%ebp
  8096ff:	56                   	push   %esi
  809700:	53                   	push   %ebx
  809701:	83 ec 10             	sub    $0x10,%esp
  809704:	8b 75 08             	mov    0x8(%ebp),%esi
  809707:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  80970a:	85 f6                	test   %esi,%esi
  80970c:	74 12                	je     809720 <pbuf_cat+0x24>
  80970e:	85 db                	test   %ebx,%ebx
  809710:	74 0e                	je     809720 <pbuf_cat+0x24>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  809712:	8b 06                	mov    (%esi),%eax
  809714:	89 f1                	mov    %esi,%ecx
  809716:	85 c0                	test   %eax,%eax
  809718:	75 26                	jne    809740 <pbuf_cat+0x44>
  80971a:	89 c2                	mov    %eax,%edx
  80971c:	89 f0                	mov    %esi,%eax
  80971e:	eb 2e                	jmp    80974e <pbuf_cat+0x52>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  809720:	c7 44 24 08 70 5b 81 	movl   $0x815b70,0x8(%esp)
  809727:	00 
  809728:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  80972f:	00 
  809730:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809737:	e8 7c 72 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  80973c:	89 c1                	mov    %eax,%ecx
  80973e:	89 d0                	mov    %edx,%eax
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  809740:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  809744:	66 01 51 08          	add    %dx,0x8(%ecx)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  809748:	8b 10                	mov    (%eax),%edx
  80974a:	85 d2                	test   %edx,%edx
  80974c:	75 ee                	jne    80973c <pbuf_cat+0x40>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  80974e:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
  809752:	66 3b 48 0a          	cmp    0xa(%eax),%cx
  809756:	74 1c                	je     809774 <pbuf_cat+0x78>
  809758:	c7 44 24 08 a8 5b 81 	movl   $0x815ba8,0x8(%esp)
  80975f:	00 
  809760:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  809767:	00 
  809768:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80976f:	e8 44 72 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  809774:	85 d2                	test   %edx,%edx
  809776:	74 1c                	je     809794 <pbuf_cat+0x98>
  809778:	c7 44 24 08 a5 5a 81 	movl   $0x815aa5,0x8(%esp)
  80977f:	00 
  809780:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  809787:	00 
  809788:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  80978f:	e8 24 72 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  809794:	66 03 4b 08          	add    0x8(%ebx),%cx
  809798:	66 89 48 08          	mov    %cx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  80979c:	89 18                	mov    %ebx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  80979e:	83 c4 10             	add    $0x10,%esp
  8097a1:	5b                   	pop    %ebx
  8097a2:	5e                   	pop    %esi
  8097a3:	5d                   	pop    %ebp
  8097a4:	c3                   	ret    

008097a5 <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  8097a5:	55                   	push   %ebp
  8097a6:	89 e5                	mov    %esp,%ebp
  8097a8:	53                   	push   %ebx
  8097a9:	83 ec 14             	sub    $0x14,%esp
  8097ac:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  8097af:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8097b3:	8b 45 08             	mov    0x8(%ebp),%eax
  8097b6:	89 04 24             	mov    %eax,(%esp)
  8097b9:	e8 3e ff ff ff       	call   8096fc <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  8097be:	89 1c 24             	mov    %ebx,(%esp)
  8097c1:	e8 25 ff ff ff       	call   8096eb <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  8097c6:	83 c4 14             	add    $0x14,%esp
  8097c9:	5b                   	pop    %ebx
  8097ca:	5d                   	pop    %ebp
  8097cb:	c3                   	ret    

008097cc <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  8097cc:	55                   	push   %ebp
  8097cd:	89 e5                	mov    %esp,%ebp
  8097cf:	83 ec 38             	sub    $0x38,%esp
  8097d2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8097d5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8097d8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8097db:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  8097de:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  8097e0:	85 f6                	test   %esi,%esi
  8097e2:	74 57                	je     80983b <pbuf_dechain+0x6f>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  8097e4:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  8097e8:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8097ec:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  8097f0:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8097f3:	0f b7 fa             	movzwl %dx,%edi
  8097f6:	0f b7 c8             	movzwl %ax,%ecx
  8097f9:	29 cf                	sub    %ecx,%edi
  8097fb:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  8097fe:	74 1c                	je     80981c <pbuf_dechain+0x50>
  809800:	c7 44 24 08 d8 5b 81 	movl   $0x815bd8,0x8(%esp)
  809807:	00 
  809808:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  80980f:	00 
  809810:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809817:	e8 9c 71 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  80981c:	66 29 c2             	sub    %ax,%dx
  80981f:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  809823:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  809829:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80982d:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  809831:	89 34 24             	mov    %esi,(%esp)
  809834:	e8 ca f9 ff ff       	call   809203 <pbuf_free>
  809839:	eb 05                	jmp    809840 <pbuf_dechain+0x74>
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  struct pbuf *q;
  u8_t tail_gone = 1;
  80983b:	b8 01 00 00 00       	mov    $0x1,%eax
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  809840:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  809844:	66 39 53 08          	cmp    %dx,0x8(%ebx)
  809848:	74 1c                	je     809866 <pbuf_dechain+0x9a>
  80984a:	c7 44 24 08 b5 5a 81 	movl   $0x815ab5,0x8(%esp)
  809851:	00 
  809852:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  809859:	00 
  80985a:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809861:	e8 52 71 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  return ((tail_gone > 0) ? NULL : q);
  809866:	84 c0                	test   %al,%al
  809868:	b8 00 00 00 00       	mov    $0x0,%eax
  80986d:	0f 45 f0             	cmovne %eax,%esi
}
  809870:	89 f0                	mov    %esi,%eax
  809872:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809875:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809878:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80987b:	89 ec                	mov    %ebp,%esp
  80987d:	5d                   	pop    %ebp
  80987e:	c3                   	ret    

0080987f <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  80987f:	55                   	push   %ebp
  809880:	89 e5                	mov    %esp,%ebp
  809882:	57                   	push   %edi
  809883:	56                   	push   %esi
  809884:	53                   	push   %ebx
  809885:	83 ec 4c             	sub    $0x4c,%esp
  809888:	8b 75 08             	mov    0x8(%ebp),%esi
  80988b:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  80988e:	85 f6                	test   %esi,%esi
  809890:	0f 94 c0             	sete   %al
  809893:	74 0e                	je     8098a3 <pbuf_copy+0x24>
  809895:	85 db                	test   %ebx,%ebx
  809897:	74 0a                	je     8098a3 <pbuf_copy+0x24>
  809899:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  80989d:	66 39 56 08          	cmp    %dx,0x8(%esi)
  8098a1:	73 1c                	jae    8098bf <pbuf_copy+0x40>
  8098a3:	c7 44 24 08 fc 5b 81 	movl   $0x815bfc,0x8(%esp)
  8098aa:	00 
  8098ab:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  8098b2:	00 
  8098b3:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8098ba:	e8 f9 70 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  8098bf:	84 c0                	test   %al,%al
  8098c1:	75 11                	jne    8098d4 <pbuf_copy+0x55>
  8098c3:	bf 00 00 00 00       	mov    $0x0,%edi
  8098c8:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
  8098ce:	eb 20                	jmp    8098f0 <pbuf_copy+0x71>
  8098d0:	85 f6                	test   %esi,%esi
  8098d2:	75 1c                	jne    8098f0 <pbuf_copy+0x71>
  8098d4:	c7 44 24 08 ca 5a 81 	movl   $0x815aca,0x8(%esp)
  8098db:	00 
  8098dc:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  8098e3:	00 
  8098e4:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8098eb:	e8 c8 70 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  8098f0:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  8098f4:	0f b7 56 0a          	movzwl 0xa(%esi),%edx
  8098f8:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  8098fc:	29 c2                	sub    %eax,%edx
  8098fe:	89 55 c4             	mov    %edx,-0x3c(%ebp)
  809901:	0f b7 d1             	movzwl %cx,%edx
  809904:	0f b7 c7             	movzwl %di,%eax
  809907:	29 c2                	sub    %eax,%edx
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  809909:	66 29 f9             	sub    %di,%cx
  80990c:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  809910:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  809914:	39 55 c4             	cmp    %edx,-0x3c(%ebp)
  809917:	89 ca                	mov    %ecx,%edx
  809919:	0f 4c d0             	cmovl  %eax,%edx
  80991c:	66 89 55 c8          	mov    %dx,-0x38(%ebp)
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  809920:	0f b7 c2             	movzwl %dx,%eax
  809923:	89 44 24 08          	mov    %eax,0x8(%esp)
  809927:	0f b7 c7             	movzwl %di,%eax
  80992a:	03 43 04             	add    0x4(%ebx),%eax
  80992d:	89 44 24 04          	mov    %eax,0x4(%esp)
  809931:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809935:	03 46 04             	add    0x4(%esi),%eax
  809938:	89 04 24             	mov    %eax,(%esp)
  80993b:	e8 c7 79 ff ff       	call   801307 <memcpy>
    offset_to += len;
  809940:	0f b7 45 c8          	movzwl -0x38(%ebp),%eax
  809944:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  809948:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  80994c:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  809950:	76 1c                	jbe    80996e <pbuf_copy+0xef>
  809952:	c7 44 24 08 d7 5a 81 	movl   $0x815ad7,0x8(%esp)
  809959:	00 
  80995a:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  809961:	00 
  809962:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809969:	e8 4a 70 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    if (offset_to == p_to->len) {
  80996e:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  809972:	75 08                	jne    80997c <pbuf_copy+0xfd>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  809974:	8b 36                	mov    (%esi),%esi
    offset_to += len;
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
  809976:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  80997c:	66 03 7d c8          	add    -0x38(%ebp),%di
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  809980:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  809984:	66 39 c7             	cmp    %ax,%di
  809987:	76 1c                	jbe    8099a5 <pbuf_copy+0x126>
  809989:	c7 44 24 08 ee 5a 81 	movl   $0x815aee,0x8(%esp)
  809990:	00 
  809991:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  809998:	00 
  809999:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8099a0:	e8 13 70 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    if (offset_from >= p_from->len) {
  8099a5:	66 39 c7             	cmp    %ax,%di
  8099a8:	72 07                	jb     8099b1 <pbuf_copy+0x132>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  8099aa:	8b 1b                	mov    (%ebx),%ebx
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
    if (offset_from >= p_from->len) {
      /* on to next p_from (if any) */
      offset_from = 0;
  8099ac:	bf 00 00 00 00       	mov    $0x0,%edi
      p_from = p_from->next;
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  8099b1:	85 db                	test   %ebx,%ebx
  8099b3:	74 2b                	je     8099e0 <pbuf_copy+0x161>
  8099b5:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  8099b9:	66 39 53 0a          	cmp    %dx,0xa(%ebx)
  8099bd:	75 21                	jne    8099e0 <pbuf_copy+0x161>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  8099bf:	83 3b 00             	cmpl   $0x0,(%ebx)
  8099c2:	74 1c                	je     8099e0 <pbuf_copy+0x161>
  8099c4:	c7 44 24 08 2c 5c 81 	movl   $0x815c2c,0x8(%esp)
  8099cb:	00 
  8099cc:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  8099d3:	00 
  8099d4:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  8099db:	e8 d8 6f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  8099e0:	85 f6                	test   %esi,%esi
  8099e2:	74 2b                	je     809a0f <pbuf_copy+0x190>
  8099e4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8099e8:	66 39 46 0a          	cmp    %ax,0xa(%esi)
  8099ec:	75 21                	jne    809a0f <pbuf_copy+0x190>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  8099ee:	83 3e 00             	cmpl   $0x0,(%esi)
  8099f1:	74 1c                	je     809a0f <pbuf_copy+0x190>
  8099f3:	c7 44 24 08 2c 5c 81 	movl   $0x815c2c,0x8(%esp)
  8099fa:	00 
  8099fb:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  809a02:	00 
  809a03:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809a0a:	e8 a9 6f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  809a0f:	85 db                	test   %ebx,%ebx
  809a11:	0f 85 b9 fe ff ff    	jne    8098d0 <pbuf_copy+0x51>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  809a17:	b8 00 00 00 00       	mov    $0x0,%eax
  809a1c:	83 c4 4c             	add    $0x4c,%esp
  809a1f:	5b                   	pop    %ebx
  809a20:	5e                   	pop    %esi
  809a21:	5f                   	pop    %edi
  809a22:	5d                   	pop    %ebp
  809a23:	c3                   	ret    

00809a24 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  809a24:	55                   	push   %ebp
  809a25:	89 e5                	mov    %esp,%ebp
  809a27:	57                   	push   %edi
  809a28:	56                   	push   %esi
  809a29:	53                   	push   %ebx
  809a2a:	83 ec 2c             	sub    $0x2c,%esp
  809a2d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809a30:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  809a34:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  809a38:	85 db                	test   %ebx,%ebx
  809a3a:	75 1c                	jne    809a58 <pbuf_copy_partial+0x34>
  809a3c:	c7 44 24 08 58 5c 81 	movl   $0x815c58,0x8(%esp)
  809a43:	00 
  809a44:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  809a4b:	00 
  809a4c:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809a53:	e8 60 6f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  809a58:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  809a5c:	75 1c                	jne    809a7a <pbuf_copy_partial+0x56>
  809a5e:	c7 44 24 08 7c 5c 81 	movl   $0x815c7c,0x8(%esp)
  809a65:	00 
  809a66:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  809a6d:	00 
  809a6e:	c7 04 24 78 59 81 00 	movl   $0x815978,(%esp)
  809a75:	e8 3e 6f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  809a7a:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  809a80:	66 85 f6             	test   %si,%si
  809a83:	74 61                	je     809ae6 <pbuf_copy_partial+0xc2>
  809a85:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    if ((offset != 0) && (offset >= p->len)) {
  809a8b:	66 85 c0             	test   %ax,%ax
  809a8e:	74 0e                	je     809a9e <pbuf_copy_partial+0x7a>
  809a90:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  809a94:	66 39 c2             	cmp    %ax,%dx
  809a97:	77 05                	ja     809a9e <pbuf_copy_partial+0x7a>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  809a99:	66 29 d0             	sub    %dx,%ax
  809a9c:	eb 3d                	jmp    809adb <pbuf_copy_partial+0xb7>
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  809a9e:	0f b7 7b 0a          	movzwl 0xa(%ebx),%edi
  809aa2:	66 29 c7             	sub    %ax,%di
  809aa5:	66 39 f7             	cmp    %si,%di
  809aa8:	0f 47 fe             	cmova  %esi,%edi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  809aab:	0f b7 d7             	movzwl %di,%edx
  809aae:	89 54 24 08          	mov    %edx,0x8(%esp)
  809ab2:	0f b7 c0             	movzwl %ax,%eax
  809ab5:	03 43 04             	add    0x4(%ebx),%eax
  809ab8:	89 44 24 04          	mov    %eax,0x4(%esp)
  809abc:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809ac0:	03 45 0c             	add    0xc(%ebp),%eax
  809ac3:	89 04 24             	mov    %eax,(%esp)
  809ac6:	e8 3c 78 ff ff       	call   801307 <memcpy>
      copied_total += buf_copy_len;
  809acb:	66 01 7d e4          	add    %di,-0x1c(%ebp)
      left += buf_copy_len;
  809acf:	66 01 7d e6          	add    %di,-0x1a(%ebp)
      len -= buf_copy_len;
  809ad3:	66 29 fe             	sub    %di,%si
      offset = 0;
  809ad6:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  809adb:	8b 1b                	mov    (%ebx),%ebx
  809add:	66 85 f6             	test   %si,%si
  809ae0:	74 04                	je     809ae6 <pbuf_copy_partial+0xc2>
  809ae2:	85 db                	test   %ebx,%ebx
  809ae4:	75 a5                	jne    809a8b <pbuf_copy_partial+0x67>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  809ae6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809aea:	83 c4 2c             	add    $0x2c,%esp
  809aed:	5b                   	pop    %ebx
  809aee:	5e                   	pop    %esi
  809aef:	5f                   	pop    %edi
  809af0:	5d                   	pop    %ebp
  809af1:	c3                   	ret    
	...

00809b00 <_ZL12sswt_handlerPv>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  809b00:	55                   	push   %ebp
  809b01:	89 e5                	mov    %esp,%ebp
  809b03:	83 ec 18             	sub    $0x18,%esp
  809b06:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  809b09:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  809b0e:	8b 40 04             	mov    0x4(%eax),%eax
  809b11:	8b 00                	mov    (%eax),%eax
  809b13:	89 04 24             	mov    %eax,(%esp)
  809b16:	e8 84 56 00 00       	call   80f19f <sys_sem_signal>
}
  809b1b:	c9                   	leave  
  809b1c:	c3                   	ret    

00809b1d <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  809b1d:	55                   	push   %ebp
  809b1e:	89 e5                	mov    %esp,%ebp
  809b20:	57                   	push   %edi
  809b21:	56                   	push   %esi
  809b22:	53                   	push   %ebx
  809b23:	83 ec 1c             	sub    $0x1c,%esp
  809b26:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  809b29:	e8 0d 5b 00 00       	call   80f63b <sys_arch_timeouts>
  809b2e:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  809b30:	85 c0                	test   %eax,%eax
  809b32:	74 06                	je     809b3a <sys_mbox_fetch+0x1d>
  809b34:	8b 00                	mov    (%eax),%eax
  809b36:	85 c0                	test   %eax,%eax
  809b38:	75 19                	jne    809b53 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  809b3a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  809b41:	00 
  809b42:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809b46:	8b 45 08             	mov    0x8(%ebp),%eax
  809b49:	89 04 24             	mov    %eax,(%esp)
  809b4c:	e8 03 59 00 00       	call   80f454 <sys_arch_mbox_fetch>
  809b51:	eb 5d                	jmp    809bb0 <sys_mbox_fetch+0x93>
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  809b53:	8b 40 04             	mov    0x4(%eax),%eax
  809b56:	85 c0                	test   %eax,%eax
  809b58:	74 18                	je     809b72 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  809b5a:	89 44 24 08          	mov    %eax,0x8(%esp)
  809b5e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809b62:	8b 45 08             	mov    0x8(%ebp),%eax
  809b65:	89 04 24             	mov    %eax,(%esp)
  809b68:	e8 e7 58 00 00       	call   80f454 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  809b6d:	83 f8 ff             	cmp    $0xffffffff,%eax
  809b70:	75 27                	jne    809b99 <sys_mbox_fetch+0x7c>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  809b72:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  809b74:	8b 10                	mov    (%eax),%edx
  809b76:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  809b78:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  809b7b:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  809b7e:	89 44 24 04          	mov    %eax,0x4(%esp)
  809b82:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  809b89:	e8 b3 f2 ff ff       	call   808e41 <memp_free>
      if (h != NULL) {
  809b8e:	85 db                	test   %ebx,%ebx
  809b90:	74 97                	je     809b29 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  809b92:	89 34 24             	mov    %esi,(%esp)
  809b95:	ff d3                	call   *%ebx
  809b97:	eb 90                	jmp    809b29 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  809b99:	8b 13                	mov    (%ebx),%edx
  809b9b:	8b 4a 04             	mov    0x4(%edx),%ecx
  809b9e:	39 c8                	cmp    %ecx,%eax
  809ba0:	73 07                	jae    809ba9 <sys_mbox_fetch+0x8c>
        timeouts->next->time -= time_needed;
  809ba2:	29 c1                	sub    %eax,%ecx
  809ba4:	89 4a 04             	mov    %ecx,0x4(%edx)
  809ba7:	eb 07                	jmp    809bb0 <sys_mbox_fetch+0x93>
      } else {
        timeouts->next->time = 0;
  809ba9:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  809bb0:	83 c4 1c             	add    $0x1c,%esp
  809bb3:	5b                   	pop    %ebx
  809bb4:	5e                   	pop    %esi
  809bb5:	5f                   	pop    %edi
  809bb6:	5d                   	pop    %ebp
  809bb7:	c3                   	ret    

00809bb8 <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  809bb8:	55                   	push   %ebp
  809bb9:	89 e5                	mov    %esp,%ebp
  809bbb:	57                   	push   %edi
  809bbc:	56                   	push   %esi
  809bbd:	53                   	push   %ebx
  809bbe:	83 ec 1c             	sub    $0x1c,%esp
  809bc1:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  809bc4:	e8 72 5a 00 00       	call   80f63b <sys_arch_timeouts>
  809bc9:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  809bcb:	85 c0                	test   %eax,%eax
  809bcd:	74 06                	je     809bd5 <sys_sem_wait+0x1d>
  809bcf:	8b 00                	mov    (%eax),%eax
  809bd1:	85 c0                	test   %eax,%eax
  809bd3:	75 12                	jne    809be7 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  809bd5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809bdc:	00 
  809bdd:	89 3c 24             	mov    %edi,(%esp)
  809be0:	e8 1f 56 00 00       	call   80f204 <sys_arch_sem_wait>
  809be5:	eb 56                	jmp    809c3d <sys_sem_wait+0x85>
  } else {
    if (timeouts->next->time > 0) {
  809be7:	8b 40 04             	mov    0x4(%eax),%eax
  809bea:	85 c0                	test   %eax,%eax
  809bec:	74 11                	je     809bff <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  809bee:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bf2:	89 3c 24             	mov    %edi,(%esp)
  809bf5:	e8 0a 56 00 00       	call   80f204 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  809bfa:	83 f8 ff             	cmp    $0xffffffff,%eax
  809bfd:	75 27                	jne    809c26 <sys_sem_wait+0x6e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  809bff:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  809c01:	8b 10                	mov    (%eax),%edx
  809c03:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  809c05:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  809c08:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  809c0b:	89 44 24 04          	mov    %eax,0x4(%esp)
  809c0f:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  809c16:	e8 26 f2 ff ff       	call   808e41 <memp_free>
      if (h != NULL) {
  809c1b:	85 db                	test   %ebx,%ebx
  809c1d:	74 a5                	je     809bc4 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  809c1f:	89 34 24             	mov    %esi,(%esp)
  809c22:	ff d3                	call   *%ebx
  809c24:	eb 9e                	jmp    809bc4 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  809c26:	8b 13                	mov    (%ebx),%edx
  809c28:	8b 4a 04             	mov    0x4(%edx),%ecx
  809c2b:	39 c8                	cmp    %ecx,%eax
  809c2d:	73 07                	jae    809c36 <sys_sem_wait+0x7e>
        timeouts->next->time -= time_needed;
  809c2f:	29 c1                	sub    %eax,%ecx
  809c31:	89 4a 04             	mov    %ecx,0x4(%edx)
  809c34:	eb 07                	jmp    809c3d <sys_sem_wait+0x85>
      } else {
        timeouts->next->time = 0;
  809c36:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  809c3d:	83 c4 1c             	add    $0x1c,%esp
  809c40:	5b                   	pop    %ebx
  809c41:	5e                   	pop    %esi
  809c42:	5f                   	pop    %edi
  809c43:	5d                   	pop    %ebp
  809c44:	c3                   	ret    

00809c45 <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  809c45:	55                   	push   %ebp
  809c46:	89 e5                	mov    %esp,%ebp
  809c48:	57                   	push   %edi
  809c49:	56                   	push   %esi
  809c4a:	53                   	push   %ebx
  809c4b:	83 ec 1c             	sub    $0x1c,%esp
  809c4e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = (struct sys_timeo*) memp_malloc(MEMP_SYS_TIMEOUT);
  809c51:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  809c58:	e8 84 f1 ff ff       	call   808de1 <memp_malloc>
  809c5d:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  809c5f:	85 c0                	test   %eax,%eax
  809c61:	75 1c                	jne    809c7f <sys_timeout+0x3a>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  809c63:	c7 44 24 08 a1 5c 81 	movl   $0x815ca1,0x8(%esp)
  809c6a:	00 
  809c6b:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  809c72:	00 
  809c73:	c7 04 24 be 5c 81 00 	movl   $0x815cbe,(%esp)
  809c7a:	e8 39 6d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    return;
  }
  timeout->next = NULL;
  809c7f:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  809c85:	8b 45 0c             	mov    0xc(%ebp),%eax
  809c88:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  809c8b:	8b 45 10             	mov    0x10(%ebp),%eax
  809c8e:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  809c91:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  809c94:	e8 a2 59 00 00       	call   80f63b <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  809c99:	85 c0                	test   %eax,%eax
  809c9b:	75 1c                	jne    809cb9 <sys_timeout+0x74>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  809c9d:	c7 44 24 08 d2 5c 81 	movl   $0x815cd2,0x8(%esp)
  809ca4:	00 
  809ca5:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  809cac:	00 
  809cad:	c7 04 24 be 5c 81 00 	movl   $0x815cbe,(%esp)
  809cb4:	e8 ff 6c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    return;
  }

  if (timeouts->next == NULL) {
  809cb9:	8b 38                	mov    (%eax),%edi
  809cbb:	85 ff                	test   %edi,%edi
  809cbd:	75 04                	jne    809cc3 <sys_timeout+0x7e>
    timeouts->next = timeout;
  809cbf:	89 18                	mov    %ebx,(%eax)
    return;
  809cc1:	eb 52                	jmp    809d15 <sys_timeout+0xd0>
  }

  if (timeouts->next->time > msecs) {
  809cc3:	8b 57 04             	mov    0x4(%edi),%edx
  809cc6:	39 d6                	cmp    %edx,%esi
  809cc8:	73 2f                	jae    809cf9 <sys_timeout+0xb4>
    timeouts->next->time -= msecs;
  809cca:	29 f2                	sub    %esi,%edx
  809ccc:	89 57 04             	mov    %edx,0x4(%edi)
    timeout->next = timeouts->next;
  809ccf:	8b 10                	mov    (%eax),%edx
  809cd1:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  809cd3:	89 18                	mov    %ebx,(%eax)
  809cd5:	eb 3e                	jmp    809d15 <sys_timeout+0xd0>
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  809cd7:	8b 4b 04             	mov    0x4(%ebx),%ecx
  809cda:	2b 4a 04             	sub    0x4(%edx),%ecx
  809cdd:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  809ce0:	8b 02                	mov    (%edx),%eax
  809ce2:	85 c0                	test   %eax,%eax
  809ce4:	74 0b                	je     809cf1 <sys_timeout+0xac>
  809ce6:	3b 48 04             	cmp    0x4(%eax),%ecx
  809ce9:	72 25                	jb     809d10 <sys_timeout+0xcb>
  809ceb:	89 c2                	mov    %eax,%edx
  809ced:	eb e8                	jmp    809cd7 <sys_timeout+0x92>
  809cef:	89 fa                	mov    %edi,%edx
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  809cf1:	8b 02                	mov    (%edx),%eax
  809cf3:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  809cf5:	89 1a                	mov    %ebx,(%edx)
  809cf7:	eb 1c                	jmp    809d15 <sys_timeout+0xd0>
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  809cf9:	8b 4b 04             	mov    0x4(%ebx),%ecx
  809cfc:	29 d1                	sub    %edx,%ecx
  809cfe:	89 4b 04             	mov    %ecx,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  809d01:	8b 17                	mov    (%edi),%edx
  809d03:	85 d2                	test   %edx,%edx
  809d05:	74 e8                	je     809cef <sys_timeout+0xaa>
  809d07:	3b 4a 04             	cmp    0x4(%edx),%ecx
  809d0a:	73 cb                	jae    809cd7 <sys_timeout+0x92>
  809d0c:	89 d0                	mov    %edx,%eax
  809d0e:	89 fa                	mov    %edi,%edx
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  809d10:	29 48 04             	sub    %ecx,0x4(%eax)
  809d13:	eb dc                	jmp    809cf1 <sys_timeout+0xac>
        t->next = timeout;
        break;
      }
    }
  }
}
  809d15:	83 c4 1c             	add    $0x1c,%esp
  809d18:	5b                   	pop    %ebx
  809d19:	5e                   	pop    %esi
  809d1a:	5f                   	pop    %edi
  809d1b:	5d                   	pop    %ebp
  809d1c:	c3                   	ret    

00809d1d <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  809d1d:	55                   	push   %ebp
  809d1e:	89 e5                	mov    %esp,%ebp
  809d20:	57                   	push   %edi
  809d21:	56                   	push   %esi
  809d22:	53                   	push   %ebx
  809d23:	83 ec 1c             	sub    $0x1c,%esp
  809d26:	8b 5d 08             	mov    0x8(%ebp),%ebx
  809d29:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  809d2c:	e8 0a 59 00 00       	call   80f63b <sys_arch_timeouts>

  if (timeouts == NULL) {
  809d31:	85 c0                	test   %eax,%eax
  809d33:	75 1c                	jne    809d51 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  809d35:	c7 44 24 08 f0 5c 81 	movl   $0x815cf0,0x8(%esp)
  809d3c:	00 
  809d3d:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  809d44:	00 
  809d45:	c7 04 24 be 5c 81 00 	movl   $0x815cbe,(%esp)
  809d4c:	e8 67 6c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    return;
  }
  if (timeouts->next == NULL) {
  809d51:	8b 10                	mov    (%eax),%edx
  809d53:	bf 00 00 00 00       	mov    $0x0,%edi
  809d58:	85 d2                	test   %edx,%edx
  809d5a:	75 06                	jne    809d62 <sys_untimeout+0x45>
  809d5c:	eb 40                	jmp    809d9e <sys_untimeout+0x81>
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  809d5e:	89 d7                	mov    %edx,%edi
  809d60:	89 ca                	mov    %ecx,%edx
    if ((t->h == h) && (t->arg == arg)) {
  809d62:	39 5a 08             	cmp    %ebx,0x8(%edx)
  809d65:	75 31                	jne    809d98 <sys_untimeout+0x7b>
  809d67:	39 72 0c             	cmp    %esi,0xc(%edx)
  809d6a:	75 2c                	jne    809d98 <sys_untimeout+0x7b>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  809d6c:	85 ff                	test   %edi,%edi
  809d6e:	75 06                	jne    809d76 <sys_untimeout+0x59>
        timeouts->next = t->next;
  809d70:	8b 0a                	mov    (%edx),%ecx
  809d72:	89 08                	mov    %ecx,(%eax)
  809d74:	eb 04                	jmp    809d7a <sys_untimeout+0x5d>
      else
        prev_t->next = t->next;
  809d76:	8b 02                	mov    (%edx),%eax
  809d78:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  809d7a:	8b 02                	mov    (%edx),%eax
  809d7c:	85 c0                	test   %eax,%eax
  809d7e:	74 06                	je     809d86 <sys_untimeout+0x69>
        t->next->time += t->time;
  809d80:	8b 4a 04             	mov    0x4(%edx),%ecx
  809d83:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  809d86:	89 54 24 04          	mov    %edx,0x4(%esp)
  809d8a:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  809d91:	e8 ab f0 ff ff       	call   808e41 <memp_free>
      return;
  809d96:	eb 06                	jmp    809d9e <sys_untimeout+0x81>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  809d98:	8b 0a                	mov    (%edx),%ecx
  809d9a:	85 c9                	test   %ecx,%ecx
  809d9c:	75 c0                	jne    809d5e <sys_untimeout+0x41>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  809d9e:	83 c4 1c             	add    $0x1c,%esp
  809da1:	5b                   	pop    %ebx
  809da2:	5e                   	pop    %esi
  809da3:	5f                   	pop    %edi
  809da4:	5d                   	pop    %ebp
  809da5:	c3                   	ret    

00809da6 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  809da6:	55                   	push   %ebp
  809da7:	89 e5                	mov    %esp,%ebp
  809da9:	83 ec 28             	sub    $0x28,%esp
  809dac:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  809daf:	8d 55 08             	lea    0x8(%ebp),%edx
  809db2:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  809db5:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  809dbb:	85 c0                	test   %eax,%eax
  809dbd:	74 17                	je     809dd6 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  809dbf:	8d 55 f0             	lea    -0x10(%ebp),%edx
  809dc2:	89 54 24 08          	mov    %edx,0x8(%esp)
  809dc6:	c7 44 24 04 00 9b 80 	movl   $0x809b00,0x4(%esp)
  809dcd:	00 
  809dce:	89 04 24             	mov    %eax,(%esp)
  809dd1:	e8 6f fe ff ff       	call   809c45 <sys_timeout>
  }
  sys_sem_wait(sem);
  809dd6:	8b 45 08             	mov    0x8(%ebp),%eax
  809dd9:	89 04 24             	mov    %eax,(%esp)
  809ddc:	e8 d7 fd ff ff       	call   809bb8 <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
    /* timeout */
    return 0;
  809de1:	b8 00 00 00 00       	mov    $0x0,%eax
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  }
  sys_sem_wait(sem);
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  809de6:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  809deb:	75 18                	jne    809e05 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  809ded:	8d 45 f0             	lea    -0x10(%ebp),%eax
  809df0:	89 44 24 04          	mov    %eax,0x4(%esp)
  809df4:	c7 04 24 00 9b 80 00 	movl   $0x809b00,(%esp)
  809dfb:	e8 1d ff ff ff       	call   809d1d <sys_untimeout>
    return 1;
  809e00:	b8 01 00 00 00       	mov    $0x1,%eax
  }
}
  809e05:	c9                   	leave  
  809e06:	c3                   	ret    

00809e07 <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  809e07:	55                   	push   %ebp
  809e08:	89 e5                	mov    %esp,%ebp
  809e0a:	53                   	push   %ebx
  809e0b:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  809e0e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  809e15:	e8 c4 4f 00 00       	call   80edde <sys_sem_new>
  809e1a:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  809e1c:	8b 45 08             	mov    0x8(%ebp),%eax
  809e1f:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e23:	89 1c 24             	mov    %ebx,(%esp)
  809e26:	e8 7b ff ff ff       	call   809da6 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  809e2b:	89 1c 24             	mov    %ebx,(%esp)
  809e2e:	e8 6e 50 00 00       	call   80eea1 <sys_sem_free>
}
  809e33:	83 c4 14             	add    $0x14,%esp
  809e36:	5b                   	pop    %ebx
  809e37:	5d                   	pop    %ebp
  809e38:	c3                   	ret    
  809e39:	00 00                	add    %al,(%eax)
  809e3b:	00 00                	add    %al,(%eax)
  809e3d:	00 00                	add    %al,(%eax)
	...

00809e40 <_ZL15tcp_accept_nullPvP7tcp_pcba>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  809e40:	55                   	push   %ebp
  809e41:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  809e43:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  809e48:	5d                   	pop    %ebp
  809e49:	c3                   	ret    

00809e4a <_ZL12tcp_new_portv>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  809e4a:	55                   	push   %ebp
  809e4b:	89 e5                	mov    %esp,%ebp
  809e4d:	57                   	push   %edi
  809e4e:	56                   	push   %esi
  809e4f:	53                   	push   %ebx
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  809e50:	8b 0d dc a3 b3 00    	mov    0xb3a3dc,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  809e56:	8b 1d e0 a3 b3 00    	mov    0xb3a3e0,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  809e5c:	8b 3d d8 a3 b3 00    	mov    0xb3a3d8,%edi
  809e62:	0f b7 15 80 80 81 00 	movzwl 0x818080,%edx
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  809e69:	be 00 10 00 00       	mov    $0x1000,%esi
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  809e6e:	66 83 c2 01          	add    $0x1,%dx
    port = TCP_LOCAL_PORT_RANGE_START;
  809e72:	0f 48 d6             	cmovs  %esi,%edx
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  809e75:	85 c9                	test   %ecx,%ecx
  809e77:	74 19                	je     809e92 <_ZL12tcp_new_portv+0x48>
  809e79:	89 c8                	mov    %ecx,%eax
    if (pcb->local_port == port) {
  809e7b:	66 3b 51 1c          	cmp    0x1c(%ecx),%dx
  809e7f:	75 08                	jne    809e89 <_ZL12tcp_new_portv+0x3f>
  809e81:	eb eb                	jmp    809e6e <_ZL12tcp_new_portv+0x24>
  809e83:	66 39 50 1c          	cmp    %dx,0x1c(%eax)
  809e87:	74 e5                	je     809e6e <_ZL12tcp_new_portv+0x24>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  809e89:	8b 40 0c             	mov    0xc(%eax),%eax
  809e8c:	85 c0                	test   %eax,%eax
  809e8e:	66 90                	xchg   %ax,%ax
  809e90:	75 f1                	jne    809e83 <_ZL12tcp_new_portv+0x39>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  809e92:	85 db                	test   %ebx,%ebx
  809e94:	74 19                	je     809eaf <_ZL12tcp_new_portv+0x65>
  809e96:	89 d8                	mov    %ebx,%eax
    if (pcb->local_port == port) {
  809e98:	66 3b 53 1c          	cmp    0x1c(%ebx),%dx
  809e9c:	75 0a                	jne    809ea8 <_ZL12tcp_new_portv+0x5e>
  809e9e:	66 90                	xchg   %ax,%ax
  809ea0:	eb cc                	jmp    809e6e <_ZL12tcp_new_portv+0x24>
  809ea2:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  809ea6:	74 c6                	je     809e6e <_ZL12tcp_new_portv+0x24>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  809ea8:	8b 40 0c             	mov    0xc(%eax),%eax
  809eab:	85 c0                	test   %eax,%eax
  809ead:	75 f3                	jne    809ea2 <_ZL12tcp_new_portv+0x58>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  809eaf:	85 ff                	test   %edi,%edi
  809eb1:	75 09                	jne    809ebc <_ZL12tcp_new_portv+0x72>
  809eb3:	66 89 15 80 80 81 00 	mov    %dx,0x818080
  809eba:	eb 1e                	jmp    809eda <_ZL12tcp_new_portv+0x90>
  809ebc:	89 f8                	mov    %edi,%eax
    if (pcb->local_port == port) {
  809ebe:	66 3b 57 1c          	cmp    0x1c(%edi),%dx
  809ec2:	75 08                	jne    809ecc <_ZL12tcp_new_portv+0x82>
  809ec4:	eb a8                	jmp    809e6e <_ZL12tcp_new_portv+0x24>
  809ec6:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  809eca:	74 a2                	je     809e6e <_ZL12tcp_new_portv+0x24>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  809ecc:	8b 40 0c             	mov    0xc(%eax),%eax
  809ecf:	85 c0                	test   %eax,%eax
  809ed1:	75 f3                	jne    809ec6 <_ZL12tcp_new_portv+0x7c>
  809ed3:	66 89 15 80 80 81 00 	mov    %dx,0x818080
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  809eda:	0f b7 05 80 80 81 00 	movzwl 0x818080,%eax
  809ee1:	5b                   	pop    %ebx
  809ee2:	5e                   	pop    %esi
  809ee3:	5f                   	pop    %edi
  809ee4:	5d                   	pop    %ebp
  809ee5:	c3                   	ret    

00809ee6 <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  809ee6:	55                   	push   %ebp
  809ee7:	89 e5                	mov    %esp,%ebp
  809ee9:	57                   	push   %edi
  809eea:	56                   	push   %esi
  809eeb:	53                   	push   %ebx
  809eec:	83 ec 1c             	sub    $0x1c,%esp
  809eef:	8b 75 08             	mov    0x8(%ebp),%esi
  809ef2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  809ef5:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  809ef9:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  809efd:	74 1c                	je     809f1b <tcp_bind+0x35>
  809eff:	c7 44 24 08 10 5d 81 	movl   $0x815d10,0x8(%esp)
  809f06:	00 
  809f07:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  809f0e:	00 
  809f0f:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  809f16:	e8 9d 6a ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  if (port == 0) {
  809f1b:	66 85 c0             	test   %ax,%ax
  809f1e:	75 05                	jne    809f25 <tcp_bind+0x3f>
    port = tcp_new_port();
  809f20:	e8 25 ff ff ff       	call   809e4a <_ZL12tcp_new_portv>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  809f25:	8b 15 d8 a3 b3 00    	mov    0xb3a3d8,%edx
  809f2b:	85 d2                	test   %edx,%edx
  809f2d:	74 39                	je     809f68 <tcp_bind+0x82>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  809f2f:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  809f33:	75 2c                	jne    809f61 <tcp_bind+0x7b>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  809f35:	85 d2                	test   %edx,%edx
  809f37:	0f 84 ff 00 00 00    	je     80a03c <tcp_bind+0x156>
  809f3d:	8b 0a                	mov    (%edx),%ecx
  809f3f:	85 c9                	test   %ecx,%ecx
  809f41:	0f 84 fc 00 00 00    	je     80a043 <tcp_bind+0x15d>
  809f47:	85 db                	test   %ebx,%ebx
  809f49:	0f 84 fb 00 00 00    	je     80a04a <tcp_bind+0x164>
  809f4f:	8b 3b                	mov    (%ebx),%edi
  809f51:	85 ff                	test   %edi,%edi
  809f53:	0f 84 f8 00 00 00    	je     80a051 <tcp_bind+0x16b>
  809f59:	39 f9                	cmp    %edi,%ecx
  809f5b:	0f 84 f7 00 00 00    	je     80a058 <tcp_bind+0x172>
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  809f61:	8b 52 0c             	mov    0xc(%edx),%edx
  809f64:	85 d2                	test   %edx,%edx
  809f66:	75 c7                	jne    809f2f <tcp_bind+0x49>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  809f68:	8b 15 dc a3 b3 00    	mov    0xb3a3dc,%edx
  809f6e:	85 d2                	test   %edx,%edx
  809f70:	74 3b                	je     809fad <tcp_bind+0xc7>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  809f72:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  809f76:	75 2e                	jne    809fa6 <tcp_bind+0xc0>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  809f78:	85 d2                	test   %edx,%edx
  809f7a:	0f 84 df 00 00 00    	je     80a05f <tcp_bind+0x179>
  809f80:	8b 0a                	mov    (%edx),%ecx
  809f82:	85 c9                	test   %ecx,%ecx
  809f84:	0f 84 dc 00 00 00    	je     80a066 <tcp_bind+0x180>
  809f8a:	85 db                	test   %ebx,%ebx
  809f8c:	0f 84 db 00 00 00    	je     80a06d <tcp_bind+0x187>
  809f92:	8b 3b                	mov    (%ebx),%edi
  809f94:	85 ff                	test   %edi,%edi
  809f96:	0f 84 d8 00 00 00    	je     80a074 <tcp_bind+0x18e>
  809f9c:	39 f9                	cmp    %edi,%ecx
  809f9e:	66 90                	xchg   %ax,%ax
  809fa0:	0f 84 d5 00 00 00    	je     80a07b <tcp_bind+0x195>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  809fa6:	8b 52 0c             	mov    0xc(%edx),%edx
  809fa9:	85 d2                	test   %edx,%edx
  809fab:	75 c5                	jne    809f72 <tcp_bind+0x8c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  809fad:	8b 15 d4 a3 b3 00    	mov    0xb3a3d4,%edx
  809fb3:	85 d2                	test   %edx,%edx
  809fb5:	74 39                	je     809ff0 <tcp_bind+0x10a>
    if (cpcb->local_port == port) {
  809fb7:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  809fbb:	75 2c                	jne    809fe9 <tcp_bind+0x103>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  809fbd:	85 d2                	test   %edx,%edx
  809fbf:	0f 84 bd 00 00 00    	je     80a082 <tcp_bind+0x19c>
  809fc5:	8b 0a                	mov    (%edx),%ecx
  809fc7:	85 c9                	test   %ecx,%ecx
  809fc9:	0f 84 ba 00 00 00    	je     80a089 <tcp_bind+0x1a3>
  809fcf:	85 db                	test   %ebx,%ebx
  809fd1:	0f 84 b9 00 00 00    	je     80a090 <tcp_bind+0x1aa>
  809fd7:	8b 3b                	mov    (%ebx),%edi
  809fd9:	85 ff                	test   %edi,%edi
  809fdb:	0f 84 b6 00 00 00    	je     80a097 <tcp_bind+0x1b1>
  809fe1:	39 f9                	cmp    %edi,%ecx
  809fe3:	0f 84 b5 00 00 00    	je     80a09e <tcp_bind+0x1b8>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  809fe9:	8b 52 0c             	mov    0xc(%edx),%edx
  809fec:	85 d2                	test   %edx,%edx
  809fee:	75 c7                	jne    809fb7 <tcp_bind+0xd1>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  809ff0:	8b 15 e0 a3 b3 00    	mov    0xb3a3e0,%edx
  809ff6:	85 d2                	test   %edx,%edx
  809ff8:	74 17                	je     80a011 <tcp_bind+0x12b>
    if (cpcb->local_port == port) {
  809ffa:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  809ffe:	75 0a                	jne    80a00a <tcp_bind+0x124>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  80a000:	8b 0b                	mov    (%ebx),%ecx
  80a002:	39 0a                	cmp    %ecx,(%edx)
  80a004:	0f 84 9b 00 00 00    	je     80a0a5 <tcp_bind+0x1bf>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  80a00a:	8b 52 0c             	mov    0xc(%edx),%edx
  80a00d:	85 d2                	test   %edx,%edx
  80a00f:	75 e9                	jne    809ffa <tcp_bind+0x114>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  80a011:	85 db                	test   %ebx,%ebx
  80a013:	74 09                	je     80a01e <tcp_bind+0x138>
  80a015:	83 3b 00             	cmpl   $0x0,(%ebx)
  80a018:	74 04                	je     80a01e <tcp_bind+0x138>
    pcb->local_ip = *ipaddr;
  80a01a:	8b 13                	mov    (%ebx),%edx
  80a01c:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  80a01e:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  80a022:	a1 d4 a3 b3 00       	mov    0xb3a3d4,%eax
  80a027:	89 46 0c             	mov    %eax,0xc(%esi)
  80a02a:	89 35 d4 a3 b3 00    	mov    %esi,0xb3a3d4
  80a030:	e8 e8 c7 ff ff       	call   80681d <tcp_timer_needed>
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  80a035:	b8 00 00 00 00       	mov    $0x0,%eax
  80a03a:	eb 6e                	jmp    80a0aa <tcp_bind+0x1c4>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80a03c:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a041:	eb 67                	jmp    80a0aa <tcp_bind+0x1c4>
  80a043:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a048:	eb 60                	jmp    80a0aa <tcp_bind+0x1c4>
  80a04a:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a04f:	eb 59                	jmp    80a0aa <tcp_bind+0x1c4>
  80a051:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a056:	eb 52                	jmp    80a0aa <tcp_bind+0x1c4>
  80a058:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a05d:	eb 4b                	jmp    80a0aa <tcp_bind+0x1c4>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80a05f:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a064:	eb 44                	jmp    80a0aa <tcp_bind+0x1c4>
  80a066:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a06b:	eb 3d                	jmp    80a0aa <tcp_bind+0x1c4>
  80a06d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a072:	eb 36                	jmp    80a0aa <tcp_bind+0x1c4>
  80a074:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a079:	eb 2f                	jmp    80a0aa <tcp_bind+0x1c4>
  80a07b:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a080:	eb 28                	jmp    80a0aa <tcp_bind+0x1c4>
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
          ip_addr_isany(ipaddr) ||
          ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80a082:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a087:	eb 21                	jmp    80a0aa <tcp_bind+0x1c4>
  80a089:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a08e:	eb 1a                	jmp    80a0aa <tcp_bind+0x1c4>
  80a090:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a095:	eb 13                	jmp    80a0aa <tcp_bind+0x1c4>
  80a097:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a09c:	eb 0c                	jmp    80a0aa <tcp_bind+0x1c4>
  80a09e:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80a0a3:	eb 05                	jmp    80a0aa <tcp_bind+0x1c4>
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
        return ERR_USE;
  80a0a5:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  }
  pcb->local_port = port;
  TCP_REG(&tcp_bound_pcbs, pcb);
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
}
  80a0aa:	83 c4 1c             	add    $0x1c,%esp
  80a0ad:	5b                   	pop    %ebx
  80a0ae:	5e                   	pop    %esi
  80a0af:	5f                   	pop    %edi
  80a0b0:	5d                   	pop    %ebp
  80a0b1:	c3                   	ret    

0080a0b2 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  80a0b2:	55                   	push   %ebp
  80a0b3:	89 e5                	mov    %esp,%ebp
  80a0b5:	83 ec 18             	sub    $0x18,%esp
  80a0b8:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80a0bb:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80a0be:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  80a0c1:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80a0c5:	74 1c                	je     80a0e3 <tcp_listen_with_backlog+0x31>
  80a0c7:	c7 44 24 08 3c 5d 81 	movl   $0x815d3c,0x8(%esp)
  80a0ce:	00 
  80a0cf:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80a0d6:	00 
  80a0d7:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a0de:	e8 d5 68 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = (struct tcp_pcb_listen *) memp_malloc(MEMP_TCP_PCB_LISTEN);
  80a0e3:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80a0ea:	e8 f2 ec ff ff       	call   808de1 <memp_malloc>
  80a0ef:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
    return NULL;
  80a0f1:	b8 00 00 00 00       	mov    $0x0,%eax
  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = (struct tcp_pcb_listen *) memp_malloc(MEMP_TCP_PCB_LISTEN);
  if (lpcb == NULL) {
  80a0f6:	85 f6                	test   %esi,%esi
  80a0f8:	0f 84 ab 00 00 00    	je     80a1a9 <tcp_listen_with_backlog+0xf7>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  80a0fe:	8b 43 18             	mov    0x18(%ebx),%eax
  80a101:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  80a104:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80a108:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  80a10c:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  80a113:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80a117:	83 c8 02             	or     $0x2,%eax
  80a11a:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  80a11e:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80a122:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  80a125:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80a129:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  80a12c:	b8 00 00 00 00       	mov    $0x0,%eax
  80a131:	85 db                	test   %ebx,%ebx
  80a133:	74 02                	je     80a137 <tcp_listen_with_backlog+0x85>
  80a135:	8b 03                	mov    (%ebx),%eax
  80a137:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80a139:	8b 15 d4 a3 b3 00    	mov    0xb3a3d4,%edx
  80a13f:	39 da                	cmp    %ebx,%edx
  80a141:	75 0a                	jne    80a14d <tcp_listen_with_backlog+0x9b>
  80a143:	8b 42 0c             	mov    0xc(%edx),%eax
  80a146:	a3 d4 a3 b3 00       	mov    %eax,0xb3a3d4
  80a14b:	eb 29                	jmp    80a176 <tcp_listen_with_backlog+0xc4>
  80a14d:	89 15 e4 a3 b3 00    	mov    %edx,0xb3a3e4
  80a153:	89 d1                	mov    %edx,%ecx
  80a155:	85 d2                	test   %edx,%edx
  80a157:	75 06                	jne    80a15f <tcp_listen_with_backlog+0xad>
  80a159:	eb 1b                	jmp    80a176 <tcp_listen_with_backlog+0xc4>
  80a15b:	89 c1                	mov    %eax,%ecx
  80a15d:	89 c2                	mov    %eax,%edx
  80a15f:	8b 42 0c             	mov    0xc(%edx),%eax
  80a162:	85 c0                	test   %eax,%eax
  80a164:	74 4d                	je     80a1b3 <tcp_listen_with_backlog+0x101>
  80a166:	39 c3                	cmp    %eax,%ebx
  80a168:	75 f1                	jne    80a15b <tcp_listen_with_backlog+0xa9>
  80a16a:	89 0d e4 a3 b3 00    	mov    %ecx,0xb3a3e4
  80a170:	8b 43 0c             	mov    0xc(%ebx),%eax
  80a173:	89 42 0c             	mov    %eax,0xc(%edx)
  80a176:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  80a17d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a181:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80a188:	e8 b4 ec ff ff       	call   808e41 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  80a18d:	c7 46 20 40 9e 80 00 	movl   $0x809e40,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  80a194:	a1 d8 a3 b3 00       	mov    0xb3a3d8,%eax
  80a199:	89 46 0c             	mov    %eax,0xc(%esi)
  80a19c:	89 35 d8 a3 b3 00    	mov    %esi,0xb3a3d8
  80a1a2:	e8 76 c6 ff ff       	call   80681d <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  80a1a7:	89 f0                	mov    %esi,%eax
}
  80a1a9:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80a1ac:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80a1af:	89 ec                	mov    %ebp,%esp
  80a1b1:	5d                   	pop    %ebp
  80a1b2:	c3                   	ret    
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80a1b3:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  80a1b8:	eb bc                	jmp    80a176 <tcp_listen_with_backlog+0xc4>

0080a1ba <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  80a1ba:	55                   	push   %ebp
  80a1bb:	89 e5                	mov    %esp,%ebp
  80a1bd:	56                   	push   %esi
  80a1be:	53                   	push   %ebx
  80a1bf:	83 ec 10             	sub    $0x10,%esp
  80a1c2:	8b 45 08             	mov    0x8(%ebp),%eax
  80a1c5:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  80a1c9:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  80a1cd:	0f b7 f1             	movzwl %cx,%esi
  80a1d0:	0f b7 da             	movzwl %dx,%ebx
  80a1d3:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  80a1d6:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  80a1dc:	76 0e                	jbe    80a1ec <tcp_recved+0x32>
    pcb->rcv_wnd = TCP_WND;
  80a1de:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  80a1e4:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  80a1ea:	eb 11                	jmp    80a1fd <tcp_recved+0x43>
  } else {
    pcb->rcv_wnd += len;
  80a1ec:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  80a1ef:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  80a1f3:	66 3b 50 34          	cmp    0x34(%eax),%dx
  80a1f7:	72 04                	jb     80a1fd <tcp_recved+0x43>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  80a1f9:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  80a1fd:	0f b6 48 20          	movzbl 0x20(%eax),%ecx
  80a201:	0f b6 d1             	movzbl %cl,%edx
  80a204:	89 d3                	mov    %edx,%ebx
  80a206:	83 e3 01             	and    $0x1,%ebx
  80a209:	75 24                	jne    80a22f <tcp_recved+0x75>
  80a20b:	f6 c2 02             	test   $0x2,%dl
  80a20e:	75 1f                	jne    80a22f <tcp_recved+0x75>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  80a210:	85 db                	test   %ebx,%ebx
  80a212:	74 13                	je     80a227 <tcp_recved+0x6d>
  80a214:	83 e1 fe             	and    $0xfffffffe,%ecx
  80a217:	83 c9 02             	or     $0x2,%ecx
  80a21a:	88 48 20             	mov    %cl,0x20(%eax)
  80a21d:	89 04 24             	mov    %eax,(%esp)
  80a220:	e8 d0 2b 00 00       	call   80cdf5 <tcp_output>
  80a225:	eb 22                	jmp    80a249 <tcp_recved+0x8f>
  80a227:	83 c9 01             	or     $0x1,%ecx
  80a22a:	88 48 20             	mov    %cl,0x20(%eax)
  80a22d:	eb 1a                	jmp    80a249 <tcp_recved+0x8f>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  80a22f:	85 db                	test   %ebx,%ebx
  80a231:	74 16                	je     80a249 <tcp_recved+0x8f>
  80a233:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  80a239:	76 0e                	jbe    80a249 <tcp_recved+0x8f>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  80a23b:	83 c9 02             	or     $0x2,%ecx
  80a23e:	88 48 20             	mov    %cl,0x20(%eax)
  80a241:	89 04 24             	mov    %eax,(%esp)
  80a244:	e8 ac 2b 00 00       	call   80cdf5 <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  80a249:	83 c4 10             	add    $0x10,%esp
  80a24c:	5b                   	pop    %ebx
  80a24d:	5e                   	pop    %esi
  80a24e:	5d                   	pop    %ebp
  80a24f:	c3                   	ret    

0080a250 <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  80a250:	55                   	push   %ebp
  80a251:	89 e5                	mov    %esp,%ebp
  80a253:	53                   	push   %ebx
  80a254:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80a257:	8b 1d dc a3 b3 00    	mov    0xb3a3dc,%ebx
  80a25d:	85 db                	test   %ebx,%ebx
  80a25f:	74 65                	je     80a2c6 <tcp_fasttmr+0x76>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  80a261:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80a267:	85 c0                	test   %eax,%eax
  80a269:	74 3a                	je     80a2a5 <tcp_fasttmr+0x55>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80a26b:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  80a271:	85 d2                	test   %edx,%edx
  80a273:	74 1e                	je     80a293 <tcp_fasttmr+0x43>
  80a275:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80a27c:	00 
  80a27d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80a281:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a285:	8b 43 18             	mov    0x18(%ebx),%eax
  80a288:	89 04 24             	mov    %eax,(%esp)
  80a28b:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  80a28d:	84 c0                	test   %al,%al
  80a28f:	75 14                	jne    80a2a5 <tcp_fasttmr+0x55>
  80a291:	eb 08                	jmp    80a29b <tcp_fasttmr+0x4b>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  80a293:	89 04 24             	mov    %eax,(%esp)
  80a296:	e8 68 ef ff ff       	call   809203 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  80a29b:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80a2a2:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  80a2a5:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80a2a9:	a8 01                	test   $0x1,%al
  80a2ab:	74 12                	je     80a2bf <tcp_fasttmr+0x6f>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  80a2ad:	83 c8 02             	or     $0x2,%eax
  80a2b0:	88 43 20             	mov    %al,0x20(%ebx)
  80a2b3:	89 1c 24             	mov    %ebx,(%esp)
  80a2b6:	e8 3a 2b 00 00       	call   80cdf5 <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80a2bb:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80a2bf:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  80a2c2:	85 db                	test   %ebx,%ebx
  80a2c4:	75 9b                	jne    80a261 <tcp_fasttmr+0x11>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  80a2c6:	83 c4 14             	add    $0x14,%esp
  80a2c9:	5b                   	pop    %ebx
  80a2ca:	5d                   	pop    %ebp
  80a2cb:	c3                   	ret    

0080a2cc <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  80a2cc:	55                   	push   %ebp
  80a2cd:	89 e5                	mov    %esp,%ebp
  80a2cf:	83 ec 18             	sub    $0x18,%esp
  80a2d2:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80a2d5:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80a2d8:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  80a2db:	bb 00 00 00 00       	mov    $0x0,%ebx
  
  if (seg != NULL) {
  80a2e0:	85 f6                	test   %esi,%esi
  80a2e2:	74 21                	je     80a305 <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  80a2e4:	8b 46 04             	mov    0x4(%esi),%eax
  80a2e7:	85 c0                	test   %eax,%eax
  80a2e9:	74 0a                	je     80a2f5 <tcp_seg_free+0x29>
      count = pbuf_free(seg->p);
  80a2eb:	89 04 24             	mov    %eax,(%esp)
  80a2ee:	e8 10 ef ff ff       	call   809203 <pbuf_free>
  80a2f3:	89 c3                	mov    %eax,%ebx
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  80a2f5:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a2f9:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80a300:	e8 3c eb ff ff       	call   808e41 <memp_free>
  }
  return count;
}
  80a305:	89 d8                	mov    %ebx,%eax
  80a307:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80a30a:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80a30d:	89 ec                	mov    %ebp,%esp
  80a30f:	5d                   	pop    %ebp
  80a310:	c3                   	ret    

0080a311 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  80a311:	55                   	push   %ebp
  80a312:	89 e5                	mov    %esp,%ebp
  80a314:	56                   	push   %esi
  80a315:	53                   	push   %ebx
  80a316:	83 ec 10             	sub    $0x10,%esp
  80a319:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  80a31c:	be 00 00 00 00       	mov    $0x0,%esi
  struct tcp_seg *next;
  while (seg != NULL) {
  80a321:	85 c0                	test   %eax,%eax
  80a323:	75 04                	jne    80a329 <tcp_segs_free+0x18>
  80a325:	eb 12                	jmp    80a339 <tcp_segs_free+0x28>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  80a327:	89 d8                	mov    %ebx,%eax
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
    next = seg->next;
  80a329:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  80a32b:	89 04 24             	mov    %eax,(%esp)
  80a32e:	e8 99 ff ff ff       	call   80a2cc <tcp_seg_free>
  80a333:	01 c6                	add    %eax,%esi
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  80a335:	85 db                	test   %ebx,%ebx
  80a337:	75 ee                	jne    80a327 <tcp_segs_free+0x16>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  80a339:	89 f0                	mov    %esi,%eax
  80a33b:	83 c4 10             	add    $0x10,%esp
  80a33e:	5b                   	pop    %ebx
  80a33f:	5e                   	pop    %esi
  80a340:	5d                   	pop    %ebp
  80a341:	c3                   	ret    

0080a342 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  80a342:	55                   	push   %ebp
  80a343:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  80a345:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a348:	8b 45 08             	mov    0x8(%ebp),%eax
  80a34b:	88 50 14             	mov    %dl,0x14(%eax)
}
  80a34e:	5d                   	pop    %ebp
  80a34f:	c3                   	ret    

0080a350 <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  80a350:	55                   	push   %ebp
  80a351:	89 e5                	mov    %esp,%ebp
  80a353:	53                   	push   %ebx
  80a354:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = (struct tcp_seg *) memp_malloc(MEMP_TCP_SEG);
  80a357:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80a35e:	e8 7e ea ff ff       	call   808de1 <memp_malloc>
  80a363:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  80a365:	85 c0                	test   %eax,%eax
  80a367:	74 22                	je     80a38b <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  80a369:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a370:	00 
  80a371:	8b 45 08             	mov    0x8(%ebp),%eax
  80a374:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a378:	89 1c 24             	mov    %ebx,(%esp)
  80a37b:	e8 87 6f ff ff       	call   801307 <memcpy>
  pbuf_ref(cseg->p);
  80a380:	8b 43 04             	mov    0x4(%ebx),%eax
  80a383:	89 04 24             	mov    %eax,(%esp)
  80a386:	e8 60 f3 ff ff       	call   8096eb <pbuf_ref>
  return cseg;
}
  80a38b:	89 d8                	mov    %ebx,%eax
  80a38d:	83 c4 14             	add    $0x14,%esp
  80a390:	5b                   	pop    %ebx
  80a391:	5d                   	pop    %ebp
  80a392:	c3                   	ret    

0080a393 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  80a393:	55                   	push   %ebp
  80a394:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  80a396:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a399:	8b 45 08             	mov    0x8(%ebp),%eax
  80a39c:	89 50 18             	mov    %edx,0x18(%eax)
}
  80a39f:	5d                   	pop    %ebp
  80a3a0:	c3                   	ret    

0080a3a1 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  80a3a1:	55                   	push   %ebp
  80a3a2:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  80a3a4:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3a7:	8b 45 08             	mov    0x8(%ebp),%eax
  80a3aa:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  80a3b0:	5d                   	pop    %ebp
  80a3b1:	c3                   	ret    

0080a3b2 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  80a3b2:	55                   	push   %ebp
  80a3b3:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  80a3b5:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3b8:	8b 45 08             	mov    0x8(%ebp),%eax
  80a3bb:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  80a3c1:	5d                   	pop    %ebp
  80a3c2:	c3                   	ret    

0080a3c3 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  80a3c3:	55                   	push   %ebp
  80a3c4:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  80a3c6:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3c9:	8b 45 08             	mov    0x8(%ebp),%eax
  80a3cc:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  80a3d2:	5d                   	pop    %ebp
  80a3d3:	c3                   	ret    

0080a3d4 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  80a3d4:	55                   	push   %ebp
  80a3d5:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80a3d7:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3da:	8b 45 08             	mov    0x8(%ebp),%eax
  80a3dd:	89 50 20             	mov    %edx,0x20(%eax)
}
  80a3e0:	5d                   	pop    %ebp
  80a3e1:	c3                   	ret    

0080a3e2 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  80a3e2:	55                   	push   %ebp
  80a3e3:	89 e5                	mov    %esp,%ebp
  80a3e5:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80a3e8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80a3eb:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  80a3f1:	8b 55 10             	mov    0x10(%ebp),%edx
  80a3f4:	88 50 31             	mov    %dl,0x31(%eax)
}
  80a3f7:	5d                   	pop    %ebp
  80a3f8:	c3                   	ret    

0080a3f9 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  80a3f9:	55                   	push   %ebp
  80a3fa:	89 e5                	mov    %esp,%ebp
  80a3fc:	53                   	push   %ebx
  80a3fd:	83 ec 14             	sub    $0x14,%esp
  80a400:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
  80a403:	8b 43 10             	mov    0x10(%ebx),%eax
  80a406:	85 c0                	test   %eax,%eax
  80a408:	74 62                	je     80a46c <tcp_pcb_purge+0x73>
  80a40a:	83 f8 0a             	cmp    $0xa,%eax
  80a40d:	74 5d                	je     80a46c <tcp_pcb_purge+0x73>
  80a40f:	83 f8 01             	cmp    $0x1,%eax
  80a412:	74 58                	je     80a46c <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  80a414:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  80a41a:	85 c0                	test   %eax,%eax
  80a41c:	74 12                	je     80a430 <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  80a41e:	89 04 24             	mov    %eax,(%esp)
  80a421:	e8 dd ed ff ff       	call   809203 <pbuf_free>
      pcb->refused_data = NULL;
  80a426:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  80a42d:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  80a430:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  80a436:	8b 43 7c             	mov    0x7c(%ebx),%eax
  80a439:	89 04 24             	mov    %eax,(%esp)
  80a43c:	e8 d0 fe ff ff       	call   80a311 <tcp_segs_free>
    pcb->ooseq = NULL;
  80a441:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  80a448:	8b 43 74             	mov    0x74(%ebx),%eax
  80a44b:	89 04 24             	mov    %eax,(%esp)
  80a44e:	e8 be fe ff ff       	call   80a311 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  80a453:	8b 43 78             	mov    0x78(%ebx),%eax
  80a456:	89 04 24             	mov    %eax,(%esp)
  80a459:	e8 b3 fe ff ff       	call   80a311 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  80a45e:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  80a465:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  80a46c:	83 c4 14             	add    $0x14,%esp
  80a46f:	5b                   	pop    %ebx
  80a470:	5d                   	pop    %ebp
  80a471:	c3                   	ret    

0080a472 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  80a472:	55                   	push   %ebp
  80a473:	89 e5                	mov    %esp,%ebp
  80a475:	53                   	push   %ebx
  80a476:	83 ec 14             	sub    $0x14,%esp
  80a479:	8b 45 08             	mov    0x8(%ebp),%eax
  80a47c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  80a47f:	8b 10                	mov    (%eax),%edx
  80a481:	39 da                	cmp    %ebx,%edx
  80a483:	75 07                	jne    80a48c <tcp_pcb_remove+0x1a>
  80a485:	8b 52 0c             	mov    0xc(%edx),%edx
  80a488:	89 10                	mov    %edx,(%eax)
  80a48a:	eb 2d                	jmp    80a4b9 <tcp_pcb_remove+0x47>
  80a48c:	89 15 e4 a3 b3 00    	mov    %edx,0xb3a3e4
  80a492:	89 d1                	mov    %edx,%ecx
  80a494:	85 d2                	test   %edx,%edx
  80a496:	75 06                	jne    80a49e <tcp_pcb_remove+0x2c>
  80a498:	eb 1f                	jmp    80a4b9 <tcp_pcb_remove+0x47>
  80a49a:	89 c1                	mov    %eax,%ecx
  80a49c:	89 c2                	mov    %eax,%edx
  80a49e:	8b 42 0c             	mov    0xc(%edx),%eax
  80a4a1:	85 c0                	test   %eax,%eax
  80a4a3:	0f 84 bb 00 00 00    	je     80a564 <tcp_pcb_remove+0xf2>
  80a4a9:	39 c3                	cmp    %eax,%ebx
  80a4ab:	75 ed                	jne    80a49a <tcp_pcb_remove+0x28>
  80a4ad:	89 0d e4 a3 b3 00    	mov    %ecx,0xb3a3e4
  80a4b3:	8b 43 0c             	mov    0xc(%ebx),%eax
  80a4b6:	89 42 0c             	mov    %eax,0xc(%edx)
  80a4b9:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  80a4c0:	89 1c 24             	mov    %ebx,(%esp)
  80a4c3:	e8 31 ff ff ff       	call   80a3f9 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  80a4c8:	8b 43 10             	mov    0x10(%ebx),%eax
  80a4cb:	83 f8 0a             	cmp    $0xa,%eax
  80a4ce:	74 1b                	je     80a4eb <tcp_pcb_remove+0x79>
  80a4d0:	83 f8 01             	cmp    $0x1,%eax
  80a4d3:	74 16                	je     80a4eb <tcp_pcb_remove+0x79>
  80a4d5:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  80a4d9:	a8 01                	test   $0x1,%al
  80a4db:	74 0e                	je     80a4eb <tcp_pcb_remove+0x79>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  80a4dd:	83 c8 02             	or     $0x2,%eax
  80a4e0:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  80a4e3:	89 1c 24             	mov    %ebx,(%esp)
  80a4e6:	e8 0a 29 00 00       	call   80cdf5 <tcp_output>
  }

  if (pcb->state != LISTEN) {
  80a4eb:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  80a4ef:	74 66                	je     80a557 <tcp_pcb_remove+0xe5>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  80a4f1:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  80a4f5:	74 1c                	je     80a513 <tcp_pcb_remove+0xa1>
  80a4f7:	c7 44 24 08 06 5f 81 	movl   $0x815f06,0x8(%esp)
  80a4fe:	00 
  80a4ff:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  80a506:	00 
  80a507:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a50e:	e8 a5 64 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  80a513:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80a517:	74 1c                	je     80a535 <tcp_pcb_remove+0xc3>
  80a519:	c7 44 24 08 1e 5f 81 	movl   $0x815f1e,0x8(%esp)
  80a520:	00 
  80a521:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  80a528:	00 
  80a529:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a530:	e8 83 64 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  80a535:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  80a539:	74 1c                	je     80a557 <tcp_pcb_remove+0xe5>
  80a53b:	c7 44 24 08 37 5f 81 	movl   $0x815f37,0x8(%esp)
  80a542:	00 
  80a543:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  80a54a:	00 
  80a54b:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a552:	e8 61 64 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  80a557:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  80a55e:	83 c4 14             	add    $0x14,%esp
  80a561:	5b                   	pop    %ebx
  80a562:	5d                   	pop    %ebp
  80a563:	c3                   	ret    
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
  80a564:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  80a569:	e9 4b ff ff ff       	jmp    80a4b9 <tcp_pcb_remove+0x47>

0080a56e <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80a56e:	55                   	push   %ebp
  80a56f:	89 e5                	mov    %esp,%ebp
  80a571:	57                   	push   %edi
  80a572:	56                   	push   %esi
  80a573:	53                   	push   %ebx
  80a574:	83 ec 4c             	sub    $0x4c,%esp
  80a577:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80a57a:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80a57e:	75 25                	jne    80a5a5 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  80a580:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a584:	c7 04 24 e0 a3 b3 00 	movl   $0xb3a3e0,(%esp)
  80a58b:	e8 e2 fe ff ff       	call   80a472 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  80a590:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a594:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80a59b:	e8 a1 e8 ff ff       	call   808e41 <memp_free>
  80a5a0:	e9 d1 00 00 00       	jmp    80a676 <tcp_abort+0x108>
  } else {
    seqno = pcb->snd_nxt;
  80a5a5:	8b 43 54             	mov    0x54(%ebx),%eax
  80a5a8:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    ackno = pcb->rcv_nxt;
  80a5ab:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  80a5ae:	b8 00 00 00 00       	mov    $0x0,%eax
  80a5b3:	85 db                	test   %ebx,%ebx
  80a5b5:	74 02                	je     80a5b9 <tcp_abort+0x4b>
  80a5b7:	8b 03                	mov    (%ebx),%eax
  80a5b9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  80a5bc:	b8 00 00 00 00       	mov    $0x0,%eax
  80a5c1:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80a5c4:	74 03                	je     80a5c9 <tcp_abort+0x5b>
  80a5c6:	8b 43 04             	mov    0x4(%ebx),%eax
  80a5c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  80a5cc:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  80a5d0:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
    remote_port = pcb->remote_port;
  80a5d4:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  80a5d8:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  80a5dc:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  80a5e2:	8b 43 18             	mov    0x18(%ebx),%eax
  80a5e5:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80a5e8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a5ec:	c7 04 24 dc a3 b3 00 	movl   $0xb3a3dc,(%esp)
  80a5f3:	e8 7a fe ff ff       	call   80a472 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  80a5f8:	8b 43 78             	mov    0x78(%ebx),%eax
  80a5fb:	85 c0                	test   %eax,%eax
  80a5fd:	74 08                	je     80a607 <tcp_abort+0x99>
      tcp_segs_free(pcb->unacked);
  80a5ff:	89 04 24             	mov    %eax,(%esp)
  80a602:	e8 0a fd ff ff       	call   80a311 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  80a607:	8b 43 74             	mov    0x74(%ebx),%eax
  80a60a:	85 c0                	test   %eax,%eax
  80a60c:	74 08                	je     80a616 <tcp_abort+0xa8>
      tcp_segs_free(pcb->unsent);
  80a60e:	89 04 24             	mov    %eax,(%esp)
  80a611:	e8 fb fc ff ff       	call   80a311 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  80a616:	8b 43 7c             	mov    0x7c(%ebx),%eax
  80a619:	85 c0                	test   %eax,%eax
  80a61b:	74 08                	je     80a625 <tcp_abort+0xb7>
      tcp_segs_free(pcb->ooseq);
  80a61d:	89 04 24             	mov    %eax,(%esp)
  80a620:	e8 ec fc ff ff       	call   80a311 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  80a625:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a629:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80a630:	e8 0c e8 ff ff       	call   808e41 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  80a635:	85 f6                	test   %esi,%esi
  80a637:	74 10                	je     80a649 <tcp_abort+0xdb>
  80a639:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  80a640:	ff 
  80a641:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80a644:	89 04 24             	mov    %eax,(%esp)
  80a647:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  80a649:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
  80a64d:	89 44 24 14          	mov    %eax,0x14(%esp)
  80a651:	0f b7 45 d2          	movzwl -0x2e(%ebp),%eax
  80a655:	89 44 24 10          	mov    %eax,0x10(%esp)
  80a659:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80a65c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80a660:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80a663:	89 44 24 08          	mov    %eax,0x8(%esp)
  80a667:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a66b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80a66e:	89 04 24             	mov    %eax,(%esp)
  80a671:	e8 1a 2c 00 00       	call   80d290 <tcp_rst>
  }
}
  80a676:	83 c4 4c             	add    $0x4c,%esp
  80a679:	5b                   	pop    %ebx
  80a67a:	5e                   	pop    %esi
  80a67b:	5f                   	pop    %edi
  80a67c:	5d                   	pop    %ebp
  80a67d:	c3                   	ret    

0080a67e <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80a67e:	55                   	push   %ebp
  80a67f:	89 e5                	mov    %esp,%ebp
  80a681:	57                   	push   %edi
  80a682:	56                   	push   %esi
  80a683:	53                   	push   %ebx
  80a684:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  80a687:	83 05 d0 a3 b3 00 01 	addl   $0x1,0xb3a3d0

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  80a68e:	8b 1d dc a3 b3 00    	mov    0xb3a3dc,%ebx
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80a694:	85 db                	test   %ebx,%ebx
  80a696:	0f 84 55 03 00 00    	je     80a9f1 <tcp_slowtmr+0x373>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80a69c:	8b 43 10             	mov    0x10(%ebx),%eax
  80a69f:	85 c0                	test   %eax,%eax
  80a6a1:	74 1c                	je     80a6bf <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80a6a3:	83 f8 01             	cmp    $0x1,%eax
  80a6a6:	74 38                	je     80a6e0 <tcp_slowtmr+0x62>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80a6a8:	83 f8 0a             	cmp    $0xa,%eax
  80a6ab:	74 54                	je     80a701 <tcp_slowtmr+0x83>
  struct tcp_pcb *pcb, *pcb2, *prev;
  u16_t eff_wnd;
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;
  80a6ad:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)

  ++tcp_ticks;

  /* Steps through all of the active PCBs. */
  prev = NULL;
  80a6b1:	bf 00 00 00 00       	mov    $0x0,%edi
  80a6b6:	eb 65                	jmp    80a71d <tcp_slowtmr+0x9f>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80a6b8:	8b 43 10             	mov    0x10(%ebx),%eax
  80a6bb:	85 c0                	test   %eax,%eax
  80a6bd:	75 1c                	jne    80a6db <tcp_slowtmr+0x5d>
  80a6bf:	c7 44 24 08 60 5d 81 	movl   $0x815d60,0x8(%esp)
  80a6c6:	00 
  80a6c7:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  80a6ce:	00 
  80a6cf:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a6d6:	e8 dd 62 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80a6db:	83 f8 01             	cmp    $0x1,%eax
  80a6de:	75 1c                	jne    80a6fc <tcp_slowtmr+0x7e>
  80a6e0:	c7 44 24 08 8c 5d 81 	movl   $0x815d8c,0x8(%esp)
  80a6e7:	00 
  80a6e8:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  80a6ef:	00 
  80a6f0:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a6f7:	e8 bc 62 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  80a6fc:	83 f8 0a             	cmp    $0xa,%eax
  80a6ff:	75 1c                	jne    80a71d <tcp_slowtmr+0x9f>
  80a701:	c7 44 24 08 b8 5d 81 	movl   $0x815db8,0x8(%esp)
  80a708:	00 
  80a709:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  80a710:	00 
  80a711:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a718:	e8 9b 62 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80a71d:	83 f8 02             	cmp    $0x2,%eax
  80a720:	75 0f                	jne    80a731 <tcp_slowtmr+0xb3>
      ++pcb_remove;
  80a722:	be 01 00 00 00       	mov    $0x1,%esi
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  80a727:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  80a72b:	0f 84 f1 00 00 00    	je     80a822 <tcp_slowtmr+0x1a4>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80a731:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
      ++pcb_remove;
  80a735:	be 01 00 00 00       	mov    $0x1,%esi

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  80a73a:	80 fa 0c             	cmp    $0xc,%dl
  80a73d:	0f 84 df 00 00 00    	je     80a822 <tcp_slowtmr+0x1a4>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  80a743:	0f b6 8b a4 00 00 00 	movzbl 0xa4(%ebx),%ecx
  80a74a:	84 c9                	test   %cl,%cl
  80a74c:	74 50                	je     80a79e <tcp_slowtmr+0x120>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  80a74e:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  80a754:	83 c0 01             	add    $0x1,%eax
  80a757:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80a75d:	0f b6 d1             	movzbl %cl,%edx
  80a760:	0f b6 92 6f 5f 81 00 	movzbl 0x815f6f(%edx),%edx
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  80a767:	be 00 00 00 00       	mov    $0x0,%esi
    } else {
      if (pcb->persist_backoff > 0) {
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  80a76c:	39 d0                	cmp    %edx,%eax
  80a76e:	0f 82 ae 00 00 00    	jb     80a822 <tcp_slowtmr+0x1a4>
          pcb->persist_cnt = 0;
  80a774:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  80a77b:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  80a77e:	80 f9 06             	cmp    $0x6,%cl
  80a781:	77 09                	ja     80a78c <tcp_slowtmr+0x10e>
            pcb->persist_backoff++;
  80a783:	83 c1 01             	add    $0x1,%ecx
  80a786:	88 8b a4 00 00 00    	mov    %cl,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  80a78c:	89 1c 24             	mov    %ebx,(%esp)
  80a78f:	e8 52 2e 00 00       	call   80d5e6 <tcp_zero_window_probe>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  80a794:	be 00 00 00 00       	mov    $0x0,%esi
  80a799:	e9 84 00 00 00       	jmp    80a822 <tcp_slowtmr+0x1a4>
          }
          tcp_zero_window_probe(pcb);
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  80a79e:	0f b7 4b 32          	movzwl 0x32(%ebx),%ecx
  80a7a2:	66 85 c9             	test   %cx,%cx
  80a7a5:	78 07                	js     80a7ae <tcp_slowtmr+0x130>
          ++pcb->rtime;
  80a7a7:	83 c1 01             	add    $0x1,%ecx
  80a7aa:	66 89 4b 32          	mov    %cx,0x32(%ebx)
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  80a7ae:	be 00 00 00 00       	mov    $0x0,%esi
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
          ++pcb->rtime;

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  80a7b3:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80a7b7:	74 69                	je     80a822 <tcp_slowtmr+0x1a4>
  80a7b9:	0f b7 4b 44          	movzwl 0x44(%ebx),%ecx
  80a7bd:	66 39 4b 32          	cmp    %cx,0x32(%ebx)
  80a7c1:	7c 5f                	jl     80a822 <tcp_slowtmr+0x1a4>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  80a7c3:	83 f8 02             	cmp    $0x2,%eax
  80a7c6:	74 1d                	je     80a7e5 <tcp_slowtmr+0x167>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80a7c8:	0f bf 43 40          	movswl 0x40(%ebx),%eax
  80a7cc:	c1 f8 03             	sar    $0x3,%eax
  80a7cf:	0f bf 4b 42          	movswl 0x42(%ebx),%ecx
  80a7d3:	01 c8                	add    %ecx,%eax
  80a7d5:	0f b6 d2             	movzbl %dl,%edx
  80a7d8:	0f b6 8a 77 5f 81 00 	movzbl 0x815f77(%edx),%ecx
  80a7df:	d3 e0                	shl    %cl,%eax
  80a7e1:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80a7e5:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  80a7eb:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  80a7ef:	66 39 53 5c          	cmp    %dx,0x5c(%ebx)
  80a7f3:	66 0f 46 53 5c       	cmovbe 0x5c(%ebx),%dx
  80a7f8:	0f b7 d2             	movzwl %dx,%edx
  80a7fb:	d1 fa                	sar    %edx
  80a7fd:	66 89 53 50          	mov    %dx,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  80a801:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  80a805:	66 39 d0             	cmp    %dx,%ax
  80a808:	76 07                	jbe    80a811 <tcp_slowtmr+0x193>
            pcb->ssthresh = pcb->mss * 2;
  80a80a:	8d 14 00             	lea    (%eax,%eax,1),%edx
  80a80d:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  80a811:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  80a815:	89 1c 24             	mov    %ebx,(%esp)
  80a818:	e8 d2 2b 00 00       	call   80d3ef <tcp_rexmit_rto>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);

    pcb_remove = 0;
  80a81d:	be 00 00 00 00       	mov    $0x0,%esi
          tcp_rexmit_rto(pcb);
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  80a822:	8b 43 10             	mov    0x10(%ebx),%eax
  80a825:	83 f8 06             	cmp    $0x6,%eax
  80a828:	75 13                	jne    80a83d <tcp_slowtmr+0x1bf>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80a82a:	8b 15 d0 a3 b3 00    	mov    0xb3a3d0,%edx
  80a830:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80a833:	83 fa 29             	cmp    $0x29,%edx
  80a836:	89 f2                	mov    %esi,%edx
  80a838:	80 da ff             	sbb    $0xff,%dl
  80a83b:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  80a83d:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80a841:	74 67                	je     80a8aa <tcp_slowtmr+0x22c>
  80a843:	83 f8 04             	cmp    $0x4,%eax
  80a846:	74 05                	je     80a84d <tcp_slowtmr+0x1cf>
  80a848:	83 f8 07             	cmp    $0x7,%eax
  80a84b:	75 5d                	jne    80a8aa <tcp_slowtmr+0x22c>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  80a84d:	a1 d0 a3 b3 00       	mov    0xb3a3d0,%eax
  80a852:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80a855:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80a858:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
  80a85e:	8d 91 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%edx
  80a864:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80a869:	f7 e2                	mul    %edx
  80a86b:	c1 ea 05             	shr    $0x5,%edx
  80a86e:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80a871:	76 0a                	jbe    80a87d <tcp_slowtmr+0x1ff>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80a873:	89 1c 24             	mov    %ebx,(%esp)
  80a876:	e8 f3 fc ff ff       	call   80a56e <tcp_abort>
  80a87b:	eb 2d                	jmp    80a8aa <tcp_slowtmr+0x22c>
#if LWIP_TCP_KEEPALIVE
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
  80a87d:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80a884:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  80a88a:	01 ca                	add    %ecx,%edx
  80a88c:	b8 d3 4d 62 10       	mov    $0x10624dd3,%eax
  80a891:	f7 e2                	mul    %edx
  80a893:	c1 ea 05             	shr    $0x5,%edx
  80a896:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80a899:	76 0f                	jbe    80a8aa <tcp_slowtmr+0x22c>
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  80a89b:	89 1c 24             	mov    %ebx,(%esp)
  80a89e:	e8 ee 2b 00 00       	call   80d491 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  80a8a3:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  80a8aa:	8b 53 7c             	mov    0x7c(%ebx),%edx
  80a8ad:	85 d2                	test   %edx,%edx
  80a8af:	74 25                	je     80a8d6 <tcp_slowtmr+0x258>
  80a8b1:	8b 0d d0 a3 b3 00    	mov    0xb3a3d0,%ecx
  80a8b7:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  80a8ba:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  80a8be:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80a8c1:	01 c0                	add    %eax,%eax
  80a8c3:	39 c1                	cmp    %eax,%ecx
  80a8c5:	72 0f                	jb     80a8d6 <tcp_slowtmr+0x258>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
      tcp_segs_free(pcb->ooseq);
  80a8c7:	89 14 24             	mov    %edx,(%esp)
  80a8ca:	e8 42 fa ff ff       	call   80a311 <tcp_segs_free>
      pcb->ooseq = NULL;
  80a8cf:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  80a8d6:	8b 43 10             	mov    0x10(%ebx),%eax
  80a8d9:	83 f8 03             	cmp    $0x3,%eax
  80a8dc:	75 13                	jne    80a8f1 <tcp_slowtmr+0x273>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  80a8de:	8b 15 d0 a3 b3 00    	mov    0xb3a3d0,%edx
  80a8e4:	2b 53 2c             	sub    0x2c(%ebx),%edx
  80a8e7:	83 fa 28             	cmp    $0x28,%edx
  80a8ea:	76 05                	jbe    80a8f1 <tcp_slowtmr+0x273>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  80a8ec:	83 c6 01             	add    $0x1,%esi
  80a8ef:	eb 19                	jmp    80a90a <tcp_slowtmr+0x28c>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  80a8f1:	83 f8 09             	cmp    $0x9,%eax
  80a8f4:	75 14                	jne    80a90a <tcp_slowtmr+0x28c>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80a8f6:	a1 d0 a3 b3 00       	mov    0xb3a3d0,%eax
  80a8fb:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  80a8fe:	3d f1 00 00 00       	cmp    $0xf1,%eax
  80a903:	89 f2                	mov    %esi,%edx
  80a905:	80 da ff             	sbb    $0xff,%dl
  80a908:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80a90a:	89 f1                	mov    %esi,%ecx
  80a90c:	84 c9                	test   %cl,%cl
  80a90e:	0f 84 96 00 00 00    	je     80a9aa <tcp_slowtmr+0x32c>
      tcp_pcb_purge(pcb);      
  80a914:	89 1c 24             	mov    %ebx,(%esp)
  80a917:	e8 dd fa ff ff       	call   80a3f9 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  80a91c:	85 ff                	test   %edi,%edi
  80a91e:	74 2c                	je     80a94c <tcp_slowtmr+0x2ce>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  80a920:	3b 1d dc a3 b3 00    	cmp    0xb3a3dc,%ebx
  80a926:	75 1c                	jne    80a944 <tcp_slowtmr+0x2c6>
  80a928:	c7 44 24 08 e8 5d 81 	movl   $0x815de8,0x8(%esp)
  80a92f:	00 
  80a930:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  80a937:	00 
  80a938:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a93f:	e8 74 60 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        prev->next = pcb->next;
  80a944:	8b 43 0c             	mov    0xc(%ebx),%eax
  80a947:	89 47 0c             	mov    %eax,0xc(%edi)
  80a94a:	eb 2d                	jmp    80a979 <tcp_slowtmr+0x2fb>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  80a94c:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
  80a951:	39 d8                	cmp    %ebx,%eax
  80a953:	74 1c                	je     80a971 <tcp_slowtmr+0x2f3>
  80a955:	c7 44 24 08 14 5e 81 	movl   $0x815e14,0x8(%esp)
  80a95c:	00 
  80a95d:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  80a964:	00 
  80a965:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80a96c:	e8 47 60 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        tcp_active_pcbs = pcb->next;
  80a971:	8b 40 0c             	mov    0xc(%eax),%eax
  80a974:	a3 dc a3 b3 00       	mov    %eax,0xb3a3dc
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  80a979:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80a97f:	85 c0                	test   %eax,%eax
  80a981:	74 10                	je     80a993 <tcp_slowtmr+0x315>
  80a983:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  80a98a:	ff 
  80a98b:	8b 53 18             	mov    0x18(%ebx),%edx
  80a98e:	89 14 24             	mov    %edx,(%esp)
  80a991:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  80a993:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  80a996:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a99a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80a9a1:	e8 9b e4 ff ff       	call   808e41 <memp_free>
      pcb = pcb2;
  80a9a6:	89 f3                	mov    %esi,%ebx
  80a9a8:	eb 3f                	jmp    80a9e9 <tcp_slowtmr+0x36b>
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  80a9aa:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  80a9ae:	83 c0 01             	add    $0x1,%eax
  80a9b1:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80a9b4:	3a 43 31             	cmp    0x31(%ebx),%al
  80a9b7:	72 2b                	jb     80a9e4 <tcp_slowtmr+0x366>
        pcb->polltmr = 0;
  80a9b9:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  80a9bd:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80a9c3:	85 c0                	test   %eax,%eax
  80a9c5:	74 0f                	je     80a9d6 <tcp_slowtmr+0x358>
  80a9c7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a9cb:	8b 53 18             	mov    0x18(%ebx),%edx
  80a9ce:	89 14 24             	mov    %edx,(%esp)
  80a9d1:	ff d0                	call   *%eax
  80a9d3:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  80a9d6:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80a9da:	75 08                	jne    80a9e4 <tcp_slowtmr+0x366>
          tcp_output(pcb);
  80a9dc:	89 1c 24             	mov    %ebx,(%esp)
  80a9df:	e8 11 24 00 00       	call   80cdf5 <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  80a9e4:	89 df                	mov    %ebx,%edi
  80a9e6:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  80a9e9:	85 db                	test   %ebx,%ebx
  80a9eb:	0f 85 c7 fc ff ff    	jne    80a6b8 <tcp_slowtmr+0x3a>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  80a9f1:	8b 1d e0 a3 b3 00    	mov    0xb3a3e0,%ebx
  while (pcb != NULL) {
  80a9f7:	85 db                	test   %ebx,%ebx
  80a9f9:	0f 84 c7 00 00 00    	je     80aac6 <tcp_slowtmr+0x448>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80a9ff:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80aa03:	75 0d                	jne    80aa12 <tcp_slowtmr+0x394>
    }
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  80aa05:	be 00 00 00 00       	mov    $0x0,%esi
  80aa0a:	eb 22                	jmp    80aa2e <tcp_slowtmr+0x3b0>
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  80aa0c:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80aa10:	74 1c                	je     80aa2e <tcp_slowtmr+0x3b0>
  80aa12:	c7 44 24 08 40 5e 81 	movl   $0x815e40,0x8(%esp)
  80aa19:	00 
  80aa1a:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  80aa21:	00 
  80aa22:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80aa29:	e8 8a 5f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  80aa2e:	a1 d0 a3 b3 00       	mov    0xb3a3d0,%eax
  80aa33:	2b 43 2c             	sub    0x2c(%ebx),%eax
    }
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  80aa36:	3d f0 00 00 00       	cmp    $0xf0,%eax
  80aa3b:	76 7c                	jbe    80aab9 <tcp_slowtmr+0x43b>
      tcp_pcb_purge(pcb);      
  80aa3d:	89 1c 24             	mov    %ebx,(%esp)
  80aa40:	e8 b4 f9 ff ff       	call   80a3f9 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  80aa45:	85 f6                	test   %esi,%esi
  80aa47:	74 2c                	je     80aa75 <tcp_slowtmr+0x3f7>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  80aa49:	3b 1d e0 a3 b3 00    	cmp    0xb3a3e0,%ebx
  80aa4f:	75 1c                	jne    80aa6d <tcp_slowtmr+0x3ef>
  80aa51:	c7 44 24 08 70 5e 81 	movl   $0x815e70,0x8(%esp)
  80aa58:	00 
  80aa59:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  80aa60:	00 
  80aa61:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80aa68:	e8 4b 5f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        prev->next = pcb->next;
  80aa6d:	8b 43 0c             	mov    0xc(%ebx),%eax
  80aa70:	89 46 0c             	mov    %eax,0xc(%esi)
  80aa73:	eb 2d                	jmp    80aaa2 <tcp_slowtmr+0x424>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  80aa75:	a1 e0 a3 b3 00       	mov    0xb3a3e0,%eax
  80aa7a:	39 d8                	cmp    %ebx,%eax
  80aa7c:	74 1c                	je     80aa9a <tcp_slowtmr+0x41c>
  80aa7e:	c7 44 24 08 98 5e 81 	movl   $0x815e98,0x8(%esp)
  80aa85:	00 
  80aa86:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  80aa8d:	00 
  80aa8e:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80aa95:	e8 1e 5f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        tcp_tw_pcbs = pcb->next;
  80aa9a:	8b 40 0c             	mov    0xc(%eax),%eax
  80aa9d:	a3 e0 a3 b3 00       	mov    %eax,0xb3a3e0
      }
      pcb2 = pcb->next;
  80aaa2:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  80aaa5:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80aaa9:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80aab0:	e8 8c e3 ff ff       	call   808e41 <memp_free>
      pcb = pcb2;
  80aab5:	89 fb                	mov    %edi,%ebx
  80aab7:	eb 05                	jmp    80aabe <tcp_slowtmr+0x440>
    } else {
      prev = pcb;
      pcb = pcb->next;
  80aab9:	89 de                	mov    %ebx,%esi
  80aabb:	8b 5b 0c             	mov    0xc(%ebx),%ebx

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  80aabe:	85 db                	test   %ebx,%ebx
  80aac0:	0f 85 46 ff ff ff    	jne    80aa0c <tcp_slowtmr+0x38e>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  80aac6:	83 c4 2c             	add    $0x2c,%esp
  80aac9:	5b                   	pop    %ebx
  80aaca:	5e                   	pop    %esi
  80aacb:	5f                   	pop    %edi
  80aacc:	5d                   	pop    %ebp
  80aacd:	c3                   	ret    

0080aace <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  80aace:	55                   	push   %ebp
  80aacf:	89 e5                	mov    %esp,%ebp
  80aad1:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80aad4:	e8 77 f7 ff ff       	call   80a250 <tcp_fasttmr>

  if (++tcp_timer & 1) {
  80aad9:	0f b6 05 e8 a3 b3 00 	movzbl 0xb3a3e8,%eax
  80aae0:	83 c0 01             	add    $0x1,%eax
  80aae3:	a2 e8 a3 b3 00       	mov    %al,0xb3a3e8
  80aae8:	a8 01                	test   $0x1,%al
  80aaea:	74 05                	je     80aaf1 <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  80aaec:	e8 8d fb ff ff       	call   80a67e <tcp_slowtmr>
  }
}
  80aaf1:	c9                   	leave  
  80aaf2:	c3                   	ret    

0080aaf3 <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  80aaf3:	55                   	push   %ebp
  80aaf4:	89 e5                	mov    %esp,%ebp
  80aaf6:	53                   	push   %ebx
  80aaf7:	83 ec 14             	sub    $0x14,%esp
  80aafa:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  80aafd:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  80ab01:	0f 87 14 01 00 00    	ja     80ac1b <tcp_close+0x128>
  80ab07:	8b 43 10             	mov    0x10(%ebx),%eax
  80ab0a:	ff 24 85 50 5f 81 00 	jmp    *0x815f50(,%eax,4)
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80ab11:	8b 15 d4 a3 b3 00    	mov    0xb3a3d4,%edx
  80ab17:	39 da                	cmp    %ebx,%edx
  80ab19:	75 0a                	jne    80ab25 <tcp_close+0x32>
  80ab1b:	8b 42 0c             	mov    0xc(%edx),%eax
  80ab1e:	a3 d4 a3 b3 00       	mov    %eax,0xb3a3d4
  80ab23:	eb 2d                	jmp    80ab52 <tcp_close+0x5f>
  80ab25:	89 15 e4 a3 b3 00    	mov    %edx,0xb3a3e4
  80ab2b:	89 d1                	mov    %edx,%ecx
  80ab2d:	85 d2                	test   %edx,%edx
  80ab2f:	75 06                	jne    80ab37 <tcp_close+0x44>
  80ab31:	eb 1f                	jmp    80ab52 <tcp_close+0x5f>
  80ab33:	89 c1                	mov    %eax,%ecx
  80ab35:	89 c2                	mov    %eax,%edx
  80ab37:	8b 42 0c             	mov    0xc(%edx),%eax
  80ab3a:	85 c0                	test   %eax,%eax
  80ab3c:	0f 84 fc 00 00 00    	je     80ac3e <tcp_close+0x14b>
  80ab42:	39 c3                	cmp    %eax,%ebx
  80ab44:	75 ed                	jne    80ab33 <tcp_close+0x40>
  80ab46:	89 0d e4 a3 b3 00    	mov    %ecx,0xb3a3e4
  80ab4c:	8b 43 0c             	mov    0xc(%ebx),%eax
  80ab4f:	89 42 0c             	mov    %eax,0xc(%edx)
  80ab52:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  80ab59:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ab5d:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80ab64:	e8 d8 e2 ff ff       	call   808e41 <memp_free>
     * and the user needs some way to free it should the need arise.
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
  80ab69:	b8 00 00 00 00       	mov    $0x0,%eax
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  80ab6e:	e9 c5 00 00 00       	jmp    80ac38 <tcp_close+0x145>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  80ab73:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ab77:	c7 04 24 d8 a3 b3 00 	movl   $0xb3a3d8,(%esp)
  80ab7e:	e8 ef f8 ff ff       	call   80a472 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  80ab83:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ab87:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80ab8e:	e8 ae e2 ff ff       	call   808e41 <memp_free>
    TCP_RMV(&tcp_bound_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    break;
  case LISTEN:
    err = ERR_OK;
  80ab93:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  80ab98:	e9 9b 00 00 00       	jmp    80ac38 <tcp_close+0x145>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80ab9d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80aba1:	c7 04 24 dc a3 b3 00 	movl   $0xb3a3dc,(%esp)
  80aba8:	e8 c5 f8 ff ff       	call   80a472 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  80abad:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80abb1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80abb8:	e8 84 e2 ff ff       	call   808e41 <memp_free>
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
    pcb = NULL;
    break;
  case SYN_SENT:
    err = ERR_OK;
  80abbd:	b8 00 00 00 00       	mov    $0x0,%eax
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
    memp_free(MEMP_TCP_PCB, pcb);
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  80abc2:	eb 74                	jmp    80ac38 <tcp_close+0x145>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80abc4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80abcb:	00 
  80abcc:	89 1c 24             	mov    %ebx,(%esp)
  80abcf:	e8 de 21 00 00       	call   80cdb2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80abd4:	84 c0                	test   %al,%al
  80abd6:	75 60                	jne    80ac38 <tcp_close+0x145>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  80abd8:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  80abdf:	eb 3f                	jmp    80ac20 <tcp_close+0x12d>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80abe1:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80abe8:	00 
  80abe9:	89 1c 24             	mov    %ebx,(%esp)
  80abec:	e8 c1 21 00 00       	call   80cdb2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80abf1:	84 c0                	test   %al,%al
  80abf3:	75 43                	jne    80ac38 <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  80abf5:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  80abfc:	eb 22                	jmp    80ac20 <tcp_close+0x12d>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  80abfe:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80ac05:	00 
  80ac06:	89 1c 24             	mov    %ebx,(%esp)
  80ac09:	e8 a4 21 00 00       	call   80cdb2 <tcp_send_ctrl>
    if (err == ERR_OK) {
  80ac0e:	84 c0                	test   %al,%al
  80ac10:	75 26                	jne    80ac38 <tcp_close+0x145>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  80ac12:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
  80ac19:	eb 05                	jmp    80ac20 <tcp_close+0x12d>
    }
    break;
  default:
    /* Has already been closed, do nothing. */
    err = ERR_OK;
    pcb = NULL;
  80ac1b:	bb 00 00 00 00       	mov    $0x0,%ebx
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  80ac20:	85 db                	test   %ebx,%ebx
  80ac22:	74 0f                	je     80ac33 <tcp_close+0x140>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  80ac24:	89 1c 24             	mov    %ebx,(%esp)
  80ac27:	e8 c9 21 00 00       	call   80cdf5 <tcp_output>
  80ac2c:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac31:	eb 05                	jmp    80ac38 <tcp_close+0x145>
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  80ac33:	b8 00 00 00 00       	mov    $0x0,%eax
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  }
  return err;
}
  80ac38:	83 c4 14             	add    $0x14,%esp
  80ac3b:	5b                   	pop    %ebx
  80ac3c:	5d                   	pop    %ebp
  80ac3d:	c3                   	ret    
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  80ac3e:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  80ac43:	e9 0a ff ff ff       	jmp    80ab52 <tcp_close+0x5f>

0080ac48 <_ZL13tcp_recv_nullPvP7tcp_pcbP4pbufa>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80ac48:	55                   	push   %ebp
  80ac49:	89 e5                	mov    %esp,%ebp
  80ac4b:	83 ec 18             	sub    $0x18,%esp
  80ac4e:	8b 45 10             	mov    0x10(%ebp),%eax
  80ac51:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  80ac55:	85 c0                	test   %eax,%eax
  80ac57:	74 0f                	je     80ac68 <_ZL13tcp_recv_nullPvP7tcp_pcbP4pbufa+0x20>
    pbuf_free(p);
  80ac59:	89 04 24             	mov    %eax,(%esp)
  80ac5c:	e8 a2 e5 ff ff       	call   809203 <pbuf_free>
  } else if (err == ERR_OK) {
    return tcp_close(pcb);
  }
  return ERR_OK;
  80ac61:	b8 00 00 00 00       	mov    $0x0,%eax
  80ac66:	eb 14                	jmp    80ac7c <_ZL13tcp_recv_nullPvP7tcp_pcbP4pbufa+0x34>
  80ac68:	b8 00 00 00 00       	mov    $0x0,%eax
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  arg = arg;
  if (p != NULL) {
    pbuf_free(p);
  } else if (err == ERR_OK) {
  80ac6d:	84 d2                	test   %dl,%dl
  80ac6f:	75 0b                	jne    80ac7c <_ZL13tcp_recv_nullPvP7tcp_pcbP4pbufa+0x34>
    return tcp_close(pcb);
  80ac71:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ac74:	89 04 24             	mov    %eax,(%esp)
  80ac77:	e8 77 fe ff ff       	call   80aaf3 <tcp_close>
  }
  return ERR_OK;
}
  80ac7c:	c9                   	leave  
  80ac7d:	c3                   	ret    

0080ac7e <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80ac7e:	55                   	push   %ebp
  80ac7f:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  80ac81:	a1 d0 a3 b3 00       	mov    0xb3a3d0,%eax
  80ac86:	03 05 7c 80 81 00    	add    0x81807c,%eax
  80ac8c:	a3 7c 80 81 00       	mov    %eax,0x81807c
  return iss;
}
  80ac91:	5d                   	pop    %ebp
  80ac92:	c3                   	ret    

0080ac93 <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80ac93:	55                   	push   %ebp
  80ac94:	89 e5                	mov    %esp,%ebp
  80ac96:	83 ec 38             	sub    $0x38,%esp
  80ac99:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ac9c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ac9f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80aca2:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = (struct tcp_pcb *) memp_malloc(MEMP_TCP_PCB);
  80aca6:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80acad:	e8 2f e1 ff ff       	call   808de1 <memp_malloc>
  80acb2:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  80acb4:	85 c0                	test   %eax,%eax
  80acb6:	0f 85 bb 00 00 00    	jne    80ad77 <tcp_alloc+0xe4>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80acbc:	a1 e0 a3 b3 00       	mov    0xb3a3e0,%eax
  80acc1:	85 c0                	test   %eax,%eax
  80acc3:	74 30                	je     80acf5 <tcp_alloc+0x62>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80acc5:	8b 1d d0 a3 b3 00    	mov    0xb3a3d0,%ebx
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  80accb:	bf 00 00 00 00       	mov    $0x0,%edi
tcp_kill_timewait(void)
{
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;

  inactivity = 0;
  80acd0:	b9 00 00 00 00       	mov    $0x0,%ecx
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80acd5:	89 da                	mov    %ebx,%edx
  80acd7:	2b 50 2c             	sub    0x2c(%eax),%edx
  80acda:	39 ca                	cmp    %ecx,%edx
  80acdc:	72 04                	jb     80ace2 <tcp_alloc+0x4f>
      inactivity = tcp_ticks - pcb->tmr;
  80acde:	89 d1                	mov    %edx,%ecx

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  80ace0:	89 c7                	mov    %eax,%edi
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  80ace2:	8b 40 0c             	mov    0xc(%eax),%eax
  80ace5:	85 c0                	test   %eax,%eax
  80ace7:	75 ec                	jne    80acd5 <tcp_alloc+0x42>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  80ace9:	85 ff                	test   %edi,%edi
  80aceb:	74 08                	je     80acf5 <tcp_alloc+0x62>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80aced:	89 3c 24             	mov    %edi,(%esp)
  80acf0:	e8 79 f8 ff ff       	call   80a56e <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = (struct tcp_pcb *) memp_malloc(MEMP_TCP_PCB);
  80acf5:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80acfc:	e8 e0 e0 ff ff       	call   808de1 <memp_malloc>
  80ad01:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  80ad03:	85 c0                	test   %eax,%eax
  80ad05:	75 70                	jne    80ad77 <tcp_alloc+0xe4>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80ad07:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
  80ad0c:	85 c0                	test   %eax,%eax
  80ad0e:	74 51                	je     80ad61 <tcp_alloc+0xce>
    if (pcb->prio <= prio &&
  80ad10:	8b 15 d0 a3 b3 00    	mov    0xb3a3d0,%edx
  80ad16:	89 55 e0             	mov    %edx,-0x20(%ebp)

  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  80ad19:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)


  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  80ad20:	bf 00 00 00 00       	mov    $0x0,%edi
  struct tcp_pcb *pcb, *inactive;
  u32_t inactivity;
  u8_t mprio;


  mprio = TCP_PRIO_MAX;
  80ad25:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  80ad2a:	89 f3                	mov    %esi,%ebx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80ad2c:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  80ad30:	38 d3                	cmp    %dl,%bl
  80ad32:	72 15                	jb     80ad49 <tcp_alloc+0xb6>
  80ad34:	38 ca                	cmp    %cl,%dl
  80ad36:	77 11                	ja     80ad49 <tcp_alloc+0xb6>
  80ad38:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80ad3b:	2b 70 2c             	sub    0x2c(%eax),%esi
  80ad3e:	39 f7                	cmp    %esi,%edi
  80ad40:	77 07                	ja     80ad49 <tcp_alloc+0xb6>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
  80ad42:	89 d1                	mov    %edx,%ecx
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
  80ad44:	89 f7                	mov    %esi,%edi
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80ad46:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80ad49:	8b 40 0c             	mov    0xc(%eax),%eax
  80ad4c:	85 c0                	test   %eax,%eax
  80ad4e:	75 dc                	jne    80ad2c <tcp_alloc+0x99>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  80ad50:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80ad54:	74 0b                	je     80ad61 <tcp_alloc+0xce>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80ad56:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80ad59:	89 04 24             	mov    %eax,(%esp)
  80ad5c:	e8 0d f8 ff ff       	call   80a56e <tcp_abort>
    pcb = (struct tcp_pcb *) memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = (struct tcp_pcb *) memp_malloc(MEMP_TCP_PCB);
  80ad61:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80ad68:	e8 74 e0 ff ff       	call   808de1 <memp_malloc>
  80ad6d:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  80ad6f:	85 c0                	test   %eax,%eax
  80ad71:	0f 84 9b 00 00 00    	je     80ae12 <tcp_alloc+0x17f>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  80ad77:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  80ad7e:	00 
  80ad7f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ad86:	00 
  80ad87:	89 1c 24             	mov    %ebx,(%esp)
  80ad8a:	e8 a2 64 ff ff       	call   801231 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  80ad8f:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  80ad93:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  80ad99:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  80ad9f:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  80ada5:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  80adab:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  80adaf:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80adb3:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  80adb9:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  80adbf:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  80adc5:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  80adcb:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  80add1:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  80add7:	e8 a2 fe ff ff       	call   80ac7e <tcp_next_iss>
    pcb->snd_wl2 = iss;
  80addc:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  80addf:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  80ade2:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  80ade5:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  80ade8:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  80adeb:	a1 d0 a3 b3 00       	mov    0xb3a3d0,%eax
  80adf0:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  80adf3:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  80adf7:	c7 83 88 00 00 00 48 	movl   $0x80ac48,0x88(%ebx)
  80adfe:	ac 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80ae01:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  80ae08:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  80ae0b:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  80ae12:	89 d8                	mov    %ebx,%eax
  80ae14:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80ae17:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80ae1a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80ae1d:	89 ec                	mov    %ebp,%esp
  80ae1f:	5d                   	pop    %ebp
  80ae20:	c3                   	ret    

0080ae21 <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  80ae21:	55                   	push   %ebp
  80ae22:	89 e5                	mov    %esp,%ebp
  80ae24:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  80ae27:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  80ae2e:	e8 60 fe ff ff       	call   80ac93 <tcp_alloc>
}
  80ae33:	c9                   	leave  
  80ae34:	c3                   	ret    

0080ae35 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  80ae35:	55                   	push   %ebp
  80ae36:	89 e5                	mov    %esp,%ebp
  80ae38:	53                   	push   %ebx
  80ae39:	83 ec 14             	sub    $0x14,%esp
  80ae3c:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80ae40:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ae43:	89 04 24             	mov    %eax,(%esp)
  80ae46:	e8 d5 01 00 00       	call   80b020 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  80ae4b:	85 c0                	test   %eax,%eax
  80ae4d:	74 12                	je     80ae61 <tcp_eff_send_mss+0x2c>
  80ae4f:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  80ae53:	66 85 c0             	test   %ax,%ax
  80ae56:	74 09                	je     80ae61 <tcp_eff_send_mss+0x2c>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
  80ae58:	83 e8 28             	sub    $0x28,%eax
{
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  if ((outif != NULL) && (outif->mtu != 0)) {
  80ae5b:	66 39 c3             	cmp    %ax,%bx
  80ae5e:	0f 47 d8             	cmova  %eax,%ebx
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  }
  return sendmss;
}
  80ae61:	89 d8                	mov    %ebx,%eax
  80ae63:	83 c4 14             	add    $0x14,%esp
  80ae66:	5b                   	pop    %ebx
  80ae67:	5d                   	pop    %ebp
  80ae68:	c3                   	ret    

0080ae69 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  80ae69:	55                   	push   %ebp
  80ae6a:	89 e5                	mov    %esp,%ebp
  80ae6c:	57                   	push   %edi
  80ae6d:	56                   	push   %esi
  80ae6e:	53                   	push   %ebx
  80ae6f:	83 ec 3c             	sub    $0x3c,%esp
  80ae72:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ae75:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80ae78:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  80ae7c:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80ae80:	74 1c                	je     80ae9e <tcp_connect+0x35>
  80ae82:	c7 44 24 08 c0 5e 81 	movl   $0x815ec0,0x8(%esp)
  80ae89:	00 
  80ae8a:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  80ae91:	00 
  80ae92:	c7 04 24 f2 5e 81 00 	movl   $0x815ef2,(%esp)
  80ae99:	e8 1a 5b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
    pcb->remote_ip = *ipaddr;
  } else {
    return ERR_VAL;
  80ae9e:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  80aea3:	85 ff                	test   %edi,%edi
  80aea5:	0f 84 24 01 00 00    	je     80afcf <tcp_connect+0x166>
    pcb->remote_ip = *ipaddr;
  80aeab:	8b 17                	mov    (%edi),%edx
  80aead:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  80aeb0:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  80aeb4:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  80aeb9:	75 09                	jne    80aec4 <tcp_connect+0x5b>
    pcb->local_port = tcp_new_port();
  80aebb:	e8 8a ef ff ff       	call   809e4a <_ZL12tcp_new_portv>
  80aec0:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  80aec4:	e8 b5 fd ff ff       	call   80ac7e <tcp_next_iss>
  pcb->rcv_nxt = 0;
  80aec9:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  80aed0:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  80aed3:	83 e8 01             	sub    $0x1,%eax
  80aed6:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  80aed9:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  80aedc:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  80aee2:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  80aee8:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  80aeee:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  80aef4:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80aef8:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  80aeff:	e8 31 ff ff ff       	call   80ae35 <tcp_eff_send_mss>
  80af04:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  80af08:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  80af0e:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80af11:	01 c0                	add    %eax,%eax
  80af13:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  80af17:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  80af1e:	8b 45 14             	mov    0x14(%ebp),%eax
  80af21:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80af27:	8b 15 d4 a3 b3 00    	mov    0xb3a3d4,%edx
  80af2d:	39 da                	cmp    %ebx,%edx
  80af2f:	75 0a                	jne    80af3b <tcp_connect+0xd2>
  80af31:	8b 42 0c             	mov    0xc(%edx),%eax
  80af34:	a3 d4 a3 b3 00       	mov    %eax,0xb3a3d4
  80af39:	eb 2d                	jmp    80af68 <tcp_connect+0xff>
  80af3b:	89 15 e4 a3 b3 00    	mov    %edx,0xb3a3e4
  80af41:	89 d1                	mov    %edx,%ecx
  80af43:	85 d2                	test   %edx,%edx
  80af45:	75 06                	jne    80af4d <tcp_connect+0xe4>
  80af47:	eb 1f                	jmp    80af68 <tcp_connect+0xff>
  80af49:	89 c1                	mov    %eax,%ecx
  80af4b:	89 c2                	mov    %eax,%edx
  80af4d:	8b 42 0c             	mov    0xc(%edx),%eax
  80af50:	85 c0                	test   %eax,%eax
  80af52:	0f 84 81 00 00 00    	je     80afd9 <tcp_connect+0x170>
  80af58:	39 c3                	cmp    %eax,%ebx
  80af5a:	75 ed                	jne    80af49 <tcp_connect+0xe0>
  80af5c:	89 0d e4 a3 b3 00    	mov    %ecx,0xb3a3e4
  80af62:	8b 43 0c             	mov    0xc(%ebx),%eax
  80af65:	89 42 0c             	mov    %eax,0xc(%edx)
  TCP_REG(&tcp_active_pcbs, pcb);
  80af68:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
  80af6d:	89 43 0c             	mov    %eax,0xc(%ebx)
  80af70:	89 1d dc a3 b3 00    	mov    %ebx,0xb3a3dc
  80af76:	e8 a2 b8 ff ff       	call   80681d <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  80af7b:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  80af82:	e8 53 14 00 00       	call   80c3da <htonl>
  80af87:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  80af8a:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80af91:	00 
  80af92:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80af95:	89 44 24 14          	mov    %eax,0x14(%esp)
  80af99:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80afa0:	00 
  80afa1:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  80afa8:	00 
  80afa9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80afb0:	00 
  80afb1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80afb8:	00 
  80afb9:	89 1c 24             	mov    %ebx,(%esp)
  80afbc:	e8 8f 16 00 00       	call   80c650 <tcp_enqueue>
  80afc1:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  80afc3:	84 c0                	test   %al,%al
  80afc5:	75 08                	jne    80afcf <tcp_connect+0x166>
    tcp_output(pcb);
  80afc7:	89 1c 24             	mov    %ebx,(%esp)
  80afca:	e8 26 1e 00 00       	call   80cdf5 <tcp_output>
  }
  return ret;
} 
  80afcf:	89 f0                	mov    %esi,%eax
  80afd1:	83 c4 3c             	add    $0x3c,%esp
  80afd4:	5b                   	pop    %ebx
  80afd5:	5e                   	pop    %esi
  80afd6:	5f                   	pop    %edi
  80afd7:	5d                   	pop    %ebp
  80afd8:	c3                   	ret    
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  80afd9:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  80afde:	eb 88                	jmp    80af68 <tcp_connect+0xff>

0080afe0 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  80afe0:	55                   	push   %ebp
  80afe1:	89 e5                	mov    %esp,%ebp
  80afe3:	53                   	push   %ebx
  80afe4:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  80afe7:	8b 45 08             	mov    0x8(%ebp),%eax
  80afea:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80afec:	8d 5a ff             	lea    -0x1(%edx),%ebx
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  80afef:	b8 01 00 00 00       	mov    $0x1,%eax
{
  u32_t addr2test;

  addr2test = addr->addr;
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  80aff4:	83 fb fd             	cmp    $0xfffffffd,%ebx
  80aff7:	77 24                	ja     80b01d <ip_addr_isbroadcast+0x3d>
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  80aff9:	b8 00 00 00 00       	mov    $0x0,%eax
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  80affe:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  80b002:	74 19                	je     80b01d <ip_addr_isbroadcast+0x3d>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  80b004:	8b 59 04             	mov    0x4(%ecx),%ebx
  80b007:	39 d3                	cmp    %edx,%ebx
  80b009:	74 12                	je     80b01d <ip_addr_isbroadcast+0x3d>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80b00b:	8b 49 08             	mov    0x8(%ecx),%ecx
  80b00e:	31 d3                	xor    %edx,%ebx
  80b010:	85 cb                	test   %ecx,%ebx
  80b012:	75 09                	jne    80b01d <ip_addr_isbroadcast+0x3d>
  80b014:	f7 d1                	not    %ecx
  80b016:	21 ca                	and    %ecx,%edx
 * 
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
  80b018:	39 d1                	cmp    %edx,%ecx
  80b01a:	0f 94 c0             	sete   %al
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  80b01d:	5b                   	pop    %ebx
  80b01e:	5d                   	pop    %ebp
  80b01f:	c3                   	ret    

0080b020 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  80b020:	55                   	push   %ebp
  80b021:	89 e5                	mov    %esp,%ebp
  80b023:	56                   	push   %esi
  80b024:	53                   	push   %ebx
  80b025:	83 ec 10             	sub    $0x10,%esp
  80b028:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80b02b:	8b 1d c4 a3 b3 00    	mov    0xb3a3c4,%ebx
  80b031:	85 db                	test   %ebx,%ebx
  80b033:	74 1c                	je     80b051 <ip_route+0x31>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  80b035:	89 1c 24             	mov    %ebx,(%esp)
  80b038:	e8 bc e0 ff ff       	call   8090f9 <netif_is_up>
  80b03d:	84 c0                	test   %al,%al
  80b03f:	74 0a                	je     80b04b <ip_route+0x2b>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  80b041:	8b 43 04             	mov    0x4(%ebx),%eax
  80b044:	33 06                	xor    (%esi),%eax
  80b046:	85 43 08             	test   %eax,0x8(%ebx)
  80b049:	74 25                	je     80b070 <ip_route+0x50>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  80b04b:	8b 1b                	mov    (%ebx),%ebx
  80b04d:	85 db                	test   %ebx,%ebx
  80b04f:	75 e4                	jne    80b035 <ip_route+0x15>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  80b051:	a1 c8 a3 b3 00       	mov    0xb3a3c8,%eax
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  80b056:	bb 00 00 00 00       	mov    $0x0,%ebx
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  80b05b:	85 c0                	test   %eax,%eax
  80b05d:	74 11                	je     80b070 <ip_route+0x50>
  80b05f:	89 04 24             	mov    %eax,(%esp)
  80b062:	e8 92 e0 ff ff       	call   8090f9 <netif_is_up>
    LWIP_DEBUGF(IP_DEBUG | 2, ("ip_route: No route to 0x%"X32_F"\n", dest->addr));
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  80b067:	84 c0                	test   %al,%al
  80b069:	0f 45 1d c8 a3 b3 00 	cmovne 0xb3a3c8,%ebx
  }
  /* no matching netif found, use default netif */
  return netif_default;
}
  80b070:	89 d8                	mov    %ebx,%eax
  80b072:	83 c4 10             	add    $0x10,%esp
  80b075:	5b                   	pop    %ebx
  80b076:	5e                   	pop    %esi
  80b077:	5d                   	pop    %ebp
  80b078:	c3                   	ret    

0080b079 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  80b079:	55                   	push   %ebp
  80b07a:	89 e5                	mov    %esp,%ebp
  80b07c:	83 ec 48             	sub    $0x48,%esp
  80b07f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80b082:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80b085:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80b088:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = (struct ip_hdr *) p->payload;
  80b08b:	8b 5e 04             	mov    0x4(%esi),%ebx
  if (IPH_V(iphdr) != 4) {
  80b08e:	0f b7 03             	movzwl (%ebx),%eax
  80b091:	89 04 24             	mov    %eax,(%esp)
  80b094:	e8 2d 13 00 00       	call   80c3c6 <ntohs>
  80b099:	0f b7 c0             	movzwl %ax,%eax
  80b09c:	c1 f8 0c             	sar    $0xc,%eax
  80b09f:	83 f8 04             	cmp    $0x4,%eax
  80b0a2:	74 0d                	je     80b0b1 <ip_input+0x38>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  80b0a4:	89 34 24             	mov    %esi,(%esp)
  80b0a7:	e8 57 e1 ff ff       	call   809203 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80b0ac:	e9 76 02 00 00       	jmp    80b327 <ip_input+0x2ae>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  80b0b1:	0f b7 03             	movzwl (%ebx),%eax
  80b0b4:	89 04 24             	mov    %eax,(%esp)
  80b0b7:	e8 0a 13 00 00       	call   80c3c6 <ntohs>
  80b0bc:	0f b6 c4             	movzbl %ah,%eax
  80b0bf:	83 e0 0f             	and    $0xf,%eax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  80b0c2:	c1 e0 02             	shl    $0x2,%eax
  80b0c5:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  80b0c9:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80b0cd:	89 04 24             	mov    %eax,(%esp)
  80b0d0:	e8 f1 12 00 00       	call   80c3c6 <ntohs>
  80b0d5:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  80b0d7:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80b0db:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  80b0df:	77 06                	ja     80b0e7 <ip_input+0x6e>
  80b0e1:	66 3b 7e 08          	cmp    0x8(%esi),%di
  80b0e5:	76 0d                	jbe    80b0f4 <ip_input+0x7b>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  80b0e7:	89 34 24             	mov    %esi,(%esp)
  80b0ea:	e8 14 e1 ff ff       	call   809203 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  80b0ef:	e9 33 02 00 00       	jmp    80b327 <ip_input+0x2ae>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  80b0f4:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80b0f8:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b0fc:	89 1c 24             	mov    %ebx,(%esp)
  80b0ff:	e8 6b 11 00 00       	call   80c26f <inet_chksum>
  80b104:	66 85 c0             	test   %ax,%ax
  80b107:	74 0d                	je     80b116 <ip_input+0x9d>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  80b109:	89 34 24             	mov    %esi,(%esp)
  80b10c:	e8 f2 e0 ff ff       	call   809203 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  80b111:	e9 11 02 00 00       	jmp    80b327 <ip_input+0x2ae>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  80b116:	0f b7 ff             	movzwl %di,%edi
  80b119:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80b11d:	89 34 24             	mov    %esi,(%esp)
  80b120:	e8 ba e1 ff ff       	call   8092df <pbuf_realloc>
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
  80b125:	8b 7d 0c             	mov    0xc(%ebp),%edi
#endif /* LWIP_IGMP */
  {
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
  80b128:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80b12f:	8d 43 10             	lea    0x10(%ebx),%eax
  80b132:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80b135:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80b138:	89 de                	mov    %ebx,%esi
  80b13a:	bb 01 00 00 00       	mov    $0x1,%ebx
  80b13f:	eb 05                	jmp    80b146 <ip_input+0xcd>
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
    do {
  80b141:	bb 00 00 00 00       	mov    $0x0,%ebx
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  80b146:	89 3c 24             	mov    %edi,(%esp)
  80b149:	e8 ab df ff ff       	call   8090f9 <netif_is_up>
  80b14e:	84 c0                	test   %al,%al
  80b150:	74 3a                	je     80b18c <ip_input+0x113>
  80b152:	83 ff fc             	cmp    $0xfffffffc,%edi
  80b155:	74 35                	je     80b18c <ip_input+0x113>
  80b157:	8b 47 04             	mov    0x4(%edi),%eax
  80b15a:	85 c0                	test   %eax,%eax
  80b15c:	74 2e                	je     80b18c <ip_input+0x113>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80b15e:	3b 46 10             	cmp    0x10(%esi),%eax
  80b161:	74 1c                	je     80b17f <ip_input+0x106>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  80b163:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80b167:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b16a:	89 04 24             	mov    %eax,(%esp)
  80b16d:	e8 6e fe ff ff       	call   80afe0 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  80b172:	84 c0                	test   %al,%al
  80b174:	74 16                	je     80b18c <ip_input+0x113>
  80b176:	89 f3                	mov    %esi,%ebx
  80b178:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80b17b:	89 f8                	mov    %edi,%eax
  80b17d:	eb 07                	jmp    80b186 <ip_input+0x10d>
  80b17f:	89 f3                	mov    %esi,%ebx
  80b181:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80b184:	89 f8                	mov    %edi,%eax
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  80b186:	85 c0                	test   %eax,%eax
  80b188:	75 4f                	jne    80b1d9 <ip_input+0x160>
  80b18a:	eb 21                	jmp    80b1ad <ip_input+0x134>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  80b18c:	85 db                	test   %ebx,%ebx
  80b18e:	74 08                	je     80b198 <ip_input+0x11f>
        first = 0;
        netif = netif_list;
  80b190:	8b 3d c4 a3 b3 00    	mov    0xb3a3c4,%edi
  80b196:	eb 02                	jmp    80b19a <ip_input+0x121>
      } else {
        netif = netif->next;
  80b198:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  80b19a:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  80b19d:	75 05                	jne    80b1a4 <ip_input+0x12b>
        netif = netif->next;
  80b19f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b1a2:	8b 38                	mov    (%eax),%edi
    /* start trying with inp. if that's not acceptable, start walking the
       list of configured netifs.
       'first' is used as a boolean to mark whether we started walking the list */
    int first = 1;
    netif = inp;
    do {
  80b1a4:	85 ff                	test   %edi,%edi
  80b1a6:	75 99                	jne    80b141 <ip_input+0xc8>
  80b1a8:	89 f3                	mov    %esi,%ebx
  80b1aa:	8b 75 dc             	mov    -0x24(%ebp),%esi
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  80b1ad:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80b1b1:	89 04 24             	mov    %eax,(%esp)
  80b1b4:	e8 0d 12 00 00       	call   80c3c6 <ntohs>
  80b1b9:	bf 00 00 00 00       	mov    $0x0,%edi
  80b1be:	3c 11                	cmp    $0x11,%al
  80b1c0:	75 17                	jne    80b1d9 <ip_input+0x160>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  80b1c2:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80b1c6:	0f b7 44 03 02       	movzwl 0x2(%ebx,%eax,1),%eax
  80b1cb:	89 04 24             	mov    %eax,(%esp)
  80b1ce:	e8 f3 11 00 00       	call   80c3c6 <ntohs>
  80b1d3:	66 83 f8 44          	cmp    $0x44,%ax
  80b1d7:	74 4e                	je     80b227 <ip_input+0x1ae>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80b1d9:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b1dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b1e0:	8d 43 0c             	lea    0xc(%ebx),%eax
  80b1e3:	89 04 24             	mov    %eax,(%esp)
  80b1e6:	e8 f5 fd ff ff       	call   80afe0 <ip_addr_isbroadcast>
  80b1eb:	84 c0                	test   %al,%al
  80b1ed:	75 2b                	jne    80b21a <ip_input+0x1a1>
  80b1ef:	8b 43 0c             	mov    0xc(%ebx),%eax
  80b1f2:	89 45 e0             	mov    %eax,-0x20(%ebp)
         (ip_addr_ismulticast(&(iphdr->src)))) {
  80b1f5:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80b1fc:	e8 38 14 00 00       	call   80c639 <ntohl>
  80b201:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80b204:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80b20b:	e8 29 14 00 00       	call   80c639 <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  80b210:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80b213:	23 55 e0             	and    -0x20(%ebp),%edx
  80b216:	39 c2                	cmp    %eax,%edx
  80b218:	75 10                	jne    80b22a <ip_input+0x1b1>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  80b21a:	89 34 24             	mov    %esi,(%esp)
  80b21d:	e8 e1 df ff ff       	call   809203 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  80b222:	e9 00 01 00 00       	jmp    80b327 <ip_input+0x2ae>
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
        LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: DHCP packet accepted.\n"));
        netif = inp;
  80b227:	8b 7d 0c             	mov    0xc(%ebp),%edi
      return ERR_OK;
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  80b22a:	85 ff                	test   %edi,%edi
  80b22c:	75 0d                	jne    80b23b <ip_input+0x1c2>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  80b22e:	89 34 24             	mov    %esi,(%esp)
  80b231:	e8 cd df ff ff       	call   809203 <pbuf_free>
    return ERR_OK;
  80b236:	e9 ec 00 00 00       	jmp    80b327 <ip_input+0x2ae>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  80b23b:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  80b23f:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  80b246:	e8 6e 11 00 00       	call   80c3b9 <htons>
  80b24b:	66 85 f8             	test   %di,%ax
  80b24e:	74 15                	je     80b265 <ip_input+0x1ec>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  80b250:	89 34 24             	mov    %esi,(%esp)
  80b253:	e8 5d 05 00 00       	call   80b7b5 <ip_reass>
  80b258:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  80b25a:	85 c0                	test   %eax,%eax
  80b25c:	0f 84 c5 00 00 00    	je     80b327 <ip_input+0x2ae>
      return ERR_OK;
    }
    iphdr = (struct ip_hdr *) p->payload;
  80b262:	8b 58 04             	mov    0x4(%eax),%ebx
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  80b265:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b268:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b26c:	89 34 24             	mov    %esi,(%esp)
  80b26f:	e8 5c 85 00 00       	call   8137d0 <raw_input>
  80b274:	84 c0                	test   %al,%al
  80b276:	0f 85 ab 00 00 00    	jne    80b327 <ip_input+0x2ae>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  80b27c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80b280:	89 04 24             	mov    %eax,(%esp)
  80b283:	e8 3e 11 00 00       	call   80c3c6 <ntohs>
  80b288:	0f b6 c0             	movzbl %al,%eax
  80b28b:	83 f8 06             	cmp    $0x6,%eax
  80b28e:	74 1d                	je     80b2ad <ip_input+0x234>
  80b290:	83 f8 11             	cmp    $0x11,%eax
  80b293:	74 07                	je     80b29c <ip_input+0x223>
  80b295:	83 f8 01             	cmp    $0x1,%eax
  80b298:	75 35                	jne    80b2cf <ip_input+0x256>
  80b29a:	eb 22                	jmp    80b2be <ip_input+0x245>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  80b29c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b29f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2a3:	89 34 24             	mov    %esi,(%esp)
  80b2a6:	e8 b5 24 00 00       	call   80d760 <udp_input>
      break;
  80b2ab:	eb 7a                	jmp    80b327 <ip_input+0x2ae>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  80b2ad:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2b0:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2b4:	89 34 24             	mov    %esi,(%esp)
  80b2b7:	e8 53 77 00 00       	call   812a0f <tcp_input>
      break;
  80b2bc:	eb 69                	jmp    80b327 <ip_input+0x2ae>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  80b2be:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2c1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2c5:	89 34 24             	mov    %esi,(%esp)
  80b2c8:	e8 d3 87 00 00       	call   813aa0 <icmp_input>
      break;
  80b2cd:	eb 58                	jmp    80b327 <ip_input+0x2ae>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80b2cf:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b2d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b2d6:	8d 43 10             	lea    0x10(%ebx),%eax
  80b2d9:	89 04 24             	mov    %eax,(%esp)
  80b2dc:	e8 ff fc ff ff       	call   80afe0 <ip_addr_isbroadcast>
  80b2e1:	84 c0                	test   %al,%al
  80b2e3:	75 3a                	jne    80b31f <ip_input+0x2a6>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  80b2e5:	8b 43 10             	mov    0x10(%ebx),%eax
  80b2e8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b2eb:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80b2f2:	e8 42 13 00 00       	call   80c639 <ntohl>
  80b2f7:	89 c7                	mov    %eax,%edi
  80b2f9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80b300:	e8 34 13 00 00       	call   80c639 <ntohl>
  80b305:	23 7d e4             	and    -0x1c(%ebp),%edi
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  80b308:	39 c7                	cmp    %eax,%edi
  80b30a:	74 13                	je     80b31f <ip_input+0x2a6>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  80b30c:	89 5e 04             	mov    %ebx,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  80b30f:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80b316:	00 
  80b317:	89 34 24             	mov    %esi,(%esp)
  80b31a:	e8 dc 8a 00 00       	call   813dfb <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  80b31f:	89 34 24             	mov    %esi,(%esp)
  80b322:	e8 dc de ff ff       	call   809203 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  80b327:	b8 00 00 00 00       	mov    $0x0,%eax
  80b32c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80b32f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80b332:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80b335:	89 ec                	mov    %ebp,%esp
  80b337:	5d                   	pop    %ebp
  80b338:	c3                   	ret    

0080b339 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  80b339:	55                   	push   %ebp
  80b33a:	89 e5                	mov    %esp,%ebp
  80b33c:	83 ec 48             	sub    $0x48,%esp
  80b33f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80b342:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80b345:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80b348:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80b34b:	8b 7d 10             	mov    0x10(%ebp),%edi
  80b34e:	8b 75 20             	mov    0x20(%ebp),%esi
  80b351:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80b355:	88 45 d8             	mov    %al,-0x28(%ebp)
  80b358:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  80b35c:	88 55 d7             	mov    %dl,-0x29(%ebp)
  80b35f:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  80b363:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  80b366:	85 ff                	test   %edi,%edi
  80b368:	0f 84 32 01 00 00    	je     80b4a0 <ip_output_if+0x167>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  80b36e:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b375:	00 
  80b376:	89 1c 24             	mov    %ebx,(%esp)
  80b379:	e8 92 dd ff ff       	call   809110 <pbuf_header>
  80b37e:	84 c0                	test   %al,%al
  80b380:	0f 85 51 01 00 00    	jne    80b4d7 <ip_output_if+0x19e>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = (struct ip_hdr *) p->payload;
  80b386:	8b 53 04             	mov    0x4(%ebx),%edx
  80b389:	89 55 d0             	mov    %edx,-0x30(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  80b38c:	66 83 7b 0a 13       	cmpw   $0x13,0xa(%ebx)
  80b391:	77 1c                	ja     80b3af <ip_output_if+0x76>
  80b393:	c7 44 24 08 8c 5f 81 	movl   $0x815f8c,0x8(%esp)
  80b39a:	00 
  80b39b:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  80b3a2:	00 
  80b3a3:	c7 04 24 b9 5f 81 00 	movl   $0x815fb9,(%esp)
  80b3aa:	e8 09 56 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  80b3af:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b3b2:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80b3b6:	89 04 24             	mov    %eax,(%esp)
  80b3b9:	e8 08 10 00 00       	call   80c3c6 <ntohs>
  80b3be:	0f b6 d0             	movzbl %al,%edx
  80b3c1:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
  80b3c5:	c1 e0 08             	shl    $0x8,%eax
  80b3c8:	09 d0                	or     %edx,%eax
  80b3ca:	0f b7 c0             	movzwl %ax,%eax
  80b3cd:	89 04 24             	mov    %eax,(%esp)
  80b3d0:	e8 e4 0f 00 00       	call   80c3b9 <htons>
  80b3d5:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b3d8:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  80b3dc:	0f b7 c0             	movzwl %ax,%eax
  80b3df:	89 04 24             	mov    %eax,(%esp)
  80b3e2:	e8 df 0f 00 00       	call   80c3c6 <ntohs>
  80b3e7:	89 c2                	mov    %eax,%edx
  80b3e9:	b2 00                	mov    $0x0,%dl
  80b3eb:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  80b3ef:	09 d0                	or     %edx,%eax
  80b3f1:	0f b7 c0             	movzwl %ax,%eax
  80b3f4:	89 04 24             	mov    %eax,(%esp)
  80b3f7:	e8 bd 0f 00 00       	call   80c3b9 <htons>
  80b3fc:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b3ff:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  80b403:	8b 07                	mov    (%edi),%eax
  80b405:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  80b408:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  80b40c:	80 cc 45             	or     $0x45,%ah
  80b40f:	89 04 24             	mov    %eax,(%esp)
  80b412:	e8 a2 0f 00 00       	call   80c3b9 <htons>
  80b417:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b41a:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  80b41d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80b421:	89 04 24             	mov    %eax,(%esp)
  80b424:	e8 90 0f 00 00       	call   80c3b9 <htons>
  80b429:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b42c:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  80b430:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  80b436:	0f b7 05 ec a3 b3 00 	movzwl 0xb3a3ec,%eax
  80b43d:	89 04 24             	mov    %eax,(%esp)
  80b440:	e8 74 0f 00 00       	call   80c3b9 <htons>
  80b445:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b448:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  80b44c:	66 83 05 ec a3 b3 00 	addw   $0x1,0xb3a3ec
  80b453:	01 

    if (ip_addr_isany(src)) {
  80b454:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80b458:	74 09                	je     80b463 <ip_output_if+0x12a>
  80b45a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b45d:	8b 02                	mov    (%edx),%eax
  80b45f:	85 c0                	test   %eax,%eax
  80b461:	75 15                	jne    80b478 <ip_output_if+0x13f>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  80b463:	b8 00 00 00 00       	mov    $0x0,%eax
  80b468:	83 fe fc             	cmp    $0xfffffffc,%esi
  80b46b:	74 03                	je     80b470 <ip_output_if+0x137>
  80b46d:	8b 46 04             	mov    0x4(%esi),%eax
  80b470:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b473:	89 42 0c             	mov    %eax,0xc(%edx)
  80b476:	eb 06                	jmp    80b47e <ip_output_if+0x145>
    } else {
      ip_addr_set(&(iphdr->src), src);
  80b478:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b47b:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  80b47e:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80b481:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80b487:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b48e:	00 
  80b48f:	89 04 24             	mov    %eax,(%esp)
  80b492:	e8 d8 0d 00 00       	call   80c26f <inet_chksum>
  80b497:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80b49a:	66 89 42 0a          	mov    %ax,0xa(%edx)
  80b49e:	eb 06                	jmp    80b4a6 <ip_output_if+0x16d>
#endif
  } else {
    /* IP header already included in p */
    iphdr = (struct ip_hdr *) p->payload;
    dest = &(iphdr->dest);
  80b4a0:	8b 7b 04             	mov    0x4(%ebx),%edi
  80b4a3:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  80b4a6:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
  80b4aa:	66 85 c0             	test   %ax,%ax
  80b4ad:	74 18                	je     80b4c7 <ip_output_if+0x18e>
  80b4af:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  80b4b3:	73 12                	jae    80b4c7 <ip_output_if+0x18e>
    return ip_frag(p,netif,dest);
  80b4b5:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b4b9:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b4bd:	89 1c 24             	mov    %ebx,(%esp)
  80b4c0:	e8 ce 08 00 00       	call   80bd93 <ip_frag>
  80b4c5:	eb 15                	jmp    80b4dc <ip_output_if+0x1a3>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  80b4c7:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b4cb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b4cf:	89 34 24             	mov    %esi,(%esp)
  80b4d2:	ff 56 14             	call   *0x14(%esi)
  80b4d5:	eb 05                	jmp    80b4dc <ip_output_if+0x1a3>
    if (pbuf_header(p, IP_HLEN)) {
      LWIP_DEBUGF(IP_DEBUG | 2, ("ip_output: not enough room for IP header in pbuf\n"));

      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
  80b4d7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  }
}
  80b4dc:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80b4df:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80b4e2:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80b4e5:	89 ec                	mov    %ebp,%esp
  80b4e7:	5d                   	pop    %ebp
  80b4e8:	c3                   	ret    

0080b4e9 <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  80b4e9:	55                   	push   %ebp
  80b4ea:	89 e5                	mov    %esp,%ebp
  80b4ec:	83 ec 48             	sub    $0x48,%esp
  80b4ef:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80b4f2:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80b4f5:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80b4f8:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80b4fb:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80b4ff:	88 45 e7             	mov    %al,-0x19(%ebp)
  80b502:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  80b506:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  80b50a:	89 1c 24             	mov    %ebx,(%esp)
  80b50d:	e8 0e fb ff ff       	call   80b020 <ip_route>
  80b512:	89 c2                	mov    %eax,%edx
    return ERR_RTE;
  80b514:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  80b519:	85 d2                	test   %edx,%edx
  80b51b:	74 36                	je     80b553 <ip_output+0x6a>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  80b51d:	89 54 24 18          	mov    %edx,0x18(%esp)
  80b521:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80b527:	89 74 24 14          	mov    %esi,0x14(%esp)
  80b52b:	81 e7 ff 00 00 00    	and    $0xff,%edi
  80b531:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80b535:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80b539:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b53d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80b541:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b544:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b548:	8b 45 08             	mov    0x8(%ebp),%eax
  80b54b:	89 04 24             	mov    %eax,(%esp)
  80b54e:	e8 e6 fd ff ff       	call   80b339 <ip_output_if>
}
  80b553:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80b556:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80b559:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80b55c:	89 ec                	mov    %ebp,%esp
  80b55e:	5d                   	pop    %ebp
  80b55f:	c3                   	ret    

0080b560 <_ZL25ip_reass_dequeue_datagramP12ip_reassdataS0_>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80b560:	55                   	push   %ebp
  80b561:	89 e5                	mov    %esp,%ebp
  80b563:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  80b566:	8b 0d e0 a9 b3 00    	mov    0xb3a9e0,%ecx
  80b56c:	39 c1                	cmp    %eax,%ecx
  80b56e:	75 0a                	jne    80b57a <_ZL25ip_reass_dequeue_datagramP12ip_reassdataS0_+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  80b570:	8b 11                	mov    (%ecx),%edx
  80b572:	89 15 e0 a9 b3 00    	mov    %edx,0xb3a9e0
  80b578:	eb 24                	jmp    80b59e <_ZL25ip_reass_dequeue_datagramP12ip_reassdataS0_+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  80b57a:	85 d2                	test   %edx,%edx
  80b57c:	75 1c                	jne    80b59a <_ZL25ip_reass_dequeue_datagramP12ip_reassdataS0_+0x3a>
  80b57e:	c7 44 24 08 d1 5f 81 	movl   $0x815fd1,0x8(%esp)
  80b585:	00 
  80b586:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  80b58d:	00 
  80b58e:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80b595:	e8 1e 54 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    prev->next = ipr->next;
  80b59a:	8b 08                	mov    (%eax),%ecx
  80b59c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80b59e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b5a2:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80b5a9:	e8 93 d8 ff ff       	call   808e41 <memp_free>
}
  80b5ae:	c9                   	leave  
  80b5af:	c3                   	ret    

0080b5b0 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80b5b0:	55                   	push   %ebp
  80b5b1:	89 e5                	mov    %esp,%ebp
  80b5b3:	57                   	push   %edi
  80b5b4:	56                   	push   %esi
  80b5b5:	53                   	push   %ebx
  80b5b6:	83 ec 2c             	sub    $0x2c,%esp
  80b5b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b5bc:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  80b5bf:	39 c2                	cmp    %eax,%edx
  80b5c1:	75 1c                	jne    80b5df <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0x2f>
  80b5c3:	c7 44 24 08 07 60 81 	movl   $0x816007,0x8(%esp)
  80b5ca:	00 
  80b5cb:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80b5d2:	00 
  80b5d3:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80b5da:	e8 d9 53 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (prev != NULL) {
  80b5df:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80b5e3:	74 26                	je     80b60b <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  80b5e5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b5e8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b5eb:	39 10                	cmp    %edx,(%eax)
  80b5ed:	74 1c                	je     80b60b <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0x5b>
  80b5ef:	c7 44 24 08 13 60 81 	movl   $0x816013,0x8(%esp)
  80b5f6:	00 
  80b5f7:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  80b5fe:	00 
  80b5ff:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80b606:	e8 ad 53 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  80b60b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b60e:	8b 58 04             	mov    0x4(%eax),%ebx
  80b611:	8b 43 04             	mov    0x4(%ebx),%eax
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  int pbufs_freed = 0;
  80b614:	bf 00 00 00 00       	mov    $0x0,%edi
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  if (iprh->start == 0) {
  80b619:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80b61e:	75 47                	jne    80b667 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  80b620:	8b 00                	mov    (%eax),%eax
  80b622:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b625:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  80b628:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80b62f:	00 
  80b630:	89 d0                	mov    %edx,%eax
  80b632:	83 c0 08             	add    $0x8,%eax
  80b635:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b639:	8b 43 04             	mov    0x4(%ebx),%eax
  80b63c:	89 04 24             	mov    %eax,(%esp)
  80b63f:	e8 c3 5c ff ff       	call   801307 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  80b644:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80b64b:	00 
  80b64c:	89 1c 24             	mov    %ebx,(%esp)
  80b64f:	e8 b9 88 00 00       	call   813f0d <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  80b654:	89 1c 24             	mov    %ebx,(%esp)
  80b657:	e8 75 e0 ff ff       	call   8096d1 <pbuf_clen>
  80b65c:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  80b65f:	89 1c 24             	mov    %ebx,(%esp)
  80b662:	e8 9c db ff ff       	call   809203 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  80b667:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b66a:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  80b66d:	85 db                	test   %ebx,%ebx
  80b66f:	75 04                	jne    80b675 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0xc5>
  80b671:	eb 20                	jmp    80b693 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0xe3>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80b673:	89 f3                	mov    %esi,%ebx
  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  80b675:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80b678:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  80b67a:	89 1c 24             	mov    %ebx,(%esp)
  80b67d:	e8 4f e0 ff ff       	call   8096d1 <pbuf_clen>
  80b682:	0f b6 c0             	movzbl %al,%eax
  80b685:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  80b687:	89 1c 24             	mov    %ebx,(%esp)
  80b68a:	e8 74 db ff ff       	call   809203 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  80b68f:	85 f6                	test   %esi,%esi
  80b691:	75 e0                	jne    80b673 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0xc3>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  80b693:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b696:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b699:	e8 c2 fe ff ff       	call   80b560 <_ZL25ip_reass_dequeue_datagramP12ip_reassdataS0_>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  80b69e:	0f b7 05 dc a9 b3 00 	movzwl 0xb3a9dc,%eax
  80b6a5:	0f b7 d0             	movzwl %ax,%edx
  80b6a8:	39 fa                	cmp    %edi,%edx
  80b6aa:	7d 1c                	jge    80b6c8 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_+0x118>
  80b6ac:	c7 44 24 08 25 60 81 	movl   $0x816025,0x8(%esp)
  80b6b3:	00 
  80b6b4:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  80b6bb:	00 
  80b6bc:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80b6c3:	e8 f0 52 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  ip_reass_pbufcount -= pbufs_freed;
  80b6c8:	66 29 f8             	sub    %di,%ax
  80b6cb:	66 a3 dc a9 b3 00    	mov    %ax,0xb3a9dc

  return pbufs_freed;
}
  80b6d1:	89 f8                	mov    %edi,%eax
  80b6d3:	83 c4 2c             	add    $0x2c,%esp
  80b6d6:	5b                   	pop    %ebx
  80b6d7:	5e                   	pop    %esi
  80b6d8:	5f                   	pop    %edi
  80b6d9:	5d                   	pop    %ebp
  80b6da:	c3                   	ret    

0080b6db <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  80b6db:	55                   	push   %ebp
  80b6dc:	89 e5                	mov    %esp,%ebp
  80b6de:	57                   	push   %edi
  80b6df:	56                   	push   %esi
  80b6e0:	53                   	push   %ebx
  80b6e1:	83 ec 2c             	sub    $0x2c,%esp
  80b6e4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b6e7:	89 55 dc             	mov    %edx,-0x24(%ebp)
  /* @todo Can't we simply remove the last datagram in the
   *       linked list behind reassdatagrams?
   */
  struct ip_reassdata *r, *oldest, *prev;
  int pbufs_freed = 0, pbufs_freed_current;
  80b6ea:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  80b6f1:	8b 0d e0 a9 b3 00    	mov    0xb3a9e0,%ecx
    while (r != NULL) {
  80b6f7:	85 c9                	test   %ecx,%ecx
  80b6f9:	74 75                	je     80b770 <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x95>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  80b6fb:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b6fe:	8b 78 0c             	mov    0xc(%eax),%edi
  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
  80b701:	bb 00 00 00 00       	mov    $0x0,%ebx

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
  80b706:	ba 00 00 00 00       	mov    $0x0,%edx
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
  80b70b:	b8 00 00 00 00       	mov    $0x0,%eax
  80b710:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80b713:	eb 05                	jmp    80b71a <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x3f>
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  80b715:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
        prev = r;
      }
      r = r->next;
  80b718:	89 f1                	mov    %esi,%ecx
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  80b71a:	39 79 14             	cmp    %edi,0x14(%ecx)
  80b71d:	75 18                	jne    80b737 <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x5c>
  80b71f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b722:	8b 52 10             	mov    0x10(%edx),%edx
  80b725:	39 51 18             	cmp    %edx,0x18(%ecx)
  80b728:	75 0d                	jne    80b737 <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x5c>
  80b72a:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80b72d:	0f b7 76 04          	movzwl 0x4(%esi),%esi
  80b731:	66 39 71 0c          	cmp    %si,0xc(%ecx)
  80b735:	74 17                	je     80b74e <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x73>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  80b737:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  80b73a:	85 c0                	test   %eax,%eax
  80b73c:	74 0e                	je     80b74c <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x71>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  80b73e:	0f b6 71 1f          	movzbl 0x1f(%ecx),%esi
  80b742:	89 f2                	mov    %esi,%edx
  80b744:	3a 50 1f             	cmp    0x1f(%eax),%dl
  80b747:	0f 46 c1             	cmovbe %ecx,%eax
  80b74a:	eb 02                	jmp    80b74e <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x73>
    r = reassdatagrams;
    while (r != NULL) {
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
        /* Not the same datagram as fraghdr */
        other_datagrams++;
        if (oldest == NULL) {
  80b74c:	89 c8                	mov    %ecx,%eax
        } else if (r->timer <= oldest->timer) {
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  80b74e:	8b 31                	mov    (%ecx),%esi
  80b750:	85 f6                	test   %esi,%esi
  80b752:	75 c1                	jne    80b715 <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x3a>
  80b754:	8b 55 d4             	mov    -0x2c(%ebp),%edx
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  80b757:	85 c0                	test   %eax,%eax
  80b759:	74 08                	je     80b763 <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x88>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  80b75b:	e8 50 fe ff ff       	call   80b5b0 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_>
      pbufs_freed += pbufs_freed_current;
  80b760:	01 45 e0             	add    %eax,-0x20(%ebp)
  int pbufs_freed = 0, pbufs_freed_current;
  int other_datagrams;

  /* Free datagrams until being allowed to enqueue 'pbufs_needed' pbufs,
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
  80b763:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80b766:	39 75 e0             	cmp    %esi,-0x20(%ebp)
  80b769:	7d 05                	jge    80b770 <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x95>
  80b76b:	83 fb 01             	cmp    $0x1,%ebx
  80b76e:	7f 81                	jg     80b6f1 <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri+0x16>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
      pbufs_freed += pbufs_freed_current;
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  return pbufs_freed;
}
  80b770:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b773:	83 c4 2c             	add    $0x2c,%esp
  80b776:	5b                   	pop    %ebx
  80b777:	5e                   	pop    %esi
  80b778:	5f                   	pop    %edi
  80b779:	5d                   	pop    %ebp
  80b77a:	c3                   	ret    

0080b77b <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  80b77b:	55                   	push   %ebp
  80b77c:	89 e5                	mov    %esp,%ebp
  80b77e:	56                   	push   %esi
  80b77f:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80b780:	a1 e0 a9 b3 00       	mov    0xb3a9e0,%eax
  while (r != NULL) {
  80b785:	85 c0                	test   %eax,%eax
  80b787:	74 28                	je     80b7b1 <ip_reass_tmr+0x36>
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;
  80b789:	bb 00 00 00 00       	mov    $0x0,%ebx

  r = reassdatagrams;
  while (r != NULL) {
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  80b78e:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  80b792:	84 d2                	test   %dl,%dl
  80b794:	74 0c                	je     80b7a2 <ip_reass_tmr+0x27>
      r->timer--;
  80b796:	83 ea 01             	sub    $0x1,%edx
  80b799:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  80b79c:	89 c3                	mov    %eax,%ebx
  80b79e:	8b 00                	mov    (%eax),%eax
  80b7a0:	eb 0b                	jmp    80b7ad <ip_reass_tmr+0x32>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80b7a2:	8b 30                	mov    (%eax),%esi
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80b7a4:	89 da                	mov    %ebx,%edx
  80b7a6:	e8 05 fe ff ff       	call   80b5b0 <_ZL31ip_reass_free_complete_datagramP12ip_reassdataS0_>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80b7ab:	89 f0                	mov    %esi,%eax
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  80b7ad:	85 c0                	test   %eax,%eax
  80b7af:	75 dd                	jne    80b78e <ip_reass_tmr+0x13>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  80b7b1:	5b                   	pop    %ebx
  80b7b2:	5e                   	pop    %esi
  80b7b3:	5d                   	pop    %ebp
  80b7b4:	c3                   	ret    

0080b7b5 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80b7b5:	55                   	push   %ebp
  80b7b6:	89 e5                	mov    %esp,%ebp
  80b7b8:	57                   	push   %edi
  80b7b9:	56                   	push   %esi
  80b7ba:	53                   	push   %ebx
  80b7bb:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  80b7be:	8b 45 08             	mov    0x8(%ebp),%eax
  80b7c1:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80b7c4:	0f b7 03             	movzwl (%ebx),%eax
  80b7c7:	89 04 24             	mov    %eax,(%esp)
  80b7ca:	e8 f7 0b 00 00       	call   80c3c6 <ntohs>
  80b7cf:	c1 e8 06             	shr    $0x6,%eax
  80b7d2:	83 e0 3c             	and    $0x3c,%eax
  80b7d5:	83 f8 14             	cmp    $0x14,%eax
  80b7d8:	0f 85 c8 04 00 00    	jne    80bca6 <ip_reass+0x4f1>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80b7de:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80b7e2:	89 04 24             	mov    %eax,(%esp)
  80b7e5:	e8 dc 0b 00 00       	call   80c3c6 <ntohs>
  80b7ea:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80b7ee:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80b7f2:	89 04 24             	mov    %eax,(%esp)
  80b7f5:	e8 cc 0b 00 00       	call   80c3c6 <ntohs>
  80b7fa:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80b7fe:	0f b7 03             	movzwl (%ebx),%eax
  80b801:	89 04 24             	mov    %eax,(%esp)
  80b804:	e8 bd 0b 00 00       	call   80c3c6 <ntohs>
  80b809:	66 89 45 b8          	mov    %ax,-0x48(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  80b80d:	8b 55 08             	mov    0x8(%ebp),%edx
  80b810:	89 14 24             	mov    %edx,(%esp)
  80b813:	e8 b9 de ff ff       	call   8096d1 <pbuf_clen>
  80b818:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  80b81a:	0f b6 c8             	movzbl %al,%ecx
  80b81d:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80b820:	0f b7 05 dc a9 b3 00 	movzwl 0xb3a9dc,%eax
  80b827:	01 c8                	add    %ecx,%eax
  80b829:	83 f8 0a             	cmp    $0xa,%eax
  80b82c:	7e 24                	jle    80b852 <ip_reass+0x9d>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  80b82e:	89 ca                	mov    %ecx,%edx
  80b830:	89 d8                	mov    %ebx,%eax
  80b832:	e8 a4 fe ff ff       	call   80b6db <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri>
  80b837:	85 c0                	test   %eax,%eax
  80b839:	0f 84 67 04 00 00    	je     80bca6 <ip_reass+0x4f1>
  80b83f:	0f b7 05 dc a9 b3 00 	movzwl 0xb3a9dc,%eax
  80b846:	03 45 e0             	add    -0x20(%ebp),%eax
  80b849:	83 f8 0a             	cmp    $0xa,%eax
  80b84c:	0f 8f 54 04 00 00    	jg     80bca6 <ip_reass+0x4f1>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80b852:	8b 35 e0 a9 b3 00    	mov    0xb3a9e0,%esi
  80b858:	85 f6                	test   %esi,%esi
  80b85a:	0f 84 90 04 00 00    	je     80bcf0 <ip_reass+0x53b>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  80b860:	8b 53 0c             	mov    0xc(%ebx),%edx
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  80b863:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80b86a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80b86f:	eb 04                	jmp    80b875 <ip_reass+0xc0>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80b871:	89 f1                	mov    %esi,%ecx
  80b873:	89 c6                	mov    %eax,%esi
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  80b875:	39 56 14             	cmp    %edx,0x14(%esi)
  80b878:	75 12                	jne    80b88c <ip_reass+0xd7>
  80b87a:	8b 43 10             	mov    0x10(%ebx),%eax
  80b87d:	39 46 18             	cmp    %eax,0x18(%esi)
  80b880:	75 0a                	jne    80b88c <ip_reass+0xd7>
  80b882:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80b886:	66 39 46 0c          	cmp    %ax,0xc(%esi)
  80b88a:	74 0b                	je     80b897 <ip_reass+0xe2>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80b88c:	8b 06                	mov    (%esi),%eax
  80b88e:	85 c0                	test   %eax,%eax
  80b890:	75 df                	jne    80b871 <ip_reass+0xbc>
  80b892:	89 75 d8             	mov    %esi,-0x28(%ebp)
  80b895:	eb 0a                	jmp    80b8a1 <ip_reass+0xec>
  80b897:	89 4d d8             	mov    %ecx,-0x28(%ebp)
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  80b89a:	89 75 b4             	mov    %esi,-0x4c(%ebp)
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  80b89d:	85 f6                	test   %esi,%esi
  80b89f:	75 7d                	jne    80b91e <ip_reass+0x169>
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = (struct ip_reassdata*) memp_malloc(MEMP_REASSDATA);
  80b8a1:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80b8a8:	e8 34 d5 ff ff       	call   808de1 <memp_malloc>
  80b8ad:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  80b8af:	85 c0                	test   %eax,%eax
  80b8b1:	75 29                	jne    80b8dc <ip_reass+0x127>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  80b8b3:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b8b6:	89 d8                	mov    %ebx,%eax
  80b8b8:	e8 1e fe ff ff       	call   80b6db <_ZL31ip_reass_remove_oldest_datagramP6ip_hdri>
  80b8bd:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80b8c0:	0f 8f e0 03 00 00    	jg     80bca6 <ip_reass+0x4f1>
      ipr = (struct ip_reassdata*) memp_malloc(MEMP_REASSDATA);
  80b8c6:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80b8cd:	e8 0f d5 ff ff       	call   808de1 <memp_malloc>
  80b8d2:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  80b8d4:	85 c0                	test   %eax,%eax
  80b8d6:	0f 84 ca 03 00 00    	je     80bca6 <ip_reass+0x4f1>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  80b8dc:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80b8e3:	00 
  80b8e4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80b8eb:	00 
  80b8ec:	89 34 24             	mov    %esi,(%esp)
  80b8ef:	e8 3d 59 ff ff       	call   801231 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80b8f4:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  80b8f8:	a1 e0 a9 b3 00       	mov    0xb3a9e0,%eax
  80b8fd:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  80b8ff:	89 35 e0 a9 b3 00    	mov    %esi,0xb3a9e0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80b905:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80b90c:	00 
  80b90d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b911:	8d 46 08             	lea    0x8(%esi),%eax
  80b914:	89 04 24             	mov    %eax,(%esp)
  80b917:	e8 eb 59 ff ff       	call   801307 <memcpy>
  80b91c:	eb 41                	jmp    80b95f <ip_reass+0x1aa>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80b91e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80b922:	89 04 24             	mov    %eax,(%esp)
  80b925:	e8 9c 0a 00 00       	call   80c3c6 <ntohs>
  80b92a:	66 a9 ff 1f          	test   $0x1fff,%ax
  80b92e:	75 2f                	jne    80b95f <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  80b930:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  80b933:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  80b937:	89 04 24             	mov    %eax,(%esp)
  80b93a:	e8 87 0a 00 00       	call   80c3c6 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80b93f:	66 a9 ff 1f          	test   $0x1fff,%ax
  80b943:	74 1a                	je     80b95f <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  80b945:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80b94c:	00 
  80b94d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80b951:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  80b954:	83 c0 08             	add    $0x8,%eax
  80b957:	89 04 24             	mov    %eax,(%esp)
  80b95a:	e8 a8 59 ff ff       	call   801307 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  80b95f:	66 81 e7 ff 00       	and    $0xff,%di
  80b964:	66 01 3d dc a9 b3 00 	add    %di,0xb3a9dc

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  80b96b:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80b96f:	89 04 24             	mov    %eax,(%esp)
  80b972:	e8 4f 0a 00 00       	call   80c3c6 <ntohs>
  80b977:	f6 c4 20             	test   $0x20,%ah
  80b97a:	75 22                	jne    80b99e <ip_reass+0x1e9>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  80b97c:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80b980:	0f b7 4d de          	movzwl -0x22(%ebp),%ecx
  80b984:	0f b7 5d d4          	movzwl -0x2c(%ebp),%ebx
  80b988:	8d 14 cb             	lea    (%ebx,%ecx,8),%edx
  80b98b:	0f b7 4d b8          	movzwl -0x48(%ebp),%ecx
  80b98f:	0f b6 c5             	movzbl %ch,%eax
  80b992:	83 e0 0f             	and    $0xf,%eax
  80b995:	f7 d8                	neg    %eax
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
    ipr->datagram_len = offset + len;
  80b997:	8d 04 82             	lea    (%edx,%eax,4),%eax
  80b99a:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  80b99e:	8b 7d 08             	mov    0x8(%ebp),%edi
  80b9a1:	8b 5f 04             	mov    0x4(%edi),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80b9a4:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80b9a8:	89 04 24             	mov    %eax,(%esp)
  80b9ab:	e8 16 0a 00 00       	call   80c3c6 <ntohs>
  80b9b0:	66 89 45 de          	mov    %ax,-0x22(%ebp)
  80b9b4:	0f b7 03             	movzwl (%ebx),%eax
  80b9b7:	89 04 24             	mov    %eax,(%esp)
  80b9ba:	e8 07 0a 00 00       	call   80c3c6 <ntohs>
  80b9bf:	89 c7                	mov    %eax,%edi
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80b9c1:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80b9c5:	89 04 24             	mov    %eax,(%esp)
  80b9c8:	e8 f9 09 00 00       	call   80c3c6 <ntohs>
  80b9cd:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80b9d0:	8b 55 08             	mov    0x8(%ebp),%edx
  80b9d3:	8b 52 04             	mov    0x4(%edx),%edx
  80b9d6:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  80b9d9:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80b9df:	66 89 42 04          	mov    %ax,0x4(%edx)
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80b9e3:	0f b7 4d de          	movzwl -0x22(%ebp),%ecx
  80b9e7:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  80b9ea:	89 fb                	mov    %edi,%ebx
  80b9ec:	0f b6 ff             	movzbl %bh,%edi
  80b9ef:	83 e7 0f             	and    $0xf,%edi
  80b9f2:	f7 df                	neg    %edi
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  iprh->next_pbuf = NULL;
  iprh->start = offset;
  iprh->end = offset + len;
  80b9f4:	8d 3c ba             	lea    (%edx,%edi,4),%edi
  80b9f7:	66 89 7d de          	mov    %di,-0x22(%ebp)
  80b9fb:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b9fe:	66 89 7a 06          	mov    %di,0x6(%edx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80ba02:	8b 7e 04             	mov    0x4(%esi),%edi
  80ba05:	85 ff                	test   %edi,%edi
  80ba07:	0f 84 fe 02 00 00    	je     80bd0b <ip_reass+0x556>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80ba0d:	8b 57 04             	mov    0x4(%edi),%edx
    if (iprh->start < iprh_tmp->start) {
  80ba10:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  80ba14:	66 39 c8             	cmp    %cx,%ax
  80ba17:	0f 82 df 02 00 00    	jb     80bcfc <ip_reass+0x547>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80ba1d:	66 39 c8             	cmp    %cx,%ax
  80ba20:	0f 84 f1 01 00 00    	je     80bc17 <ip_reass+0x462>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80ba26:	66 3b 42 06          	cmp    0x6(%edx),%ax
  80ba2a:	0f 82 e7 01 00 00    	jb     80bc17 <ip_reass+0x462>
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  80ba30:	bb 01 00 00 00       	mov    $0x1,%ebx
  80ba35:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  80ba38:	89 de                	mov    %ebx,%esi
  80ba3a:	eb 77                	jmp    80bab3 <ip_reass+0x2fe>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80ba3c:	8b 4f 04             	mov    0x4(%edi),%ecx
    if (iprh->start < iprh_tmp->start) {
  80ba3f:	0f b7 59 04          	movzwl 0x4(%ecx),%ebx
  80ba43:	66 39 d8             	cmp    %bx,%ax
  80ba46:	73 46                	jae    80ba8e <ip_reass+0x2d9>
  80ba48:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80ba4b:	89 f3                	mov    %esi,%ebx
  80ba4d:	8b 75 d4             	mov    -0x2c(%ebp),%esi
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80ba50:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80ba53:	89 39                	mov    %edi,(%ecx)
      if (iprh_prev != NULL) {
  80ba55:	85 d2                	test   %edx,%edx
  80ba57:	74 25                	je     80ba7e <ip_reass+0x2c9>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80ba59:	66 3b 42 06          	cmp    0x6(%edx),%ax
  80ba5d:	0f 82 b4 01 00 00    	jb     80bc17 <ip_reass+0x462>
  80ba63:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80ba67:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80ba6a:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80ba6e:	0f 87 a3 01 00 00    	ja     80bc17 <ip_reass+0x462>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80ba74:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80ba77:	89 0a                	mov    %ecx,(%edx)
  80ba79:	e9 b2 00 00 00       	jmp    80bb30 <ip_reass+0x37b>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80ba7e:	8b 45 08             	mov    0x8(%ebp),%eax
  80ba81:	89 46 04             	mov    %eax,0x4(%esi)
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  80ba84:	85 ff                	test   %edi,%edi
  80ba86:	0f 85 a4 00 00 00    	jne    80bb30 <ip_reass+0x37b>
  80ba8c:	eb 32                	jmp    80bac0 <ip_reass+0x30b>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80ba8e:	66 39 d8             	cmp    %bx,%ax
  80ba91:	0f 84 80 01 00 00    	je     80bc17 <ip_reass+0x462>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80ba97:	66 3b 41 06          	cmp    0x6(%ecx),%ax
  80ba9b:	0f 82 76 01 00 00    	jb     80bc17 <ip_reass+0x462>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80baa1:	85 d2                	test   %edx,%edx
  80baa3:	74 0c                	je     80bab1 <ip_reass+0x2fc>
        if (iprh_prev->end != iprh_tmp->start) {
          /* There is a fragment missing between the current
           * and the previous fragment */
          valid = 0;
  80baa5:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  80baa9:	ba 00 00 00 00       	mov    $0x0,%edx
  80baae:	0f 45 f2             	cmovne %edx,%esi
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80bab1:	89 ca                	mov    %ecx,%edx
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  80bab3:	8b 3a                	mov    (%edx),%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80bab5:	85 ff                	test   %edi,%edi
  80bab7:	75 83                	jne    80ba3c <ip_reass+0x287>
  80bab9:	89 f3                	mov    %esi,%ebx
  80babb:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  80babe:	eb 05                	jmp    80bac5 <ip_reass+0x310>
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  80bac0:	ba 00 00 00 00       	mov    $0x0,%edx
    if (iprh_prev != NULL) {
  80bac5:	85 d2                	test   %edx,%edx
  80bac7:	74 3f                	je     80bb08 <ip_reass+0x353>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80bac9:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80bacd:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80bad0:	66 3b 41 04          	cmp    0x4(%ecx),%ax
  80bad4:	76 1c                	jbe    80baf2 <ip_reass+0x33d>
  80bad6:	c7 44 24 08 40 60 81 	movl   $0x816040,0x8(%esp)
  80badd:	00 
  80bade:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  80bae5:	00 
  80bae6:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80baed:	e8 c6 4e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80baf2:	8b 7d 08             	mov    0x8(%ebp),%edi
  80baf5:	89 3a                	mov    %edi,(%edx)
      if (iprh_prev->end != iprh->start) {
        valid = 0;
  80baf7:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80bafa:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80bafe:	b8 00 00 00 00       	mov    $0x0,%eax
  80bb03:	0f 45 d8             	cmovne %eax,%ebx
  80bb06:	eb 28                	jmp    80bb30 <ip_reass+0x37b>
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80bb08:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  80bb0c:	74 1c                	je     80bb2a <ip_reass+0x375>
  80bb0e:	c7 44 24 08 6c 60 81 	movl   $0x81606c,0x8(%esp)
  80bb15:	00 
  80bb16:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80bb1d:	00 
  80bb1e:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80bb25:	e8 8e 4e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  80bb2a:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80bb2d:	89 4e 04             	mov    %ecx,0x4(%esi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80bb30:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  80bb34:	0f 84 80 01 00 00    	je     80bcba <ip_reass+0x505>
    /* and had no wholes so far */
    if (valid) {
  80bb3a:	85 db                	test   %ebx,%ebx
  80bb3c:	0f 84 81 01 00 00    	je     80bcc3 <ip_reass+0x50e>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80bb42:	8b 4e 04             	mov    0x4(%esi),%ecx
  80bb45:	8b 51 04             	mov    0x4(%ecx),%edx
  80bb48:	66 83 7a 04 00       	cmpw   $0x0,0x4(%edx)
  80bb4d:	0f 85 79 01 00 00    	jne    80bccc <ip_reass+0x517>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  80bb53:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80bb56:	8b 03                	mov    (%ebx),%eax
        while (q != NULL) {
  80bb58:	85 c0                	test   %eax,%eax
  80bb5a:	0f 84 ba 01 00 00    	je     80bd1a <ip_reass+0x565>
          iprh = (struct ip_reass_helper*)q->payload;
  80bb60:	8b 40 04             	mov    0x4(%eax),%eax
          if (iprh_prev->end != iprh->start) {
  80bb63:	0f b7 78 04          	movzwl 0x4(%eax),%edi
  80bb67:	66 39 7b 06          	cmp    %di,0x6(%ebx)
  80bb6b:	74 18                	je     80bb85 <ip_reass+0x3d0>
  80bb6d:	e9 63 01 00 00       	jmp    80bcd5 <ip_reass+0x520>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80bb72:	8b 5b 04             	mov    0x4(%ebx),%ebx
          if (iprh_prev->end != iprh->start) {
  80bb75:	0f b7 7b 04          	movzwl 0x4(%ebx),%edi
  80bb79:	66 39 78 06          	cmp    %di,0x6(%eax)
  80bb7d:	0f 85 5b 01 00 00    	jne    80bcde <ip_reass+0x529>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80bb83:	89 d8                	mov    %ebx,%eax
          if (iprh_prev->end != iprh->start) {
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80bb85:	8b 18                	mov    (%eax),%ebx
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80bb87:	85 db                	test   %ebx,%ebx
  80bb89:	75 e7                	jne    80bb72 <ip_reass+0x3bd>
  80bb8b:	e9 8d 01 00 00       	jmp    80bd1d <ip_reass+0x568>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80bb90:	c7 44 24 08 5e 60 81 	movl   $0x81605e,0x8(%esp)
  80bb97:	00 
  80bb98:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  80bb9f:	00 
  80bba0:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80bba7:	e8 0c 4e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
          LWIP_ASSERT("sanity check",
  80bbac:	39 c2                	cmp    %eax,%edx
  80bbae:	75 1c                	jne    80bbcc <ip_reass+0x417>
  80bbb0:	c7 44 24 08 5e 60 81 	movl   $0x81605e,0x8(%esp)
  80bbb7:	00 
  80bbb8:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  80bbbf:	00 
  80bbc0:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80bbc7:	e8 ec 4d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80bbcc:	83 38 00             	cmpl   $0x0,(%eax)
  80bbcf:	74 1c                	je     80bbed <ip_reass+0x438>
  80bbd1:	c7 44 24 08 a4 60 81 	movl   $0x8160a4,0x8(%esp)
  80bbd8:	00 
  80bbd9:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80bbe0:	00 
  80bbe1:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80bbe8:	e8 cb 4d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80bbed:	0f b7 40 06          	movzwl 0x6(%eax),%eax
  80bbf1:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  80bbf5:	0f 84 2f 01 00 00    	je     80bd2a <ip_reass+0x575>
  80bbfb:	c7 44 24 08 c8 60 81 	movl   $0x8160c8,0x8(%esp)
  80bc02:	00 
  80bc03:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80bc0a:	00 
  80bc0b:	c7 04 24 ea 5f 81 00 	movl   $0x815fea,(%esp)
  80bc12:	e8 a1 4d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80bc17:	0f b7 1d dc a9 b3 00 	movzwl 0xb3a9dc,%ebx
  80bc1e:	8b 45 08             	mov    0x8(%ebp),%eax
  80bc21:	89 04 24             	mov    %eax,(%esp)
  80bc24:	e8 a8 da ff ff       	call   8096d1 <pbuf_clen>
  80bc29:	0f b6 c0             	movzbl %al,%eax
  80bc2c:	66 29 c3             	sub    %ax,%bx
  80bc2f:	66 89 1d dc a9 b3 00 	mov    %bx,0xb3a9dc
  pbuf_free(new_p);
  80bc36:	8b 55 08             	mov    0x8(%ebp),%edx
  80bc39:	89 14 24             	mov    %edx,(%esp)
  80bc3c:	e8 c2 d5 ff ff       	call   809203 <pbuf_free>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  80bc41:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80bc48:	e9 98 00 00 00       	jmp    80bce5 <ip_reass+0x530>
  80bc4d:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80bc50:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80bc53:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80bc56:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80bc5d:	ff 
  80bc5e:	89 3c 24             	mov    %edi,(%esp)
  80bc61:	e8 aa d4 ff ff       	call   809110 <pbuf_header>
      pbuf_cat(p, r);
  80bc66:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bc6a:	89 34 24             	mov    %esi,(%esp)
  80bc6d:	e8 8a da ff ff       	call   8096fc <pbuf_cat>
      r = iprh->next_pbuf;
  80bc72:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80bc74:	85 ff                	test   %edi,%edi
  80bc76:	75 db                	jne    80bc53 <ip_reass+0x49e>
  80bc78:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80bc7b:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80bc7e:	89 f0                	mov    %esi,%eax
  80bc80:	e8 db f8 ff ff       	call   80b560 <_ZL25ip_reass_dequeue_datagramP12ip_reassdataS0_>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80bc85:	0f b7 1d dc a9 b3 00 	movzwl 0xb3a9dc,%ebx
  80bc8c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80bc8f:	89 0c 24             	mov    %ecx,(%esp)
  80bc92:	e8 3a da ff ff       	call   8096d1 <pbuf_clen>
  80bc97:	0f b6 c0             	movzbl %al,%eax
  80bc9a:	66 29 c3             	sub    %ax,%bx
  80bc9d:	66 89 1d dc a9 b3 00 	mov    %bx,0xb3a9dc

    /* Return the pbuf chain */
    return p;
  80bca4:	eb 3f                	jmp    80bce5 <ip_reass+0x530>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80bca6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80bca9:	89 1c 24             	mov    %ebx,(%esp)
  80bcac:	e8 52 d5 ff ff       	call   809203 <pbuf_free>
  return NULL;
  80bcb1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80bcb8:	eb 2b                	jmp    80bce5 <ip_reass+0x530>
    /* Return the pbuf chain */
    return p;
  }
  /* the datagram is not (yet?) reassembled completely */
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass_pbufcount: %d out\n", ip_reass_pbufcount));
  return NULL;
  80bcba:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80bcc1:	eb 22                	jmp    80bce5 <ip_reass+0x530>
  80bcc3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80bcca:	eb 19                	jmp    80bce5 <ip_reass+0x530>
  80bccc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80bcd3:	eb 10                	jmp    80bce5 <ip_reass+0x530>
  80bcd5:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80bcdc:	eb 07                	jmp    80bce5 <ip_reass+0x530>
  80bcde:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
}
  80bce5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80bce8:	83 c4 5c             	add    $0x5c,%esp
  80bceb:	5b                   	pop    %ebx
  80bcec:	5e                   	pop    %esi
  80bced:	5f                   	pop    %edi
  80bcee:	5d                   	pop    %ebp
  80bcef:	c3                   	ret    
  struct ip_hdr *fraghdr;
  struct ip_reassdata *ipr;
  struct ip_reass_helper *iprh;
  u16_t offset, len;
  u8_t clen;
  struct ip_reassdata *ipr_prev = NULL;
  80bcf0:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  80bcf7:	e9 a5 fb ff ff       	jmp    80b8a1 <ip_reass+0xec>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80bcfc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80bcff:	89 38                	mov    %edi,(%eax)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  struct pbuf *q;
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;
  80bd01:	bb 01 00 00 00       	mov    $0x1,%ebx
  80bd06:	e9 73 fd ff ff       	jmp    80ba7e <ip_reass+0x2c9>
  80bd0b:	bb 01 00 00 00       	mov    $0x1,%ebx
 * @return 0 if invalid, >0 otherwise
 */
static int
ip_reass_chain_frag_into_datagram_and_validate(struct ip_reassdata *ipr, struct pbuf *new_p)
{
  struct ip_reass_helper *iprh, *iprh_tmp, *iprh_prev=NULL;
  80bd10:	ba 00 00 00 00       	mov    $0x0,%edx
  80bd15:	e9 ab fd ff ff       	jmp    80bac5 <ip_reass+0x310>
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80bd1a:	8b 45 e0             	mov    -0x20(%ebp),%eax
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80bd1d:	85 c9                	test   %ecx,%ecx
  80bd1f:	0f 85 87 fe ff ff    	jne    80bbac <ip_reass+0x3f7>
  80bd25:	e9 66 fe ff ff       	jmp    80bb90 <ip_reass+0x3db>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80bd2a:	83 c0 14             	add    $0x14,%eax
  80bd2d:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80bd31:	8b 46 04             	mov    0x4(%esi),%eax
  80bd34:	8b 58 04             	mov    0x4(%eax),%ebx
  80bd37:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80bd39:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80bd40:	00 
  80bd41:	8d 46 08             	lea    0x8(%esi),%eax
  80bd44:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bd48:	89 1c 24             	mov    %ebx,(%esp)
  80bd4b:	e8 b7 55 ff ff       	call   801307 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80bd50:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80bd54:	89 04 24             	mov    %eax,(%esp)
  80bd57:	e8 5d 06 00 00       	call   80c3b9 <htons>
  80bd5c:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80bd60:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80bd66:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80bd6c:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80bd73:	00 
  80bd74:	89 1c 24             	mov    %ebx,(%esp)
  80bd77:	e8 f3 04 00 00       	call   80c26f <inet_chksum>
  80bd7c:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80bd80:	8b 56 04             	mov    0x4(%esi),%edx
  80bd83:	89 55 e4             	mov    %edx,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80bd86:	85 ff                	test   %edi,%edi
  80bd88:	0f 85 bf fe ff ff    	jne    80bc4d <ip_reass+0x498>
  80bd8e:	e9 e8 fe ff ff       	jmp    80bc7b <ip_reass+0x4c6>

0080bd93 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  80bd93:	55                   	push   %ebp
  80bd94:	89 e5                	mov    %esp,%ebp
  80bd96:	57                   	push   %edi
  80bd97:	56                   	push   %esi
  80bd98:	53                   	push   %ebx
  80bd99:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  80bd9c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80bd9f:	0f b7 78 2c          	movzwl 0x2c(%eax),%edi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  80bda3:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80bdaa:	00 
  80bdab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bdb2:	00 
  80bdb3:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80bdba:	e8 66 d6 ff ff       	call   809425 <pbuf_alloc>
  80bdbf:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  80bdc2:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  if (rambuf == NULL) {
  80bdc7:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  80bdcb:	0f 84 c9 01 00 00    	je     80bf9a <ip_frag+0x207>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  80bdd1:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80bdd4:	66 89 7a 0a          	mov    %di,0xa(%edx)
  80bdd8:	66 89 7a 08          	mov    %di,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  80bddc:	be 03 a4 b3 00       	mov    $0xb3a403,%esi
  80bde1:	83 e6 fc             	and    $0xfffffffc,%esi
  80bde4:	89 72 04             	mov    %esi,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = (struct ip_hdr*) rambuf->payload;
  80bde7:	89 f3                	mov    %esi,%ebx
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  80bde9:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80bdf0:	00 
  80bdf1:	8b 55 08             	mov    0x8(%ebp),%edx
  80bdf4:	8b 42 04             	mov    0x4(%edx),%eax
  80bdf7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bdfb:	89 34 24             	mov    %esi,(%esp)
  80bdfe:	e8 04 55 ff ff       	call   801307 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  80be03:	0f b7 46 06          	movzwl 0x6(%esi),%eax
  80be07:	89 04 24             	mov    %eax,(%esp)
  80be0a:	e8 b7 05 00 00       	call   80c3c6 <ntohs>
  80be0f:	89 c2                	mov    %eax,%edx
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  80be11:	66 25 00 20          	and    $0x2000,%ax
  80be15:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  80be19:	8b 45 08             	mov    0x8(%ebp),%eax
  80be1c:	0f b7 48 08          	movzwl 0x8(%eax),%ecx

  nfb = (mtu - IP_HLEN) / 8;
  80be20:	0f b7 ff             	movzwl %di,%edi
  80be23:	8d 47 f3             	lea    -0xd(%edi),%eax
  80be26:	83 ef 14             	sub    $0x14,%edi
  80be29:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80be2c:	0f 49 c7             	cmovns %edi,%eax
  80be2f:	c1 e8 03             	shr    $0x3,%eax
  80be32:	66 89 45 b8          	mov    %ax,-0x48(%ebp)

  while (left) {
  80be36:	66 83 e9 14          	sub    $0x14,%cx
  80be3a:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  80be3e:	0f 84 46 01 00 00    	je     80bf8a <ip_frag+0x1f7>
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  80be44:	66 81 e2 ff 1f       	and    $0x1fff,%dx
  80be49:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  u16_t ofo, omf;
  u16_t last;
  u16_t poff = IP_HLEN;
  80be4d:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80be53:	c1 e0 03             	shl    $0x3,%eax
  80be56:	66 89 45 b2          	mov    %ax,-0x4e(%ebp)

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80be5a:	8d 56 14             	lea    0x14(%esi),%edx
  80be5d:	89 55 b4             	mov    %edx,-0x4c(%ebp)
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  80be60:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80be64:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80be67:	0f 9d c0             	setge  %al
  80be6a:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  80be6d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80be71:	66 25 ff 1f          	and    $0x1fff,%ax
  80be75:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  80be79:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    if (!last)
  80be7d:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  80be81:	66 85 f6             	test   %si,%si
  80be84:	75 0b                	jne    80be91 <ip_frag+0xfe>
      tmp = tmp | IP_MF;
  80be86:	80 cc 20             	or     $0x20,%ah
  80be89:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  80be8d:	0f b7 7d b2          	movzwl -0x4e(%ebp),%edi

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80be91:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80be95:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80be99:	0f b7 c7             	movzwl %di,%eax
  80be9c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bea0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
  80bea3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bea7:	8b 55 08             	mov    0x8(%ebp),%edx
  80beaa:	89 14 24             	mov    %edx,(%esp)
  80bead:	e8 72 db ff ff       	call   809a24 <pbuf_copy_partial>
  80beb2:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  80beb6:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80beba:	89 04 24             	mov    %eax,(%esp)
  80bebd:	e8 f7 04 00 00       	call   80c3b9 <htons>
  80bec2:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80bec6:	8d 47 14             	lea    0x14(%edi),%eax
  80bec9:	0f b7 c0             	movzwl %ax,%eax
  80becc:	89 04 24             	mov    %eax,(%esp)
  80becf:	e8 e5 04 00 00       	call   80c3b9 <htons>
  80bed4:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  80bed8:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80bede:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80bee5:	00 
  80bee6:	89 1c 24             	mov    %ebx,(%esp)
  80bee9:	e8 81 03 00 00       	call   80c26f <inet_chksum>
  80beee:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  80bef2:	66 85 f6             	test   %si,%si
  80bef5:	74 19                	je     80bf10 <ip_frag+0x17d>
      pbuf_realloc(rambuf, left + IP_HLEN);
  80bef7:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80befb:	83 c0 14             	add    $0x14,%eax
  80befe:	0f b7 c0             	movzwl %ax,%eax
  80bf01:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bf05:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80bf08:	89 04 24             	mov    %eax,(%esp)
  80bf0b:	e8 cf d3 ff ff       	call   8092df <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  80bf10:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bf17:	00 
  80bf18:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bf1f:	00 
  80bf20:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80bf27:	e8 f9 d4 ff ff       	call   809425 <pbuf_alloc>
  80bf2c:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  80bf2e:	85 c0                	test   %eax,%eax
  80bf30:	74 46                	je     80bf78 <ip_frag+0x1e5>
      pbuf_chain(header, rambuf);
  80bf32:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80bf35:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bf39:	89 04 24             	mov    %eax,(%esp)
  80bf3c:	e8 64 d8 ff ff       	call   8097a5 <pbuf_chain>
      netif->output(netif, header, dest);
  80bf41:	8b 45 10             	mov    0x10(%ebp),%eax
  80bf44:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bf48:	89 74 24 04          	mov    %esi,0x4(%esp)
  80bf4c:	8b 55 0c             	mov    0xc(%ebp),%edx
  80bf4f:	89 14 24             	mov    %edx,(%esp)
  80bf52:	ff 52 14             	call   *0x14(%edx)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  80bf55:	89 34 24             	mov    %esi,(%esp)
  80bf58:	e8 a6 d2 ff ff       	call   809203 <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80bf5d:	66 29 7d e6          	sub    %di,-0x1a(%ebp)
  80bf61:	74 27                	je     80bf8a <ip_frag+0x1f7>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80bf63:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80bf67:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  80bf6b:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  80bf6f:	66 01 55 e0          	add    %dx,-0x20(%ebp)
  80bf73:	e9 e8 fe ff ff       	jmp    80be60 <ip_frag+0xcd>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80bf78:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80bf7b:	89 04 24             	mov    %eax,(%esp)
  80bf7e:	e8 80 d2 ff ff       	call   809203 <pbuf_free>
      return ERR_MEM;
  80bf83:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bf88:	eb 10                	jmp    80bf9a <ip_frag+0x207>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80bf8a:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80bf8d:	89 14 24             	mov    %edx,(%esp)
  80bf90:	e8 6e d2 ff ff       	call   809203 <pbuf_free>
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
  80bf95:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80bf9a:	83 c4 5c             	add    $0x5c,%esp
  80bf9d:	5b                   	pop    %ebx
  80bf9e:	5e                   	pop    %esi
  80bf9f:	5f                   	pop    %edi
  80bfa0:	5d                   	pop    %ebp
  80bfa1:	c3                   	ret    
	...

0080bfa4 <_ZL20lwip_standard_chksumPvt>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80bfa4:	55                   	push   %ebp
  80bfa5:	89 e5                	mov    %esp,%ebp
  80bfa7:	57                   	push   %edi
  80bfa8:	56                   	push   %esi
  80bfa9:	53                   	push   %ebx
  80bfaa:	83 ec 2c             	sub    $0x2c,%esp
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80bfad:	89 c1                	mov    %eax,%ecx
{
  u32_t acc;
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  80bfaf:	bb 00 00 00 00       	mov    $0x0,%ebx
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80bfb4:	66 83 fa 01          	cmp    $0x1,%dx
  80bfb8:	76 3e                	jbe    80bff8 <_ZL20lwip_standard_chksumPvt+0x54>
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80bfba:	83 ea 02             	sub    $0x2,%edx
  80bfbd:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  80bfc1:	66 d1 ea             	shr    %dx
  80bfc4:	0f b7 d2             	movzwl %dx,%edx
  80bfc7:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80bfca:	8d 7c 50 02          	lea    0x2(%eax,%edx,2),%edi
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80bfce:	89 c2                	mov    %eax,%edx
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80bfd0:	0f b6 32             	movzbl (%edx),%esi
  80bfd3:	c1 e6 08             	shl    $0x8,%esi
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80bfd6:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
  80bfda:	09 ce                	or     %ecx,%esi
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80bfdc:	8d 4a 02             	lea    0x2(%edx),%ecx
  80bfdf:	89 ca                	mov    %ecx,%edx
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  80bfe1:	0f b7 f6             	movzwl %si,%esi
  80bfe4:	01 f3                	add    %esi,%ebx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80bfe6:	39 cf                	cmp    %ecx,%edi
  80bfe8:	75 e6                	jne    80bfd0 <_ZL20lwip_standard_chksumPvt+0x2c>
  80bfea:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80bfed:	8d 4c 50 02          	lea    0x2(%eax,%edx,2),%ecx
  80bff1:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80bff5:	83 e2 01             	and    $0x1,%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80bff8:	66 85 d2             	test   %dx,%dx
  80bffb:	74 0b                	je     80c008 <_ZL20lwip_standard_chksumPvt+0x64>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
  80bffd:	0f b6 01             	movzbl (%ecx),%eax
  80c000:	c1 e0 08             	shl    $0x8,%eax
    acc += src;
  80c003:	0f b7 c0             	movzwl %ax,%eax
  80c006:	01 c3                	add    %eax,%ebx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80c008:	89 d8                	mov    %ebx,%eax
  80c00a:	c1 e8 10             	shr    $0x10,%eax
  80c00d:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  80c013:	01 c3                	add    %eax,%ebx
  if ((acc & 0xffff0000) != 0) {
  80c015:	f7 c3 00 00 ff ff    	test   $0xffff0000,%ebx
  80c01b:	74 0d                	je     80c02a <_ZL20lwip_standard_chksumPvt+0x86>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80c01d:	89 d8                	mov    %ebx,%eax
  80c01f:	c1 e8 10             	shr    $0x10,%eax
  80c022:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  80c028:	01 c3                	add    %eax,%ebx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80c02a:	0f b7 db             	movzwl %bx,%ebx
  80c02d:	89 1c 24             	mov    %ebx,(%esp)
  80c030:	e8 84 03 00 00       	call   80c3b9 <htons>
}
  80c035:	83 c4 2c             	add    $0x2c,%esp
  80c038:	5b                   	pop    %ebx
  80c039:	5e                   	pop    %esi
  80c03a:	5f                   	pop    %edi
  80c03b:	5d                   	pop    %ebp
  80c03c:	c3                   	ret    

0080c03d <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80c03d:	55                   	push   %ebp
  80c03e:	89 e5                	mov    %esp,%ebp
  80c040:	57                   	push   %edi
  80c041:	56                   	push   %esi
  80c042:	53                   	push   %ebx
  80c043:	83 ec 2c             	sub    $0x2c,%esp
  80c046:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c049:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80c04d:	88 45 e7             	mov    %al,-0x19(%ebp)
  80c050:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80c054:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80c058:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80c05d:	85 db                	test   %ebx,%ebx
  80c05f:	74 63                	je     80c0c4 <inet_chksum_pseudo+0x87>
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  80c061:	bf 00 00 00 00       	mov    $0x0,%edi
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80c066:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c06a:	8b 43 04             	mov    0x4(%ebx),%eax
  80c06d:	e8 32 ff ff ff       	call   80bfa4 <_ZL20lwip_standard_chksumPvt>
  80c072:	0f b7 c0             	movzwl %ax,%eax
  80c075:	8d 34 30             	lea    (%eax,%esi,1),%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80c078:	89 f0                	mov    %esi,%eax
  80c07a:	c1 e8 10             	shr    $0x10,%eax
  80c07d:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80c083:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80c085:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80c089:	74 1c                	je     80c0a7 <inet_chksum_pseudo+0x6a>
      swapped = 1 - swapped;
  80c08b:	b8 01 00 00 00       	mov    $0x1,%eax
  80c090:	89 fa                	mov    %edi,%edx
  80c092:	28 d0                	sub    %dl,%al
  80c094:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80c096:	89 f0                	mov    %esi,%eax
  80c098:	c1 e0 08             	shl    $0x8,%eax
  80c09b:	25 ff ff 00 00       	and    $0xffff,%eax
  80c0a0:	89 f2                	mov    %esi,%edx
  80c0a2:	0f b6 f6             	movzbl %dh,%esi
  80c0a5:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80c0a7:	8b 1b                	mov    (%ebx),%ebx
  80c0a9:	85 db                	test   %ebx,%ebx
  80c0ab:	75 b9                	jne    80c066 <inet_chksum_pseudo+0x29>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80c0ad:	89 f8                	mov    %edi,%eax
  80c0af:	84 c0                	test   %al,%al
  80c0b1:	74 11                	je     80c0c4 <inet_chksum_pseudo+0x87>
    acc = SWAP_BYTES_IN_WORD(acc);
  80c0b3:	89 f0                	mov    %esi,%eax
  80c0b5:	c1 e0 08             	shl    $0x8,%eax
  80c0b8:	25 ff ff 00 00       	and    $0xffff,%eax
  80c0bd:	89 f2                	mov    %esi,%edx
  80c0bf:	0f b6 f6             	movzbl %dh,%esi
  80c0c2:	09 c6                	or     %eax,%esi
  }
  acc += (src->addr & 0xffffUL);
  80c0c4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c0c7:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80c0c9:	8b 45 10             	mov    0x10(%ebp),%eax
  80c0cc:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  80c0ce:	89 d1                	mov    %edx,%ecx
  80c0d0:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80c0d3:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80c0d9:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80c0dc:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  80c0df:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  80c0e1:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80c0e4:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80c0e7:	8d 34 30             	lea    (%eax,%esi,1),%esi
  acc += (u32_t)htons((u16_t)proto);
  80c0ea:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80c0ee:	89 04 24             	mov    %eax,(%esp)
  80c0f1:	e8 c3 02 00 00       	call   80c3b9 <htons>
  80c0f6:	0f b7 c0             	movzwl %ax,%eax
  80c0f9:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  80c0fb:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80c0ff:	89 04 24             	mov    %eax,(%esp)
  80c102:	e8 b2 02 00 00       	call   80c3b9 <htons>
  80c107:	0f b7 c0             	movzwl %ax,%eax
  80c10a:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80c10c:	89 f0                	mov    %esi,%eax
  80c10e:	c1 e8 10             	shr    $0x10,%eax
  80c111:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80c117:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  80c119:	89 f0                	mov    %esi,%eax
  80c11b:	c1 e8 10             	shr    $0x10,%eax
  80c11e:	8d 04 06             	lea    (%esi,%eax,1),%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80c121:	f7 d0                	not    %eax
}
  80c123:	83 c4 2c             	add    $0x2c,%esp
  80c126:	5b                   	pop    %ebx
  80c127:	5e                   	pop    %esi
  80c128:	5f                   	pop    %edi
  80c129:	5d                   	pop    %ebp
  80c12a:	c3                   	ret    

0080c12b <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80c12b:	55                   	push   %ebp
  80c12c:	89 e5                	mov    %esp,%ebp
  80c12e:	57                   	push   %edi
  80c12f:	56                   	push   %esi
  80c130:	53                   	push   %ebx
  80c131:	83 ec 3c             	sub    $0x3c,%esp
  80c134:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c137:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80c13b:	88 45 d6             	mov    %al,-0x2a(%ebp)
  80c13e:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80c142:	66 89 55 d4          	mov    %dx,-0x2c(%ebp)
  80c146:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80c14a:	85 db                	test   %ebx,%ebx
  80c14c:	0f 84 b1 00 00 00    	je     80c203 <inet_chksum_pseudo_partial+0xd8>
  80c152:	66 85 f6             	test   %si,%si
  80c155:	0f 84 a8 00 00 00    	je     80c203 <inet_chksum_pseudo_partial+0xd8>
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  swapped = 0;
  80c15b:	c6 45 d7 00          	movb   $0x0,-0x29(%ebp)
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  80c15f:	bf 00 00 00 00       	mov    $0x0,%edi
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80c164:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80c168:	66 39 c6             	cmp    %ax,%si
  80c16b:	89 c2                	mov    %eax,%edx
  80c16d:	0f 46 d6             	cmovbe %esi,%edx
  80c170:	66 89 55 d8          	mov    %dx,-0x28(%ebp)
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80c174:	0f b7 d2             	movzwl %dx,%edx
  80c177:	8b 43 04             	mov    0x4(%ebx),%eax
  80c17a:	e8 25 fe ff ff       	call   80bfa4 <_ZL20lwip_standard_chksumPvt>
    chksum_len -= chklen;
  80c17f:	66 2b 75 d8          	sub    -0x28(%ebp),%si
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80c183:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80c188:	76 1c                	jbe    80c1a6 <inet_chksum_pseudo_partial+0x7b>
  80c18a:	c7 44 24 08 f5 60 81 	movl   $0x8160f5,0x8(%esp)
  80c191:	00 
  80c192:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80c199:	00 
  80c19a:	c7 04 24 00 61 81 00 	movl   $0x816100,(%esp)
  80c1a1:	e8 12 48 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80c1a6:	0f b7 c0             	movzwl %ax,%eax
  80c1a9:	8d 3c 38             	lea    (%eax,%edi,1),%edi
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80c1ac:	89 fa                	mov    %edi,%edx
  80c1ae:	c1 ea 10             	shr    $0x10,%edx
  80c1b1:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  80c1b7:	01 d7                	add    %edx,%edi
    if (q->len % 2 != 0) {
  80c1b9:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80c1bd:	74 1c                	je     80c1db <inet_chksum_pseudo_partial+0xb0>
      swapped = 1 - swapped;
  80c1bf:	b8 01 00 00 00       	mov    $0x1,%eax
  80c1c4:	2a 45 d7             	sub    -0x29(%ebp),%al
  80c1c7:	88 45 d7             	mov    %al,-0x29(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80c1ca:	89 f8                	mov    %edi,%eax
  80c1cc:	c1 e0 08             	shl    $0x8,%eax
  80c1cf:	25 ff ff 00 00       	and    $0xffff,%eax
  80c1d4:	89 fa                	mov    %edi,%edx
  80c1d6:	0f b6 fe             	movzbl %dh,%edi
  80c1d9:	09 c7                	or     %eax,%edi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80c1db:	8b 1b                	mov    (%ebx),%ebx
  80c1dd:	85 db                	test   %ebx,%ebx
  80c1df:	74 09                	je     80c1ea <inet_chksum_pseudo_partial+0xbf>
  80c1e1:	66 85 f6             	test   %si,%si
  80c1e4:	0f 85 7a ff ff ff    	jne    80c164 <inet_chksum_pseudo_partial+0x39>
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80c1ea:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80c1ee:	74 18                	je     80c208 <inet_chksum_pseudo_partial+0xdd>
    acc = SWAP_BYTES_IN_WORD(acc);
  80c1f0:	89 f8                	mov    %edi,%eax
  80c1f2:	c1 e0 08             	shl    $0x8,%eax
  80c1f5:	25 ff ff 00 00       	and    $0xffff,%eax
  80c1fa:	89 fa                	mov    %edi,%edx
  80c1fc:	0f b6 fe             	movzbl %dh,%edi
  80c1ff:	09 c7                	or     %eax,%edi
  80c201:	eb 05                	jmp    80c208 <inet_chksum_pseudo_partial+0xdd>
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;
  u16_t chklen;

  acc = 0;
  80c203:	bf 00 00 00 00       	mov    $0x0,%edi
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80c208:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c20b:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80c20d:	8b 45 10             	mov    0x10(%ebp),%eax
  80c210:	8b 00                	mov    (%eax),%eax

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  80c212:	89 d1                	mov    %edx,%ecx
  80c214:	c1 e9 10             	shr    $0x10,%ecx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80c217:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80c21d:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80c220:	0f b7 c8             	movzwl %ax,%ecx

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  80c223:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  acc += ((dest->addr >> 16) & 0xffffUL);
  80c225:	c1 e8 10             	shr    $0x10,%eax
  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80c228:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80c22b:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  acc += (u32_t)htons((u16_t)proto);
  80c22e:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  80c232:	89 04 24             	mov    %eax,(%esp)
  80c235:	e8 7f 01 00 00       	call   80c3b9 <htons>
  80c23a:	0f b7 c0             	movzwl %ax,%eax
  80c23d:	01 c7                	add    %eax,%edi
  acc += (u32_t)htons(proto_len);
  80c23f:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80c243:	89 04 24             	mov    %eax,(%esp)
  80c246:	e8 6e 01 00 00       	call   80c3b9 <htons>
  80c24b:	0f b7 c0             	movzwl %ax,%eax
  80c24e:	01 c7                	add    %eax,%edi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80c250:	89 f8                	mov    %edi,%eax
  80c252:	c1 e8 10             	shr    $0x10,%eax
  80c255:	81 e7 ff ff 00 00    	and    $0xffff,%edi
  80c25b:	8d 04 07             	lea    (%edi,%eax,1),%eax
  acc = FOLD_U32T(acc);
  80c25e:	89 c2                	mov    %eax,%edx
  80c260:	c1 ea 10             	shr    $0x10,%edx
  80c263:	01 d0                	add    %edx,%eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
  80c265:	f7 d0                	not    %eax
}
  80c267:	83 c4 3c             	add    $0x3c,%esp
  80c26a:	5b                   	pop    %ebx
  80c26b:	5e                   	pop    %esi
  80c26c:	5f                   	pop    %edi
  80c26d:	5d                   	pop    %ebp
  80c26e:	c3                   	ret    

0080c26f <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80c26f:	55                   	push   %ebp
  80c270:	89 e5                	mov    %esp,%ebp
  80c272:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80c275:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80c279:	8b 45 08             	mov    0x8(%ebp),%eax
  80c27c:	e8 23 fd ff ff       	call   80bfa4 <_ZL20lwip_standard_chksumPvt>
  80c281:	f7 d0                	not    %eax
}
  80c283:	c9                   	leave  
  80c284:	c3                   	ret    

0080c285 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80c285:	55                   	push   %ebp
  80c286:	89 e5                	mov    %esp,%ebp
  80c288:	57                   	push   %edi
  80c289:	56                   	push   %esi
  80c28a:	53                   	push   %ebx
  80c28b:	83 ec 0c             	sub    $0xc,%esp
  80c28e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  80c291:	be 00 00 00 00       	mov    $0x0,%esi
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80c296:	85 db                	test   %ebx,%ebx
  80c298:	74 63                	je     80c2fd <inet_chksum_pbuf+0x78>
  u32_t acc;
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  80c29a:	bf 00 00 00 00       	mov    $0x0,%edi
  for(q = p; q != NULL; q = q->next) {
    acc += LWIP_CHKSUM(q->payload, q->len);
  80c29f:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80c2a3:	8b 43 04             	mov    0x4(%ebx),%eax
  80c2a6:	e8 f9 fc ff ff       	call   80bfa4 <_ZL20lwip_standard_chksumPvt>
  80c2ab:	0f b7 c0             	movzwl %ax,%eax
  80c2ae:	8d 34 30             	lea    (%eax,%esi,1),%esi
    acc = FOLD_U32T(acc);
  80c2b1:	89 f0                	mov    %esi,%eax
  80c2b3:	c1 e8 10             	shr    $0x10,%eax
  80c2b6:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80c2bc:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80c2be:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80c2c2:	74 1c                	je     80c2e0 <inet_chksum_pbuf+0x5b>
      swapped = 1 - swapped;
  80c2c4:	b8 01 00 00 00       	mov    $0x1,%eax
  80c2c9:	89 fa                	mov    %edi,%edx
  80c2cb:	28 d0                	sub    %dl,%al
  80c2cd:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80c2cf:	89 f0                	mov    %esi,%eax
  80c2d1:	c1 e0 08             	shl    $0x8,%eax
  80c2d4:	25 ff ff 00 00       	and    $0xffff,%eax
  80c2d9:	89 f2                	mov    %esi,%edx
  80c2db:	0f b6 f6             	movzbl %dh,%esi
  80c2de:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80c2e0:	8b 1b                	mov    (%ebx),%ebx
  80c2e2:	85 db                	test   %ebx,%ebx
  80c2e4:	75 b9                	jne    80c29f <inet_chksum_pbuf+0x1a>
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80c2e6:	89 f8                	mov    %edi,%eax
  80c2e8:	84 c0                	test   %al,%al
  80c2ea:	74 11                	je     80c2fd <inet_chksum_pbuf+0x78>
    acc = SWAP_BYTES_IN_WORD(acc);
  80c2ec:	89 f0                	mov    %esi,%eax
  80c2ee:	c1 e0 08             	shl    $0x8,%eax
  80c2f1:	25 ff ff 00 00       	and    $0xffff,%eax
  80c2f6:	89 f2                	mov    %esi,%edx
  80c2f8:	0f b6 f6             	movzbl %dh,%esi
  80c2fb:	09 c6                	or     %eax,%esi
  }
  return (u16_t)~(acc & 0xffffUL);
  80c2fd:	89 f0                	mov    %esi,%eax
  80c2ff:	f7 d0                	not    %eax
}
  80c301:	83 c4 0c             	add    $0xc,%esp
  80c304:	5b                   	pop    %ebx
  80c305:	5e                   	pop    %esi
  80c306:	5f                   	pop    %edi
  80c307:	5d                   	pop    %ebp
  80c308:	c3                   	ret    
  80c309:	00 00                	add    %al,(%eax)
  80c30b:	00 00                	add    %al,(%eax)
  80c30d:	00 00                	add    %al,(%eax)
	...

0080c310 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80c310:	55                   	push   %ebp
  80c311:	89 e5                	mov    %esp,%ebp
  80c313:	57                   	push   %edi
  80c314:	56                   	push   %esi
  80c315:	53                   	push   %ebx
  80c316:	83 ec 18             	sub    $0x18,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80c319:	8b 45 08             	mov    0x8(%ebp),%eax
  80c31c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80c31f:	8d 45 ec             	lea    -0x14(%ebp),%eax
  80c322:	89 45 dc             	mov    %eax,-0x24(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80c325:	8d 45 ef             	lea    -0x11(%ebp),%eax
  80c328:	89 45 e0             	mov    %eax,-0x20(%ebp)
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  80c32b:	bb e4 a9 b3 00       	mov    $0xb3a9e4,%ebx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80c330:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80c333:	0f b6 08             	movzbl (%eax),%ecx
  u8_t *ap;
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  80c336:	ba 00 00 00 00       	mov    $0x0,%edx
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80c33b:	b8 cd ff ff ff       	mov    $0xffffffcd,%eax
  80c340:	f6 e1                	mul    %cl
  80c342:	66 c1 e8 08          	shr    $0x8,%ax
  80c346:	c0 e8 03             	shr    $0x3,%al
  80c349:	89 c6                	mov    %eax,%esi
  80c34b:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80c34e:	01 c0                	add    %eax,%eax
  80c350:	28 c1                	sub    %al,%cl
  80c352:	89 c8                	mov    %ecx,%eax
      *ap /= (u8_t)10;
  80c354:	89 f1                	mov    %esi,%ecx
      inv[i++] = '0' + rem;
  80c356:	0f b6 fa             	movzbl %dl,%edi
  80c359:	83 c0 30             	add    $0x30,%eax
  80c35c:	88 44 3d f1          	mov    %al,-0xf(%ebp,%edi,1)
  80c360:	83 c2 01             	add    $0x1,%edx

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
  80c363:	84 c9                	test   %cl,%cl
  80c365:	75 d4                	jne    80c33b <inet_ntoa+0x2b>
  80c367:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80c36a:	88 08                	mov    %cl,(%eax)
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80c36c:	84 d2                	test   %dl,%dl
  80c36e:	74 24                	je     80c394 <inet_ntoa+0x84>
  80c370:	83 ea 01             	sub    $0x1,%edx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80c373:	0f b6 fa             	movzbl %dl,%edi
  80c376:	8d 74 3b 01          	lea    0x1(%ebx,%edi,1),%esi
  80c37a:	89 d8                	mov    %ebx,%eax
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  80c37c:	0f b6 ca             	movzbl %dl,%ecx
  80c37f:	0f b6 4c 0d f1       	movzbl -0xf(%ebp,%ecx,1),%ecx
  80c384:	88 08                	mov    %cl,(%eax)
  80c386:	83 c0 01             	add    $0x1,%eax
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80c389:	83 ea 01             	sub    $0x1,%edx
  80c38c:	39 f0                	cmp    %esi,%eax
  80c38e:	75 ec                	jne    80c37c <inet_ntoa+0x6c>
  80c390:	8d 5c 3b 01          	lea    0x1(%ebx,%edi,1),%ebx
      *rp++ = inv[i];
    *rp++ = '.';
  80c394:	c6 03 2e             	movb   $0x2e,(%ebx)
  80c397:	83 c3 01             	add    $0x1,%ebx
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80c39a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c39d:	39 45 dc             	cmp    %eax,-0x24(%ebp)
  80c3a0:	74 06                	je     80c3a8 <inet_ntoa+0x98>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  80c3a2:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
  80c3a6:	eb 88                	jmp    80c330 <inet_ntoa+0x20>
  }
  *--rp = 0;
  80c3a8:	c6 43 ff 00          	movb   $0x0,-0x1(%ebx)
  return str;
}
  80c3ac:	b8 e4 a9 b3 00       	mov    $0xb3a9e4,%eax
  80c3b1:	83 c4 18             	add    $0x18,%esp
  80c3b4:	5b                   	pop    %ebx
  80c3b5:	5e                   	pop    %esi
  80c3b6:	5f                   	pop    %edi
  80c3b7:	5d                   	pop    %ebp
  80c3b8:	c3                   	ret    

0080c3b9 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80c3b9:	55                   	push   %ebp
  80c3ba:	89 e5                	mov    %esp,%ebp
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
  80c3bc:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80c3c0:	66 c1 c0 08          	rol    $0x8,%ax
}
  80c3c4:	5d                   	pop    %ebp
  80c3c5:	c3                   	ret    

0080c3c6 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80c3c6:	55                   	push   %ebp
  80c3c7:	89 e5                	mov    %esp,%ebp
  80c3c9:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  80c3cc:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80c3d0:	89 04 24             	mov    %eax,(%esp)
  80c3d3:	e8 e1 ff ff ff       	call   80c3b9 <htons>
}
  80c3d8:	c9                   	leave  
  80c3d9:	c3                   	ret    

0080c3da <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80c3da:	55                   	push   %ebp
  80c3db:	89 e5                	mov    %esp,%ebp
  80c3dd:	8b 55 08             	mov    0x8(%ebp),%edx
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
  80c3e0:	89 d1                	mov    %edx,%ecx
  80c3e2:	c1 e9 18             	shr    $0x18,%ecx
  80c3e5:	89 d0                	mov    %edx,%eax
  80c3e7:	c1 e0 18             	shl    $0x18,%eax
  80c3ea:	09 c8                	or     %ecx,%eax
  80c3ec:	89 d1                	mov    %edx,%ecx
  80c3ee:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80c3f4:	c1 e1 08             	shl    $0x8,%ecx
  80c3f7:	09 c8                	or     %ecx,%eax
  80c3f9:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80c3ff:	c1 ea 08             	shr    $0x8,%edx
  80c402:	09 d0                	or     %edx,%eax
}
  80c404:	5d                   	pop    %ebp
  80c405:	c3                   	ret    

0080c406 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80c406:	55                   	push   %ebp
  80c407:	89 e5                	mov    %esp,%ebp
  80c409:	57                   	push   %edi
  80c40a:	56                   	push   %esi
  80c40b:	53                   	push   %ebx
  80c40c:	83 ec 28             	sub    $0x28,%esp
  80c40f:	8b 4d 08             	mov    0x8(%ebp),%ecx
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80c412:	0f be 11             	movsbl (%ecx),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80c415:	8d 5a d0             	lea    -0x30(%edx),%ebx
      return (0);
  80c418:	b8 00 00 00 00       	mov    $0x0,%eax
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80c41d:	80 fb 09             	cmp    $0x9,%bl
  80c420:	0f 87 c4 01 00 00    	ja     80c5ea <inet_aton+0x1e4>
inet_aton(const char *cp, struct in_addr *addr)
{
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;
  80c426:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80c429:	89 45 d8             	mov    %eax,-0x28(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80c42c:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  80c42f:	89 5d e0             	mov    %ebx,-0x20(%ebp)
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
  80c432:	c7 45 dc 0a 00 00 00 	movl   $0xa,-0x24(%ebp)
    if (c == '0') {
  80c439:	83 fa 30             	cmp    $0x30,%edx
  80c43c:	75 25                	jne    80c463 <inet_aton+0x5d>
      c = *++cp;
  80c43e:	83 c1 01             	add    $0x1,%ecx
  80c441:	0f be 11             	movsbl (%ecx),%edx
      if (c == 'x' || c == 'X') {
  80c444:	83 fa 78             	cmp    $0x78,%edx
  80c447:	74 0c                	je     80c455 <inet_aton+0x4f>
        base = 16;
        c = *++cp;
      } else
        base = 8;
  80c449:	c7 45 dc 08 00 00 00 	movl   $0x8,-0x24(%ebp)
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
  80c450:	83 fa 58             	cmp    $0x58,%edx
  80c453:	75 0e                	jne    80c463 <inet_aton+0x5d>
        base = 16;
        c = *++cp;
  80c455:	0f be 51 01          	movsbl 0x1(%ecx),%edx
  80c459:	83 c1 01             	add    $0x1,%ecx
    val = 0;
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
  80c45c:	c7 45 dc 10 00 00 00 	movl   $0x10,-0x24(%ebp)
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
  80c463:	8d 41 01             	lea    0x1(%ecx),%eax
  80c466:	be 00 00 00 00       	mov    $0x0,%esi
  80c46b:	eb 03                	jmp    80c470 <inet_aton+0x6a>
    base = 10;
    if (c == '0') {
      c = *++cp;
      if (c == 'x' || c == 'X') {
        base = 16;
        c = *++cp;
  80c46d:	83 c0 01             	add    $0x1,%eax
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
  80c470:	8d 78 ff             	lea    -0x1(%eax),%edi
        c = *++cp;
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80c473:	89 d1                	mov    %edx,%ecx
  80c475:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80c478:	80 fb 09             	cmp    $0x9,%bl
  80c47b:	77 0d                	ja     80c48a <inet_aton+0x84>
        val = (val * base) + (int)(c - '0');
  80c47d:	0f af 75 dc          	imul   -0x24(%ebp),%esi
  80c481:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80c485:	0f be 10             	movsbl (%eax),%edx
  80c488:	eb e3                	jmp    80c46d <inet_aton+0x67>
      } else if (base == 16 && isxdigit(c)) {
  80c48a:	83 7d dc 10          	cmpl   $0x10,-0x24(%ebp)
  80c48e:	0f 85 5e 01 00 00    	jne    80c5f2 <inet_aton+0x1ec>
  80c494:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80c497:	88 5d d3             	mov    %bl,-0x2d(%ebp)
  80c49a:	80 fb 05             	cmp    $0x5,%bl
  80c49d:	76 0c                	jbe    80c4ab <inet_aton+0xa5>
  80c49f:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80c4a2:	80 fb 05             	cmp    $0x5,%bl
  80c4a5:	0f 87 4d 01 00 00    	ja     80c5f8 <inet_aton+0x1f2>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80c4ab:	89 f1                	mov    %esi,%ecx
  80c4ad:	c1 e1 04             	shl    $0x4,%ecx
  80c4b0:	8d 72 0a             	lea    0xa(%edx),%esi
  80c4b3:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80c4b7:	19 d2                	sbb    %edx,%edx
  80c4b9:	83 e2 20             	and    $0x20,%edx
  80c4bc:	83 c2 41             	add    $0x41,%edx
  80c4bf:	29 d6                	sub    %edx,%esi
  80c4c1:	09 ce                	or     %ecx,%esi
        c = *++cp;
  80c4c3:	0f be 10             	movsbl (%eax),%edx
  80c4c6:	eb a5                	jmp    80c46d <inet_aton+0x67>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80c4c8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c4cb:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80c4ce:	0f 83 0a 01 00 00    	jae    80c5de <inet_aton+0x1d8>
        return (0);
      *pp++ = val;
  80c4d4:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80c4d7:	89 1a                	mov    %ebx,(%edx)
      c = *++cp;
  80c4d9:	8d 4f 01             	lea    0x1(%edi),%ecx
  80c4dc:	0f be 57 01          	movsbl 0x1(%edi),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80c4e0:	8d 42 d0             	lea    -0x30(%edx),%eax
  80c4e3:	3c 09                	cmp    $0x9,%al
  80c4e5:	0f 87 fa 00 00 00    	ja     80c5e5 <inet_aton+0x1df>
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
  80c4eb:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  80c4ef:	e9 3e ff ff ff       	jmp    80c432 <inet_aton+0x2c>
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
    return (0);
  80c4f4:	b8 00 00 00 00       	mov    $0x0,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80c4f9:	80 f9 1f             	cmp    $0x1f,%cl
  80c4fc:	0f 86 e8 00 00 00    	jbe    80c5ea <inet_aton+0x1e4>
  80c502:	84 d2                	test   %dl,%dl
  80c504:	0f 88 e0 00 00 00    	js     80c5ea <inet_aton+0x1e4>
  80c50a:	83 fa 20             	cmp    $0x20,%edx
  80c50d:	74 1d                	je     80c52c <inet_aton+0x126>
  80c50f:	83 fa 0c             	cmp    $0xc,%edx
  80c512:	74 18                	je     80c52c <inet_aton+0x126>
  80c514:	83 fa 0a             	cmp    $0xa,%edx
  80c517:	74 13                	je     80c52c <inet_aton+0x126>
  80c519:	83 fa 0d             	cmp    $0xd,%edx
  80c51c:	74 0e                	je     80c52c <inet_aton+0x126>
  80c51e:	83 fa 09             	cmp    $0x9,%edx
  80c521:	74 09                	je     80c52c <inet_aton+0x126>
  80c523:	83 fa 0b             	cmp    $0xb,%edx
  80c526:	0f 85 be 00 00 00    	jne    80c5ea <inet_aton+0x1e4>
    return (0);
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  80c52c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80c52f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80c532:	29 c2                	sub    %eax,%edx
  80c534:	c1 fa 02             	sar    $0x2,%edx
  80c537:	83 c2 01             	add    $0x1,%edx
  switch (n) {
  80c53a:	83 fa 02             	cmp    $0x2,%edx
  80c53d:	74 25                	je     80c564 <inet_aton+0x15e>
  80c53f:	83 fa 02             	cmp    $0x2,%edx
  80c542:	7f 0f                	jg     80c553 <inet_aton+0x14d>

  case 0:
    return (0);       /* initial nondigit */
  80c544:	b8 00 00 00 00       	mov    $0x0,%eax
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80c549:	85 d2                	test   %edx,%edx
  80c54b:	0f 84 99 00 00 00    	je     80c5ea <inet_aton+0x1e4>
  80c551:	eb 6c                	jmp    80c5bf <inet_aton+0x1b9>
  80c553:	83 fa 03             	cmp    $0x3,%edx
  80c556:	74 23                	je     80c57b <inet_aton+0x175>
  80c558:	83 fa 04             	cmp    $0x4,%edx
  80c55b:	90                   	nop
  80c55c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80c560:	75 5d                	jne    80c5bf <inet_aton+0x1b9>
  80c562:	eb 36                	jmp    80c59a <inet_aton+0x194>
  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
      return (0);
  80c564:	b8 00 00 00 00       	mov    $0x0,%eax

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  80c569:	81 fb ff ff ff 00    	cmp    $0xffffff,%ebx
  80c56f:	77 79                	ja     80c5ea <inet_aton+0x1e4>
      return (0);
    val |= parts[0] << 24;
  80c571:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80c574:	c1 e6 18             	shl    $0x18,%esi
  80c577:	09 de                	or     %ebx,%esi
    break;
  80c579:	eb 44                	jmp    80c5bf <inet_aton+0x1b9>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
      return (0);
  80c57b:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= parts[0] << 24;
    break;

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80c580:	81 fb ff ff 00 00    	cmp    $0xffff,%ebx
  80c586:	77 62                	ja     80c5ea <inet_aton+0x1e4>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80c588:	8b 75 e8             	mov    -0x18(%ebp),%esi
  80c58b:	c1 e6 10             	shl    $0x10,%esi
  80c58e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c591:	c1 e0 18             	shl    $0x18,%eax
  80c594:	09 c6                	or     %eax,%esi
  80c596:	09 de                	or     %ebx,%esi
    break;
  80c598:	eb 25                	jmp    80c5bf <inet_aton+0x1b9>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
      return (0);
  80c59a:	b8 00 00 00 00       	mov    $0x0,%eax
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
    break;

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80c59f:	81 fb ff 00 00 00    	cmp    $0xff,%ebx
  80c5a5:	77 43                	ja     80c5ea <inet_aton+0x1e4>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80c5a7:	8b 75 e8             	mov    -0x18(%ebp),%esi
  80c5aa:	c1 e6 10             	shl    $0x10,%esi
  80c5ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c5b0:	c1 e0 18             	shl    $0x18,%eax
  80c5b3:	09 c6                	or     %eax,%esi
  80c5b5:	8b 45 ec             	mov    -0x14(%ebp),%eax
  80c5b8:	c1 e0 08             	shl    $0x8,%eax
  80c5bb:	09 c6                	or     %eax,%esi
  80c5bd:	09 de                	or     %ebx,%esi
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
  80c5bf:	b8 01 00 00 00       	mov    $0x1,%eax
    if (val > 0xff)
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
    break;
  }
  if (addr)
  80c5c4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80c5c8:	74 20                	je     80c5ea <inet_aton+0x1e4>
    addr->s_addr = htonl(val);
  80c5ca:	89 34 24             	mov    %esi,(%esp)
  80c5cd:	e8 08 fe ff ff       	call   80c3da <htonl>
  80c5d2:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80c5d5:	89 03                	mov    %eax,(%ebx)
  return (1);
  80c5d7:	b8 01 00 00 00       	mov    $0x1,%eax
  80c5dc:	eb 0c                	jmp    80c5ea <inet_aton+0x1e4>
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
  80c5de:	b8 00 00 00 00       	mov    $0x0,%eax
  80c5e3:	eb 05                	jmp    80c5ea <inet_aton+0x1e4>
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
      return (0);
  80c5e5:	b8 00 00 00 00       	mov    $0x0,%eax
    break;
  }
  if (addr)
    addr->s_addr = htonl(val);
  return (1);
}
  80c5ea:	83 c4 28             	add    $0x28,%esp
  80c5ed:	5b                   	pop    %ebx
  80c5ee:	5e                   	pop    %esi
  80c5ef:	5f                   	pop    %edi
  80c5f0:	5d                   	pop    %ebp
  80c5f1:	c3                   	ret    
    }
    for (;;) {
      if (isdigit(c)) {
        val = (val * base) + (int)(c - '0');
        c = *++cp;
      } else if (base == 16 && isxdigit(c)) {
  80c5f2:	89 d0                	mov    %edx,%eax
  80c5f4:	89 f3                	mov    %esi,%ebx
  80c5f6:	eb 04                	jmp    80c5fc <inet_aton+0x1f6>
  80c5f8:	89 d0                	mov    %edx,%eax
  80c5fa:	89 f3                	mov    %esi,%ebx
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
        c = *++cp;
      } else
        break;
    }
    if (c == '.') {
  80c5fc:	83 f8 2e             	cmp    $0x2e,%eax
  80c5ff:	0f 84 c3 fe ff ff    	je     80c4c8 <inet_aton+0xc2>
  80c605:	89 f3                	mov    %esi,%ebx
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80c607:	85 d2                	test   %edx,%edx
  80c609:	0f 84 1d ff ff ff    	je     80c52c <inet_aton+0x126>
  80c60f:	e9 e0 fe ff ff       	jmp    80c4f4 <inet_aton+0xee>

0080c614 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80c614:	55                   	push   %ebp
  80c615:	89 e5                	mov    %esp,%ebp
  80c617:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80c61a:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80c61d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c621:	8b 45 08             	mov    0x8(%ebp),%eax
  80c624:	89 04 24             	mov    %eax,(%esp)
  80c627:	e8 da fd ff ff       	call   80c406 <inet_aton>
  80c62c:	85 c0                	test   %eax,%eax
    return (val.s_addr);
  80c62e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c633:	0f 45 45 fc          	cmovne -0x4(%ebp),%eax
  }
  return (INADDR_NONE);
}
  80c637:	c9                   	leave  
  80c638:	c3                   	ret    

0080c639 <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80c639:	55                   	push   %ebp
  80c63a:	89 e5                	mov    %esp,%ebp
  80c63c:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  80c63f:	8b 45 08             	mov    0x8(%ebp),%eax
  80c642:	89 04 24             	mov    %eax,(%esp)
  80c645:	e8 90 fd ff ff       	call   80c3da <htonl>
}
  80c64a:	c9                   	leave  
  80c64b:	c3                   	ret    
  80c64c:	00 00                	add    %al,(%eax)
	...

0080c650 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80c650:	55                   	push   %ebp
  80c651:	89 e5                	mov    %esp,%ebp
  80c653:	57                   	push   %edi
  80c654:	56                   	push   %esi
  80c655:	53                   	push   %ebx
  80c656:	83 ec 6c             	sub    $0x6c,%esp
  80c659:	8b 7d 08             	mov    0x8(%ebp),%edi
  80c65c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c65f:	0f b7 55 10          	movzwl 0x10(%ebp),%edx
  80c663:	66 89 55 b4          	mov    %dx,-0x4c(%ebp)
  80c667:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  80c66b:	88 4d b8             	mov    %cl,-0x48(%ebp)
  80c66e:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  80c672:	88 55 98             	mov    %dl,-0x68(%ebp)
  80c675:	0f b6 4d 20          	movzbl 0x20(%ebp),%ecx
  80c679:	88 4d d4             	mov    %cl,-0x2c(%ebp)
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80c67c:	66 83 7d b4 00       	cmpw   $0x0,-0x4c(%ebp)
  80c681:	74 20                	je     80c6a3 <tcp_enqueue+0x53>
  80c683:	84 c9                	test   %cl,%cl
  80c685:	74 1c                	je     80c6a3 <tcp_enqueue+0x53>
  80c687:	c7 44 24 08 24 61 81 	movl   $0x816124,0x8(%esp)
  80c68e:	00 
  80c68f:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  80c696:	00 
  80c697:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80c69e:	e8 15 43 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80c6a3:	85 c0                	test   %eax,%eax
  80c6a5:	0f 95 45 b3          	setne  -0x4d(%ebp)
  80c6a9:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80c6ad:	0f 95 45 cb          	setne  -0x35(%ebp)
  80c6b1:	80 7d b3 00          	cmpb   $0x0,-0x4d(%ebp)
  80c6b5:	74 22                	je     80c6d9 <tcp_enqueue+0x89>
  80c6b7:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80c6bb:	74 1c                	je     80c6d9 <tcp_enqueue+0x89>
  80c6bd:	c7 44 24 08 64 61 81 	movl   $0x816164,0x8(%esp)
  80c6c4:	00 
  80c6c5:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  80c6cc:	00 
  80c6cd:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80c6d4:	e8 df 42 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80c6d9:	0f b7 55 b4          	movzwl -0x4c(%ebp),%edx
  80c6dd:	66 3b 57 6e          	cmp    0x6e(%edi),%dx
  80c6e1:	76 0e                	jbe    80c6f1 <tcp_enqueue+0xa1>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80c6e3:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  80c6e7:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c6ec:	e9 35 06 00 00       	jmp    80cd26 <tcp_enqueue+0x6d6>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80c6f1:	8b 4f 68             	mov    0x68(%edi),%ecx
  80c6f4:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80c6f7:	0f b7 57 70          	movzwl 0x70(%edi),%edx
  80c6fb:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80c6ff:	66 83 fa 1f          	cmp    $0x1f,%dx
  80c703:	76 0e                	jbe    80c713 <tcp_enqueue+0xc3>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80c705:	80 4f 20 80          	orb    $0x80,0x20(%edi)
    return ERR_MEM;
  80c709:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80c70e:	e9 13 06 00 00       	jmp    80cd26 <tcp_enqueue+0x6d6>
  }
  if (queuelen != 0) {
  80c713:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  80c718:	74 63                	je     80c77d <tcp_enqueue+0x12d>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80c71a:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c71e:	74 3b                	je     80c75b <tcp_enqueue+0x10b>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80c720:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
  80c724:	c0 ea 02             	shr    $0x2,%dl
  80c727:	c1 e2 0c             	shl    $0xc,%edx
  80c72a:	66 81 c2 00 50       	add    $0x5000,%dx
  80c72f:	66 89 55 b6          	mov    %dx,-0x4a(%ebp)
  80c733:	89 45 cc             	mov    %eax,-0x34(%ebp)
  80c736:	0f b7 4d b4          	movzwl -0x4c(%ebp),%ecx
  80c73a:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  80c73e:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
  80c745:	bb 00 00 00 00       	mov    $0x0,%ebx
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80c74a:	0f b6 45 98          	movzbl -0x68(%ebp),%eax
  80c74e:	83 e0 01             	and    $0x1,%eax
  80c751:	89 45 ac             	mov    %eax,-0x54(%ebp)
  80c754:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80c757:	89 df                	mov    %ebx,%edi
  80c759:	eb 55                	jmp    80c7b0 <tcp_enqueue+0x160>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80c75b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c75f:	75 bf                	jne    80c720 <tcp_enqueue+0xd0>
  80c761:	c7 44 24 08 ac 61 81 	movl   $0x8161ac,0x8(%esp)
  80c768:	00 
  80c769:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80c770:	00 
  80c771:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80c778:	e8 3b 42 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80c77d:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80c781:	75 06                	jne    80c789 <tcp_enqueue+0x139>
  80c783:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80c787:	74 97                	je     80c720 <tcp_enqueue+0xd0>
  80c789:	c7 44 24 08 e8 61 81 	movl   $0x8161e8,0x8(%esp)
  80c790:	00 
  80c791:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80c798:	00 
  80c799:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80c7a0:	e8 13 42 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  80c7a5:	0f b7 f6             	movzwl %si,%esi
  80c7a8:	01 75 d8             	add    %esi,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80c7ab:	01 75 cc             	add    %esi,-0x34(%ebp)
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = (struct tcp_seg *) memp_malloc(MEMP_TCP_SEG);
  80c7ae:	89 df                	mov    %ebx,%edi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80c7b0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80c7b3:	0f b7 72 34          	movzwl 0x34(%edx),%esi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = (struct tcp_seg *) memp_malloc(MEMP_TCP_SEG);
  80c7b7:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80c7be:	e8 1e c6 ff ff       	call   808de1 <memp_malloc>
  80c7c3:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80c7c5:	85 c0                	test   %eax,%eax
  80c7c7:	0f 84 e8 04 00 00    	je     80ccb5 <tcp_enqueue+0x665>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80c7cd:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80c7d3:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80c7da:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80c7de:	74 24                	je     80c804 <tcp_enqueue+0x1b4>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80c7e0:	85 ff                	test   %edi,%edi
  80c7e2:	75 1c                	jne    80c800 <tcp_enqueue+0x1b0>
  80c7e4:	c7 44 24 08 de 62 81 	movl   $0x8162de,0x8(%esp)
  80c7eb:	00 
  80c7ec:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80c7f3:	00 
  80c7f4:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80c7fb:	e8 b8 41 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      useg->next = seg;
  80c800:	89 07                	mov    %eax,(%edi)
  80c802:	eb 03                	jmp    80c807 <tcp_enqueue+0x1b7>
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = (struct tcp_seg *) memp_malloc(MEMP_TCP_SEG);
  80c804:	89 45 d0             	mov    %eax,-0x30(%ebp)
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
      useg->next = seg;
  80c807:	66 39 75 e4          	cmp    %si,-0x1c(%ebp)
  80c80b:	0f b7 4d e4          	movzwl -0x1c(%ebp),%ecx
  80c80f:	0f 46 f1             	cmovbe %ecx,%esi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80c812:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80c816:	74 6a                	je     80c882 <tcp_enqueue+0x232>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80c818:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c81f:	00 
  80c820:	0f b6 45 d4          	movzbl -0x2c(%ebp),%eax
  80c824:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c828:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c82f:	e8 f1 cb ff ff       	call   809425 <pbuf_alloc>
  80c834:	89 43 04             	mov    %eax,0x4(%ebx)
  80c837:	85 c0                	test   %eax,%eax
  80c839:	0f 84 7b 04 00 00    	je     80ccba <tcp_enqueue+0x66a>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80c83f:	0f b6 55 d4          	movzbl -0x2c(%ebp),%edx
  80c843:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80c847:	73 1c                	jae    80c865 <tcp_enqueue+0x215>
  80c849:	c7 44 24 08 1c 62 81 	movl   $0x81621c,0x8(%esp)
  80c850:	00 
  80c851:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  80c858:	00 
  80c859:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80c860:	e8 53 41 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80c865:	89 04 24             	mov    %eax,(%esp)
  80c868:	e8 64 ce ff ff       	call   8096d1 <pbuf_clen>
  80c86d:	0f b6 c0             	movzbl %al,%eax
  80c870:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      seg->dataptr = seg->p->payload;
  80c874:	8b 43 04             	mov    0x4(%ebx),%eax
  80c877:	8b 40 04             	mov    0x4(%eax),%eax
  80c87a:	89 43 08             	mov    %eax,0x8(%ebx)
  80c87d:	e9 1a 01 00 00       	jmp    80c99c <tcp_enqueue+0x34c>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80c882:	83 7d ac 00          	cmpl   $0x0,-0x54(%ebp)
  80c886:	0f 84 87 00 00 00    	je     80c913 <tcp_enqueue+0x2c3>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80c88c:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c893:	00 
  80c894:	0f b7 c6             	movzwl %si,%eax
  80c897:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c89b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c8a2:	e8 7e cb ff ff       	call   809425 <pbuf_alloc>
  80c8a7:	89 43 04             	mov    %eax,0x4(%ebx)
  80c8aa:	85 c0                	test   %eax,%eax
  80c8ac:	0f 84 0d 04 00 00    	je     80ccbf <tcp_enqueue+0x66f>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80c8b2:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80c8b6:	76 1c                	jbe    80c8d4 <tcp_enqueue+0x284>
  80c8b8:	c7 44 24 08 44 62 81 	movl   $0x816244,0x8(%esp)
  80c8bf:	00 
  80c8c0:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80c8c7:	00 
  80c8c8:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80c8cf:	e8 e4 40 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80c8d4:	89 04 24             	mov    %eax,(%esp)
  80c8d7:	e8 f5 cd ff ff       	call   8096d1 <pbuf_clen>
  80c8dc:	0f b6 c0             	movzbl %al,%eax
  80c8df:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      if (arg != NULL) {
  80c8e3:	80 7d b3 00          	cmpb   $0x0,-0x4d(%ebp)
  80c8e7:	74 1c                	je     80c905 <tcp_enqueue+0x2b5>
        MEMCPY(seg->p->payload, ptr, seglen);
  80c8e9:	0f b7 c6             	movzwl %si,%eax
  80c8ec:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c8f0:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80c8f3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8f7:	8b 43 04             	mov    0x4(%ebx),%eax
  80c8fa:	8b 40 04             	mov    0x4(%eax),%eax
  80c8fd:	89 04 24             	mov    %eax,(%esp)
  80c900:	e8 02 4a ff ff       	call   801307 <memcpy>
      }
      seg->dataptr = seg->p->payload;
  80c905:	8b 43 04             	mov    0x4(%ebx),%eax
  80c908:	8b 40 04             	mov    0x4(%eax),%eax
  80c90b:	89 43 08             	mov    %eax,0x8(%ebx)
  80c90e:	e9 89 00 00 00       	jmp    80c99c <tcp_enqueue+0x34c>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80c913:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80c91a:	00 
  80c91b:	0f b7 c6             	movzwl %si,%eax
  80c91e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c922:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c929:	e8 f7 ca ff ff       	call   809425 <pbuf_alloc>
  80c92e:	89 c7                	mov    %eax,%edi
  80c930:	85 c0                	test   %eax,%eax
  80c932:	0f 84 8c 03 00 00    	je     80ccc4 <tcp_enqueue+0x674>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80c938:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80c93b:	89 50 04             	mov    %edx,0x4(%eax)
      seg->dataptr = ptr;
  80c93e:	89 53 08             	mov    %edx,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80c941:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c948:	00 
  80c949:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c950:	00 
  80c951:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80c958:	e8 c8 ca ff ff       	call   809425 <pbuf_alloc>
  80c95d:	89 43 04             	mov    %eax,0x4(%ebx)
  80c960:	85 c0                	test   %eax,%eax
  80c962:	75 12                	jne    80c976 <tcp_enqueue+0x326>
  80c964:	89 fb                	mov    %edi,%ebx
  80c966:	8b 7d dc             	mov    -0x24(%ebp),%edi
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80c969:	89 1c 24             	mov    %ebx,(%esp)
  80c96c:	e8 92 c8 ff ff       	call   809203 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  80c971:	e9 5b 03 00 00       	jmp    80ccd1 <tcp_enqueue+0x681>
      }
      queuelen += pbuf_clen(seg->p);
  80c976:	89 04 24             	mov    %eax,(%esp)
  80c979:	e8 53 cd ff ff       	call   8096d1 <pbuf_clen>
  80c97e:	0f b6 c0             	movzbl %al,%eax
  80c981:	0f b7 4d e2          	movzwl -0x1e(%ebp),%ecx
  80c985:	8d 44 01 01          	lea    0x1(%ecx,%eax,1),%eax
  80c989:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80c98d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80c991:	8b 43 04             	mov    0x4(%ebx),%eax
  80c994:	89 04 24             	mov    %eax,(%esp)
  80c997:	e8 60 cd ff ff       	call   8096fc <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80c99c:	66 83 7d e2 20       	cmpw   $0x20,-0x1e(%ebp)
  80c9a1:	0f 87 22 03 00 00    	ja     80ccc9 <tcp_enqueue+0x679>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80c9a7:	66 89 73 0c          	mov    %si,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80c9ab:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80c9b2:	00 
  80c9b3:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9b6:	89 04 24             	mov    %eax,(%esp)
  80c9b9:	e8 52 c7 ff ff       	call   809110 <pbuf_header>
  80c9be:	84 c0                	test   %al,%al
  80c9c0:	0f 85 08 03 00 00    	jne    80ccce <tcp_enqueue+0x67e>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = (struct tcp_hdr *) seg->p->payload;
  80c9c6:	8b 43 04             	mov    0x4(%ebx),%eax
  80c9c9:	8b 78 04             	mov    0x4(%eax),%edi
  80c9cc:	89 7b 10             	mov    %edi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  80c9cf:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80c9d2:	0f b7 42 1c          	movzwl 0x1c(%edx),%eax
  80c9d6:	89 04 24             	mov    %eax,(%esp)
  80c9d9:	e8 db f9 ff ff       	call   80c3b9 <htons>
  80c9de:	66 89 07             	mov    %ax,(%edi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80c9e1:	8b 7b 10             	mov    0x10(%ebx),%edi
  80c9e4:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80c9e7:	0f b7 41 1e          	movzwl 0x1e(%ecx),%eax
  80c9eb:	89 04 24             	mov    %eax,(%esp)
  80c9ee:	e8 c6 f9 ff ff       	call   80c3b9 <htons>
  80c9f3:	66 89 47 02          	mov    %ax,0x2(%edi)
    seg->tcphdr->seqno = htonl(seqno);
  80c9f7:	8b 7b 10             	mov    0x10(%ebx),%edi
  80c9fa:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80c9fd:	89 04 24             	mov    %eax,(%esp)
  80ca00:	e8 d5 f9 ff ff       	call   80c3da <htonl>
  80ca05:	89 47 04             	mov    %eax,0x4(%edi)
    seg->tcphdr->urgp = 0;
  80ca08:	8b 43 10             	mov    0x10(%ebx),%eax
  80ca0b:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80ca11:	8b 7b 10             	mov    0x10(%ebx),%edi
  80ca14:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80ca18:	89 04 24             	mov    %eax,(%esp)
  80ca1b:	e8 a6 f9 ff ff       	call   80c3c6 <ntohs>
  80ca20:	83 e0 c0             	and    $0xffffffc0,%eax
  80ca23:	0f b6 55 b8          	movzbl -0x48(%ebp),%edx
  80ca27:	09 c2                	or     %eax,%edx
  80ca29:	0f b7 d2             	movzwl %dx,%edx
  80ca2c:	89 14 24             	mov    %edx,(%esp)
  80ca2f:	e8 85 f9 ff ff       	call   80c3b9 <htons>
  80ca34:	66 89 47 0c          	mov    %ax,0xc(%edi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80ca38:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80ca3c:	75 23                	jne    80ca61 <tcp_enqueue+0x411>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80ca3e:	8b 7b 10             	mov    0x10(%ebx),%edi
  80ca41:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80ca45:	89 04 24             	mov    %eax,(%esp)
  80ca48:	e8 79 f9 ff ff       	call   80c3c6 <ntohs>
  80ca4d:	83 e0 3f             	and    $0x3f,%eax
  80ca50:	80 cc 50             	or     $0x50,%ah
  80ca53:	89 04 24             	mov    %eax,(%esp)
  80ca56:	e8 5e f9 ff ff       	call   80c3b9 <htons>
  80ca5b:	66 89 47 0c          	mov    %ax,0xc(%edi)
  80ca5f:	eb 3f                	jmp    80caa0 <tcp_enqueue+0x450>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80ca61:	8b 7b 10             	mov    0x10(%ebx),%edi
  80ca64:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80ca68:	89 04 24             	mov    %eax,(%esp)
  80ca6b:	e8 56 f9 ff ff       	call   80c3c6 <ntohs>
  80ca70:	83 e0 3f             	and    $0x3f,%eax
  80ca73:	66 0b 45 b6          	or     -0x4a(%ebp),%ax
  80ca77:	0f b7 c0             	movzwl %ax,%eax
  80ca7a:	89 04 24             	mov    %eax,(%esp)
  80ca7d:	e8 37 f9 ff ff       	call   80c3b9 <htons>
  80ca82:	66 89 47 0c          	mov    %ax,0xc(%edi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80ca86:	0f b6 45 d4          	movzbl -0x2c(%ebp),%eax
  80ca8a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80ca8e:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80ca91:	89 54 24 04          	mov    %edx,0x4(%esp)
  80ca95:	8b 43 08             	mov    0x8(%ebx),%eax
  80ca98:	89 04 24             	mov    %eax,(%esp)
  80ca9b:	e8 67 48 ff ff       	call   801307 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80caa0:	66 29 75 e4          	sub    %si,-0x1c(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80caa4:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80caa8:	0f 84 f7 fc ff ff    	je     80c7a5 <tcp_enqueue+0x155>
  80caae:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  80cab3:	0f 85 ec fc ff ff    	jne    80c7a5 <tcp_enqueue+0x155>
  80cab9:	8b 7d dc             	mov    -0x24(%ebp),%edi
    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = (struct tcp_seg *) memp_malloc(MEMP_TCP_SEG);
  80cabc:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80cabf:	8b 4f 74             	mov    0x74(%edi),%ecx
  80cac2:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80cac5:	85 c9                	test   %ecx,%ecx
  80cac7:	75 09                	jne    80cad2 <tcp_enqueue+0x482>
  80cac9:	e9 27 01 00 00       	jmp    80cbf5 <tcp_enqueue+0x5a5>
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80cace:	89 c2                	mov    %eax,%edx
  80cad0:	eb 03                	jmp    80cad5 <tcp_enqueue+0x485>
  80cad2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cad5:	8b 02                	mov    (%edx),%eax
  80cad7:	85 c0                	test   %eax,%eax
  80cad9:	75 f3                	jne    80cace <tcp_enqueue+0x47e>
  80cadb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80cade:	89 55 dc             	mov    %edx,-0x24(%ebp)
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80cae1:	85 d2                	test   %edx,%edx
  80cae3:	0f 84 45 02 00 00    	je     80cd2e <tcp_enqueue+0x6de>
  80cae9:	0f b7 42 0c          	movzwl 0xc(%edx),%eax
  80caed:	89 45 d8             	mov    %eax,-0x28(%ebp)
    TCP_TCPLEN(useg) != 0 &&
  80caf0:	8b 42 10             	mov    0x10(%edx),%eax
  80caf3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80caf7:	89 04 24             	mov    %eax,(%esp)
  80cafa:	e8 c7 f8 ff ff       	call   80c3c6 <ntohs>
  80caff:	89 c2                	mov    %eax,%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80cb01:	b8 01 00 00 00       	mov    $0x1,%eax
  80cb06:	f6 c2 01             	test   $0x1,%dl
  80cb09:	75 1b                	jne    80cb26 <tcp_enqueue+0x4d6>
    TCP_TCPLEN(useg) != 0 &&
  80cb0b:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80cb0e:	8b 42 10             	mov    0x10(%edx),%eax
  80cb11:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb15:	89 04 24             	mov    %eax,(%esp)
  80cb18:	e8 a9 f8 ff ff       	call   80c3c6 <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80cb1d:	83 e0 02             	and    $0x2,%eax
  80cb20:	0f 95 c0             	setne  %al
  80cb23:	0f b6 c0             	movzbl %al,%eax
  80cb26:	03 45 d8             	add    -0x28(%ebp),%eax
  80cb29:	85 c0                	test   %eax,%eax
  80cb2b:	0f 84 fd 01 00 00    	je     80cd2e <tcp_enqueue+0x6de>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80cb31:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80cb34:	8b 41 10             	mov    0x10(%ecx),%eax
  80cb37:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80cb3b:	89 04 24             	mov    %eax,(%esp)
  80cb3e:	e8 83 f8 ff ff       	call   80c3c6 <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80cb43:	a8 03                	test   $0x3,%al
  80cb45:	0f 85 e3 01 00 00    	jne    80cd2e <tcp_enqueue+0x6de>
  80cb4b:	f6 45 b8 03          	testb  $0x3,-0x48(%ebp)
  80cb4f:	0f 85 d9 01 00 00    	jne    80cd2e <tcp_enqueue+0x6de>
  80cb55:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80cb58:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  80cb5c:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80cb5f:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80cb63:	01 c2                	add    %eax,%edx
  80cb65:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80cb69:	39 c2                	cmp    %eax,%edx
  80cb6b:	0f 8f bd 01 00 00    	jg     80cd2e <tcp_enqueue+0x6de>
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80cb71:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80cb78:	ff 
  80cb79:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80cb7c:	8b 42 04             	mov    0x4(%edx),%eax
  80cb7f:	89 04 24             	mov    %eax,(%esp)
  80cb82:	e8 89 c5 ff ff       	call   809110 <pbuf_header>
  80cb87:	84 c0                	test   %al,%al
  80cb89:	74 1c                	je     80cba7 <tcp_enqueue+0x557>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80cb8b:	c7 44 24 08 eb 62 81 	movl   $0x8162eb,0x8(%esp)
  80cb92:	00 
  80cb93:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80cb9a:	00 
  80cb9b:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80cba2:	e8 11 3e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80cba7:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80cbaa:	8b 41 04             	mov    0x4(%ecx),%eax
  80cbad:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cbb1:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80cbb4:	8b 42 04             	mov    0x4(%edx),%eax
  80cbb7:	89 04 24             	mov    %eax,(%esp)
  80cbba:	e8 3d cb ff ff       	call   8096fc <pbuf_cat>
    useg->len += queue->len;
  80cbbf:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80cbc2:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80cbc6:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80cbc9:	66 01 42 0c          	add    %ax,0xc(%edx)
    useg->next = queue->next;
  80cbcd:	8b 01                	mov    (%ecx),%eax
  80cbcf:	89 02                	mov    %eax,(%edx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
      seg = NULL;
  80cbd1:	39 4d d4             	cmp    %ecx,-0x2c(%ebp)
  80cbd4:	b8 00 00 00 00       	mov    $0x0,%eax
  80cbd9:	0f 44 d8             	cmove  %eax,%ebx
    }
    memp_free(MEMP_TCP_SEG, queue);
  80cbdc:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80cbe0:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80cbe7:	e8 55 c2 ff ff       	call   808e41 <memp_free>
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80cbec:	0f b6 55 b8          	movzbl -0x48(%ebp),%edx
  80cbf0:	83 e2 01             	and    $0x1,%edx
  80cbf3:	eb 24                	jmp    80cc19 <tcp_enqueue+0x5c9>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80cbf5:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80cbf8:	89 4f 74             	mov    %ecx,0x74(%edi)
  80cbfb:	eb 08                	jmp    80cc05 <tcp_enqueue+0x5b5>
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80cbfd:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80cc00:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cc03:	89 10                	mov    %edx,(%eax)
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80cc05:	0f b6 45 b8          	movzbl -0x48(%ebp),%eax
  80cc09:	89 c2                	mov    %eax,%edx
  80cc0b:	83 e2 01             	and    $0x1,%edx
  80cc0e:	83 e0 03             	and    $0x3,%eax
    ++len;
  80cc11:	83 f8 01             	cmp    $0x1,%eax
  80cc14:	66 83 5d b4 ff       	sbbw   $0xffffffff,-0x4c(%ebp)
  }
  if (flags & TCP_FIN) {
  80cc19:	85 d2                	test   %edx,%edx
  80cc1b:	74 04                	je     80cc21 <tcp_enqueue+0x5d1>
    pcb->flags |= TF_FIN;
  80cc1d:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  80cc21:	0f b7 45 b4          	movzwl -0x4c(%ebp),%eax
  80cc25:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80cc28:	0f b7 4d b4          	movzwl -0x4c(%ebp),%ecx
  80cc2c:	66 29 4f 6e          	sub    %cx,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80cc30:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80cc34:	66 89 47 70          	mov    %ax,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80cc38:	66 85 c0             	test   %ax,%ax
  80cc3b:	74 28                	je     80cc65 <tcp_enqueue+0x615>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80cc3d:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80cc41:	75 22                	jne    80cc65 <tcp_enqueue+0x615>
  80cc43:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80cc47:	75 1c                	jne    80cc65 <tcp_enqueue+0x615>
  80cc49:	c7 44 24 08 78 62 81 	movl   $0x816278,0x8(%esp)
  80cc50:	00 
  80cc51:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80cc58:	00 
  80cc59:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80cc60:	e8 53 3d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80cc65:	85 db                	test   %ebx,%ebx
  80cc67:	0f 84 ad 00 00 00    	je     80cd1a <tcp_enqueue+0x6ca>
  80cc6d:	66 85 f6             	test   %si,%si
  80cc70:	0f 84 a4 00 00 00    	je     80cd1a <tcp_enqueue+0x6ca>
  80cc76:	8b 5b 10             	mov    0x10(%ebx),%ebx
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  80cc79:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80cc7e:	85 db                	test   %ebx,%ebx
  80cc80:	0f 84 a0 00 00 00    	je     80cd26 <tcp_enqueue+0x6d6>
  80cc86:	f6 45 98 02          	testb  $0x2,-0x68(%ebp)
  80cc8a:	0f 85 96 00 00 00    	jne    80cd26 <tcp_enqueue+0x6d6>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80cc90:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80cc94:	89 04 24             	mov    %eax,(%esp)
  80cc97:	e8 2a f7 ff ff       	call   80c3c6 <ntohs>
  80cc9c:	83 c8 08             	or     $0x8,%eax
  80cc9f:	0f b7 c0             	movzwl %ax,%eax
  80cca2:	89 04 24             	mov    %eax,(%esp)
  80cca5:	e8 0f f7 ff ff       	call   80c3b9 <htons>
  80ccaa:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  }

  return ERR_OK;
  80ccae:	b8 00 00 00 00       	mov    $0x0,%eax
  80ccb3:	eb 71                	jmp    80cd26 <tcp_enqueue+0x6d6>
  80ccb5:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80ccb8:	eb 17                	jmp    80ccd1 <tcp_enqueue+0x681>
  80ccba:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80ccbd:	eb 12                	jmp    80ccd1 <tcp_enqueue+0x681>
  80ccbf:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80ccc2:	eb 0d                	jmp    80ccd1 <tcp_enqueue+0x681>
  80ccc4:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80ccc7:	eb 08                	jmp    80ccd1 <tcp_enqueue+0x681>
  80ccc9:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80cccc:	eb 03                	jmp    80ccd1 <tcp_enqueue+0x681>
  80ccce:	8b 7d dc             	mov    -0x24(%ebp),%edi
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80ccd1:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80ccd5:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
  80ccd9:	74 0b                	je     80cce6 <tcp_enqueue+0x696>
    tcp_segs_free(queue);
  80ccdb:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80ccde:	89 14 24             	mov    %edx,(%esp)
  80cce1:	e8 2b d6 ff ff       	call   80a311 <tcp_segs_free>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  80cce6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
    tcp_segs_free(queue);
  }
  if (pcb->snd_queuelen != 0) {
  80cceb:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80ccf0:	74 34                	je     80cd26 <tcp_enqueue+0x6d6>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80ccf2:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80ccf6:	75 29                	jne    80cd21 <tcp_enqueue+0x6d1>
  80ccf8:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80ccfc:	75 28                	jne    80cd26 <tcp_enqueue+0x6d6>
  80ccfe:	c7 44 24 08 78 62 81 	movl   $0x816278,0x8(%esp)
  80cd05:	00 
  80cd06:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80cd0d:	00 
  80cd0e:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80cd15:	e8 9e 3c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  }

  return ERR_OK;
  80cd1a:	b8 00 00 00 00       	mov    $0x0,%eax
  80cd1f:	eb 05                	jmp    80cd26 <tcp_enqueue+0x6d6>
  if (pcb->snd_queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
  80cd21:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80cd26:	83 c4 6c             	add    $0x6c,%esp
  80cd29:	5b                   	pop    %ebx
  80cd2a:	5e                   	pop    %esi
  80cd2b:	5f                   	pop    %edi
  80cd2c:	5d                   	pop    %ebp
  80cd2d:	c3                   	ret    
    }
    memp_free(MEMP_TCP_SEG, queue);
  }
  else {
    /* empty list */
    if (useg == NULL) {
  80cd2e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80cd32:	0f 85 c5 fe ff ff    	jne    80cbfd <tcp_enqueue+0x5ad>
  80cd38:	e9 b8 fe ff ff       	jmp    80cbf5 <tcp_enqueue+0x5a5>

0080cd3d <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80cd3d:	55                   	push   %ebp
  80cd3e:	89 e5                	mov    %esp,%ebp
  80cd40:	53                   	push   %ebx
  80cd41:	83 ec 24             	sub    $0x24,%esp
  80cd44:	8b 55 08             	mov    0x8(%ebp),%edx
  80cd47:	0f b7 4d 10          	movzwl 0x10(%ebp),%ecx
  80cd4b:	0f b6 5d 14          	movzbl 0x14(%ebp),%ebx
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80cd4f:	8b 42 10             	mov    0x10(%edx),%eax
  80cd52:	83 f8 04             	cmp    $0x4,%eax
  80cd55:	74 0f                	je     80cd66 <tcp_write+0x29>
  80cd57:	83 f8 07             	cmp    $0x7,%eax
  80cd5a:	74 0a                	je     80cd66 <tcp_write+0x29>
  80cd5c:	83 f8 02             	cmp    $0x2,%eax
  80cd5f:	74 05                	je     80cd66 <tcp_write+0x29>
  80cd61:	83 f8 03             	cmp    $0x3,%eax
  80cd64:	75 41                	jne    80cda7 <tcp_write+0x6a>
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
    }
    return ERR_OK;
  80cd66:	b8 00 00 00 00       	mov    $0x0,%eax
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80cd6b:	66 85 c9             	test   %cx,%cx
  80cd6e:	74 3c                	je     80cdac <tcp_write+0x6f>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80cd70:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80cd77:	00 
  80cd78:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80cd7f:	00 
  80cd80:	0f b6 db             	movzbl %bl,%ebx
  80cd83:	89 5c 24 10          	mov    %ebx,0x10(%esp)
  80cd87:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80cd8e:	00 
  80cd8f:	0f b7 c9             	movzwl %cx,%ecx
  80cd92:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80cd96:	8b 45 0c             	mov    0xc(%ebp),%eax
  80cd99:	89 44 24 04          	mov    %eax,0x4(%esp)
  80cd9d:	89 14 24             	mov    %edx,(%esp)
  80cda0:	e8 ab f8 ff ff       	call   80c650 <tcp_enqueue>
  80cda5:	eb 05                	jmp    80cdac <tcp_write+0x6f>
    }
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  80cda7:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  }
}
  80cdac:	83 c4 24             	add    $0x24,%esp
  80cdaf:	5b                   	pop    %ebx
  80cdb0:	5d                   	pop    %ebp
  80cdb1:	c3                   	ret    

0080cdb2 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80cdb2:	55                   	push   %ebp
  80cdb3:	89 e5                	mov    %esp,%ebp
  80cdb5:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80cdb8:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80cdbf:	00 
  80cdc0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80cdc7:	00 
  80cdc8:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80cdcf:	00 
  80cdd0:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80cdd4:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80cdd8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80cddf:	00 
  80cde0:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80cde7:	00 
  80cde8:	8b 45 08             	mov    0x8(%ebp),%eax
  80cdeb:	89 04 24             	mov    %eax,(%esp)
  80cdee:	e8 5d f8 ff ff       	call   80c650 <tcp_enqueue>
}
  80cdf3:	c9                   	leave  
  80cdf4:	c3                   	ret    

0080cdf5 <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80cdf5:	55                   	push   %ebp
  80cdf6:	89 e5                	mov    %esp,%ebp
  80cdf8:	57                   	push   %edi
  80cdf9:	56                   	push   %esi
  80cdfa:	53                   	push   %ebx
  80cdfb:	83 ec 3c             	sub    $0x3c,%esp
  80cdfe:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80ce01:	39 35 28 14 b4 00    	cmp    %esi,0xb41428
  80ce07:	0f 84 70 04 00 00    	je     80d27d <tcp_output+0x488>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80ce0d:	0f b7 56 5c          	movzwl 0x5c(%esi),%edx
  80ce11:	0f b7 46 4e          	movzwl 0x4e(%esi),%eax
  80ce15:	0f b7 ca             	movzwl %dx,%ecx
  80ce18:	0f b7 d8             	movzwl %ax,%ebx
  80ce1b:	66 39 c2             	cmp    %ax,%dx
  80ce1e:	0f 43 cb             	cmovae %ebx,%ecx
  80ce21:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  seg = pcb->unsent;
  80ce24:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80ce27:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  80ce2a:	85 ff                	test   %edi,%edi
  80ce2c:	75 04                	jne    80ce32 <tcp_output+0x3d>
  80ce2e:	eb 08                	jmp    80ce38 <tcp_output+0x43>
    for (; useg->next != NULL; useg = useg->next);
  80ce30:	89 c7                	mov    %eax,%edi
  80ce32:	8b 07                	mov    (%edi),%eax
  80ce34:	85 c0                	test   %eax,%eax
  80ce36:	75 f8                	jne    80ce30 <tcp_output+0x3b>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80ce38:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  80ce3c:	0f 84 ac 03 00 00    	je     80d1ee <tcp_output+0x3f9>
  80ce42:	85 db                	test   %ebx,%ebx
  80ce44:	74 21                	je     80ce67 <tcp_output+0x72>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80ce46:	8b 43 10             	mov    0x10(%ebx),%eax
  80ce49:	8b 40 04             	mov    0x4(%eax),%eax
  80ce4c:	89 04 24             	mov    %eax,(%esp)
  80ce4f:	e8 e5 f7 ff ff       	call   80c639 <ntohl>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80ce54:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80ce58:	2b 56 48             	sub    0x48(%esi),%edx
  80ce5b:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80ce5e:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80ce61:	0f 83 87 03 00 00    	jae    80d1ee <tcp_output+0x3f9>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80ce67:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ce6e:	00 
  80ce6f:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80ce76:	00 
  80ce77:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80ce7e:	e8 a2 c5 ff ff       	call   809425 <pbuf_alloc>
  80ce83:	89 c3                	mov    %eax,%ebx
    if (p == NULL) {
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
  80ce85:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
    if (p == NULL) {
  80ce8a:	85 db                	test   %ebx,%ebx
  80ce8c:	0f 84 f0 03 00 00    	je     80d282 <tcp_output+0x48d>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80ce92:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = (struct tcp_hdr *) p->payload;
  80ce96:	8b 7b 04             	mov    0x4(%ebx),%edi
    tcphdr->src = htons(pcb->local_port);
  80ce99:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80ce9d:	89 04 24             	mov    %eax,(%esp)
  80cea0:	e8 14 f5 ff ff       	call   80c3b9 <htons>
  80cea5:	66 89 07             	mov    %ax,(%edi)
    tcphdr->dest = htons(pcb->remote_port);
  80cea8:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80ceac:	89 04 24             	mov    %eax,(%esp)
  80ceaf:	e8 05 f5 ff ff       	call   80c3b9 <htons>
  80ceb4:	66 89 47 02          	mov    %ax,0x2(%edi)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80ceb8:	8b 46 54             	mov    0x54(%esi),%eax
  80cebb:	89 04 24             	mov    %eax,(%esp)
  80cebe:	e8 17 f5 ff ff       	call   80c3da <htonl>
  80cec3:	89 47 04             	mov    %eax,0x4(%edi)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80cec6:	8b 46 24             	mov    0x24(%esi),%eax
  80cec9:	89 04 24             	mov    %eax,(%esp)
  80cecc:	e8 09 f5 ff ff       	call   80c3da <htonl>
  80ced1:	89 47 08             	mov    %eax,0x8(%edi)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80ced4:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80ced8:	89 04 24             	mov    %eax,(%esp)
  80cedb:	e8 e6 f4 ff ff       	call   80c3c6 <ntohs>
  80cee0:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80cee5:	83 c8 10             	or     $0x10,%eax
  80cee8:	89 04 24             	mov    %eax,(%esp)
  80ceeb:	e8 c9 f4 ff ff       	call   80c3b9 <htons>
  80cef0:	66 89 47 0c          	mov    %ax,0xc(%edi)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80cef4:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80cef8:	89 04 24             	mov    %eax,(%esp)
  80cefb:	e8 b9 f4 ff ff       	call   80c3b9 <htons>
  80cf00:	66 89 47 0e          	mov    %ax,0xe(%edi)
    tcphdr->urgp = 0;
  80cf04:	66 c7 47 12 00 00    	movw   $0x0,0x12(%edi)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80cf0a:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80cf0e:	89 04 24             	mov    %eax,(%esp)
  80cf11:	e8 b0 f4 ff ff       	call   80c3c6 <ntohs>
  80cf16:	83 e0 3f             	and    $0x3f,%eax
  80cf19:	80 cc 50             	or     $0x50,%ah
  80cf1c:	89 04 24             	mov    %eax,(%esp)
  80cf1f:	e8 95 f4 ff ff       	call   80c3b9 <htons>
  80cf24:	66 89 47 0c          	mov    %ax,0xc(%edi)

    tcphdr->chksum = 0;
  80cf28:	66 c7 47 10 00 00    	movw   $0x0,0x10(%edi)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
          IP_PROTO_TCP, p->tot_len);
  80cf2e:	8d 46 04             	lea    0x4(%esi),%eax
  80cf31:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cf34:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80cf38:	89 44 24 10          	mov    %eax,0x10(%esp)
  80cf3c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80cf43:	00 
  80cf44:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80cf47:	89 54 24 08          	mov    %edx,0x8(%esp)
  80cf4b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cf4f:	89 1c 24             	mov    %ebx,(%esp)
  80cf52:	e8 e6 f0 ff ff       	call   80c03d <inet_chksum_pseudo>
  80cf57:	66 89 47 10          	mov    %ax,0x10(%edi)
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
        IP_PROTO_TCP);
  80cf5b:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80cf62:	00 
  80cf63:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80cf67:	89 44 24 10          	mov    %eax,0x10(%esp)
  80cf6b:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80cf6f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80cf73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80cf76:	89 44 24 08          	mov    %eax,0x8(%esp)
  80cf7a:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cf7e:	89 1c 24             	mov    %ebx,(%esp)
  80cf81:	e8 63 e5 ff ff       	call   80b4e9 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80cf86:	89 1c 24             	mov    %ebx,(%esp)
  80cf89:	e8 75 c2 ff ff       	call   809203 <pbuf_free>

    return ERR_OK;
  80cf8e:	b8 00 00 00 00       	mov    $0x0,%eax
  80cf93:	e9 ea 02 00 00       	jmp    80d282 <tcp_output+0x48d>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80cf98:	c7 44 24 08 ff 62 81 	movl   $0x8162ff,0x8(%esp)
  80cf9f:	00 
  80cfa0:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80cfa7:	00 
  80cfa8:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80cfaf:	e8 04 3a ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80cfb4:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80cfb8:	74 1c                	je     80cfd6 <tcp_output+0x1e1>
  80cfba:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80cfbe:	a8 40                	test   $0x40,%al
  80cfc0:	75 14                	jne    80cfd6 <tcp_output+0x1e1>
  80cfc2:	8b 56 74             	mov    0x74(%esi),%edx
  80cfc5:	85 d2                	test   %edx,%edx
  80cfc7:	74 05                	je     80cfce <tcp_output+0x1d9>
  80cfc9:	83 3a 00             	cmpl   $0x0,(%edx)
  80cfcc:	75 08                	jne    80cfd6 <tcp_output+0x1e1>
  80cfce:	a8 a0                	test   $0xa0,%al
  80cfd0:	0f 84 62 02 00 00    	je     80d238 <tcp_output+0x443>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80cfd6:	8b 03                	mov    (%ebx),%eax
  80cfd8:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80cfdb:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80cfdf:	74 25                	je     80d006 <tcp_output+0x211>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80cfe1:	8b 7b 10             	mov    0x10(%ebx),%edi
  80cfe4:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80cfe8:	89 04 24             	mov    %eax,(%esp)
  80cfeb:	e8 d6 f3 ff ff       	call   80c3c6 <ntohs>
  80cff0:	83 c8 10             	or     $0x10,%eax
  80cff3:	0f b7 c0             	movzwl %ax,%eax
  80cff6:	89 04 24             	mov    %eax,(%esp)
  80cff9:	e8 bb f3 ff ff       	call   80c3b9 <htons>
  80cffe:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80d002:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80d006:	8b 7b 10             	mov    0x10(%ebx),%edi
  80d009:	8b 46 24             	mov    0x24(%esi),%eax
  80d00c:	89 04 24             	mov    %eax,(%esp)
  80d00f:	e8 c6 f3 ff ff       	call   80c3da <htonl>
  80d014:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80d017:	8b 7b 10             	mov    0x10(%ebx),%edi
  80d01a:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80d01e:	89 04 24             	mov    %eax,(%esp)
  80d021:	e8 93 f3 ff ff       	call   80c3b9 <htons>
  80d026:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80d02a:	85 f6                	test   %esi,%esi
  80d02c:	74 05                	je     80d033 <tcp_output+0x23e>
  80d02e:	83 3e 00             	cmpl   $0x0,(%esi)
  80d031:	75 22                	jne    80d055 <tcp_output+0x260>
    netif = ip_route(&(pcb->remote_ip));
  80d033:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d036:	89 14 24             	mov    %edx,(%esp)
  80d039:	e8 e2 df ff ff       	call   80b020 <ip_route>
    if (netif == NULL) {
  80d03e:	85 c0                	test   %eax,%eax
  80d040:	0f 84 bd 00 00 00    	je     80d103 <tcp_output+0x30e>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80d046:	ba 00 00 00 00       	mov    $0x0,%edx
  80d04b:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80d04e:	74 03                	je     80d053 <tcp_output+0x25e>
  80d050:	8b 50 04             	mov    0x4(%eax),%edx
  80d053:	89 16                	mov    %edx,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80d055:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  80d05a:	75 06                	jne    80d062 <tcp_output+0x26d>
    pcb->rtime = 0;
  80d05c:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  80d062:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  80d066:	75 19                	jne    80d081 <tcp_output+0x28c>
    pcb->rttest = tcp_ticks;
  80d068:	a1 d0 a3 b3 00       	mov    0xb3a3d0,%eax
  80d06d:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80d070:	8b 43 10             	mov    0x10(%ebx),%eax
  80d073:	8b 40 04             	mov    0x4(%eax),%eax
  80d076:	89 04 24             	mov    %eax,(%esp)
  80d079:	e8 bb f5 ff ff       	call   80c639 <ntohl>
  80d07e:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80d081:	8b 43 04             	mov    0x4(%ebx),%eax
  80d084:	8b 53 10             	mov    0x10(%ebx),%edx
  80d087:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80d08b:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80d08f:	8b 43 04             	mov    0x4(%ebx),%eax
  80d092:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80d096:	8b 43 04             	mov    0x4(%ebx),%eax
  80d099:	8b 53 10             	mov    0x10(%ebx),%edx
  80d09c:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  80d09f:	8b 43 10             	mov    0x10(%ebx),%eax
  80d0a2:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80d0a8:	8b 7b 10             	mov    0x10(%ebx),%edi
  80d0ab:	8b 43 04             	mov    0x4(%ebx),%eax
  80d0ae:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80d0b2:	89 54 24 10          	mov    %edx,0x10(%esp)
  80d0b6:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80d0bd:	00 
  80d0be:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d0c1:	89 54 24 08          	mov    %edx,0x8(%esp)
  80d0c5:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d0c9:	89 04 24             	mov    %eax,(%esp)
  80d0cc:	e8 6c ef ff ff       	call   80c03d <inet_chksum_pseudo>
  80d0d1:	66 89 47 10          	mov    %ax,0x10(%edi)
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
      IP_PROTO_TCP);
  80d0d5:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80d0dc:	00 
  80d0dd:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80d0e1:	89 44 24 10          	mov    %eax,0x10(%esp)
  80d0e5:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80d0e9:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d0ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d0f0:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d0f4:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d0f8:	8b 43 04             	mov    0x4(%ebx),%eax
  80d0fb:	89 04 24             	mov    %eax,(%esp)
  80d0fe:	e8 e6 e3 ff ff       	call   80b4e9 <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80d103:	8b 43 10             	mov    0x10(%ebx),%eax
  80d106:	8b 40 04             	mov    0x4(%eax),%eax
  80d109:	89 04 24             	mov    %eax,(%esp)
  80d10c:	e8 28 f5 ff ff       	call   80c639 <ntohl>
  80d111:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80d114:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80d118:	8b 43 10             	mov    0x10(%ebx),%eax
  80d11b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d11f:	89 04 24             	mov    %eax,(%esp)
  80d122:	e8 9f f2 ff ff       	call   80c3c6 <ntohs>
  80d127:	ba 01 00 00 00       	mov    $0x1,%edx
  80d12c:	a8 01                	test   $0x1,%al
  80d12e:	75 18                	jne    80d148 <tcp_output+0x353>
  80d130:	8b 43 10             	mov    0x10(%ebx),%eax
  80d133:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d137:	89 04 24             	mov    %eax,(%esp)
  80d13a:	e8 87 f2 ff ff       	call   80c3c6 <ntohs>
  80d13f:	83 e0 02             	and    $0x2,%eax
  80d142:	0f 95 c2             	setne  %dl
  80d145:	0f b6 d2             	movzbl %dl,%edx
  80d148:	8d 3c 3a             	lea    (%edx,%edi,1),%edi
  80d14b:	03 7d e0             	add    -0x20(%ebp),%edi
  80d14e:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80d151:	39 7e 58             	cmp    %edi,0x58(%esi)
  80d154:	79 03                	jns    80d159 <tcp_output+0x364>
      pcb->snd_max = pcb->snd_nxt;
  80d156:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80d159:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80d15d:	8b 43 10             	mov    0x10(%ebx),%eax
  80d160:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d164:	89 04 24             	mov    %eax,(%esp)
  80d167:	e8 5a f2 ff ff       	call   80c3c6 <ntohs>
  80d16c:	ba 01 00 00 00       	mov    $0x1,%edx
  80d171:	a8 01                	test   $0x1,%al
  80d173:	75 18                	jne    80d18d <tcp_output+0x398>
  80d175:	8b 43 10             	mov    0x10(%ebx),%eax
  80d178:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d17c:	89 04 24             	mov    %eax,(%esp)
  80d17f:	e8 42 f2 ff ff       	call   80c3c6 <ntohs>
  80d184:	83 e0 02             	and    $0x2,%eax
  80d187:	0f 95 c2             	setne  %dl
  80d18a:	0f b6 d2             	movzbl %dl,%edx
  80d18d:	8d 3c 3a             	lea    (%edx,%edi,1),%edi
  80d190:	85 ff                	test   %edi,%edi
  80d192:	7e 4d                	jle    80d1e1 <tcp_output+0x3ec>
      seg->next = NULL;
  80d194:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80d19a:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80d19e:	75 08                	jne    80d1a8 <tcp_output+0x3b3>
        pcb->unacked = seg;
  80d1a0:	89 5e 78             	mov    %ebx,0x78(%esi)
  80d1a3:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  80d1a6:	eb 41                	jmp    80d1e9 <tcp_output+0x3f4>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80d1a8:	8b 43 10             	mov    0x10(%ebx),%eax
  80d1ab:	8b 40 04             	mov    0x4(%eax),%eax
  80d1ae:	89 04 24             	mov    %eax,(%esp)
  80d1b1:	e8 83 f4 ff ff       	call   80c639 <ntohl>
  80d1b6:	89 c7                	mov    %eax,%edi
  80d1b8:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80d1bb:	8b 42 10             	mov    0x10(%edx),%eax
  80d1be:	8b 40 04             	mov    0x4(%eax),%eax
  80d1c1:	89 04 24             	mov    %eax,(%esp)
  80d1c4:	e8 70 f4 ff ff       	call   80c639 <ntohl>
  80d1c9:	39 c7                	cmp    %eax,%edi
  80d1cb:	79 0a                	jns    80d1d7 <tcp_output+0x3e2>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80d1cd:	8b 46 78             	mov    0x78(%esi),%eax
  80d1d0:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80d1d2:	89 5e 78             	mov    %ebx,0x78(%esi)
  80d1d5:	eb 12                	jmp    80d1e9 <tcp_output+0x3f4>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80d1d7:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80d1da:	89 18                	mov    %ebx,(%eax)
  80d1dc:	89 5d dc             	mov    %ebx,-0x24(%ebp)
  80d1df:	eb 08                	jmp    80d1e9 <tcp_output+0x3f4>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80d1e1:	89 1c 24             	mov    %ebx,(%esp)
  80d1e4:	e8 e3 d0 ff ff       	call   80a2cc <tcp_seg_free>
    }
    seg = pcb->unsent;
  80d1e9:	8b 5e 74             	mov    0x74(%esi),%ebx
  80d1ec:	eb 09                	jmp    80d1f7 <tcp_output+0x402>
  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80d1ee:	8d 56 04             	lea    0x4(%esi),%edx
  80d1f1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80d1f4:	89 7d dc             	mov    %edi,-0x24(%ebp)
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80d1f7:	85 db                	test   %ebx,%ebx
  80d1f9:	0f 84 8b 00 00 00    	je     80d28a <tcp_output+0x495>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80d1ff:	8b 43 10             	mov    0x10(%ebx),%eax
  80d202:	8b 40 04             	mov    0x4(%eax),%eax
  80d205:	89 04 24             	mov    %eax,(%esp)
  80d208:	e8 2c f4 ff ff       	call   80c639 <ntohl>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80d20d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d211:	2b 56 48             	sub    0x48(%esi),%edx
  80d214:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80d217:	39 45 d8             	cmp    %eax,-0x28(%ebp)
  80d21a:	72 6e                	jb     80d28a <tcp_output+0x495>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80d21c:	8b 43 10             	mov    0x10(%ebx),%eax
  80d21f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d223:	89 04 24             	mov    %eax,(%esp)
  80d226:	e8 9b f1 ff ff       	call   80c3c6 <ntohs>
  80d22b:	a8 04                	test   $0x4,%al
  80d22d:	0f 84 81 fd ff ff    	je     80cfb4 <tcp_output+0x1bf>
  80d233:	e9 60 fd ff ff       	jmp    80cf98 <tcp_output+0x1a3>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80d238:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  80d23f:	90                   	nop
  80d240:	75 30                	jne    80d272 <tcp_output+0x47d>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80d242:	8b 43 10             	mov    0x10(%ebx),%eax
  80d245:	8b 40 04             	mov    0x4(%eax),%eax
  80d248:	89 04 24             	mov    %eax,(%esp)
  80d24b:	e8 e9 f3 ff ff       	call   80c639 <ntohl>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80d250:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80d254:	2b 56 48             	sub    0x48(%esi),%edx
  80d257:	01 c2                	add    %eax,%edx
  80d259:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80d25d:	39 c2                	cmp    %eax,%edx
  80d25f:	76 11                	jbe    80d272 <tcp_output+0x47d>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80d261:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  80d268:	00 00 00 
    pcb->persist_backoff = 1;
  80d26b:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80d272:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  return ERR_OK;
  80d276:	b8 00 00 00 00       	mov    $0x0,%eax
  80d27b:	eb 05                	jmp    80d282 <tcp_output+0x48d>
  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
    return ERR_OK;
  80d27d:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb->persist_backoff = 1;
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  return ERR_OK;
}
  80d282:	83 c4 3c             	add    $0x3c,%esp
  80d285:	5b                   	pop    %ebx
  80d286:	5e                   	pop    %esi
  80d287:	5f                   	pop    %edi
  80d288:	5d                   	pop    %ebp
  80d289:	c3                   	ret    
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80d28a:	85 db                	test   %ebx,%ebx
  80d28c:	75 aa                	jne    80d238 <tcp_output+0x443>
  80d28e:	eb e2                	jmp    80d272 <tcp_output+0x47d>

0080d290 <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80d290:	55                   	push   %ebp
  80d291:	89 e5                	mov    %esp,%ebp
  80d293:	57                   	push   %edi
  80d294:	56                   	push   %esi
  80d295:	53                   	push   %ebx
  80d296:	83 ec 3c             	sub    $0x3c,%esp
  80d299:	8b 7d 14             	mov    0x14(%ebp),%edi
  80d29c:	0f b7 45 18          	movzwl 0x18(%ebp),%eax
  80d2a0:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80d2a4:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  80d2a8:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80d2ac:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80d2b3:	00 
  80d2b4:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80d2bb:	00 
  80d2bc:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d2c3:	e8 5d c1 ff ff       	call   809425 <pbuf_alloc>
  80d2c8:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80d2ca:	85 c0                	test   %eax,%eax
  80d2cc:	0f 84 15 01 00 00    	je     80d3e7 <tcp_rst+0x157>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80d2d2:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80d2d7:	77 1c                	ja     80d2f5 <tcp_rst+0x65>
  80d2d9:	c7 44 24 08 98 62 81 	movl   $0x816298,0x8(%esp)
  80d2e0:	00 
  80d2e1:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  80d2e8:	00 
  80d2e9:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80d2f0:	e8 c3 36 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *) p->payload;
  80d2f5:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80d2f8:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80d2fc:	89 04 24             	mov    %eax,(%esp)
  80d2ff:	e8 b5 f0 ff ff       	call   80c3b9 <htons>
  80d304:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80d307:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80d30b:	89 04 24             	mov    %eax,(%esp)
  80d30e:	e8 a6 f0 ff ff       	call   80c3b9 <htons>
  80d313:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80d317:	8b 45 08             	mov    0x8(%ebp),%eax
  80d31a:	89 04 24             	mov    %eax,(%esp)
  80d31d:	e8 b8 f0 ff ff       	call   80c3da <htonl>
  80d322:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80d325:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d328:	89 04 24             	mov    %eax,(%esp)
  80d32b:	e8 aa f0 ff ff       	call   80c3da <htonl>
  80d330:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80d333:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d337:	89 04 24             	mov    %eax,(%esp)
  80d33a:	e8 87 f0 ff ff       	call   80c3c6 <ntohs>
  80d33f:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80d344:	83 c8 14             	or     $0x14,%eax
  80d347:	89 04 24             	mov    %eax,(%esp)
  80d34a:	e8 6a f0 ff ff       	call   80c3b9 <htons>
  80d34f:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80d353:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80d35a:	e8 5a f0 ff ff       	call   80c3b9 <htons>
  80d35f:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80d363:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80d369:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d36d:	89 04 24             	mov    %eax,(%esp)
  80d370:	e8 51 f0 ff ff       	call   80c3c6 <ntohs>
  80d375:	83 e0 3f             	and    $0x3f,%eax
  80d378:	80 cc 50             	or     $0x50,%ah
  80d37b:	89 04 24             	mov    %eax,(%esp)
  80d37e:	e8 36 f0 ff ff       	call   80c3b9 <htons>
  80d383:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80d387:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
              IP_PROTO_TCP, p->tot_len);
  80d38d:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80d391:	89 44 24 10          	mov    %eax,0x10(%esp)
  80d395:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80d39c:	00 
  80d39d:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80d3a1:	8b 45 10             	mov    0x10(%ebp),%eax
  80d3a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d3a8:	89 34 24             	mov    %esi,(%esp)
  80d3ab:	e8 8d ec ff ff       	call   80c03d <inet_chksum_pseudo>
  80d3b0:	66 89 43 10          	mov    %ax,0x10(%ebx)
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80d3b4:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80d3bb:	00 
  80d3bc:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80d3c3:	00 
  80d3c4:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80d3cb:	00 
  80d3cc:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80d3d0:	8b 45 10             	mov    0x10(%ebp),%eax
  80d3d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d3d7:	89 34 24             	mov    %esi,(%esp)
  80d3da:	e8 0a e1 ff ff       	call   80b4e9 <ip_output>
  pbuf_free(p);
  80d3df:	89 34 24             	mov    %esi,(%esp)
  80d3e2:	e8 1c be ff ff       	call   809203 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80d3e7:	83 c4 3c             	add    $0x3c,%esp
  80d3ea:	5b                   	pop    %ebx
  80d3eb:	5e                   	pop    %esi
  80d3ec:	5f                   	pop    %edi
  80d3ed:	5d                   	pop    %ebp
  80d3ee:	c3                   	ret    

0080d3ef <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80d3ef:	55                   	push   %ebp
  80d3f0:	89 e5                	mov    %esp,%ebp
  80d3f2:	53                   	push   %ebx
  80d3f3:	83 ec 14             	sub    $0x14,%esp
  80d3f6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80d3f9:	8b 53 78             	mov    0x78(%ebx),%edx
  80d3fc:	85 d2                	test   %edx,%edx
  80d3fe:	75 04                	jne    80d404 <tcp_rexmit_rto+0x15>
  80d400:	eb 3e                	jmp    80d440 <tcp_rexmit_rto+0x51>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80d402:	89 c2                	mov    %eax,%edx
  80d404:	8b 02                	mov    (%edx),%eax
  80d406:	85 c0                	test   %eax,%eax
  80d408:	75 f8                	jne    80d402 <tcp_rexmit_rto+0x13>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80d40a:	8b 43 74             	mov    0x74(%ebx),%eax
  80d40d:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80d40f:	8b 43 78             	mov    0x78(%ebx),%eax
  80d412:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80d415:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80d41c:	8b 40 10             	mov    0x10(%eax),%eax
  80d41f:	8b 40 04             	mov    0x4(%eax),%eax
  80d422:	89 04 24             	mov    %eax,(%esp)
  80d425:	e8 0f f2 ff ff       	call   80c639 <ntohl>
  80d42a:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80d42d:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80d431:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80d438:	89 1c 24             	mov    %ebx,(%esp)
  80d43b:	e8 b5 f9 ff ff       	call   80cdf5 <tcp_output>
}
  80d440:	83 c4 14             	add    $0x14,%esp
  80d443:	5b                   	pop    %ebx
  80d444:	5d                   	pop    %ebp
  80d445:	c3                   	ret    

0080d446 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80d446:	55                   	push   %ebp
  80d447:	89 e5                	mov    %esp,%ebp
  80d449:	53                   	push   %ebx
  80d44a:	83 ec 14             	sub    $0x14,%esp
  80d44d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80d450:	8b 43 78             	mov    0x78(%ebx),%eax
  80d453:	85 c0                	test   %eax,%eax
  80d455:	74 34                	je     80d48b <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80d457:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80d459:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80d45c:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80d45e:	8b 43 78             	mov    0x78(%ebx),%eax
  80d461:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80d464:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80d467:	8b 40 10             	mov    0x10(%eax),%eax
  80d46a:	8b 40 04             	mov    0x4(%eax),%eax
  80d46d:	89 04 24             	mov    %eax,(%esp)
  80d470:	e8 c4 f1 ff ff       	call   80c639 <ntohl>
  80d475:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80d478:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80d47c:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80d483:	89 1c 24             	mov    %ebx,(%esp)
  80d486:	e8 6a f9 ff ff       	call   80cdf5 <tcp_output>
}
  80d48b:	83 c4 14             	add    $0x14,%esp
  80d48e:	5b                   	pop    %ebx
  80d48f:	5d                   	pop    %ebp
  80d490:	c3                   	ret    

0080d491 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80d491:	55                   	push   %ebp
  80d492:	89 e5                	mov    %esp,%ebp
  80d494:	57                   	push   %edi
  80d495:	56                   	push   %esi
  80d496:	53                   	push   %ebx
  80d497:	83 ec 3c             	sub    $0x3c,%esp
  80d49a:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80d49d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80d4a4:	00 
  80d4a5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80d4ac:	00 
  80d4ad:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d4b4:	e8 6c bf ff ff       	call   809425 <pbuf_alloc>
  80d4b9:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80d4bb:	85 c0                	test   %eax,%eax
  80d4bd:	0f 84 1b 01 00 00    	je     80d5de <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80d4c3:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80d4c8:	77 1c                	ja     80d4e6 <tcp_keepalive+0x55>
  80d4ca:	c7 44 24 08 98 62 81 	movl   $0x816298,0x8(%esp)
  80d4d1:	00 
  80d4d2:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80d4d9:	00 
  80d4da:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80d4e1:	e8 d2 34 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *) p->payload;
  80d4e6:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80d4e9:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80d4ed:	89 04 24             	mov    %eax,(%esp)
  80d4f0:	e8 c4 ee ff ff       	call   80c3b9 <htons>
  80d4f5:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80d4f8:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80d4fc:	89 04 24             	mov    %eax,(%esp)
  80d4ff:	e8 b5 ee ff ff       	call   80c3b9 <htons>
  80d504:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80d508:	8b 46 54             	mov    0x54(%esi),%eax
  80d50b:	83 e8 01             	sub    $0x1,%eax
  80d50e:	89 04 24             	mov    %eax,(%esp)
  80d511:	e8 c4 ee ff ff       	call   80c3da <htonl>
  80d516:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80d519:	8b 46 24             	mov    0x24(%esi),%eax
  80d51c:	89 04 24             	mov    %eax,(%esp)
  80d51f:	e8 b6 ee ff ff       	call   80c3da <htonl>
  80d524:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80d527:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d52b:	89 04 24             	mov    %eax,(%esp)
  80d52e:	e8 93 ee ff ff       	call   80c3c6 <ntohs>
  80d533:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80d538:	89 04 24             	mov    %eax,(%esp)
  80d53b:	e8 79 ee ff ff       	call   80c3b9 <htons>
  80d540:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80d544:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80d548:	89 04 24             	mov    %eax,(%esp)
  80d54b:	e8 69 ee ff ff       	call   80c3b9 <htons>
  80d550:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80d554:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80d55a:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d55e:	89 04 24             	mov    %eax,(%esp)
  80d561:	e8 60 ee ff ff       	call   80c3c6 <ntohs>
  80d566:	83 e0 3f             	and    $0x3f,%eax
  80d569:	80 cc 50             	or     $0x50,%ah
  80d56c:	89 04 24             	mov    %eax,(%esp)
  80d56f:	e8 45 ee ff ff       	call   80c3b9 <htons>
  80d574:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80d578:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  80d57e:	8d 46 04             	lea    0x4(%esi),%eax
  80d581:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d584:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d588:	89 44 24 10          	mov    %eax,0x10(%esp)
  80d58c:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80d593:	00 
  80d594:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d597:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d59b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d59f:	89 3c 24             	mov    %edi,(%esp)
  80d5a2:	e8 96 ea ff ff       	call   80c03d <inet_chksum_pseudo>
  80d5a7:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80d5ab:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80d5b2:	00 
  80d5b3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80d5ba:	00 
  80d5bb:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80d5bf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d5c3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80d5c6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d5ca:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d5ce:	89 3c 24             	mov    %edi,(%esp)
  80d5d1:	e8 13 df ff ff       	call   80b4e9 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80d5d6:	89 3c 24             	mov    %edi,(%esp)
  80d5d9:	e8 25 bc ff ff       	call   809203 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80d5de:	83 c4 3c             	add    $0x3c,%esp
  80d5e1:	5b                   	pop    %ebx
  80d5e2:	5e                   	pop    %esi
  80d5e3:	5f                   	pop    %edi
  80d5e4:	5d                   	pop    %ebp
  80d5e5:	c3                   	ret    

0080d5e6 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80d5e6:	55                   	push   %ebp
  80d5e7:	89 e5                	mov    %esp,%ebp
  80d5e9:	57                   	push   %edi
  80d5ea:	56                   	push   %esi
  80d5eb:	53                   	push   %ebx
  80d5ec:	83 ec 3c             	sub    $0x3c,%esp
  80d5ef:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80d5f2:	8b 46 78             	mov    0x78(%esi),%eax
  80d5f5:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80d5f8:	85 c0                	test   %eax,%eax
  80d5fa:	75 0e                	jne    80d60a <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80d5fc:	8b 56 74             	mov    0x74(%esi),%edx
  80d5ff:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  80d602:	85 d2                	test   %edx,%edx
  80d604:	0f 84 4b 01 00 00    	je     80d755 <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80d60a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80d611:	00 
  80d612:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  80d619:	00 
  80d61a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d621:	e8 ff bd ff ff       	call   809425 <pbuf_alloc>
  80d626:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80d628:	85 c0                	test   %eax,%eax
  80d62a:	0f 84 25 01 00 00    	je     80d755 <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80d630:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80d635:	77 1c                	ja     80d653 <tcp_zero_window_probe+0x6d>
  80d637:	c7 44 24 08 98 62 81 	movl   $0x816298,0x8(%esp)
  80d63e:	00 
  80d63f:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  80d646:	00 
  80d647:	c7 04 24 c6 62 81 00 	movl   $0x8162c6,(%esp)
  80d64e:	e8 65 33 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = (struct tcp_hdr *) p->payload;
  80d653:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80d656:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80d65a:	89 04 24             	mov    %eax,(%esp)
  80d65d:	e8 57 ed ff ff       	call   80c3b9 <htons>
  80d662:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80d665:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80d669:	89 04 24             	mov    %eax,(%esp)
  80d66c:	e8 48 ed ff ff       	call   80c3b9 <htons>
  80d671:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80d675:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d678:	8b 41 10             	mov    0x10(%ecx),%eax
  80d67b:	8b 40 04             	mov    0x4(%eax),%eax
  80d67e:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80d681:	8b 46 24             	mov    0x24(%esi),%eax
  80d684:	89 04 24             	mov    %eax,(%esp)
  80d687:	e8 4e ed ff ff       	call   80c3da <htonl>
  80d68c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80d68f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d693:	89 04 24             	mov    %eax,(%esp)
  80d696:	e8 2b ed ff ff       	call   80c3c6 <ntohs>
  80d69b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80d6a0:	89 04 24             	mov    %eax,(%esp)
  80d6a3:	e8 11 ed ff ff       	call   80c3b9 <htons>
  80d6a8:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80d6ac:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80d6b0:	89 04 24             	mov    %eax,(%esp)
  80d6b3:	e8 01 ed ff ff       	call   80c3b9 <htons>
  80d6b8:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80d6bc:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80d6c2:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80d6c6:	89 04 24             	mov    %eax,(%esp)
  80d6c9:	e8 f8 ec ff ff       	call   80c3c6 <ntohs>
  80d6ce:	83 e0 3f             	and    $0x3f,%eax
  80d6d1:	80 cc 50             	or     $0x50,%ah
  80d6d4:	89 04 24             	mov    %eax,(%esp)
  80d6d7:	e8 dd ec ff ff       	call   80c3b9 <htons>
  80d6dc:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80d6e0:	8b 47 04             	mov    0x4(%edi),%eax
  80d6e3:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d6e6:	8b 51 08             	mov    0x8(%ecx),%edx
  80d6e9:	0f b6 12             	movzbl (%edx),%edx
  80d6ec:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80d6ef:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
                                      IP_PROTO_TCP, p->tot_len);
  80d6f5:	8d 46 04             	lea    0x4(%esi),%eax
  80d6f8:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80d6fb:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80d6ff:	89 44 24 10          	mov    %eax,0x10(%esp)
  80d703:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80d70a:	00 
  80d70b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d70e:	89 54 24 08          	mov    %edx,0x8(%esp)
  80d712:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d716:	89 3c 24             	mov    %edi,(%esp)
  80d719:	e8 1f e9 ff ff       	call   80c03d <inet_chksum_pseudo>
  80d71e:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80d722:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80d729:	00 
  80d72a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80d731:	00 
  80d732:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80d736:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d73a:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d73d:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80d741:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d745:	89 3c 24             	mov    %edi,(%esp)
  80d748:	e8 9c dd ff ff       	call   80b4e9 <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80d74d:	89 3c 24             	mov    %edi,(%esp)
  80d750:	e8 ae ba ff ff       	call   809203 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80d755:	83 c4 3c             	add    $0x3c,%esp
  80d758:	5b                   	pop    %ebx
  80d759:	5e                   	pop    %esi
  80d75a:	5f                   	pop    %edi
  80d75b:	5d                   	pop    %ebp
  80d75c:	c3                   	ret    
  80d75d:	00 00                	add    %al,(%eax)
	...

0080d760 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80d760:	55                   	push   %ebp
  80d761:	89 e5                	mov    %esp,%ebp
  80d763:	57                   	push   %edi
  80d764:	56                   	push   %esi
  80d765:	53                   	push   %ebx
  80d766:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = (struct ip_hdr *) p->payload;
  80d769:	8b 45 08             	mov    0x8(%ebp),%eax
  80d76c:	8b 40 04             	mov    0x4(%eax),%eax
  80d76f:	89 45 e0             	mov    %eax,-0x20(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80d772:	8b 55 08             	mov    0x8(%ebp),%edx
  80d775:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80d779:	0f b7 00             	movzwl (%eax),%eax
  80d77c:	89 04 24             	mov    %eax,(%esp)
  80d77f:	e8 42 ec ff ff       	call   80c3c6 <ntohs>
  80d784:	0f b6 c4             	movzbl %ah,%eax
  80d787:	83 e0 0f             	and    $0xf,%eax
  80d78a:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80d791:	39 c3                	cmp    %eax,%ebx
  80d793:	7c 2e                	jl     80d7c3 <udp_input+0x63>
  80d795:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d798:	0f b7 02             	movzwl (%edx),%eax
  80d79b:	89 04 24             	mov    %eax,(%esp)
  80d79e:	e8 23 ec ff ff       	call   80c3c6 <ntohs>
  80d7a3:	c1 e8 06             	shr    $0x6,%eax
  80d7a6:	83 e0 3c             	and    $0x3c,%eax
  80d7a9:	f7 d8                	neg    %eax
  80d7ab:	98                   	cwtl   
  80d7ac:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d7b0:	8b 45 08             	mov    0x8(%ebp),%eax
  80d7b3:	89 04 24             	mov    %eax,(%esp)
  80d7b6:	e8 55 b9 ff ff       	call   809110 <pbuf_header>
  80d7bb:	84 c0                	test   %al,%al
  80d7bd:	0f 84 cf 02 00 00    	je     80da92 <udp_input+0x332>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80d7c3:	8b 55 08             	mov    0x8(%ebp),%edx
  80d7c6:	89 14 24             	mov    %edx,(%esp)
  80d7c9:	e8 35 ba ff ff       	call   809203 <pbuf_free>
    goto end;
  80d7ce:	e9 19 03 00 00       	jmp    80daec <udp_input+0x38c>
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80d7d3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80d7d8:	66 83 7d e6 43       	cmpw   $0x43,-0x1a(%ebp)
  80d7dd:	0f 85 16 01 00 00    	jne    80d8f9 <udp_input+0x199>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80d7e3:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d7e6:	8b 42 20             	mov    0x20(%edx),%eax
  80d7e9:	85 c0                	test   %eax,%eax
  80d7eb:	0f 84 03 01 00 00    	je     80d8f4 <udp_input+0x194>
  80d7f1:	8b 58 08             	mov    0x8(%eax),%ebx
  80d7f4:	85 db                	test   %ebx,%ebx
  80d7f6:	0f 84 fd 00 00 00    	je     80d8f9 <udp_input+0x199>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80d7fc:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80d7ff:	0f 84 06 01 00 00    	je     80d90b <udp_input+0x1ab>
  80d805:	8b 43 04             	mov    0x4(%ebx),%eax
  80d808:	85 c0                	test   %eax,%eax
  80d80a:	0f 84 fb 00 00 00    	je     80d90b <udp_input+0x1ab>
  80d810:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d813:	3b 42 0c             	cmp    0xc(%edx),%eax
  80d816:	0f 84 ef 00 00 00    	je     80d90b <udp_input+0x1ab>
  80d81c:	bb 00 00 00 00       	mov    $0x0,%ebx
  80d821:	e9 d3 00 00 00       	jmp    80d8f9 <udp_input+0x199>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80d826:	8b 1d f4 a9 b3 00    	mov    0xb3a9f4,%ebx
  80d82c:	85 db                	test   %ebx,%ebx
  80d82e:	0f 84 a9 02 00 00    	je     80dadd <udp_input+0x37d>
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  80d834:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
      }
    }
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
  80d83b:	bf 00 00 00 00       	mov    $0x0,%edi
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80d840:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d843:	83 c0 10             	add    $0x10,%eax
  80d846:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80d849:	eb 04                	jmp    80d84f <udp_input+0xef>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80d84b:	89 df                	mov    %ebx,%edi
  80d84d:	89 c3                	mov    %eax,%ebx
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80d84f:	66 39 73 12          	cmp    %si,0x12(%ebx)
  80d853:	75 7f                	jne    80d8d4 <udp_input+0x174>
  80d855:	85 db                	test   %ebx,%ebx
  80d857:	74 24                	je     80d87d <udp_input+0x11d>
  80d859:	8b 03                	mov    (%ebx),%eax
  80d85b:	85 c0                	test   %eax,%eax
  80d85d:	74 1e                	je     80d87d <udp_input+0x11d>
  80d85f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d862:	3b 42 10             	cmp    0x10(%edx),%eax
  80d865:	74 16                	je     80d87d <udp_input+0x11d>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80d867:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d86a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d86e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80d871:	89 14 24             	mov    %edx,(%esp)
  80d874:	e8 67 d7 ff ff       	call   80afe0 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80d879:	84 c0                	test   %al,%al
  80d87b:	74 57                	je     80d8d4 <udp_input+0x174>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80d87d:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80d881:	0f 85 43 02 00 00    	jne    80daca <udp_input+0x36a>
  80d887:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  80d88b:	83 e0 04             	and    $0x4,%eax
  80d88e:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80d891:	0f 44 c3             	cmove  %ebx,%eax
  80d894:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80d897:	e9 2e 02 00 00       	jmp    80daca <udp_input+0x36a>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80d89c:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80d89f:	74 13                	je     80d8b4 <udp_input+0x154>
  80d8a1:	8b 43 04             	mov    0x4(%ebx),%eax
  80d8a4:	85 c0                	test   %eax,%eax
  80d8a6:	74 10                	je     80d8b8 <udp_input+0x158>
  80d8a8:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d8ab:	3b 42 0c             	cmp    0xc(%edx),%eax
  80d8ae:	75 24                	jne    80d8d4 <udp_input+0x174>
  80d8b0:	89 d8                	mov    %ebx,%eax
  80d8b2:	eb 06                	jmp    80d8ba <udp_input+0x15a>
  80d8b4:	89 d8                	mov    %ebx,%eax
  80d8b6:	eb 02                	jmp    80d8ba <udp_input+0x15a>
  80d8b8:	89 d8                	mov    %ebx,%eax
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
        /* the first fully matching PCB */
        if (prev != NULL) {
  80d8ba:	85 ff                	test   %edi,%edi
  80d8bc:	74 26                	je     80d8e4 <udp_input+0x184>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80d8be:	8b 50 0c             	mov    0xc(%eax),%edx
  80d8c1:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80d8c4:	8b 15 f4 a9 b3 00    	mov    0xb3a9f4,%edx
  80d8ca:	89 50 0c             	mov    %edx,0xc(%eax)
          udp_pcbs = pcb;
  80d8cd:	a3 f4 a9 b3 00       	mov    %eax,0xb3a9f4
  80d8d2:	eb 10                	jmp    80d8e4 <udp_input+0x184>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80d8d4:	8b 43 0c             	mov    0xc(%ebx),%eax
  80d8d7:	85 c0                	test   %eax,%eax
  80d8d9:	0f 85 6c ff ff ff    	jne    80d84b <udp_input+0xeb>
  80d8df:	e9 00 02 00 00       	jmp    80dae4 <udp_input+0x384>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  80d8e4:	85 c0                	test   %eax,%eax
  80d8e6:	75 23                	jne    80d90b <udp_input+0x1ab>
  80d8e8:	8b 5d dc             	mov    -0x24(%ebp),%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80d8eb:	85 db                	test   %ebx,%ebx
  80d8ed:	8d 76 00             	lea    0x0(%esi),%esi
  80d8f0:	75 19                	jne    80d90b <udp_input+0x1ab>
  80d8f2:	eb 05                	jmp    80d8f9 <udp_input+0x199>
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80d8f4:	bb 00 00 00 00       	mov    $0x0,%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80d8f9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d8fc:	8b 50 10             	mov    0x10(%eax),%edx
  80d8ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d902:	39 50 04             	cmp    %edx,0x4(%eax)
  80d905:	0f 85 7a 01 00 00    	jne    80da85 <udp_input+0x325>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80d90b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80d90e:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80d913:	74 44                	je     80d959 <udp_input+0x1f9>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
                               (struct ip_addr *)&(iphdr->dest),
                               IP_PROTO_UDP, p->tot_len) != 0) {
  80d915:	8b 55 08             	mov    0x8(%ebp),%edx
  80d918:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80d91c:	89 44 24 10          	mov    %eax,0x10(%esp)
  80d920:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80d927:	00 
  80d928:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d92b:	83 c0 10             	add    $0x10,%eax
  80d92e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80d932:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d935:	83 c0 0c             	add    $0xc,%eax
  80d938:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d93c:	89 14 24             	mov    %edx,(%esp)
  80d93f:	e8 f9 e6 ff ff       	call   80c03d <inet_chksum_pseudo>
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80d944:	66 85 c0             	test   %ax,%ax
  80d947:	74 10                	je     80d959 <udp_input+0x1f9>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80d949:	8b 45 08             	mov    0x8(%ebp),%eax
  80d94c:	89 04 24             	mov    %eax,(%esp)
  80d94f:	e8 af b8 ff ff       	call   809203 <pbuf_free>
          goto end;
  80d954:	e9 93 01 00 00       	jmp    80daec <udp_input+0x38c>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80d959:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80d960:	ff 
  80d961:	8b 55 08             	mov    0x8(%ebp),%edx
  80d964:	89 14 24             	mov    %edx,(%esp)
  80d967:	e8 a4 b7 ff ff       	call   809110 <pbuf_header>
  80d96c:	84 c0                	test   %al,%al
  80d96e:	74 1c                	je     80d98c <udp_input+0x22c>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80d970:	c7 44 24 08 eb 62 81 	movl   $0x8162eb,0x8(%esp)
  80d977:	00 
  80d978:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80d97f:	00 
  80d980:	c7 04 24 16 63 81 00 	movl   $0x816316,(%esp)
  80d987:	e8 2c 30 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80d98c:	85 db                	test   %ebx,%ebx
  80d98e:	74 41                	je     80d9d1 <udp_input+0x271>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80d990:	8b 43 18             	mov    0x18(%ebx),%eax
  80d993:	85 c0                	test   %eax,%eax
  80d995:	74 2a                	je     80d9c1 <udp_input+0x261>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80d997:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80d99b:	89 54 24 10          	mov    %edx,0x10(%esp)
  80d99f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d9a2:	83 c2 0c             	add    $0xc,%edx
  80d9a5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80d9a9:	8b 55 08             	mov    0x8(%ebp),%edx
  80d9ac:	89 54 24 08          	mov    %edx,0x8(%esp)
  80d9b0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d9b4:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80d9b7:	89 14 24             	mov    %edx,(%esp)
  80d9ba:	ff d0                	call   *%eax
  80d9bc:	e9 2b 01 00 00       	jmp    80daec <udp_input+0x38c>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80d9c1:	8b 45 08             	mov    0x8(%ebp),%eax
  80d9c4:	89 04 24             	mov    %eax,(%esp)
  80d9c7:	e8 37 b8 ff ff       	call   809203 <pbuf_free>
        goto end;
  80d9cc:	e9 1b 01 00 00       	jmp    80daec <udp_input+0x38c>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80d9d1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d9d4:	89 54 24 04          	mov    %edx,0x4(%esp)
  80d9d8:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d9db:	83 c0 10             	add    $0x10,%eax
  80d9de:	89 04 24             	mov    %eax,(%esp)
  80d9e1:	e8 fa d5 ff ff       	call   80afe0 <ip_addr_isbroadcast>
  80d9e6:	84 c0                	test   %al,%al
  80d9e8:	0f 85 8a 00 00 00    	jne    80da78 <udp_input+0x318>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80d9ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80d9f1:	8b 70 10             	mov    0x10(%eax),%esi
  80d9f4:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80d9fb:	e8 39 ec ff ff       	call   80c639 <ntohl>
  80da00:	89 c3                	mov    %eax,%ebx
  80da02:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80da09:	e8 2b ec ff ff       	call   80c639 <ntohl>
  80da0e:	21 f3                	and    %esi,%ebx
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80da10:	39 c3                	cmp    %eax,%ebx
  80da12:	74 64                	je     80da78 <udp_input+0x318>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80da14:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80da17:	0f b7 02             	movzwl (%edx),%eax
  80da1a:	89 04 24             	mov    %eax,(%esp)
  80da1d:	e8 a4 e9 ff ff       	call   80c3c6 <ntohs>
  80da22:	0f b6 c4             	movzbl %ah,%eax
  80da25:	83 e0 0f             	and    $0xf,%eax
  80da28:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80da2f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80da33:	8b 45 08             	mov    0x8(%ebp),%eax
  80da36:	89 04 24             	mov    %eax,(%esp)
  80da39:	e8 d2 b6 ff ff       	call   809110 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80da3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80da41:	8b 55 08             	mov    0x8(%ebp),%edx
  80da44:	39 42 04             	cmp    %eax,0x4(%edx)
  80da47:	74 1c                	je     80da65 <udp_input+0x305>
  80da49:	c7 44 24 08 2a 63 81 	movl   $0x81632a,0x8(%esp)
  80da50:	00 
  80da51:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80da58:	00 
  80da59:	c7 04 24 16 63 81 00 	movl   $0x816316,(%esp)
  80da60:	e8 53 2f ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80da65:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80da6c:	00 
  80da6d:	8b 55 08             	mov    0x8(%ebp),%edx
  80da70:	89 14 24             	mov    %edx,(%esp)
  80da73:	e8 83 63 00 00       	call   813dfb <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80da78:	8b 45 08             	mov    0x8(%ebp),%eax
  80da7b:	89 04 24             	mov    %eax,(%esp)
  80da7e:	e8 80 b7 ff ff       	call   809203 <pbuf_free>
  80da83:	eb 67                	jmp    80daec <udp_input+0x38c>
    }
  } else {
    pbuf_free(p);
  80da85:	8b 55 08             	mov    0x8(%ebp),%edx
  80da88:	89 14 24             	mov    %edx,(%esp)
  80da8b:	e8 73 b7 ff ff       	call   809203 <pbuf_free>
  80da90:	eb 5a                	jmp    80daec <udp_input+0x38c>
    snmp_inc_udpinerrors();
    pbuf_free(p);
    goto end;
  }

  udphdr = (struct udp_hdr *)p->payload;
  80da92:	8b 45 08             	mov    0x8(%ebp),%eax
  80da95:	8b 40 04             	mov    0x4(%eax),%eax
  80da98:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80da9b:	0f b7 00             	movzwl (%eax),%eax
  80da9e:	89 04 24             	mov    %eax,(%esp)
  80daa1:	e8 20 e9 ff ff       	call   80c3c6 <ntohs>
  80daa6:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  dest = ntohs(udphdr->dest);
  80daaa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80daad:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80dab1:	89 04 24             	mov    %eax,(%esp)
  80dab4:	e8 0d e9 ff ff       	call   80c3c6 <ntohs>
  80dab9:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80dabb:	66 83 f8 44          	cmp    $0x44,%ax
  80dabf:	0f 85 61 fd ff ff    	jne    80d826 <udp_input+0xc6>
  80dac5:	e9 09 fd ff ff       	jmp    80d7d3 <udp_input+0x73>
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80daca:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80dace:	66 39 43 14          	cmp    %ax,0x14(%ebx)
  80dad2:	0f 85 fc fd ff ff    	jne    80d8d4 <udp_input+0x174>
  80dad8:	e9 bf fd ff ff       	jmp    80d89c <udp_input+0x13c>
  } else
#endif /* LWIP_DHCP */
  {
    prev = NULL;
    local_match = 0;
    uncon_pcb = NULL;
  80dadd:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80dae4:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  80dae7:	e9 ff fd ff ff       	jmp    80d8eb <udp_input+0x18b>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80daec:	83 c4 4c             	add    $0x4c,%esp
  80daef:	5b                   	pop    %ebx
  80daf0:	5e                   	pop    %esi
  80daf1:	5f                   	pop    %edi
  80daf2:	5d                   	pop    %ebp
  80daf3:	c3                   	ret    

0080daf4 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80daf4:	55                   	push   %ebp
  80daf5:	89 e5                	mov    %esp,%ebp
  80daf7:	57                   	push   %edi
  80daf8:	56                   	push   %esi
  80daf9:	53                   	push   %ebx
  80dafa:	83 ec 2c             	sub    $0x2c,%esp
  80dafd:	8b 55 08             	mov    0x8(%ebp),%edx
  80db00:	8b 75 0c             	mov    0xc(%ebp),%esi
  80db03:	0f b7 5d 10          	movzwl 0x10(%ebp),%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80db07:	a1 f4 a9 b3 00       	mov    0xb3a9f4,%eax
  80db0c:	85 c0                	test   %eax,%eax
  80db0e:	74 37                	je     80db47 <udp_bind+0x53>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  80db10:	b9 00 00 00 00       	mov    $0x0,%ecx
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80db15:	39 c2                	cmp    %eax,%edx
  80db17:	75 25                	jne    80db3e <udp_bind+0x4a>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80db19:	84 c9                	test   %cl,%cl
  80db1b:	74 1c                	je     80db39 <udp_bind+0x45>
  80db1d:	c7 44 24 08 3e 63 81 	movl   $0x81633e,0x8(%esp)
  80db24:	00 
  80db25:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80db2c:	00 
  80db2d:	c7 04 24 16 63 81 00 	movl   $0x816316,(%esp)
  80db34:	e8 7f 2e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      /* pcb already in list, just rebind */
      rebind = 1;
  80db39:	b9 01 00 00 00       	mov    $0x1,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80db3e:	8b 40 0c             	mov    0xc(%eax),%eax
  80db41:	85 c0                	test   %eax,%eax
  80db43:	75 d0                	jne    80db15 <udp_bind+0x21>
  80db45:	eb 05                	jmp    80db4c <udp_bind+0x58>

  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, ("udp_bind(ipaddr = "));
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  80db47:	b9 00 00 00 00       	mov    $0x0,%ecx
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80db4c:	b8 00 00 00 00       	mov    $0x0,%eax
  80db51:	85 f6                	test   %esi,%esi
  80db53:	74 02                	je     80db57 <udp_bind+0x63>
  80db55:	8b 06                	mov    (%esi),%eax
  80db57:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80db59:	66 85 db             	test   %bx,%bx
  80db5c:	75 4a                	jne    80dba8 <udp_bind+0xb4>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80db5e:	8b 3d f4 a9 b3 00    	mov    0xb3a9f4,%edi
  80db64:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  if (port == 0) {
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
  80db67:	bb 00 10 00 00       	mov    $0x1000,%ebx
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80db6c:	eb 1d                	jmp    80db8b <udp_bind+0x97>
      if (ipcb->local_port == port) {
  80db6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80db71:	0f b7 70 12          	movzwl 0x12(%eax),%esi
  80db75:	66 39 de             	cmp    %bx,%si
  80db78:	75 08                	jne    80db82 <udp_bind+0x8e>
        /* port is already used by another udp_pcb */
        port++;
  80db7a:	8d 5e 01             	lea    0x1(%esi),%ebx
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
  80db7d:	89 7d e4             	mov    %edi,-0x1c(%ebp)
  80db80:	eb 09                	jmp    80db8b <udp_bind+0x97>
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80db82:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80db85:	8b 40 0c             	mov    0xc(%eax),%eax
  80db88:	89 45 e4             	mov    %eax,-0x1c(%ebp)
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80db8b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80db8f:	0f 95 c0             	setne  %al
  80db92:	89 c6                	mov    %eax,%esi
  80db94:	74 07                	je     80db9d <udp_bind+0xa9>
  80db96:	66 81 fb ff 7f       	cmp    $0x7fff,%bx
  80db9b:	75 d1                	jne    80db6e <udp_bind+0x7a>
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
  80db9d:	bf f5 ff ff ff       	mov    $0xfffffff5,%edi
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80dba2:	89 f0                	mov    %esi,%eax
  80dba4:	84 c0                	test   %al,%al
  80dba6:	75 1b                	jne    80dbc3 <udp_bind+0xcf>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  80dba8:	66 89 5a 12          	mov    %bx,0x12(%edx)
              ("udp_bind: bound to %"U16_F".%"U16_F".%"U16_F".%"U16_F", port %"U16_F"\n",
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
  80dbac:	bf 00 00 00 00       	mov    $0x0,%edi
    }
  }
  pcb->local_port = port;
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80dbb1:	84 c9                	test   %cl,%cl
  80dbb3:	75 0e                	jne    80dbc3 <udp_bind+0xcf>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80dbb5:	a1 f4 a9 b3 00       	mov    0xb3a9f4,%eax
  80dbba:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  80dbbd:	89 15 f4 a9 b3 00    	mov    %edx,0xb3a9f4
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80dbc3:	89 f8                	mov    %edi,%eax
  80dbc5:	83 c4 2c             	add    $0x2c,%esp
  80dbc8:	5b                   	pop    %ebx
  80dbc9:	5e                   	pop    %esi
  80dbca:	5f                   	pop    %edi
  80dbcb:	5d                   	pop    %ebp
  80dbcc:	c3                   	ret    

0080dbcd <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80dbcd:	55                   	push   %ebp
  80dbce:	89 e5                	mov    %esp,%ebp
  80dbd0:	57                   	push   %edi
  80dbd1:	56                   	push   %esi
  80dbd2:	53                   	push   %ebx
  80dbd3:	83 ec 3c             	sub    $0x3c,%esp
  80dbd6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dbd9:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  80dbdd:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80dbe1:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80dbe6:	75 1e                	jne    80dc06 <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80dbe8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80dbef:	00 
  80dbf0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80dbf4:	89 1c 24             	mov    %ebx,(%esp)
  80dbf7:	e8 f8 fe ff ff       	call   80daf4 <udp_bind>
  80dbfc:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  80dbfe:	84 c0                	test   %al,%al
  80dc00:	0f 85 6d 01 00 00    	jne    80dd73 <udp_sendto_if+0x1a6>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80dc06:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80dc0d:	00 
  80dc0e:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dc11:	89 14 24             	mov    %edx,(%esp)
  80dc14:	e8 f7 b4 ff ff       	call   809110 <pbuf_header>
  80dc19:	84 c0                	test   %al,%al
  80dc1b:	74 37                	je     80dc54 <udp_sendto_if+0x87>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80dc1d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80dc24:	00 
  80dc25:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80dc2c:	00 
  80dc2d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80dc34:	e8 ec b7 ff ff       	call   809425 <pbuf_alloc>
  80dc39:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80dc3b:	85 c0                	test   %eax,%eax
  80dc3d:	0f 84 2b 01 00 00    	je     80dd6e <udp_sendto_if+0x1a1>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80dc43:	8b 45 0c             	mov    0xc(%ebp),%eax
  80dc46:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dc4a:	89 34 24             	mov    %esi,(%esp)
  80dc4d:	e8 53 bb ff ff       	call   8097a5 <pbuf_chain>
  80dc52:	eb 03                	jmp    80dc57 <udp_sendto_if+0x8a>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_send: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  } else {
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
  80dc54:	8b 75 0c             	mov    0xc(%ebp),%esi
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80dc57:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80dc5c:	77 1c                	ja     80dc7a <udp_sendto_if+0xad>
  80dc5e:	c7 44 24 08 4c 63 81 	movl   $0x81634c,0x8(%esp)
  80dc65:	00 
  80dc66:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80dc6d:	00 
  80dc6e:	c7 04 24 16 63 81 00 	movl   $0x816316,(%esp)
  80dc75:	e8 3e 2d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = (struct udp_hdr *) q->payload;
  80dc7a:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80dc7d:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80dc81:	89 04 24             	mov    %eax,(%esp)
  80dc84:	e8 30 e7 ff ff       	call   80c3b9 <htons>
  80dc89:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80dc8c:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80dc90:	89 04 24             	mov    %eax,(%esp)
  80dc93:	e8 21 e7 ff ff       	call   80c3b9 <htons>
  80dc98:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80dc9c:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80dca2:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80dca5:	85 db                	test   %ebx,%ebx
  80dca7:	74 06                	je     80dcaf <udp_sendto_if+0xe2>
  80dca9:	8b 03                	mov    (%ebx),%eax
  80dcab:	85 c0                	test   %eax,%eax
  80dcad:	75 0b                	jne    80dcba <udp_sendto_if+0xed>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80dcaf:	8b 55 18             	mov    0x18(%ebp),%edx
  80dcb2:	83 c2 04             	add    $0x4,%edx
  80dcb5:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80dcb8:	eb 23                	jmp    80dcdd <udp_sendto_if+0x110>
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80dcba:	8b 55 18             	mov    0x18(%ebp),%edx
  80dcbd:	3b 42 04             	cmp    0x4(%edx),%eax
  80dcc0:	74 1b                	je     80dcdd <udp_sendto_if+0x110>
        /* free the header pbuf */
        pbuf_free(q);
        q = NULL;
        /* p is still referenced by the caller, and will live on */
      }
      return ERR_VAL;
  80dcc2:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  80dcc7:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80dcca:	0f 84 a3 00 00 00    	je     80dd73 <udp_sendto_if+0x1a6>
        /* free the header pbuf */
        pbuf_free(q);
  80dcd0:	89 34 24             	mov    %esi,(%esp)
  80dcd3:	e8 2b b5 ff ff       	call   809203 <pbuf_free>
  80dcd8:	e9 96 00 00 00       	jmp    80dd73 <udp_sendto_if+0x1a6>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80dcdd:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80dce1:	89 04 24             	mov    %eax,(%esp)
  80dce4:	e8 d0 e6 ff ff       	call   80c3b9 <htons>
  80dce9:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80dced:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80dcf1:	75 35                	jne    80dd28 <udp_sendto_if+0x15b>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80dcf3:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80dcf7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80dcfb:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80dd02:	00 
  80dd03:	8b 45 10             	mov    0x10(%ebp),%eax
  80dd06:	89 44 24 08          	mov    %eax,0x8(%esp)
  80dd0a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80dd0d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80dd11:	89 34 24             	mov    %esi,(%esp)
  80dd14:	e8 24 e3 ff ff       	call   80c03d <inet_chksum_pseudo>
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80dd19:	66 85 c0             	test   %ax,%ax
  80dd1c:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  80dd21:	0f 44 c2             	cmove  %edx,%eax
  80dd24:	66 89 47 06          	mov    %ax,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80dd28:	8b 45 18             	mov    0x18(%ebp),%eax
  80dd2b:	89 44 24 18          	mov    %eax,0x18(%esp)
  80dd2f:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80dd36:	00 
  80dd37:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80dd3b:	89 44 24 10          	mov    %eax,0x10(%esp)
  80dd3f:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80dd43:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80dd47:	8b 55 10             	mov    0x10(%ebp),%edx
  80dd4a:	89 54 24 08          	mov    %edx,0x8(%esp)
  80dd4e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80dd51:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dd55:	89 34 24             	mov    %esi,(%esp)
  80dd58:	e8 dc d5 ff ff       	call   80b339 <ip_output_if>
  80dd5d:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80dd5f:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80dd62:	74 0f                	je     80dd73 <udp_sendto_if+0x1a6>
    /* free the header pbuf */
    pbuf_free(q);
  80dd64:	89 34 24             	mov    %esi,(%esp)
  80dd67:	e8 97 b4 ff ff       	call   809203 <pbuf_free>
  80dd6c:	eb 05                	jmp    80dd73 <udp_sendto_if+0x1a6>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
  80dd6e:	bf ff ff ff ff       	mov    $0xffffffff,%edi
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80dd73:	89 f8                	mov    %edi,%eax
  80dd75:	83 c4 3c             	add    $0x3c,%esp
  80dd78:	5b                   	pop    %ebx
  80dd79:	5e                   	pop    %esi
  80dd7a:	5f                   	pop    %edi
  80dd7b:	5d                   	pop    %ebp
  80dd7c:	c3                   	ret    

0080dd7d <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80dd7d:	55                   	push   %ebp
  80dd7e:	89 e5                	mov    %esp,%ebp
  80dd80:	83 ec 28             	sub    $0x28,%esp
  80dd83:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80dd86:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80dd89:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80dd8c:	0f b7 75 14          	movzwl 0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80dd90:	89 1c 24             	mov    %ebx,(%esp)
  80dd93:	e8 88 d2 ff ff       	call   80b020 <ip_route>
  80dd98:	89 c2                	mov    %eax,%edx

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  80dd9a:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
#else
  netif = ip_route(dst_ip);
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80dd9f:	85 d2                	test   %edx,%edx
  80dda1:	74 21                	je     80ddc4 <udp_sendto+0x47>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80dda3:	89 54 24 10          	mov    %edx,0x10(%esp)
  80dda7:	0f b7 f6             	movzwl %si,%esi
  80ddaa:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80ddae:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80ddb2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ddb5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ddb9:	8b 45 08             	mov    0x8(%ebp),%eax
  80ddbc:	89 04 24             	mov    %eax,(%esp)
  80ddbf:	e8 09 fe ff ff       	call   80dbcd <udp_sendto_if>
}
  80ddc4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80ddc7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80ddca:	89 ec                	mov    %ebp,%esp
  80ddcc:	5d                   	pop    %ebp
  80ddcd:	c3                   	ret    

0080ddce <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80ddce:	55                   	push   %ebp
  80ddcf:	89 e5                	mov    %esp,%ebp
  80ddd1:	83 ec 18             	sub    $0x18,%esp
  80ddd4:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80ddd7:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  80dddb:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80dddf:	8d 50 04             	lea    0x4(%eax),%edx
  80dde2:	89 54 24 08          	mov    %edx,0x8(%esp)
  80dde6:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dde9:	89 54 24 04          	mov    %edx,0x4(%esp)
  80dded:	89 04 24             	mov    %eax,(%esp)
  80ddf0:	e8 88 ff ff ff       	call   80dd7d <udp_sendto>
}
  80ddf5:	c9                   	leave  
  80ddf6:	c3                   	ret    

0080ddf7 <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80ddf7:	55                   	push   %ebp
  80ddf8:	89 e5                	mov    %esp,%ebp
  80ddfa:	57                   	push   %edi
  80ddfb:	56                   	push   %esi
  80ddfc:	53                   	push   %ebx
  80ddfd:	83 ec 1c             	sub    $0x1c,%esp
  80de00:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80de03:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80de06:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80de0a:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80de0f:	75 18                	jne    80de29 <udp_connect+0x32>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80de11:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80de18:	00 
  80de19:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80de1d:	89 1c 24             	mov    %ebx,(%esp)
  80de20:	e8 cf fc ff ff       	call   80daf4 <udp_bind>
    if (err != ERR_OK)
  80de25:	84 c0                	test   %al,%al
  80de27:	75 4e                	jne    80de77 <udp_connect+0x80>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80de29:	b8 00 00 00 00       	mov    $0x0,%eax
  80de2e:	85 ff                	test   %edi,%edi
  80de30:	74 02                	je     80de34 <udp_connect+0x3d>
  80de32:	8b 07                	mov    (%edi),%eax
  80de34:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80de37:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80de3b:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80de3f:	8b 15 f4 a9 b3 00    	mov    0xb3a9f4,%edx
  80de45:	85 d2                	test   %edx,%edx
  80de47:	74 19                	je     80de62 <udp_connect+0x6b>
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  80de49:	b8 00 00 00 00       	mov    $0x0,%eax
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
  80de4e:	39 d3                	cmp    %edx,%ebx
  80de50:	74 25                	je     80de77 <udp_connect+0x80>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80de52:	89 d0                	mov    %edx,%eax
  80de54:	eb 04                	jmp    80de5a <udp_connect+0x63>
    if (pcb == ipcb) {
  80de56:	39 c3                	cmp    %eax,%ebx
  80de58:	74 18                	je     80de72 <udp_connect+0x7b>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80de5a:	8b 40 0c             	mov    0xc(%eax),%eax
  80de5d:	85 c0                	test   %eax,%eax
  80de5f:	90                   	nop
  80de60:	75 f4                	jne    80de56 <udp_connect+0x5f>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80de62:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80de65:	89 1d f4 a9 b3 00    	mov    %ebx,0xb3a9f4
  return ERR_OK;
  80de6b:	b8 00 00 00 00       	mov    $0x0,%eax
  80de70:	eb 05                	jmp    80de77 <udp_connect+0x80>

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
    if (pcb == ipcb) {
      /* already on the list, just return */
      return ERR_OK;
  80de72:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  udp_pcbs = pcb;
  return ERR_OK;
}
  80de77:	83 c4 1c             	add    $0x1c,%esp
  80de7a:	5b                   	pop    %ebx
  80de7b:	5e                   	pop    %esi
  80de7c:	5f                   	pop    %edi
  80de7d:	5d                   	pop    %ebp
  80de7e:	c3                   	ret    

0080de7f <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80de7f:	55                   	push   %ebp
  80de80:	89 e5                	mov    %esp,%ebp
  80de82:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80de85:	8b 15 84 5f 81 00    	mov    0x815f84,%edx
  80de8b:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80de8e:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80de94:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80de98:	5d                   	pop    %ebp
  80de99:	c3                   	ret    

0080de9a <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80de9a:	55                   	push   %ebp
  80de9b:	89 e5                	mov    %esp,%ebp
  80de9d:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80dea0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80dea3:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80dea6:	8b 55 10             	mov    0x10(%ebp),%edx
  80dea9:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80deac:	5d                   	pop    %ebp
  80dead:	c3                   	ret    

0080deae <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80deae:	55                   	push   %ebp
  80deaf:	89 e5                	mov    %esp,%ebp
  80deb1:	83 ec 18             	sub    $0x18,%esp
  80deb4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80deb7:	8b 15 f4 a9 b3 00    	mov    0xb3a9f4,%edx
  80debd:	39 ca                	cmp    %ecx,%edx
  80debf:	74 06                	je     80dec7 <udp_remove+0x19>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80dec1:	85 d2                	test   %edx,%edx
  80dec3:	75 0e                	jne    80ded3 <udp_remove+0x25>
  80dec5:	eb 21                	jmp    80dee8 <udp_remove+0x3a>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80dec7:	8b 42 0c             	mov    0xc(%edx),%eax
  80deca:	a3 f4 a9 b3 00       	mov    %eax,0xb3a9f4
  80decf:	eb 17                	jmp    80dee8 <udp_remove+0x3a>
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80ded1:	89 c2                	mov    %eax,%edx
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80ded3:	8b 42 0c             	mov    0xc(%edx),%eax
  80ded6:	85 c0                	test   %eax,%eax
  80ded8:	74 0e                	je     80dee8 <udp_remove+0x3a>
  80deda:	39 c1                	cmp    %eax,%ecx
  80dedc:	75 f3                	jne    80ded1 <udp_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80dede:	8b 41 0c             	mov    0xc(%ecx),%eax
  80dee1:	89 42 0c             	mov    %eax,0xc(%edx)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80dee4:	85 c0                	test   %eax,%eax
  80dee6:	75 e9                	jne    80ded1 <udp_remove+0x23>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80dee8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80deec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80def3:	e8 49 af ff ff       	call   808e41 <memp_free>
}
  80def8:	c9                   	leave  
  80def9:	c3                   	ret    

0080defa <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80defa:	55                   	push   %ebp
  80defb:	89 e5                	mov    %esp,%ebp
  80defd:	53                   	push   %ebx
  80defe:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = (struct udp_pcb *) memp_malloc(MEMP_UDP_PCB);
  80df01:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80df08:	e8 d4 ae ff ff       	call   808de1 <memp_malloc>
  80df0d:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80df0f:	85 c0                	test   %eax,%eax
  80df11:	74 1c                	je     80df2f <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80df13:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80df1a:	00 
  80df1b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80df22:	00 
  80df23:	89 04 24             	mov    %eax,(%esp)
  80df26:	e8 06 33 ff ff       	call   801231 <memset>
    pcb->ttl = UDP_TTL;
  80df2b:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80df2f:	89 d8                	mov    %ebx,%eax
  80df31:	83 c4 14             	add    $0x14,%esp
  80df34:	5b                   	pop    %ebx
  80df35:	5d                   	pop    %ebp
  80df36:	c3                   	ret    
	...

0080df40 <_ZL14etharp_send_ipP5netifP4pbufP8eth_addrS4_>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80df40:	55                   	push   %ebp
  80df41:	89 e5                	mov    %esp,%ebp
  80df43:	57                   	push   %edi
  80df44:	56                   	push   %esi
  80df45:	53                   	push   %ebx
  80df46:	83 ec 2c             	sub    $0x2c,%esp
  80df49:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80df4c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80df4f:	89 ce                	mov    %ecx,%esi
  80df51:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = (struct eth_hdr *) p->payload;
  80df54:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80df57:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80df5b:	74 1c                	je     80df79 <_ZL14etharp_send_ipP5netifP4pbufP8eth_addrS4_+0x39>
  80df5d:	c7 44 24 08 7c 63 81 	movl   $0x81637c,0x8(%esp)
  80df64:	00 
  80df65:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80df6c:	00 
  80df6d:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80df74:	e8 3f 2a ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80df79:	ba 06 00 00 00       	mov    $0x6,%edx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80df7e:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  80df81:	0f b6 c2             	movzbl %dl,%eax
  80df84:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80df88:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80df8b:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80df8f:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80df93:	84 d2                	test   %dl,%dl
  80df95:	75 e7                	jne    80df7e <_ZL14etharp_send_ipP5netifP4pbufP8eth_addrS4_+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80df97:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80df9e:	e8 16 e4 ff ff       	call   80c3b9 <htons>
  80dfa3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80dfa7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80dfaa:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dfae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80dfb1:	89 14 24             	mov    %edx,(%esp)
  80dfb4:	ff 52 18             	call   *0x18(%edx)
}
  80dfb7:	83 c4 2c             	add    $0x2c,%esp
  80dfba:	5b                   	pop    %ebx
  80dfbb:	5e                   	pop    %esi
  80dfbc:	5f                   	pop    %edi
  80dfbd:	5d                   	pop    %ebp
  80dfbe:	c3                   	ret    

0080dfbf <_ZL13free_etharp_qP14etharp_q_entry>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80dfbf:	55                   	push   %ebp
  80dfc0:	89 e5                	mov    %esp,%ebp
  80dfc2:	56                   	push   %esi
  80dfc3:	53                   	push   %ebx
  80dfc4:	83 ec 10             	sub    $0x10,%esp
  80dfc7:	89 c6                	mov    %eax,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80dfc9:	85 c0                	test   %eax,%eax
  80dfcb:	75 1c                	jne    80dfe9 <_ZL13free_etharp_qP14etharp_q_entry+0x2a>
  80dfcd:	c7 44 24 08 36 5a 81 	movl   $0x815a36,0x8(%esp)
  80dfd4:	00 
  80dfd5:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80dfdc:	00 
  80dfdd:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80dfe4:	e8 cf 29 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80dfe9:	8b 40 04             	mov    0x4(%eax),%eax
  80dfec:	85 c0                	test   %eax,%eax
  80dfee:	74 04                	je     80dff4 <_ZL13free_etharp_qP14etharp_q_entry+0x35>
  while (q) {
    r = q;
    q = q->next;
  80dff0:	8b 1e                	mov    (%esi),%ebx
  80dff2:	eb 45                	jmp    80e039 <_ZL13free_etharp_qP14etharp_q_entry+0x7a>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80dff4:	c7 44 24 08 7d 64 81 	movl   $0x81647d,0x8(%esp)
  80dffb:	00 
  80dffc:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80e003:	00 
  80e004:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e00b:	e8 a8 29 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  while (q) {
    r = q;
    q = q->next;
  80e010:	8b 13                	mov    (%ebx),%edx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80e012:	8b 43 04             	mov    0x4(%ebx),%eax
  80e015:	85 c0                	test   %eax,%eax
  80e017:	75 1c                	jne    80e035 <_ZL13free_etharp_qP14etharp_q_entry+0x76>
  80e019:	c7 44 24 08 8a 64 81 	movl   $0x81648a,0x8(%esp)
  80e020:	00 
  80e021:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80e028:	00 
  80e029:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e030:	e8 83 29 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80e035:	89 de                	mov    %ebx,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
    r = q;
    q = q->next;
  80e037:	89 d3                	mov    %edx,%ebx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
  80e039:	89 04 24             	mov    %eax,(%esp)
  80e03c:	e8 c2 b1 ff ff       	call   809203 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80e041:	89 74 24 04          	mov    %esi,0x4(%esp)
  80e045:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80e04c:	e8 f0 ad ff ff       	call   808e41 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80e051:	85 db                	test   %ebx,%ebx
  80e053:	75 bb                	jne    80e010 <_ZL13free_etharp_qP14etharp_q_entry+0x51>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80e055:	83 c4 10             	add    $0x10,%esp
  80e058:	5b                   	pop    %ebx
  80e059:	5e                   	pop    %esi
  80e05a:	5d                   	pop    %ebp
  80e05b:	c3                   	ret    

0080e05c <_ZL10find_entryP7ip_addrh>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80e05c:	55                   	push   %ebp
  80e05d:	89 e5                	mov    %esp,%ebp
  80e05f:	57                   	push   %edi
  80e060:	56                   	push   %esi
  80e061:	53                   	push   %ebx
  80e062:	83 ec 2c             	sub    $0x2c,%esp
  80e065:	89 c6                	mov    %eax,%esi
  80e067:	88 55 e4             	mov    %dl,-0x1c(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80e06a:	85 c0                	test   %eax,%eax
  80e06c:	74 24                	je     80e092 <_ZL10find_entryP7ip_addrh+0x36>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80e06e:	0f b6 05 18 ab b3 00 	movzbl 0xb3ab18,%eax
  80e075:	0f b6 d0             	movzbl %al,%edx
  80e078:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80e07b:	83 b9 10 aa b3 00 02 	cmpl   $0x2,0xb3aa10(%ecx)
  80e082:	75 0e                	jne    80e092 <_ZL10find_entryP7ip_addrh+0x36>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80e084:	8b 89 04 aa b3 00    	mov    0xb3aa04(%ecx),%ecx
  80e08a:	39 0e                	cmp    %ecx,(%esi)
  80e08c:	0f 84 a2 01 00 00    	je     80e234 <_ZL10find_entryP7ip_addrh+0x1d8>
  80e092:	ba 14 aa b3 00       	mov    $0xb3aa14,%edx
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80e097:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80e09b:	c6 45 e3 0a          	movb   $0xa,-0x1d(%ebp)
  80e09f:	c6 45 e6 00          	movb   $0x0,-0x1a(%ebp)
  80e0a3:	c6 45 e2 00          	movb   $0x0,-0x1e(%ebp)
  80e0a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80e0ac:	bf 0a 00 00 00       	mov    $0xa,%edi
  80e0b1:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80e0b5:	c6 45 e1 0a          	movb   $0xa,-0x1f(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80e0b9:	89 f9                	mov    %edi,%ecx
  80e0bb:	80 f9 0a             	cmp    $0xa,%cl
  80e0be:	75 0a                	jne    80e0ca <_ZL10find_entryP7ip_addrh+0x6e>
  80e0c0:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  80e0c4:	75 04                	jne    80e0ca <_ZL10find_entryP7ip_addrh+0x6e>
  80e0c6:	89 c7                	mov    %eax,%edi
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
  80e0c8:	eb 6d                	jmp    80e137 <_ZL10find_entryP7ip_addrh+0xdb>
 */
static s8_t
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
  80e0ca:	89 d3                	mov    %edx,%ebx
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80e0cc:	8b 4a fc             	mov    -0x4(%edx),%ecx
  80e0cf:	83 f9 01             	cmp    $0x1,%ecx
  80e0d2:	75 3b                	jne    80e10f <_ZL10find_entryP7ip_addrh+0xb3>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80e0d4:	85 f6                	test   %esi,%esi
  80e0d6:	74 11                	je     80e0e9 <_ZL10find_entryP7ip_addrh+0x8d>
  80e0d8:	8b 4a f0             	mov    -0x10(%edx),%ecx
  80e0db:	39 0e                	cmp    %ecx,(%esi)
  80e0dd:	75 0a                	jne    80e0e9 <_ZL10find_entryP7ip_addrh+0x8d>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80e0df:	a2 18 ab b3 00       	mov    %al,0xb3ab18
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80e0e4:	e9 4b 01 00 00       	jmp    80e234 <_ZL10find_entryP7ip_addrh+0x1d8>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80e0e9:	83 7b ec 00          	cmpl   $0x0,-0x14(%ebx)
  80e0ed:	74 10                	je     80e0ff <_ZL10find_entryP7ip_addrh+0xa3>
        if (arp_table[i].ctime >= age_queue) {
  80e0ef:	0f b6 0b             	movzbl (%ebx),%ecx
  80e0f2:	38 4d e7             	cmp    %cl,-0x19(%ebp)
  80e0f5:	77 40                	ja     80e137 <_ZL10find_entryP7ip_addrh+0xdb>
  80e0f7:	88 45 e3             	mov    %al,-0x1d(%ebp)
          old_queue = i;
          age_queue = arp_table[i].ctime;
  80e0fa:	88 4d e7             	mov    %cl,-0x19(%ebp)
  80e0fd:	eb 38                	jmp    80e137 <_ZL10find_entryP7ip_addrh+0xdb>
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80e0ff:	0f b6 0b             	movzbl (%ebx),%ecx
  80e102:	38 4d e2             	cmp    %cl,-0x1e(%ebp)
  80e105:	77 30                	ja     80e137 <_ZL10find_entryP7ip_addrh+0xdb>
  80e107:	88 45 e1             	mov    %al,-0x1f(%ebp)
          old_pending = i;
          age_pending = arp_table[i].ctime;
  80e10a:	88 4d e2             	mov    %cl,-0x1e(%ebp)
  80e10d:	eb 28                	jmp    80e137 <_ZL10find_entryP7ip_addrh+0xdb>
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80e10f:	83 f9 02             	cmp    $0x2,%ecx
  80e112:	75 23                	jne    80e137 <_ZL10find_entryP7ip_addrh+0xdb>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80e114:	85 f6                	test   %esi,%esi
  80e116:	74 11                	je     80e129 <_ZL10find_entryP7ip_addrh+0xcd>
  80e118:	8b 4a f0             	mov    -0x10(%edx),%ecx
  80e11b:	39 0e                	cmp    %ecx,(%esi)
  80e11d:	75 0a                	jne    80e129 <_ZL10find_entryP7ip_addrh+0xcd>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80e11f:	a2 18 ab b3 00       	mov    %al,0xb3ab18
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80e124:	e9 0b 01 00 00       	jmp    80e234 <_ZL10find_entryP7ip_addrh+0x1d8>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80e129:	0f b6 0b             	movzbl (%ebx),%ecx
  80e12c:	38 4d e6             	cmp    %cl,-0x1a(%ebp)
  80e12f:	77 06                	ja     80e137 <_ZL10find_entryP7ip_addrh+0xdb>
  80e131:	88 45 e5             	mov    %al,-0x1b(%ebp)
        old_stable = i;
        age_stable = arp_table[i].ctime;
  80e134:	88 4d e6             	mov    %cl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80e137:	83 c0 01             	add    $0x1,%eax
  80e13a:	83 c2 1c             	add    $0x1c,%edx
  80e13d:	3c 0a                	cmp    $0xa,%al
  80e13f:	0f 85 74 ff ff ff    	jne    80e0b9 <_ZL10find_entryP7ip_addrh+0x5d>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80e145:	89 f8                	mov    %edi,%eax
  80e147:	3c 0a                	cmp    $0xa,%al
  80e149:	75 0f                	jne    80e15a <_ZL10find_entryP7ip_addrh+0xfe>
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  80e14b:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80e150:	f6 45 e4 01          	testb  $0x1,-0x1c(%ebp)
  80e154:	0f 84 da 00 00 00    	je     80e234 <_ZL10find_entryP7ip_addrh+0x1d8>
  80e15a:	f6 45 e4 02          	testb  $0x2,-0x1c(%ebp)
  80e15e:	0f 85 cb 00 00 00    	jne    80e22f <_ZL10find_entryP7ip_addrh+0x1d3>
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80e164:	89 fa                	mov    %edi,%edx
  80e166:	80 fa 09             	cmp    $0x9,%dl
  80e169:	7e 6d                	jle    80e1d8 <_ZL10find_entryP7ip_addrh+0x17c>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80e16b:	80 7d e5 09          	cmpb   $0x9,-0x1b(%ebp)
  80e16f:	7f 30                	jg     80e1a1 <_ZL10find_entryP7ip_addrh+0x145>
    /* recycle oldest stable*/
    i = old_stable;
  80e171:	0f b6 7d e5          	movzbl -0x1b(%ebp),%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80e175:	0f b6 45 e5          	movzbl -0x1b(%ebp),%eax
  80e179:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80e17c:	83 b8 00 aa b3 00 00 	cmpl   $0x0,0xb3aa00(%eax)
  80e183:	74 53                	je     80e1d8 <_ZL10find_entryP7ip_addrh+0x17c>
  80e185:	c7 44 24 08 97 64 81 	movl   $0x816497,0x8(%esp)
  80e18c:	00 
  80e18d:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80e194:	00 
  80e195:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e19c:	e8 17 28 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80e1a1:	80 7d e1 09          	cmpb   $0x9,-0x1f(%ebp)
  80e1a5:	7f 06                	jg     80e1ad <_ZL10find_entryP7ip_addrh+0x151>
    /* recycle oldest pending */
    i = old_pending;
  80e1a7:	0f b6 7d e1          	movzbl -0x1f(%ebp),%edi
  80e1ab:	eb 2b                	jmp    80e1d8 <_ZL10find_entryP7ip_addrh+0x17c>
    free_etharp_q(arp_table[i].q);
    arp_table[i].q = NULL;
#endif
    /* no empty or recyclable entries found */
  } else {
    return (s8_t)ERR_MEM;
  80e1ad:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80e1b2:	80 7d e3 09          	cmpb   $0x9,-0x1d(%ebp)
  80e1b6:	7f 7c                	jg     80e234 <_ZL10find_entryP7ip_addrh+0x1d8>
    /* recycle oldest pending */
    i = old_queue;
  80e1b8:	0f b6 7d e3          	movzbl -0x1d(%ebp),%edi
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80e1bc:	0f b6 5d e3          	movzbl -0x1d(%ebp),%ebx
  80e1c0:	6b db 1c             	imul   $0x1c,%ebx,%ebx
  80e1c3:	8b 83 00 aa b3 00    	mov    0xb3aa00(%ebx),%eax
  80e1c9:	e8 f1 fd ff ff       	call   80dfbf <_ZL13free_etharp_qP14etharp_q_entry>
    arp_table[i].q = NULL;
  80e1ce:	c7 83 00 aa b3 00 00 	movl   $0x0,0xb3aa00(%ebx)
  80e1d5:	00 00 00 
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80e1d8:	89 f9                	mov    %edi,%ecx
  80e1da:	80 f9 09             	cmp    $0x9,%cl
  80e1dd:	76 1c                	jbe    80e1fb <_ZL10find_entryP7ip_addrh+0x19f>
  80e1df:	c7 44 24 08 ae 64 81 	movl   $0x8164ae,0x8(%esp)
  80e1e6:	00 
  80e1e7:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  80e1ee:	00 
  80e1ef:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e1f6:	e8 bd 27 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80e1fb:	89 fa                	mov    %edi,%edx
  80e1fd:	0f b6 c2             	movzbl %dl,%eax
  80e200:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80e203:	c7 82 10 aa b3 00 00 	movl   $0x0,0xb3aa10(%edx)
  80e20a:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80e20d:	85 f6                	test   %esi,%esi
  80e20f:	74 08                	je     80e219 <_ZL10find_entryP7ip_addrh+0x1bd>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80e211:	8b 0e                	mov    (%esi),%ecx
  80e213:	89 8a 04 aa b3 00    	mov    %ecx,0xb3aa04(%edx)
  }
  arp_table[i].ctime = 0;
  80e219:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80e21c:	c6 80 14 aa b3 00 00 	movb   $0x0,0xb3aa14(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80e223:	89 f9                	mov    %edi,%ecx
  80e225:	88 0d 18 ab b3 00    	mov    %cl,0xb3ab18
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80e22b:	89 f8                	mov    %edi,%eax
  80e22d:	eb 05                	jmp    80e234 <_ZL10find_entryP7ip_addrh+0x1d8>
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
      /* or don't create new entry, only search? */
      || ((flags & ETHARP_FIND_ONLY) != 0)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: no empty entry found and not allowed to recycle\n"));
    return (s8_t)ERR_MEM;
  80e22f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
}
  80e234:	83 c4 2c             	add    $0x2c,%esp
  80e237:	5b                   	pop    %ebx
  80e238:	5e                   	pop    %esi
  80e239:	5f                   	pop    %edi
  80e23a:	5d                   	pop    %ebp
  80e23b:	c3                   	ret    

0080e23c <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80e23c:	55                   	push   %ebp
  80e23d:	89 e5                	mov    %esp,%ebp
  80e23f:	57                   	push   %edi
  80e240:	56                   	push   %esi
  80e241:	53                   	push   %ebx
  80e242:	83 ec 2c             	sub    $0x2c,%esp
  80e245:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80e248:	89 d3                	mov    %edx,%ebx
  80e24a:	89 ce                	mov    %ecx,%esi
  80e24c:	0f b6 7d 08          	movzbl 0x8(%ebp),%edi
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80e250:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80e254:	74 1c                	je     80e272 <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x36>
  80e256:	c7 44 24 08 c0 63 81 	movl   $0x8163c0,0x8(%esp)
  80e25d:	00 
  80e25e:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80e265:	00 
  80e266:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e26d:	e8 46 27 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80e272:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80e277:	85 d2                	test   %edx,%edx
  80e279:	0f 84 fe 00 00 00    	je     80e37d <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x141>
  80e27f:	83 3a 00             	cmpl   $0x0,(%edx)
  80e282:	0f 84 f5 00 00 00    	je     80e37d <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x141>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80e288:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e28b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e28f:	89 14 24             	mov    %edx,(%esp)
  80e292:	e8 49 cd ff ff       	call   80afe0 <ip_addr_isbroadcast>
  80e297:	89 c2                	mov    %eax,%edx
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80e299:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80e29e:	84 d2                	test   %dl,%dl
  80e2a0:	0f 85 d7 00 00 00    	jne    80e37d <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x141>
  80e2a6:	8b 13                	mov    (%ebx),%edx
  80e2a8:	89 55 e0             	mov    %edx,-0x20(%ebp)
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80e2ab:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80e2b2:	e8 82 e3 ff ff       	call   80c639 <ntohl>
  80e2b7:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80e2ba:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e2c1:	e8 73 e3 ff ff       	call   80c639 <ntohl>
  80e2c6:	89 c2                	mov    %eax,%edx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80e2c8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80e2cb:	23 4d e0             	and    -0x20(%ebp),%ecx
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80e2ce:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80e2d3:	39 d1                	cmp    %edx,%ecx
  80e2d5:	0f 85 aa 00 00 00    	jne    80e385 <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x149>
  80e2db:	e9 9d 00 00 00       	jmp    80e37d <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x141>
  /* bail out if no entry could be found */
  if (i < 0)
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80e2e0:	0f be f8             	movsbl %al,%edi
  80e2e3:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80e2e6:	c7 80 10 aa b3 00 02 	movl   $0x2,0xb3aa10(%eax)
  80e2ed:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80e2f0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80e2f3:	89 90 18 aa b3 00    	mov    %edx,0xb3aa18(%eax)
  /* insert in SNMP ARP index tree */
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  80e2f9:	b8 06 00 00 00       	mov    $0x6,%eax
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80e2fe:	6b df 1c             	imul   $0x1c,%edi,%ebx

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
  80e301:	83 e8 01             	sub    $0x1,%eax
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80e304:	0f b6 d0             	movzbl %al,%edx
  80e307:	0f b6 0c 16          	movzbl (%esi,%edx,1),%ecx
  80e30b:	88 8c 1a 08 aa b3 00 	mov    %cl,0xb3aa08(%edx,%ebx,1)
  snmp_insert_arpidx_tree(netif, &arp_table[i].ipaddr);

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
  80e312:	84 c0                	test   %al,%al
  80e314:	75 eb                	jne    80e301 <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0xc5>
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80e316:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80e319:	c6 80 14 aa b3 00 00 	movb   $0x0,0xb3aa14(%eax)
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80e320:	8b 90 00 aa b3 00    	mov    0xb3aa00(%eax),%edx
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  80e326:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80e32b:	85 d2                	test   %edx,%edx
  80e32d:	74 4e                	je     80e37d <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x141>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80e32f:	6b ff 1c             	imul   $0x1c,%edi,%edi
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80e332:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e335:	83 c0 25             	add    $0x25,%eax
  80e338:	89 45 e0             	mov    %eax,-0x20(%ebp)
  while (arp_table[i].q != NULL) {
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80e33b:	8b 02                	mov    (%edx),%eax
  80e33d:	89 87 00 aa b3 00    	mov    %eax,0xb3aa00(%edi)
    /* get the packet pointer */
    p = q->p;
  80e343:	8b 5a 04             	mov    0x4(%edx),%ebx
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80e346:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e34a:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80e351:	e8 eb aa ff ff       	call   808e41 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80e356:	89 34 24             	mov    %esi,(%esp)
  80e359:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80e35c:	89 da                	mov    %ebx,%edx
  80e35e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e361:	e8 da fb ff ff       	call   80df40 <_ZL14etharp_send_ipP5netifP4pbufP8eth_addrS4_>
    /* free the queued IP packet */
    pbuf_free(p);
  80e366:	89 1c 24             	mov    %ebx,(%esp)
  80e369:	e8 95 ae ff ff       	call   809203 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80e36e:	8b 97 00 aa b3 00    	mov    0xb3aa00(%edi),%edx
  80e374:	85 d2                	test   %edx,%edx
  80e376:	75 c3                	jne    80e33b <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0xff>
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
  80e378:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80e37d:	83 c4 2c             	add    $0x2c,%esp
  80e380:	5b                   	pop    %ebx
  80e381:	5e                   	pop    %esi
  80e382:	5f                   	pop    %edi
  80e383:	5d                   	pop    %ebp
  80e384:	c3                   	ret    
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80e385:	89 f8                	mov    %edi,%eax
  80e387:	0f b6 d0             	movzbl %al,%edx
  80e38a:	89 d8                	mov    %ebx,%eax
  80e38c:	e8 cb fc ff ff       	call   80e05c <_ZL10find_entryP7ip_addrh>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80e391:	84 c0                	test   %al,%al
  80e393:	0f 89 47 ff ff ff    	jns    80e2e0 <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0xa4>
  80e399:	eb e2                	jmp    80e37d <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh+0x141>

0080e39b <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80e39b:	55                   	push   %ebp
  80e39c:	89 e5                	mov    %esp,%ebp
  80e39e:	53                   	push   %ebx
  80e39f:	83 ec 04             	sub    $0x4,%esp
  80e3a2:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80e3a7:	0f b6 93 14 aa b3 00 	movzbl 0xb3aa14(%ebx),%edx
  80e3ae:	83 c2 01             	add    $0x1,%edx
  80e3b1:	88 93 14 aa b3 00    	mov    %dl,0xb3aa14(%ebx)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80e3b7:	8b 83 10 aa b3 00    	mov    0xb3aa10(%ebx),%eax
  80e3bd:	83 f8 02             	cmp    $0x2,%eax
  80e3c0:	75 07                	jne    80e3c9 <etharp_tmr+0x2e>
  80e3c2:	80 fa ef             	cmp    $0xef,%dl
  80e3c5:	77 10                	ja     80e3d7 <etharp_tmr+0x3c>
  80e3c7:	eb 31                	jmp    80e3fa <etharp_tmr+0x5f>
  80e3c9:	83 f8 01             	cmp    $0x1,%eax
  80e3cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80e3d0:	75 28                	jne    80e3fa <etharp_tmr+0x5f>
  80e3d2:	80 fa 01             	cmp    $0x1,%dl
  80e3d5:	76 23                	jbe    80e3fa <etharp_tmr+0x5f>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80e3d7:	8b 83 00 aa b3 00    	mov    0xb3aa00(%ebx),%eax
  80e3dd:	85 c0                	test   %eax,%eax
  80e3df:	74 0f                	je     80e3f0 <etharp_tmr+0x55>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80e3e1:	e8 d9 fb ff ff       	call   80dfbf <_ZL13free_etharp_qP14etharp_q_entry>
        arp_table[i].q = NULL;
  80e3e6:	c7 83 00 aa b3 00 00 	movl   $0x0,0xb3aa00(%ebx)
  80e3ed:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80e3f0:	c7 83 10 aa b3 00 00 	movl   $0x0,0xb3aa10(%ebx)
  80e3f7:	00 00 00 
  80e3fa:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80e3fd:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80e403:	75 a2                	jne    80e3a7 <etharp_tmr+0xc>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80e405:	83 c4 04             	add    $0x4,%esp
  80e408:	5b                   	pop    %ebx
  80e409:	5d                   	pop    %ebp
  80e40a:	c3                   	ret    

0080e40b <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80e40b:	55                   	push   %ebp
  80e40c:	89 e5                	mov    %esp,%ebp
  80e40e:	53                   	push   %ebx
  80e40f:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80e412:	ba 02 00 00 00       	mov    $0x2,%edx
  80e417:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e41a:	e8 3d fc ff ff       	call   80e05c <_ZL10find_entryP7ip_addrh>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80e41f:	84 c0                	test   %al,%al
  80e421:	78 29                	js     80e44c <etharp_find_addr+0x41>
  80e423:	0f be d0             	movsbl %al,%edx
  80e426:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80e429:	83 b9 10 aa b3 00 02 	cmpl   $0x2,0xb3aa10(%ecx)
  80e430:	75 21                	jne    80e453 <etharp_find_addr+0x48>
      *eth_ret = &arp_table[i].ethaddr;
  80e432:	89 ca                	mov    %ecx,%edx
  80e434:	8d 99 08 aa b3 00    	lea    0xb3aa08(%ecx),%ebx
  80e43a:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80e43d:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80e43f:	81 c2 04 aa b3 00    	add    $0xb3aa04,%edx
  80e445:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80e448:	89 11                	mov    %edx,(%ecx)
      return i;
  80e44a:	eb 0c                	jmp    80e458 <etharp_find_addr+0x4d>
  }
  return -1;
  80e44c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80e451:	eb 05                	jmp    80e458 <etharp_find_addr+0x4d>
  80e453:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80e458:	83 c4 04             	add    $0x4,%esp
  80e45b:	5b                   	pop    %ebx
  80e45c:	5d                   	pop    %ebp
  80e45d:	c3                   	ret    

0080e45e <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80e45e:	55                   	push   %ebp
  80e45f:	89 e5                	mov    %esp,%ebp
  80e461:	83 ec 18             	sub    $0x18,%esp
  80e464:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80e467:	85 c0                	test   %eax,%eax
  80e469:	75 1c                	jne    80e487 <etharp_ip_input+0x29>
  80e46b:	c7 44 24 08 c2 56 81 	movl   $0x8156c2,0x8(%esp)
  80e472:	00 
  80e473:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80e47a:	00 
  80e47b:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e482:	e8 31 25 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = (struct ethip_hdr *) p->payload;
  80e487:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e48a:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80e48d:	8b 48 04             	mov    0x4(%eax),%ecx
  80e490:	33 4a 1c             	xor    0x1c(%edx),%ecx
  80e493:	85 48 08             	test   %ecx,0x8(%eax)
  80e496:	75 12                	jne    80e4aa <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80e498:	8d 4a 06             	lea    0x6(%edx),%ecx
  80e49b:	83 c2 1c             	add    $0x1c,%edx
  80e49e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e4a5:	e8 92 fd ff ff       	call   80e23c <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh>
}
  80e4aa:	c9                   	leave  
  80e4ab:	c3                   	ret    

0080e4ac <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80e4ac:	55                   	push   %ebp
  80e4ad:	89 e5                	mov    %esp,%ebp
  80e4af:	83 ec 48             	sub    $0x48,%esp
  80e4b2:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80e4b5:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80e4b8:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80e4bb:	8b 7d 08             	mov    0x8(%ebp),%edi
  80e4be:	8b 75 10             	mov    0x10(%ebp),%esi
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80e4c1:	85 ff                	test   %edi,%edi
  80e4c3:	75 1c                	jne    80e4e1 <etharp_arp_input+0x35>
  80e4c5:	c7 44 24 08 c2 56 81 	movl   $0x8156c2,0x8(%esp)
  80e4cc:	00 
  80e4cd:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80e4d4:	00 
  80e4d5:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e4dc:	e8 d7 24 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80e4e1:	66 83 7e 0a 29       	cmpw   $0x29,0xa(%esi)
  80e4e6:	77 0d                	ja     80e4f5 <etharp_arp_input+0x49>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80e4e8:	89 34 24             	mov    %esi,(%esp)
  80e4eb:	e8 13 ad ff ff       	call   809203 <pbuf_free>
    return;
  80e4f0:	e9 b9 01 00 00       	jmp    80e6ae <etharp_arp_input+0x202>
  }

  hdr = (struct etharp_hdr *) p->payload;
  80e4f5:	8b 5e 04             	mov    0x4(%esi),%ebx

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80e4f8:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  80e4fc:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
  80e500:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e507:	e8 ad de ff ff       	call   80c3b9 <htons>
  80e50c:	66 39 45 d4          	cmp    %ax,-0x2c(%ebp)
  80e510:	75 52                	jne    80e564 <etharp_arp_input+0xb8>
  80e512:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80e516:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80e51a:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80e521:	e8 93 de ff ff       	call   80c3b9 <htons>
  }

  hdr = (struct etharp_hdr *) p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80e526:	66 39 45 d4          	cmp    %ax,-0x2c(%ebp)
  80e52a:	75 38                	jne    80e564 <etharp_arp_input+0xb8>
  80e52c:	0f b7 43 10          	movzwl 0x10(%ebx),%eax
  80e530:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80e534:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80e53b:	e8 79 de ff ff       	call   80c3b9 <htons>
  }

  hdr = (struct etharp_hdr *) p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80e540:	66 39 45 d4          	cmp    %ax,-0x2c(%ebp)
  80e544:	75 1e                	jne    80e564 <etharp_arp_input+0xb8>
  80e546:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80e54a:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80e54e:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80e555:	e8 5f de ff ff       	call   80c3b9 <htons>
  }

  hdr = (struct etharp_hdr *) p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80e55a:	66 39 45 d4          	cmp    %ax,-0x2c(%ebp)
  80e55e:	0f 84 02 01 00 00    	je     80e666 <etharp_arp_input+0x1ba>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80e564:	89 34 24             	mov    %esi,(%esp)
  80e567:	e8 97 ac ff ff       	call   809203 <pbuf_free>
    return;
  80e56c:	e9 3d 01 00 00       	jmp    80e6ae <etharp_arp_input+0x202>
  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80e571:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80e574:	0f 94 45 d4          	sete   -0x2c(%ebp)
  80e578:	75 16                	jne    80e590 <etharp_arp_input+0xe4>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80e57a:	8d 4b 16             	lea    0x16(%ebx),%ecx
  80e57d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e584:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80e587:	89 f8                	mov    %edi,%eax
  80e589:	e8 ae fc ff ff       	call   80e23c <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh>
  80e58e:	eb 14                	jmp    80e5a4 <etharp_arp_input+0xf8>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80e590:	8d 4b 16             	lea    0x16(%ebx),%ecx
  80e593:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e59a:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80e59d:	89 f8                	mov    %edi,%eax
  80e59f:	e8 98 fc ff ff       	call   80e23c <_ZL16update_arp_entryP5netifP7ip_addrP8eth_addrh>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80e5a4:	0f b7 43 14          	movzwl 0x14(%ebx),%eax
  80e5a8:	89 04 24             	mov    %eax,(%esp)
  80e5ab:	e8 09 de ff ff       	call   80c3b9 <htons>
  80e5b0:	66 83 f8 01          	cmp    $0x1,%ax
  80e5b4:	74 0f                	je     80e5c5 <etharp_arp_input+0x119>
  80e5b6:	66 83 f8 02          	cmp    $0x2,%ax
  80e5ba:	0f 85 9c 00 00 00    	jne    80e65c <etharp_arp_input+0x1b0>
  80e5c0:	e9 88 00 00 00       	jmp    80e64d <etharp_arp_input+0x1a1>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80e5c5:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
  80e5c9:	0f 84 8d 00 00 00    	je     80e65c <etharp_arp_input+0x1b0>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80e5cf:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e5d6:	e8 de dd ff ff       	call   80c3b9 <htons>
  80e5db:	66 89 43 14          	mov    %ax,0x14(%ebx)

      hdr->dipaddr = hdr->sipaddr;
  80e5df:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80e5e2:	89 43 26             	mov    %eax,0x26(%ebx)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80e5e5:	8b 47 04             	mov    0x4(%edi),%eax
  80e5e8:	89 43 1c             	mov    %eax,0x1c(%ebx)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80e5eb:	80 7f 24 06          	cmpb   $0x6,0x24(%edi)
  80e5ef:	74 1c                	je     80e60d <etharp_arp_input+0x161>
  80e5f1:	c7 44 24 08 7c 63 81 	movl   $0x81637c,0x8(%esp)
  80e5f8:	00 
  80e5f9:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80e600:	00 
  80e601:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e608:	e8 ab 23 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80e60d:	ba 06 00 00 00       	mov    $0x6,%edx
  80e612:	89 7d d4             	mov    %edi,-0x2c(%ebp)
  80e615:	8b 7d 0c             	mov    0xc(%ebp),%edi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80e618:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80e61b:	0f b6 c2             	movzbl %dl,%eax
  80e61e:	0f b6 4c 03 16       	movzbl 0x16(%ebx,%eax,1),%ecx
  80e623:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80e627:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80e62a:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80e62e:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80e632:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80e636:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80e63a:	84 d2                	test   %dl,%dl
  80e63c:	75 da                	jne    80e618 <etharp_arp_input+0x16c>
  80e63e:	8b 7d d4             	mov    -0x2c(%ebp),%edi

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80e641:	89 74 24 04          	mov    %esi,0x4(%esp)
  80e645:	89 3c 24             	mov    %edi,(%esp)
  80e648:	ff 57 18             	call   *0x18(%edi)
  80e64b:	eb 0f                	jmp    80e65c <etharp_arp_input+0x1b0>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80e64d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e650:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e654:	89 3c 24             	mov    %edi,(%esp)
  80e657:	e8 d4 9a ff ff       	call   808130 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80e65c:	89 34 24             	mov    %esi,(%esp)
  80e65f:	e8 9f ab ff ff       	call   809203 <pbuf_free>
  80e664:	eb 48                	jmp    80e6ae <etharp_arp_input+0x202>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80e666:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e66d:	00 
  80e66e:	8d 43 1c             	lea    0x1c(%ebx),%eax
  80e671:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e675:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e678:	89 04 24             	mov    %eax,(%esp)
  80e67b:	e8 87 2c ff ff       	call   801307 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80e680:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e687:	00 
  80e688:	8d 43 26             	lea    0x26(%ebx),%eax
  80e68b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e68f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80e692:	89 04 24             	mov    %eax,(%esp)
  80e695:	e8 6d 2c ff ff       	call   801307 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80e69a:	8b 47 04             	mov    0x4(%edi),%eax
    for_us = 0;
  80e69d:	c6 45 d4 00          	movb   $0x0,-0x2c(%ebp)
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80e6a1:	85 c0                	test   %eax,%eax
  80e6a3:	0f 84 e7 fe ff ff    	je     80e590 <etharp_arp_input+0xe4>
  80e6a9:	e9 c3 fe ff ff       	jmp    80e571 <etharp_arp_input+0xc5>
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
}
  80e6ae:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80e6b1:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80e6b4:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80e6b7:	89 ec                	mov    %ebp,%esp
  80e6b9:	5d                   	pop    %ebp
  80e6ba:	c3                   	ret    

0080e6bb <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80e6bb:	55                   	push   %ebp
  80e6bc:	89 e5                	mov    %esp,%ebp
  80e6be:	57                   	push   %edi
  80e6bf:	56                   	push   %esi
  80e6c0:	53                   	push   %ebx
  80e6c1:	83 ec 1c             	sub    $0x1c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
  80e6c4:	8b 75 08             	mov    0x8(%ebp),%esi
  80e6c7:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80e6ca:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e6d1:	00 
  80e6d2:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80e6d9:	00 
  80e6da:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80e6e1:	e8 3f ad ff ff       	call   809425 <pbuf_alloc>
  80e6e6:	89 c7                	mov    %eax,%edi
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80e6e8:	85 c0                	test   %eax,%eax
  80e6ea:	0f 84 f9 00 00 00    	je     80e7e9 <etharp_request+0x12e>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80e6f0:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80e6f5:	77 1c                	ja     80e713 <etharp_request+0x58>
  80e6f7:	c7 44 24 08 e8 63 81 	movl   $0x8163e8,0x8(%esp)
  80e6fe:	00 
  80e6ff:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80e706:	00 
  80e707:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e70e:	e8 a5 22 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = (struct etharp_hdr *) p->payload;
  80e713:	8b 58 04             	mov    0x4(%eax),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80e716:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e71d:	e8 97 dc ff ff       	call   80c3b9 <htons>
  80e722:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80e726:	8b 45 08             	mov    0x8(%ebp),%eax
  80e729:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80e72d:	74 1c                	je     80e74b <etharp_request+0x90>
  80e72f:	c7 44 24 08 7c 63 81 	movl   $0x81637c,0x8(%esp)
  80e736:	00 
  80e737:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80e73e:	00 
  80e73f:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e746:	e8 6d 22 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80e74b:	ba 06 00 00 00       	mov    $0x6,%edx
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80e750:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80e753:	0f b6 c2             	movzbl %dl,%eax
  80e756:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80e75a:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80e75e:	0f b6 88 e1 64 81 00 	movzbl 0x8164e1(%eax),%ecx
  80e765:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80e769:	0f b6 88 db 64 81 00 	movzbl 0x8164db(%eax),%ecx
  80e770:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80e773:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80e777:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80e77b:	84 d2                	test   %dl,%dl
  80e77d:	75 d1                	jne    80e750 <etharp_request+0x95>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80e77f:	8b 55 08             	mov    0x8(%ebp),%edx
  80e782:	8b 42 04             	mov    0x4(%edx),%eax
  80e785:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80e788:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e78b:	8b 00                	mov    (%eax),%eax
  80e78d:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80e790:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80e797:	e8 1d dc ff ff       	call   80c3b9 <htons>
  80e79c:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80e7a0:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80e7a7:	e8 0d dc ff ff       	call   80c3b9 <htons>
  80e7ac:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80e7b0:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80e7b7:	e8 fd db ff ff       	call   80c3b9 <htons>
  80e7bc:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80e7c0:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80e7c7:	e8 ed db ff ff       	call   80c3b9 <htons>
  80e7cc:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80e7d0:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80e7d4:	8b 45 08             	mov    0x8(%ebp),%eax
  80e7d7:	89 04 24             	mov    %eax,(%esp)
  80e7da:	ff 50 18             	call   *0x18(%eax)
  80e7dd:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80e7df:	89 3c 24             	mov    %edi,(%esp)
  80e7e2:	e8 1c aa ff ff       	call   809203 <pbuf_free>
  80e7e7:	eb 05                	jmp    80e7ee <etharp_request+0x133>
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  80e7e9:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80e7ee:	89 d8                	mov    %ebx,%eax
  80e7f0:	83 c4 1c             	add    $0x1c,%esp
  80e7f3:	5b                   	pop    %ebx
  80e7f4:	5e                   	pop    %esi
  80e7f5:	5f                   	pop    %edi
  80e7f6:	5d                   	pop    %ebp
  80e7f7:	c3                   	ret    

0080e7f8 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80e7f8:	55                   	push   %ebp
  80e7f9:	89 e5                	mov    %esp,%ebp
  80e7fb:	83 ec 38             	sub    $0x38,%esp
  80e7fe:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80e801:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80e804:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80e807:	8b 75 08             	mov    0x8(%ebp),%esi
  80e80a:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80e80d:	89 74 24 04          	mov    %esi,0x4(%esp)
  80e811:	89 1c 24             	mov    %ebx,(%esp)
  80e814:	e8 c7 c7 ff ff       	call   80afe0 <ip_addr_isbroadcast>
  80e819:	89 c2                	mov    %eax,%edx
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80e81b:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80e820:	84 d2                	test   %dl,%dl
  80e822:	0f 85 c3 01 00 00    	jne    80e9eb <etharp_query+0x1f3>
  80e828:	8b 03                	mov    (%ebx),%eax
  80e82a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      ip_addr_ismulticast(ipaddr) ||
  80e82d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80e834:	e8 00 de ff ff       	call   80c639 <ntohl>
  80e839:	89 c7                	mov    %eax,%edi
  80e83b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80e842:	e8 f2 dd ff ff       	call   80c639 <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80e847:	23 7d e4             	and    -0x1c(%ebp),%edi
  80e84a:	39 c7                	cmp    %eax,%edi
  80e84c:	0f 84 89 01 00 00    	je     80e9db <etharp_query+0x1e3>
  80e852:	85 db                	test   %ebx,%ebx
  80e854:	0f 84 88 01 00 00    	je     80e9e2 <etharp_query+0x1ea>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80e85a:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80e85f:	83 3b 00             	cmpl   $0x0,(%ebx)
  80e862:	0f 84 83 01 00 00    	je     80e9eb <etharp_query+0x1f3>
  80e868:	e9 8b 01 00 00       	jmp    80e9f8 <etharp_query+0x200>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80e86d:	0f be f8             	movsbl %al,%edi
  80e870:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80e873:	8b 80 10 aa b3 00    	mov    0xb3aa10(%eax),%eax
  80e879:	85 c0                	test   %eax,%eax
  80e87b:	75 0f                	jne    80e88c <etharp_query+0x94>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80e87d:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80e880:	c7 80 10 aa b3 00 01 	movl   $0x1,0xb3aa10(%eax)
  80e887:	00 00 00 
  80e88a:	eb 2f                	jmp    80e8bb <etharp_query+0xc3>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80e88c:	8d 50 ff             	lea    -0x1(%eax),%edx
  80e88f:	83 fa 01             	cmp    $0x1,%edx
  80e892:	76 1c                	jbe    80e8b0 <etharp_query+0xb8>
  80e894:	c7 44 24 08 1c 64 81 	movl   $0x81641c,0x8(%esp)
  80e89b:	00 
  80e89c:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80e8a3:	00 
  80e8a4:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e8ab:	e8 08 21 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80e8b0:	83 f8 01             	cmp    $0x1,%eax
  80e8b3:	74 06                	je     80e8bb <etharp_query+0xc3>
  80e8b5:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80e8b9:	75 10                	jne    80e8cb <etharp_query+0xd3>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80e8bb:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80e8bf:	89 34 24             	mov    %esi,(%esp)
  80e8c2:	e8 f4 fd ff ff       	call   80e6bb <etharp_request>
  80e8c7:	89 c3                	mov    %eax,%ebx
  80e8c9:	eb 05                	jmp    80e8d0 <etharp_query+0xd8>
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  80e8cb:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80e8d0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80e8d4:	0f 84 0f 01 00 00    	je     80e9e9 <etharp_query+0x1f1>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80e8da:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80e8dd:	8b 90 10 aa b3 00    	mov    0xb3aa10(%eax),%edx
  80e8e3:	83 fa 02             	cmp    $0x2,%edx
  80e8e6:	75 1d                	jne    80e905 <etharp_query+0x10d>
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  80e8e8:	8d 4e 25             	lea    0x25(%esi),%ecx
  if (q != NULL) {
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80e8eb:	89 c7                	mov    %eax,%edi
  80e8ed:	81 c7 08 aa b3 00    	add    $0xb3aa08,%edi
  80e8f3:	89 3c 24             	mov    %edi,(%esp)
  80e8f6:	8b 55 10             	mov    0x10(%ebp),%edx
  80e8f9:	89 f0                	mov    %esi,%eax
  80e8fb:	e8 40 f6 ff ff       	call   80df40 <_ZL14etharp_send_ipP5netifP4pbufP8eth_addrS4_>
  80e900:	e9 e6 00 00 00       	jmp    80e9eb <etharp_query+0x1f3>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80e905:	89 d8                	mov    %ebx,%eax
  80e907:	83 fa 01             	cmp    $0x1,%edx
  80e90a:	0f 85 db 00 00 00    	jne    80e9eb <etharp_query+0x1f3>
  80e910:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80e913:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80e917:	66 39 50 0a          	cmp    %dx,0xa(%eax)
  80e91b:	75 21                	jne    80e93e <etharp_query+0x146>
  80e91d:	83 38 00             	cmpl   $0x0,(%eax)
  80e920:	74 1c                	je     80e93e <etharp_query+0x146>
  80e922:	c7 44 24 08 c1 64 81 	movl   $0x8164c1,0x8(%esp)
  80e929:	00 
  80e92a:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80e931:	00 
  80e932:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80e939:	e8 7a 20 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        if(p->type != PBUF_ROM) {
  80e93e:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80e942:	75 0b                	jne    80e94f <etharp_query+0x157>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80e944:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80e946:	85 c0                	test   %eax,%eax
  80e948:	75 c9                	jne    80e913 <etharp_query+0x11b>
  80e94a:	e9 bf 00 00 00       	jmp    80ea0e <etharp_query+0x216>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80e94f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80e953:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e95a:	00 
  80e95b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e95f:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80e966:	e8 ba aa ff ff       	call   809425 <pbuf_alloc>
  80e96b:	89 c6                	mov    %eax,%esi
        if(p != NULL) {
  80e96d:	89 d8                	mov    %ebx,%eax
  80e96f:	85 f6                	test   %esi,%esi
  80e971:	74 78                	je     80e9eb <etharp_query+0x1f3>
          if (pbuf_copy(p, q) != ERR_OK) {
  80e973:	8b 45 10             	mov    0x10(%ebp),%eax
  80e976:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e97a:	89 34 24             	mov    %esi,(%esp)
  80e97d:	e8 fd ae ff ff       	call   80987f <pbuf_copy>
  80e982:	84 c0                	test   %al,%al
  80e984:	0f 84 92 00 00 00    	je     80ea1c <etharp_query+0x224>
            pbuf_free(p);
  80e98a:	89 34 24             	mov    %esi,(%esp)
  80e98d:	e8 71 a8 ff ff       	call   809203 <pbuf_free>
  80e992:	89 d8                	mov    %ebx,%eax
  80e994:	eb 55                	jmp    80e9eb <etharp_query+0x1f3>
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = (struct etharp_q_entry *) memp_malloc(MEMP_ARP_QUEUE);
        if (new_entry != NULL) {
          new_entry->next = 0;
  80e996:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80e99c:	89 70 04             	mov    %esi,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80e99f:	6b d7 1c             	imul   $0x1c,%edi,%edx
  80e9a2:	8b 8a 00 aa b3 00    	mov    0xb3aa00(%edx),%ecx
  80e9a8:	85 c9                	test   %ecx,%ecx
  80e9aa:	75 04                	jne    80e9b0 <etharp_query+0x1b8>
  80e9ac:	eb 11                	jmp    80e9bf <etharp_query+0x1c7>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
              r = r->next;
  80e9ae:	89 d1                	mov    %edx,%ecx
          new_entry->p = p;
          if(arp_table[i].q != NULL) {
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80e9b0:	8b 11                	mov    (%ecx),%edx
  80e9b2:	85 d2                	test   %edx,%edx
  80e9b4:	75 f8                	jne    80e9ae <etharp_query+0x1b6>
              r = r->next;
            }
            r->next = new_entry;
  80e9b6:	89 01                	mov    %eax,(%ecx)
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80e9b8:	b8 00 00 00 00       	mov    $0x0,%eax
  80e9bd:	eb 2c                	jmp    80e9eb <etharp_query+0x1f3>
              r = r->next;
            }
            r->next = new_entry;
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80e9bf:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80e9c2:	89 87 00 aa b3 00    	mov    %eax,0xb3aa00(%edi)
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
  80e9c8:	b8 00 00 00 00       	mov    $0x0,%eax
  80e9cd:	eb 1c                	jmp    80e9eb <etharp_query+0x1f3>
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80e9cf:	89 34 24             	mov    %esi,(%esp)
  80e9d2:	e8 2c a8 ff ff       	call   809203 <pbuf_free>
  80e9d7:	89 d8                	mov    %ebx,%eax
  80e9d9:	eb 10                	jmp    80e9eb <etharp_query+0x1f3>
  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: will not add non-unicast IP address to ARP cache\n"));
    return ERR_ARG;
  80e9db:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80e9e0:	eb 09                	jmp    80e9eb <etharp_query+0x1f3>
  80e9e2:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80e9e7:	eb 02                	jmp    80e9eb <etharp_query+0x1f3>
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80e9e9:	89 d8                	mov    %ebx,%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80e9eb:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80e9ee:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80e9f1:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80e9f4:	89 ec                	mov    %ebp,%esp
  80e9f6:	5d                   	pop    %ebp
  80e9f7:	c3                   	ret    

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80e9f8:	ba 01 00 00 00       	mov    $0x1,%edx
  80e9fd:	89 d8                	mov    %ebx,%eax
  80e9ff:	e8 58 f6 ff ff       	call   80e05c <_ZL10find_entryP7ip_addrh>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80ea04:	84 c0                	test   %al,%al
  80ea06:	0f 89 61 fe ff ff    	jns    80e86d <etharp_query+0x75>
  80ea0c:	eb dd                	jmp    80e9eb <etharp_query+0x1f3>
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80ea0e:	8b 55 10             	mov    0x10(%ebp),%edx
  80ea11:	89 14 24             	mov    %edx,(%esp)
  80ea14:	e8 d2 ac ff ff       	call   8096eb <pbuf_ref>
            p = NULL;
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
  80ea19:	8b 75 10             	mov    0x10(%ebp),%esi
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = (struct etharp_q_entry *) memp_malloc(MEMP_ARP_QUEUE);
  80ea1c:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80ea23:	e8 b9 a3 ff ff       	call   808de1 <memp_malloc>
        if (new_entry != NULL) {
  80ea28:	85 c0                	test   %eax,%eax
  80ea2a:	0f 85 66 ff ff ff    	jne    80e996 <etharp_query+0x19e>
  80ea30:	eb 9d                	jmp    80e9cf <etharp_query+0x1d7>

0080ea32 <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80ea32:	55                   	push   %ebp
  80ea33:	89 e5                	mov    %esp,%ebp
  80ea35:	83 ec 48             	sub    $0x48,%esp
  80ea38:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ea3b:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ea3e:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ea41:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ea44:	8b 75 0c             	mov    0xc(%ebp),%esi
  80ea47:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80ea4a:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80ea51:	00 
  80ea52:	89 34 24             	mov    %esi,(%esp)
  80ea55:	e8 b6 a6 ff ff       	call   809110 <pbuf_header>
  80ea5a:	89 c2                	mov    %eax,%edx
    /* bail out */
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_output: could not allocate room for header.\n"));
    LINK_STATS_INC(link.lenerr);
    return ERR_BUF;
  80ea5c:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80ea61:	84 d2                	test   %dl,%dl
  80ea63:	0f 85 bd 00 00 00    	jne    80eb26 <etharp_output+0xf4>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80ea69:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ea6d:	89 3c 24             	mov    %edi,(%esp)
  80ea70:	e8 6b c5 ff ff       	call   80afe0 <ip_addr_isbroadcast>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  80ea75:	ba db 64 81 00       	mov    $0x8164db,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80ea7a:	84 c0                	test   %al,%al
  80ea7c:	0f 85 95 00 00 00    	jne    80eb17 <etharp_output+0xe5>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80ea82:	8b 07                	mov    (%edi),%eax
  80ea84:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80ea87:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80ea8e:	e8 a6 db ff ff       	call   80c639 <ntohl>
  80ea93:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80ea96:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80ea9d:	e8 97 db ff ff       	call   80c639 <ntohl>
  80eaa2:	8b 55 d0             	mov    -0x30(%ebp),%edx
  80eaa5:	23 55 d4             	and    -0x2c(%ebp),%edx
  80eaa8:	39 c2                	cmp    %eax,%edx
  80eaaa:	75 41                	jne    80eaed <etharp_output+0xbb>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80eaac:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80eab0:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80eab4:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80eab8:	8b 07                	mov    (%edi),%eax
  80eaba:	89 04 24             	mov    %eax,(%esp)
  80eabd:	e8 77 db ff ff       	call   80c639 <ntohl>
  80eac2:	c1 e8 10             	shr    $0x10,%eax
  80eac5:	83 e0 7f             	and    $0x7f,%eax
  80eac8:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80eacb:	8b 07                	mov    (%edi),%eax
  80eacd:	89 04 24             	mov    %eax,(%esp)
  80ead0:	e8 64 db ff ff       	call   80c639 <ntohl>
  80ead5:	c1 e8 08             	shr    $0x8,%eax
  80ead8:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80eadb:	8b 07                	mov    (%edi),%eax
  80eadd:	89 04 24             	mov    %eax,(%esp)
  80eae0:	e8 54 db ff ff       	call   80c639 <ntohl>
  80eae5:	88 45 e7             	mov    %al,-0x19(%ebp)
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  80eae8:	8d 55 e2             	lea    -0x1e(%ebp),%edx
  80eaeb:	eb 2a                	jmp    80eb17 <etharp_output+0xe5>
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80eaed:	8b 43 04             	mov    0x4(%ebx),%eax
  80eaf0:	33 07                	xor    (%edi),%eax
  80eaf2:	85 43 08             	test   %eax,0x8(%ebx)
  80eaf5:	74 0e                	je     80eb05 <etharp_output+0xd3>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
      /* no default gateway available */
      } else {
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
  80eaf7:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80eafc:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80eb00:	74 24                	je     80eb26 <etharp_output+0xf4>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80eb02:	8d 7b 0c             	lea    0xc(%ebx),%edi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80eb05:	89 74 24 08          	mov    %esi,0x8(%esp)
  80eb09:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80eb0d:	89 1c 24             	mov    %ebx,(%esp)
  80eb10:	e8 e3 fc ff ff       	call   80e7f8 <etharp_query>
  80eb15:	eb 0f                	jmp    80eb26 <etharp_output+0xf4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80eb17:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80eb1a:	89 14 24             	mov    %edx,(%esp)
  80eb1d:	89 f2                	mov    %esi,%edx
  80eb1f:	89 d8                	mov    %ebx,%eax
  80eb21:	e8 1a f4 ff ff       	call   80df40 <_ZL14etharp_send_ipP5netifP4pbufP8eth_addrS4_>
}
  80eb26:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80eb29:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80eb2c:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80eb2f:	89 ec                	mov    %ebp,%esp
  80eb31:	5d                   	pop    %ebp
  80eb32:	c3                   	ret    

0080eb33 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80eb33:	55                   	push   %ebp
  80eb34:	89 e5                	mov    %esp,%ebp
  80eb36:	83 ec 18             	sub    $0x18,%esp
  80eb39:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80eb3c:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80eb3f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80eb42:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80eb45:	8b 43 04             	mov    0x4(%ebx),%eax
  80eb48:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80eb4c:	89 04 24             	mov    %eax,(%esp)
  80eb4f:	e8 65 d8 ff ff       	call   80c3b9 <htons>
  80eb54:	66 3d 00 08          	cmp    $0x800,%ax
  80eb58:	74 08                	je     80eb62 <ethernet_input+0x2f>
  80eb5a:	66 3d 06 08          	cmp    $0x806,%ax
  80eb5e:	75 61                	jne    80ebc1 <ethernet_input+0x8e>
  80eb60:	eb 4a                	jmp    80ebac <ethernet_input+0x79>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80eb62:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80eb66:	89 34 24             	mov    %esi,(%esp)
  80eb69:	e8 f0 f8 ff ff       	call   80e45e <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80eb6e:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80eb75:	ff 
  80eb76:	89 1c 24             	mov    %ebx,(%esp)
  80eb79:	e8 92 a5 ff ff       	call   809110 <pbuf_header>
  80eb7e:	84 c0                	test   %al,%al
  80eb80:	74 1c                	je     80eb9e <ethernet_input+0x6b>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80eb82:	c7 44 24 08 44 64 81 	movl   $0x816444,0x8(%esp)
  80eb89:	00 
  80eb8a:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80eb91:	00 
  80eb92:	c7 04 24 65 64 81 00 	movl   $0x816465,(%esp)
  80eb99:	e8 1a 1e ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80eb9e:	89 74 24 04          	mov    %esi,0x4(%esp)
  80eba2:	89 1c 24             	mov    %ebx,(%esp)
  80eba5:	e8 cf c4 ff ff       	call   80b079 <ip_input>
      }
      break;
  80ebaa:	eb 1d                	jmp    80ebc9 <ethernet_input+0x96>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80ebac:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80ebb0:	8d 46 25             	lea    0x25(%esi),%eax
  80ebb3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ebb7:	89 34 24             	mov    %esi,(%esp)
  80ebba:	e8 ed f8 ff ff       	call   80e4ac <etharp_arp_input>
      break;
  80ebbf:	eb 08                	jmp    80ebc9 <ethernet_input+0x96>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80ebc1:	89 1c 24             	mov    %ebx,(%esp)
  80ebc4:	e8 3a a6 ff ff       	call   809203 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80ebc9:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebce:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80ebd1:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80ebd4:	89 ec                	mov    %ebp,%esp
  80ebd6:	5d                   	pop    %ebp
  80ebd7:	c3                   	ret    
	...

0080ebe0 <_ZL15timeout_cleanupj>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80ebe0:	55                   	push   %ebp
  80ebe1:	89 e5                	mov    %esp,%ebp
  80ebe3:	83 ec 18             	sub    $0x18,%esp
  80ebe6:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ebe9:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80ebee:	89 c8                	mov    %ecx,%eax
  80ebf0:	f7 e2                	mul    %edx
  80ebf2:	c1 ea 08             	shr    $0x8,%edx
  80ebf5:	89 d0                	mov    %edx,%eax
  80ebf7:	c1 e0 08             	shl    $0x8,%eax
  80ebfa:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80ebfd:	89 c8                	mov    %ecx,%eax
  80ebff:	29 d0                	sub    %edx,%eax
  80ec01:	8b 04 85 20 ab b3 00 	mov    0xb3ab20(,%eax,4),%eax
  80ec08:	85 c0                	test   %eax,%eax
  80ec0a:	74 66                	je     80ec72 <_ZL15timeout_cleanupj+0x92>
	if (t->tid == tid) {
  80ec0c:	39 08                	cmp    %ecx,(%eax)
  80ec0e:	75 5b                	jne    80ec6b <_ZL15timeout_cleanupj+0x8b>
  80ec10:	eb 04                	jmp    80ec16 <_ZL15timeout_cleanupj+0x36>
  80ec12:	39 08                	cmp    %ecx,(%eax)
  80ec14:	75 55                	jne    80ec6b <_ZL15timeout_cleanupj+0x8b>
	    LIST_REMOVE(t, link);
  80ec16:	8b 48 0c             	mov    0xc(%eax),%ecx
  80ec19:	85 c9                	test   %ecx,%ecx
  80ec1b:	75 24                	jne    80ec41 <_ZL15timeout_cleanupj+0x61>
  80ec1d:	c7 44 24 0c ab 65 81 	movl   $0x8165ab,0xc(%esp)
  80ec24:	00 
  80ec25:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80ec2c:	00 
  80ec2d:	c7 44 24 04 16 01 00 	movl   $0x116,0x4(%esp)
  80ec34:	00 
  80ec35:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80ec3c:	e8 77 1d ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80ec41:	8b 50 08             	mov    0x8(%eax),%edx
  80ec44:	85 d2                	test   %edx,%edx
  80ec46:	74 03                	je     80ec4b <_ZL15timeout_cleanupj+0x6b>
  80ec48:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80ec4b:	8b 50 0c             	mov    0xc(%eax),%edx
  80ec4e:	8b 48 08             	mov    0x8(%eax),%ecx
  80ec51:	89 0a                	mov    %ecx,(%edx)
  80ec53:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
  80ec5a:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
	    free(t);
  80ec61:	89 04 24             	mov    %eax,(%esp)
  80ec64:	e8 47 5a ff ff       	call   8046b0 <_Z4freePv>
	    goto done;
  80ec69:	eb 07                	jmp    80ec72 <_ZL15timeout_cleanupj+0x92>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80ec6b:	8b 40 08             	mov    0x8(%eax),%eax
  80ec6e:	85 c0                	test   %eax,%eax
  80ec70:	75 a0                	jne    80ec12 <_ZL15timeout_cleanupj+0x32>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80ec72:	c9                   	leave  
  80ec73:	c3                   	ret    

0080ec74 <_ZL17lwip_thread_entryj>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80ec74:	55                   	push   %ebp
  80ec75:	89 e5                	mov    %esp,%ebp
  80ec77:	53                   	push   %ebx
  80ec78:	83 ec 14             	sub    $0x14,%esp
  80ec7b:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80ec7e:	8b 43 04             	mov    0x4(%ebx),%eax
  80ec81:	89 04 24             	mov    %eax,(%esp)
  80ec84:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80ec86:	89 1c 24             	mov    %ebx,(%esp)
  80ec89:	e8 22 5a ff ff       	call   8046b0 <_Z4freePv>
}
  80ec8e:	83 c4 14             	add    $0x14,%esp
  80ec91:	5b                   	pop    %ebx
  80ec92:	5d                   	pop    %ebp
  80ec93:	c3                   	ret    

0080ec94 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80ec94:	55                   	push   %ebp
  80ec95:	89 e5                	mov    %esp,%ebp
  80ec97:	56                   	push   %esi
  80ec98:	53                   	push   %ebx
  80ec99:	83 ec 10             	sub    $0x10,%esp
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80ec9c:	c7 05 40 fd b3 00 01 	movl   $0x1,0xb3fd40
  80eca3:	00 00 00 
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80eca6:	83 3d 50 fd b3 00 00 	cmpl   $0x0,0xb3fd50
  80ecad:	74 3c                	je     80eceb <sys_init+0x57>
  80ecaf:	eb 16                	jmp    80ecc7 <sys_init+0x33>
void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80ecb1:	c7 41 08 01 00 00 00 	movl   $0x1,0x8(%ecx)
  80ecb8:	83 c2 14             	add    $0x14,%edx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80ecbb:	83 79 18 00          	cmpl   $0x0,0x18(%ecx)
  80ecbf:	74 3a                	je     80ecfb <sys_init+0x67>
  80ecc1:	89 1d 40 11 b4 00    	mov    %ebx,0xb41140
  80ecc7:	c7 44 24 0c c4 65 81 	movl   $0x8165c4,0xc(%esp)
  80ecce:	00 
  80eccf:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80ecd6:	00 
  80ecd7:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp)
  80ecde:	00 
  80ecdf:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80ece6:	e8 cd 1c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80eceb:	8b 1d 40 11 b4 00    	mov    0xb41140,%ebx
  80ecf1:	ba 4c fd b3 00       	mov    $0xb3fd4c,%edx

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80ecf6:	b8 00 00 00 00       	mov    $0x0,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80ecfb:	89 d1                	mov    %edx,%ecx
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80ecfd:	89 1a                	mov    %ebx,(%edx)
  80ecff:	85 db                	test   %ebx,%ebx
  80ed01:	74 0d                	je     80ed10 <sys_init+0x7c>
  80ed03:	8d 34 80             	lea    (%eax,%eax,4),%esi
  80ed06:	8d 34 b5 4c fd b3 00 	lea    0xb3fd4c(,%esi,4),%esi
  80ed0d:	89 73 10             	mov    %esi,0x10(%ebx)
  80ed10:	8d 1c 80             	lea    (%eax,%eax,4),%ebx
  80ed13:	8d 1c 9d 40 fd b3 00 	lea    0xb3fd40(,%ebx,4),%ebx
  80ed1a:	c7 41 04 40 11 b4 00 	movl   $0xb41140,0x4(%ecx)

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80ed21:	83 c0 01             	add    $0x1,%eax
  80ed24:	3d 00 01 00 00       	cmp    $0x100,%eax
  80ed29:	75 86                	jne    80ecb1 <sys_init+0x1d>
  80ed2b:	89 1d 40 11 b4 00    	mov    %ebx,0xb41140
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80ed31:	c7 05 40 af b3 00 01 	movl   $0x1,0xb3af40
  80ed38:	00 00 00 
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80ed3b:	83 3d d8 af b3 00 00 	cmpl   $0x0,0xb3afd8
  80ed42:	74 42                	je     80ed86 <sys_init+0xf2>
  80ed44:	eb 1c                	jmp    80ed62 <sys_init+0xce>
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80ed46:	c7 41 08 01 00 00 00 	movl   $0x1,0x8(%ecx)
  80ed4d:	81 c2 9c 00 00 00    	add    $0x9c,%edx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80ed53:	83 b9 a0 00 00 00 00 	cmpl   $0x0,0xa0(%ecx)
  80ed5a:	74 3a                	je     80ed96 <sys_init+0x102>
  80ed5c:	89 1d 44 11 b4 00    	mov    %ebx,0xb41144
  80ed62:	c7 44 24 0c e4 65 81 	movl   $0x8165e4,0xc(%esp)
  80ed69:	00 
  80ed6a:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80ed71:	00 
  80ed72:	c7 44 24 04 3e 00 00 	movl   $0x3e,0x4(%esp)
  80ed79:	00 
  80ed7a:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80ed81:	e8 32 1c ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80ed86:	8b 1d 44 11 b4 00    	mov    0xb41144,%ebx
  80ed8c:	ba d4 af b3 00       	mov    $0xb3afd4,%edx
  80ed91:	b8 00 00 00 00       	mov    $0x0,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80ed96:	89 d1                	mov    %edx,%ecx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80ed98:	89 1a                	mov    %ebx,(%edx)
  80ed9a:	85 db                	test   %ebx,%ebx
  80ed9c:	74 12                	je     80edb0 <sys_init+0x11c>
  80ed9e:	69 f0 9c 00 00 00    	imul   $0x9c,%eax,%esi
  80eda4:	81 c6 d4 af b3 00    	add    $0xb3afd4,%esi
  80edaa:	89 b3 98 00 00 00    	mov    %esi,0x98(%ebx)
  80edb0:	69 d8 9c 00 00 00    	imul   $0x9c,%eax,%ebx
  80edb6:	81 c3 40 af b3 00    	add    $0xb3af40,%ebx
  80edbc:	c7 41 04 44 11 b4 00 	movl   $0xb41144,0x4(%ecx)
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80edc3:	83 c0 01             	add    $0x1,%eax
  80edc6:	3d 80 00 00 00       	cmp    $0x80,%eax
  80edcb:	0f 85 75 ff ff ff    	jne    80ed46 <sys_init+0xb2>
  80edd1:	89 1d 44 11 b4 00    	mov    %ebx,0xb41144
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80edd7:	83 c4 10             	add    $0x10,%esp
  80edda:	5b                   	pop    %ebx
  80eddb:	5e                   	pop    %esi
  80eddc:	5d                   	pop    %ebp
  80eddd:	c3                   	ret    

0080edde <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80edde:	55                   	push   %ebp
  80eddf:	89 e5                	mov    %esp,%ebp
  80ede1:	53                   	push   %ebx
  80ede2:	83 ec 14             	sub    $0x14,%esp
  80ede5:	0f b6 5d 08          	movzbl 0x8(%ebp),%ebx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80ede9:	a1 40 11 b4 00       	mov    0xb41140,%eax
    if (!se) {
  80edee:	85 c0                	test   %eax,%eax
  80edf0:	75 16                	jne    80ee08 <sys_sem_new+0x2a>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80edf2:	c7 04 24 08 66 81 00 	movl   $0x816608,(%esp)
  80edf9:	e8 d8 1c ff ff       	call   800ad6 <_Z7cprintfPKcz>
	return SYS_SEM_NULL;
  80edfe:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80ee03:	e9 93 00 00 00       	jmp    80ee9b <sys_sem_new+0xbd>
    }
    LIST_REMOVE(se, link);
  80ee08:	8b 50 10             	mov    0x10(%eax),%edx
  80ee0b:	85 d2                	test   %edx,%edx
  80ee0d:	75 24                	jne    80ee33 <sys_sem_new+0x55>
  80ee0f:	c7 44 24 0c 04 65 81 	movl   $0x816504,0xc(%esp)
  80ee16:	00 
  80ee17:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80ee1e:	00 
  80ee1f:	c7 44 24 04 8c 00 00 	movl   $0x8c,0x4(%esp)
  80ee26:	00 
  80ee27:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80ee2e:	e8 85 1b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80ee33:	8b 48 0c             	mov    0xc(%eax),%ecx
  80ee36:	85 c9                	test   %ecx,%ecx
  80ee38:	74 03                	je     80ee3d <sys_sem_new+0x5f>
  80ee3a:	89 51 10             	mov    %edx,0x10(%ecx)
  80ee3d:	8b 50 10             	mov    0x10(%eax),%edx
  80ee40:	8b 48 0c             	mov    0xc(%eax),%ecx
  80ee43:	89 0a                	mov    %ecx,(%edx)
  80ee45:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  80ee4c:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
    assert(se->freed);
  80ee53:	83 38 00             	cmpl   $0x0,(%eax)
  80ee56:	75 24                	jne    80ee7c <sys_sem_new+0x9e>
  80ee58:	c7 44 24 0c 1d 65 81 	movl   $0x81651d,0xc(%esp)
  80ee5f:	00 
  80ee60:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80ee67:	00 
  80ee68:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80ee6f:	00 
  80ee70:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80ee77:	e8 3c 1b ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    se->freed = 0;
  80ee7c:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80ee82:	0f b6 db             	movzbl %bl,%ebx
  80ee85:	66 89 58 08          	mov    %bx,0x8(%eax)
    se->gen++;
  80ee89:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80ee8d:	2d 40 fd b3 00       	sub    $0xb3fd40,%eax
  80ee92:	c1 f8 02             	sar    $0x2,%eax
  80ee95:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80ee9b:	83 c4 14             	add    $0x14,%esp
  80ee9e:	5b                   	pop    %ebx
  80ee9f:	5d                   	pop    %ebp
  80eea0:	c3                   	ret    

0080eea1 <sys_sem_free>:

void
sys_sem_free(sys_sem_t sem)
{
  80eea1:	55                   	push   %ebp
  80eea2:	89 e5                	mov    %esp,%ebp
  80eea4:	83 ec 18             	sub    $0x18,%esp
  80eea7:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80eeaa:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80eead:	83 3c 95 40 fd b3 00 	cmpl   $0x0,0xb3fd40(,%edx,4)
  80eeb4:	00 
  80eeb5:	74 24                	je     80eedb <sys_sem_free+0x3a>
  80eeb7:	c7 44 24 0c 27 65 81 	movl   $0x816527,0xc(%esp)
  80eebe:	00 
  80eebf:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80eec6:	00 
  80eec7:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80eece:	00 
  80eecf:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80eed6:	e8 dd 1a ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    sems[sem].freed = 1;
  80eedb:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80eede:	c1 e1 02             	shl    $0x2,%ecx
  80eee1:	8d 91 40 fd b3 00    	lea    0xb3fd40(%ecx),%edx
  80eee7:	c7 81 40 fd b3 00 01 	movl   $0x1,0xb3fd40(%ecx)
  80eeee:	00 00 00 
    sems[sem].gen++;
  80eef1:	83 42 04 01          	addl   $0x1,0x4(%edx)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80eef5:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80eef9:	74 24                	je     80ef1f <sys_sem_free+0x7e>
  80eefb:	c7 44 24 0c 30 66 81 	movl   $0x816630,0xc(%esp)
  80ef02:	00 
  80ef03:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80ef0a:	00 
  80ef0b:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  80ef12:	00 
  80ef13:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80ef1a:	e8 99 1a ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80ef1f:	8b 15 40 11 b4 00    	mov    0xb41140,%edx
  80ef25:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80ef28:	89 14 8d 4c fd b3 00 	mov    %edx,0xb3fd4c(,%ecx,4)
  80ef2f:	85 d2                	test   %edx,%edx
  80ef31:	74 0a                	je     80ef3d <sys_sem_free+0x9c>
  80ef33:	8d 0c 8d 4c fd b3 00 	lea    0xb3fd4c(,%ecx,4),%ecx
  80ef3a:	89 4a 10             	mov    %ecx,0x10(%edx)
  80ef3d:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80ef40:	8d 04 85 40 fd b3 00 	lea    0xb3fd40(,%eax,4),%eax
  80ef47:	a3 40 11 b4 00       	mov    %eax,0xb41140
  80ef4c:	c7 40 10 40 11 b4 00 	movl   $0xb41140,0x10(%eax)
}
  80ef53:	c9                   	leave  
  80ef54:	c3                   	ret    

0080ef55 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80ef55:	55                   	push   %ebp
  80ef56:	89 e5                	mov    %esp,%ebp
  80ef58:	83 ec 28             	sub    $0x28,%esp
  80ef5b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ef5e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ef61:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ef64:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80ef67:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80ef6d:	83 b8 40 af b3 00 00 	cmpl   $0x0,0xb3af40(%eax)
  80ef74:	74 24                	je     80ef9a <sys_mbox_free+0x45>
  80ef76:	c7 44 24 0c 38 65 81 	movl   $0x816538,0xc(%esp)
  80ef7d:	00 
  80ef7e:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80ef85:	00 
  80ef86:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80ef8d:	00 
  80ef8e:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80ef95:	e8 1e 1a ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    sys_sem_free(mboxes[mbox].queued_msg);
  80ef9a:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80efa0:	8b 83 cc af b3 00    	mov    0xb3afcc(%ebx),%eax
  80efa6:	89 04 24             	mov    %eax,(%esp)
  80efa9:	e8 f3 fe ff ff       	call   80eea1 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80efae:	8b 83 d0 af b3 00    	mov    0xb3afd0(%ebx),%eax
  80efb4:	89 04 24             	mov    %eax,(%esp)
  80efb7:	e8 e5 fe ff ff       	call   80eea1 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80efbc:	83 bb d8 af b3 00 00 	cmpl   $0x0,0xb3afd8(%ebx)
  80efc3:	74 24                	je     80efe9 <sys_mbox_free+0x94>
  80efc5:	c7 44 24 0c 54 66 81 	movl   $0x816654,0xc(%esp)
  80efcc:	00 
  80efcd:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80efd4:	00 
  80efd5:	c7 44 24 04 65 00 00 	movl   $0x65,0x4(%esp)
  80efdc:	00 
  80efdd:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80efe4:	e8 cf 19 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80efe9:	a1 44 11 b4 00       	mov    0xb41144,%eax
  80efee:	69 d6 9c 00 00 00    	imul   $0x9c,%esi,%edx
  80eff4:	89 82 d4 af b3 00    	mov    %eax,0xb3afd4(%edx)
  80effa:	85 c0                	test   %eax,%eax
  80effc:	74 0c                	je     80f00a <sys_mbox_free+0xb5>
  80effe:	81 c2 d4 af b3 00    	add    $0xb3afd4,%edx
  80f004:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80f00a:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80f010:	8d 86 40 af b3 00    	lea    0xb3af40(%esi),%eax
  80f016:	a3 44 11 b4 00       	mov    %eax,0xb41144
  80f01b:	c7 86 d8 af b3 00 44 	movl   $0xb41144,0xb3afd8(%esi)
  80f022:	11 b4 00 
    mboxes[mbox].freed = 1;
  80f025:	c7 86 40 af b3 00 01 	movl   $0x1,0xb3af40(%esi)
  80f02c:	00 00 00 
}
  80f02f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f032:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f035:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f038:	89 ec                	mov    %ebp,%esp
  80f03a:	5d                   	pop    %ebp
  80f03b:	c3                   	ret    

0080f03c <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80f03c:	55                   	push   %ebp
  80f03d:	89 e5                	mov    %esp,%ebp
  80f03f:	83 ec 28             	sub    $0x28,%esp
  80f042:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f045:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f048:	89 7d fc             	mov    %edi,-0x4(%ebp)
    assert(size < MBOXSLOTS);
  80f04b:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80f04f:	7e 24                	jle    80f075 <sys_mbox_new+0x39>
  80f051:	c7 44 24 0c 4c 65 81 	movl   $0x81654c,0xc(%esp)
  80f058:	00 
  80f059:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f060:	00 
  80f061:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80f068:	00 
  80f069:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f070:	e8 43 19 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80f075:	8b 1d 44 11 b4 00    	mov    0xb41144,%ebx
    if (!mbe) {
  80f07b:	85 db                	test   %ebx,%ebx
  80f07d:	75 16                	jne    80f095 <sys_mbox_new+0x59>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80f07f:	c7 04 24 7c 66 81 00 	movl   $0x81667c,(%esp)
  80f086:	e8 4b 1a ff ff       	call   800ad6 <_Z7cprintfPKcz>
	return SYS_MBOX_NULL;
  80f08b:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80f090:	e9 fb 00 00 00       	jmp    80f190 <sys_mbox_new+0x154>
    }
    LIST_REMOVE(mbe, link);
  80f095:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80f09b:	85 d2                	test   %edx,%edx
  80f09d:	75 24                	jne    80f0c3 <sys_mbox_new+0x87>
  80f09f:	c7 44 24 0c 5d 65 81 	movl   $0x81655d,0xc(%esp)
  80f0a6:	00 
  80f0a7:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f0ae:	00 
  80f0af:	c7 44 24 04 4b 00 00 	movl   $0x4b,0x4(%esp)
  80f0b6:	00 
  80f0b7:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f0be:	e8 f5 18 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80f0c3:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80f0c9:	85 c0                	test   %eax,%eax
  80f0cb:	74 06                	je     80f0d3 <sys_mbox_new+0x97>
  80f0cd:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80f0d3:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80f0d9:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80f0df:	89 10                	mov    %edx,(%eax)
  80f0e1:	c7 83 98 00 00 00 00 	movl   $0x0,0x98(%ebx)
  80f0e8:	00 00 00 
  80f0eb:	c7 83 94 00 00 00 00 	movl   $0x0,0x94(%ebx)
  80f0f2:	00 00 00 
    assert(mbe->freed);
  80f0f5:	83 3b 00             	cmpl   $0x0,(%ebx)
  80f0f8:	75 24                	jne    80f11e <sys_mbox_new+0xe2>
  80f0fa:	c7 44 24 0c 77 65 81 	movl   $0x816577,0xc(%esp)
  80f101:	00 
  80f102:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f109:	00 
  80f10a:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80f111:	00 
  80f112:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f119:	e8 9a 18 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    mbe->freed = 0;
  80f11e:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80f124:	89 df                	mov    %ebx,%edi
  80f126:	81 ef 40 af b3 00    	sub    $0xb3af40,%edi
  80f12c:	c1 ff 02             	sar    $0x2,%edi
  80f12f:	69 ff 97 6f f9 96    	imul   $0x96f96f97,%edi,%edi
  80f135:	89 fe                	mov    %edi,%esi
    mbe->head = -1;
  80f137:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80f13e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80f145:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f14c:	e8 8d fc ff ff       	call   80edde <sys_sem_new>
  80f151:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80f157:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80f15e:	e8 7b fc ff ff       	call   80edde <sys_sem_new>
  80f163:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80f169:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80f170:	74 05                	je     80f177 <sys_mbox_new+0x13b>
  80f172:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f175:	75 19                	jne    80f190 <sys_mbox_new+0x154>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80f177:	89 3c 24             	mov    %edi,(%esp)
  80f17a:	e8 d6 fd ff ff       	call   80ef55 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80f17f:	c7 04 24 a4 66 81 00 	movl   $0x8166a4,(%esp)
  80f186:	e8 4b 19 ff ff       	call   800ad6 <_Z7cprintfPKcz>
	return SYS_MBOX_NULL;
  80f18b:	be ff ff ff ff       	mov    $0xffffffff,%esi
    }
    return i;
}
  80f190:	89 f0                	mov    %esi,%eax
  80f192:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f195:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f198:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f19b:	89 ec                	mov    %ebp,%esp
  80f19d:	5d                   	pop    %ebp
  80f19e:	c3                   	ret    

0080f19f <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80f19f:	55                   	push   %ebp
  80f1a0:	89 e5                	mov    %esp,%ebp
  80f1a2:	83 ec 18             	sub    $0x18,%esp
  80f1a5:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80f1a8:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80f1ab:	83 3c 95 40 fd b3 00 	cmpl   $0x0,0xb3fd40(,%edx,4)
  80f1b2:	00 
  80f1b3:	74 24                	je     80f1d9 <sys_sem_signal+0x3a>
  80f1b5:	c7 44 24 0c 27 65 81 	movl   $0x816527,0xc(%esp)
  80f1bc:	00 
  80f1bd:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f1c4:	00 
  80f1c5:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80f1cc:	00 
  80f1cd:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f1d4:	e8 df 17 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    sems[sem].counter++;
  80f1d9:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80f1dc:	8d 14 95 40 fd b3 00 	lea    0xb3fd40(,%edx,4),%edx
  80f1e3:	66 83 42 08 01       	addw   $0x1,0x8(%edx)
    if (sems[sem].waiters) {
  80f1e8:	66 83 7a 0a 00       	cmpw   $0x0,0xa(%edx)
  80f1ed:	74 13                	je     80f202 <sys_sem_signal+0x63>
	sems[sem].waiters = 0;
  80f1ef:	89 d0                	mov    %edx,%eax
  80f1f1:	66 c7 42 0a 00 00    	movw   $0x0,0xa(%edx)
	thread_wakeup(&sems[sem].v);
  80f1f7:	83 c0 08             	add    $0x8,%eax
  80f1fa:	89 04 24             	mov    %eax,(%esp)
  80f1fd:	e8 ad 05 00 00       	call   80f7af <_Z13thread_wakeupPVj>
    }
}
  80f202:	c9                   	leave  
  80f203:	c3                   	ret    

0080f204 <sys_arch_sem_wait>:

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80f204:	55                   	push   %ebp
  80f205:	89 e5                	mov    %esp,%ebp
  80f207:	57                   	push   %edi
  80f208:	56                   	push   %esi
  80f209:	53                   	push   %ebx
  80f20a:	83 ec 2c             	sub    $0x2c,%esp
    assert(!sems[sem].freed);
  80f20d:	8b 55 08             	mov    0x8(%ebp),%edx
  80f210:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80f213:	83 3c 85 40 fd b3 00 	cmpl   $0x0,0xb3fd40(,%eax,4)
  80f21a:	00 
  80f21b:	74 24                	je     80f241 <sys_arch_sem_wait+0x3d>
  80f21d:	c7 44 24 0c 27 65 81 	movl   $0x816527,0xc(%esp)
  80f224:	00 
  80f225:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f22c:	00 
  80f22d:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80f234:	00 
  80f235:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f23c:	e8 77 17 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80f241:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f244:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80f247:	8b 04 85 44 fd b3 00 	mov    0xb3fd44(,%eax,4),%eax
  80f24e:	89 45 e0             	mov    %eax,-0x20(%ebp)

    while (tm_msec == 0 || waited < tm_msec) {
  80f251:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80f255:	0f 94 45 db          	sete   -0x25(%ebp)
  80f259:	0f 95 45 e7          	setne  -0x19(%ebp)
  80f25d:	80 7d db 00          	cmpb   $0x0,-0x25(%ebp)
  80f261:	75 0f                	jne    80f272 <sys_arch_sem_wait+0x6e>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80f263:	be ff ff ff ff       	mov    $0xffffffff,%esi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80f268:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80f26c:	0f 84 ce 00 00 00    	je     80f340 <sys_arch_sem_wait+0x13c>
	if (sems[sem].counter > 0) {
  80f272:	8b 55 08             	mov    0x8(%ebp),%edx
  80f275:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80f278:	0f b7 04 85 48 fd b3 	movzwl 0xb3fd48(,%eax,4),%eax
  80f27f:	00 
  80f280:	66 85 c0             	test   %ax,%ax
  80f283:	75 31                	jne    80f2b6 <sys_arch_sem_wait+0xb2>
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
  80f285:	be ff ff ff ff       	mov    $0xffffffff,%esi

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80f28a:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80f28e:	0f 84 ac 00 00 00    	je     80f340 <sys_arch_sem_wait+0x13c>

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80f294:	be 00 00 00 00       	mov    $0x0,%esi
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
  80f299:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80f29c:	8d 1c 85 40 fd b3 00 	lea    0xb3fd40(,%eax,4),%ebx
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80f2a3:	8d 4b 08             	lea    0x8(%ebx),%ecx
  80f2a6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  80f2a9:	eb 23                	jmp    80f2ce <sys_arch_sem_wait+0xca>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80f2ab:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  80f2af:	66 85 c0             	test   %ax,%ax
  80f2b2:	74 1a                	je     80f2ce <sys_arch_sem_wait+0xca>
  80f2b4:	eb 05                	jmp    80f2bb <sys_arch_sem_wait+0xb7>

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
    assert(!sems[sem].freed);
    u32_t waited = 0;
  80f2b6:	be 00 00 00 00       	mov    $0x0,%esi

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
	    sems[sem].counter--;
  80f2bb:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80f2be:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80f2c1:	83 e8 01             	sub    $0x1,%eax
  80f2c4:	66 89 04 95 48 fd b3 	mov    %ax,0xb3fd48(,%edx,4)
  80f2cb:	00 
	    return waited;
  80f2cc:	eb 72                	jmp    80f340 <sys_arch_sem_wait+0x13c>
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80f2ce:	e8 5b 26 ff ff       	call   80192e <_Z13sys_time_msecv>
  80f2d3:	89 c7                	mov    %eax,%edi
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80f2d5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80f2da:	80 7d e7 00          	cmpb   $0x0,-0x19(%ebp)
  80f2de:	74 08                	je     80f2e8 <sys_arch_sem_wait+0xe4>
  80f2e0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f2e3:	8d 04 07             	lea    (%edi,%eax,1),%eax
  80f2e6:	29 f0                	sub    %esi,%eax
	    sems[sem].waiters = 1;
  80f2e8:	66 c7 43 0a 01 00    	movw   $0x1,0xa(%ebx)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80f2ee:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f2f2:	8b 43 08             	mov    0x8(%ebx),%eax
  80f2f5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f2f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80f2fc:	89 04 24             	mov    %eax,(%esp)
  80f2ff:	e8 9a 07 00 00       	call   80fa9e <_Z11thread_waitPVjjj>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80f304:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80f307:	39 53 04             	cmp    %edx,0x4(%ebx)
  80f30a:	74 13                	je     80f31f <sys_arch_sem_wait+0x11b>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80f30c:	c7 04 24 d0 66 81 00 	movl   $0x8166d0,(%esp)
  80f313:	e8 be 17 ff ff       	call   800ad6 <_Z7cprintfPKcz>
		return SYS_ARCH_TIMEOUT;
  80f318:	be ff ff ff ff       	mov    $0xffffffff,%esi
  80f31d:	eb 21                	jmp    80f340 <sys_arch_sem_wait+0x13c>
	    }
	    uint32_t b = sys_time_msec();
  80f31f:	e8 0a 26 ff ff       	call   80192e <_Z13sys_time_msecv>
	    waited += (b - a);
  80f324:	29 f8                	sub    %edi,%eax
  80f326:	01 c6                	add    %eax,%esi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80f328:	39 75 0c             	cmp    %esi,0xc(%ebp)
  80f32b:	0f 87 7a ff ff ff    	ja     80f2ab <sys_arch_sem_wait+0xa7>
  80f331:	80 7d db 00          	cmpb   $0x0,-0x25(%ebp)
  80f335:	0f 85 70 ff ff ff    	jne    80f2ab <sys_arch_sem_wait+0xa7>
	    uint32_t b = sys_time_msec();
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
  80f33b:	be ff ff ff ff       	mov    $0xffffffff,%esi
}
  80f340:	89 f0                	mov    %esi,%eax
  80f342:	83 c4 2c             	add    $0x2c,%esp
  80f345:	5b                   	pop    %ebx
  80f346:	5e                   	pop    %esi
  80f347:	5f                   	pop    %edi
  80f348:	5d                   	pop    %ebp
  80f349:	c3                   	ret    

0080f34a <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80f34a:	55                   	push   %ebp
  80f34b:	89 e5                	mov    %esp,%ebp
  80f34d:	56                   	push   %esi
  80f34e:	53                   	push   %ebx
  80f34f:	83 ec 10             	sub    $0x10,%esp
  80f352:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80f355:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80f35b:	83 b8 40 af b3 00 00 	cmpl   $0x0,0xb3af40(%eax)
  80f362:	74 24                	je     80f388 <sys_mbox_trypost+0x3e>
  80f364:	c7 44 24 0c 38 65 81 	movl   $0x816538,0xc(%esp)
  80f36b:	00 
  80f36c:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f373:	00 
  80f374:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80f37b:	00 
  80f37c:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f383:	e8 30 16 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80f388:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f38f:	00 
  80f390:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80f396:	8b 83 d0 af b3 00    	mov    0xb3afd0(%ebx),%eax
  80f39c:	89 04 24             	mov    %eax,(%esp)
  80f39f:	e8 60 fe ff ff       	call   80f204 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80f3a4:	8b 93 48 af b3 00    	mov    0xb3af48(%ebx),%edx
  80f3aa:	81 c3 40 af b3 00    	add    $0xb3af40,%ebx
	return ERR_MEM;
  80f3b0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
    assert(!mboxes[mbox].freed);

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80f3b5:	3b 53 04             	cmp    0x4(%ebx),%edx
  80f3b8:	74 51                	je     80f40b <sys_mbox_trypost+0xc1>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80f3ba:	89 d8                	mov    %ebx,%eax
  80f3bc:	8d 5a 01             	lea    0x1(%edx),%ebx
  80f3bf:	89 d9                	mov    %ebx,%ecx
  80f3c1:	c1 f9 1f             	sar    $0x1f,%ecx
  80f3c4:	c1 e9 1b             	shr    $0x1b,%ecx
  80f3c7:	01 cb                	add    %ecx,%ebx
  80f3c9:	83 e3 1f             	and    $0x1f,%ebx
  80f3cc:	29 cb                	sub    %ecx,%ebx
  80f3ce:	89 58 08             	mov    %ebx,0x8(%eax)
    mboxes[mbox].msg[slot] = msg;
  80f3d1:	6b ce 27             	imul   $0x27,%esi,%ecx
  80f3d4:	01 d1                	add    %edx,%ecx
  80f3d6:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80f3d9:	89 1c 8d 4c af b3 00 	mov    %ebx,0xb3af4c(,%ecx,4)

    if (mboxes[mbox].head == -1)
  80f3e0:	83 78 04 ff          	cmpl   $0xffffffff,0x4(%eax)
  80f3e4:	75 0c                	jne    80f3f2 <sys_mbox_trypost+0xa8>
	mboxes[mbox].head = slot;
  80f3e6:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80f3ec:	89 90 44 af b3 00    	mov    %edx,0xb3af44(%eax)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80f3f2:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80f3f8:	8b 86 cc af b3 00    	mov    0xb3afcc(%esi),%eax
  80f3fe:	89 04 24             	mov    %eax,(%esp)
  80f401:	e8 99 fd ff ff       	call   80f19f <sys_sem_signal>

    return ERR_OK;
  80f406:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f40b:	83 c4 10             	add    $0x10,%esp
  80f40e:	5b                   	pop    %ebx
  80f40f:	5e                   	pop    %esi
  80f410:	5d                   	pop    %ebp
  80f411:	c3                   	ret    

0080f412 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80f412:	55                   	push   %ebp
  80f413:	89 e5                	mov    %esp,%ebp
  80f415:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80f418:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f41b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f41f:	8b 45 08             	mov    0x8(%ebp),%eax
  80f422:	89 04 24             	mov    %eax,(%esp)
  80f425:	e8 20 ff ff ff       	call   80f34a <sys_mbox_trypost>
  80f42a:	84 c0                	test   %al,%al
  80f42c:	74 24                	je     80f452 <sys_mbox_post+0x40>
  80f42e:	c7 44 24 0c fc 66 81 	movl   $0x8166fc,0xc(%esp)
  80f435:	00 
  80f436:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f43d:	00 
  80f43e:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80f445:	00 
  80f446:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f44d:	e8 66 15 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
}
  80f452:	c9                   	leave  
  80f453:	c3                   	ret    

0080f454 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80f454:	55                   	push   %ebp
  80f455:	89 e5                	mov    %esp,%ebp
  80f457:	83 ec 28             	sub    $0x28,%esp
  80f45a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f45d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f460:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f463:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f466:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80f469:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80f46f:	83 b8 40 af b3 00 00 	cmpl   $0x0,0xb3af40(%eax)
  80f476:	74 24                	je     80f49c <sys_arch_mbox_fetch+0x48>
  80f478:	c7 44 24 0c 38 65 81 	movl   $0x816538,0xc(%esp)
  80f47f:	00 
  80f480:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f487:	00 
  80f488:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80f48f:	00 
  80f490:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f497:	e8 1c 15 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80f49c:	8b 45 10             	mov    0x10(%ebp),%eax
  80f49f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f4a3:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80f4a9:	8b 80 cc af b3 00    	mov    0xb3afcc(%eax),%eax
  80f4af:	89 04 24             	mov    %eax,(%esp)
  80f4b2:	e8 4d fd ff ff       	call   80f204 <sys_arch_sem_wait>
  80f4b7:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80f4b9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f4bc:	0f 84 8c 00 00 00    	je     80f54e <sys_arch_mbox_fetch+0xfa>
	return waited;

    int slot = mboxes[mbox].head;
  80f4c2:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80f4c8:	8b 80 44 af b3 00    	mov    0xb3af44(%eax),%eax
    if (slot == -1)
  80f4ce:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f4d1:	75 1c                	jne    80f4ef <sys_arch_mbox_fetch+0x9b>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80f4d3:	c7 44 24 08 24 67 81 	movl   $0x816724,0x8(%esp)
  80f4da:	00 
  80f4db:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80f4e2:	00 
  80f4e3:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f4ea:	e8 c9 14 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    if (msg)
  80f4ef:	85 ff                	test   %edi,%edi
  80f4f1:	74 0e                	je     80f501 <sys_arch_mbox_fetch+0xad>
	*msg = mboxes[mbox].msg[slot];
  80f4f3:	6b d3 27             	imul   $0x27,%ebx,%edx
  80f4f6:	01 c2                	add    %eax,%edx
  80f4f8:	8b 14 95 4c af b3 00 	mov    0xb3af4c(,%edx,4),%edx
  80f4ff:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80f501:	83 c0 01             	add    $0x1,%eax
  80f504:	89 c2                	mov    %eax,%edx
  80f506:	c1 fa 1f             	sar    $0x1f,%edx
  80f509:	c1 ea 1b             	shr    $0x1b,%edx
  80f50c:	01 d0                	add    %edx,%eax
  80f50e:	83 e0 1f             	and    $0x1f,%eax
  80f511:	29 d0                	sub    %edx,%eax
  80f513:	69 d3 9c 00 00 00    	imul   $0x9c,%ebx,%edx
  80f519:	89 82 44 af b3 00    	mov    %eax,0xb3af44(%edx)
  80f51f:	81 c2 40 af b3 00    	add    $0xb3af40,%edx
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80f525:	3b 42 08             	cmp    0x8(%edx),%eax
  80f528:	75 10                	jne    80f53a <sys_arch_mbox_fetch+0xe6>
	mboxes[mbox].head = -1;
  80f52a:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80f530:	c7 80 44 af b3 00 ff 	movl   $0xffffffff,0xb3af44(%eax)
  80f537:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80f53a:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80f540:	8b 83 d0 af b3 00    	mov    0xb3afd0(%ebx),%eax
  80f546:	89 04 24             	mov    %eax,(%esp)
  80f549:	e8 51 fc ff ff       	call   80f19f <sys_sem_signal>
    return waited;
}
  80f54e:	89 f0                	mov    %esi,%eax
  80f550:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f553:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f556:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f559:	89 ec                	mov    %ebp,%esp
  80f55b:	5d                   	pop    %ebp
  80f55c:	c3                   	ret    

0080f55d <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80f55d:	55                   	push   %ebp
  80f55e:	89 e5                	mov    %esp,%ebp
  80f560:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80f563:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80f56a:	ff 
  80f56b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f56e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f572:	8b 45 08             	mov    0x8(%ebp),%eax
  80f575:	89 04 24             	mov    %eax,(%esp)
  80f578:	e8 d7 fe ff ff       	call   80f454 <sys_arch_mbox_fetch>
}
  80f57d:	c9                   	leave  
  80f57e:	c3                   	ret    

0080f57f <sys_thread_new>:
}

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80f57f:	55                   	push   %ebp
  80f580:	89 e5                	mov    %esp,%ebp
  80f582:	53                   	push   %ebx
  80f583:	83 ec 24             	sub    $0x24,%esp
  80f586:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt =  (struct lwip_thread *) malloc(sizeof(*lt));
  80f589:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80f590:	e8 ed 51 ff ff       	call   804782 <_Z6mallocj>
    if (lt == 0)
  80f595:	85 c0                	test   %eax,%eax
  80f597:	75 1c                	jne    80f5b5 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80f599:	c7 44 24 08 4c 67 81 	movl   $0x81674c,0x8(%esp)
  80f5a0:	00 
  80f5a1:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80f5a8:	00 
  80f5a9:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f5b0:	e8 03 14 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    if (stacksize > PGSIZE)
  80f5b5:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80f5bb:	7e 20                	jle    80f5dd <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80f5bd:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80f5c1:	c7 44 24 08 82 65 81 	movl   $0x816582,0x8(%esp)
  80f5c8:	00 
  80f5c9:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80f5d0:	00 
  80f5d1:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f5d8:	e8 db 13 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    lt->func = thread;
  80f5dd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80f5e0:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80f5e2:	8b 55 10             	mov    0x10(%ebp),%edx
  80f5e5:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80f5e8:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f5ec:	c7 44 24 08 74 ec 80 	movl   $0x80ec74,0x8(%esp)
  80f5f3:	00 
  80f5f4:	8b 45 08             	mov    0x8(%ebp),%eax
  80f5f7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f5fb:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80f5fe:	89 04 24             	mov    %eax,(%esp)
  80f601:	e8 19 02 00 00       	call   80f81f <_Z13thread_createPjPKcPFvjEj>

    if (r < 0)
  80f606:	85 c0                	test   %eax,%eax
  80f608:	79 28                	jns    80f632 <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80f60a:	89 04 24             	mov    %eax,(%esp)
  80f60d:	e8 56 05 00 00       	call   80fb68 <_Z3e2si>
  80f612:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f616:	c7 44 24 08 7c 67 81 	movl   $0x81677c,0x8(%esp)
  80f61d:	00 
  80f61e:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80f625:	00 
  80f626:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f62d:	e8 86 13 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    return tid;
}
  80f632:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f635:	83 c4 24             	add    $0x24,%esp
  80f638:	5b                   	pop    %ebx
  80f639:	5d                   	pop    %ebp
  80f63a:	c3                   	ret    

0080f63b <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80f63b:	55                   	push   %ebp
  80f63c:	89 e5                	mov    %esp,%ebp
  80f63e:	57                   	push   %edi
  80f63f:	56                   	push   %esi
  80f640:	53                   	push   %ebx
  80f641:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80f644:	e8 5a 01 00 00       	call   80f7a3 <_Z9thread_idv>
  80f649:	89 c6                	mov    %eax,%esi
    int r;
    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80f64b:	bf 01 ff 00 ff       	mov    $0xff00ff01,%edi
  80f650:	f7 e7                	mul    %edi
  80f652:	89 d7                	mov    %edx,%edi
  80f654:	c1 ef 08             	shr    $0x8,%edi
  80f657:	89 f8                	mov    %edi,%eax
  80f659:	c1 e0 08             	shl    $0x8,%eax
  80f65c:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  80f65f:	89 f0                	mov    %esi,%eax
  80f661:	29 f8                	sub    %edi,%eax
  80f663:	89 c7                	mov    %eax,%edi
  80f665:	8b 1c 85 20 ab b3 00 	mov    0xb3ab20(,%eax,4),%ebx
  80f66c:	85 db                	test   %ebx,%ebx
  80f66e:	74 1d                	je     80f68d <sys_arch_timeouts+0x52>
	if (t->tid == tid)
  80f670:	39 33                	cmp    %esi,(%ebx)
  80f672:	75 12                	jne    80f686 <sys_arch_timeouts+0x4b>
  80f674:	e9 ed 00 00 00       	jmp    80f766 <sys_arch_timeouts+0x12b>
  80f679:	39 33                	cmp    %esi,(%ebx)
  80f67b:	90                   	nop
  80f67c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f680:	0f 84 e0 00 00 00    	je     80f766 <sys_arch_timeouts+0x12b>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();
    int r;
    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80f686:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80f689:	85 db                	test   %ebx,%ebx
  80f68b:	75 ec                	jne    80f679 <sys_arch_timeouts+0x3e>
	if (t->tid == tid)
	    goto out;

    t = (struct sys_thread *) malloc(sizeof(*t));
  80f68d:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80f694:	e8 e9 50 ff ff       	call   804782 <_Z6mallocj>
  80f699:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80f69b:	85 c0                	test   %eax,%eax
  80f69d:	75 1c                	jne    80f6bb <sys_arch_timeouts+0x80>
	panic("sys_arch_timeouts: cannot malloc");
  80f69f:	c7 44 24 08 a8 67 81 	movl   $0x8167a8,0x8(%esp)
  80f6a6:	00 
  80f6a7:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80f6ae:	00 
  80f6af:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f6b6:	e8 fd 12 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    r = thread_onhalt(timeout_cleanup);
  80f6bb:	c7 04 24 e0 eb 80 00 	movl   $0x80ebe0,(%esp)
  80f6c2:	e8 2e 01 00 00       	call   80f7f5 <_Z13thread_onhaltPFvjE>
    if (r < 0)
  80f6c7:	85 c0                	test   %eax,%eax
  80f6c9:	79 28                	jns    80f6f3 <sys_arch_timeouts+0xb8>
	panic("thread_onhalt failed: %s", e2s(r));
  80f6cb:	89 04 24             	mov    %eax,(%esp)
  80f6ce:	e8 95 04 00 00       	call   80fb68 <_Z3e2si>
  80f6d3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80f6d7:	c7 44 24 08 91 65 81 	movl   $0x816591,0x8(%esp)
  80f6de:	00 
  80f6df:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80f6e6:	00 
  80f6e7:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f6ee:	e8 c5 12 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

    t->tid = tid;
  80f6f3:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80f6f5:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80f6fc:	00 
  80f6fd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f704:	00 
  80f705:	8d 43 04             	lea    0x4(%ebx),%eax
  80f708:	89 04 24             	mov    %eax,(%esp)
  80f70b:	e8 21 1b ff ff       	call   801231 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80f710:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80f714:	74 24                	je     80f73a <sys_arch_timeouts+0xff>
  80f716:	c7 44 24 0c aa 65 81 	movl   $0x8165aa,0xc(%esp)
  80f71d:	00 
  80f71e:	c7 44 24 08 8b 49 81 	movl   $0x81498b,0x8(%esp)
  80f725:	00 
  80f726:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  80f72d:	00 
  80f72e:	c7 04 24 e7 64 81 00 	movl   $0x8164e7,(%esp)
  80f735:	e8 7e 12 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  80f73a:	8b 04 bd 20 ab b3 00 	mov    0xb3ab20(,%edi,4),%eax
  80f741:	89 43 08             	mov    %eax,0x8(%ebx)
  80f744:	85 c0                	test   %eax,%eax
  80f746:	74 0d                	je     80f755 <sys_arch_timeouts+0x11a>
  80f748:	8b 04 bd 20 ab b3 00 	mov    0xb3ab20(,%edi,4),%eax
  80f74f:	8d 53 08             	lea    0x8(%ebx),%edx
  80f752:	89 50 0c             	mov    %edx,0xc(%eax)
  80f755:	89 1c bd 20 ab b3 00 	mov    %ebx,0xb3ab20(,%edi,4)
  80f75c:	8d 04 bd 20 ab b3 00 	lea    0xb3ab20(,%edi,4),%eax
  80f763:	89 43 0c             	mov    %eax,0xc(%ebx)

out:
    return &t->tmo;
  80f766:	8d 43 04             	lea    0x4(%ebx),%eax
}
  80f769:	83 c4 1c             	add    $0x1c,%esp
  80f76c:	5b                   	pop    %ebx
  80f76d:	5e                   	pop    %esi
  80f76e:	5f                   	pop    %edi
  80f76f:	5d                   	pop    %ebp
  80f770:	c3                   	ret    

0080f771 <lwip_core_lock>:

void
lwip_core_lock(void)
{
  80f771:	55                   	push   %ebp
  80f772:	89 e5                	mov    %esp,%ebp
}
  80f774:	5d                   	pop    %ebp
  80f775:	c3                   	ret    

0080f776 <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80f776:	55                   	push   %ebp
  80f777:	89 e5                	mov    %esp,%ebp
}
  80f779:	5d                   	pop    %ebp
  80f77a:	c3                   	ret    
  80f77b:	00 00                	add    %al,(%eax)
  80f77d:	00 00                	add    %al,(%eax)
	...

0080f780 <_Z11thread_initv>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80f780:	55                   	push   %ebp
  80f781:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80f783:	c7 05 48 11 b4 00 00 	movl   $0x0,0xb41148
  80f78a:	00 00 00 
    tq->tq_last = 0;
  80f78d:	c7 05 4c 11 b4 00 00 	movl   $0x0,0xb4114c
  80f794:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80f797:	c7 05 5c 11 b4 00 00 	movl   $0x0,0xb4115c
  80f79e:	00 00 00 
}
  80f7a1:	5d                   	pop    %ebp
  80f7a2:	c3                   	ret    

0080f7a3 <_Z9thread_idv>:

uint32_t
thread_id(void) {
  80f7a3:	55                   	push   %ebp
  80f7a4:	89 e5                	mov    %esp,%ebp
    return cur_tc->tc_tid;
  80f7a6:	a1 50 11 b4 00       	mov    0xb41150,%eax
    threadq_init(&thread_queue);
    max_tid = 0;
}

uint32_t
thread_id(void) {
  80f7ab:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80f7ad:	5d                   	pop    %ebp
  80f7ae:	c3                   	ret    

0080f7af <_Z13thread_wakeupPVj>:

void
thread_wakeup(volatile uint32_t *addr) {
  80f7af:	55                   	push   %ebp
  80f7b0:	89 e5                	mov    %esp,%ebp
  80f7b2:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80f7b5:	a1 48 11 b4 00       	mov    0xb41148,%eax
    while (tc) {
  80f7ba:	85 c0                	test   %eax,%eax
  80f7bc:	74 10                	je     80f7ce <_Z13thread_wakeupPVj+0x1f>
	if (tc->tc_wait_addr == addr)
  80f7be:	39 50 48             	cmp    %edx,0x48(%eax)
  80f7c1:	75 04                	jne    80f7c7 <_Z13thread_wakeupPVj+0x18>
	    tc->tc_wakeup = 1;
  80f7c3:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80f7c7:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80f7ca:	85 c0                	test   %eax,%eax
  80f7cc:	75 f0                	jne    80f7be <_Z13thread_wakeupPVj+0xf>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80f7ce:	5d                   	pop    %ebp
  80f7cf:	c3                   	ret    

0080f7d0 <_Z22thread_wakeups_pendingv>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80f7d0:	55                   	push   %ebp
  80f7d1:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80f7d3:	8b 15 48 11 b4 00    	mov    0xb41148,%edx
    int n = 0;
  80f7d9:	b8 00 00 00 00       	mov    $0x0,%eax
    while (tc)
  80f7de:	85 d2                	test   %edx,%edx
  80f7e0:	74 11                	je     80f7f3 <_Z22thread_wakeups_pendingv+0x23>
    {
        if(tc->tc_wakeup)
  80f7e2:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
            ++n;
  80f7e6:	80 f9 01             	cmp    $0x1,%cl
  80f7e9:	83 d8 ff             	sbb    $0xffffffff,%eax
        tc = tc->tc_queue_link;
  80f7ec:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc)
  80f7ef:	85 d2                	test   %edx,%edx
  80f7f1:	75 ef                	jne    80f7e2 <_Z22thread_wakeups_pendingv+0x12>
        if(tc->tc_wakeup)
            ++n;
        tc = tc->tc_queue_link;
    }
    return n;
}
  80f7f3:	5d                   	pop    %ebp
  80f7f4:	c3                   	ret    

0080f7f5 <_Z13thread_onhaltPFvjE>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80f7f5:	55                   	push   %ebp
  80f7f6:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80f7f8:	8b 15 50 11 b4 00    	mov    0xb41150,%edx
  80f7fe:	8b 4a 60             	mov    0x60(%edx),%ecx
	return -E_NO_MEM;
  80f801:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    return n;
}

int
thread_onhalt(void (*fun)(thread_id_t)) {
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80f806:	83 f9 03             	cmp    $0x3,%ecx
  80f809:	7f 12                	jg     80f81d <_Z13thread_onhaltPFvjE+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80f80b:	8b 45 08             	mov    0x8(%ebp),%eax
  80f80e:	89 44 8a 50          	mov    %eax,0x50(%edx,%ecx,4)
  80f812:	83 c1 01             	add    $0x1,%ecx
  80f815:	89 4a 60             	mov    %ecx,0x60(%edx)
    return 0;
  80f818:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80f81d:	5d                   	pop    %ebp
  80f81e:	c3                   	ret    

0080f81f <_Z13thread_createPjPKcPFvjEj>:
    thread_halt();
}

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80f81f:	55                   	push   %ebp
  80f820:	89 e5                	mov    %esp,%ebp
  80f822:	57                   	push   %edi
  80f823:	56                   	push   %esi
  80f824:	53                   	push   %ebx
  80f825:	83 ec 1c             	sub    $0x1c,%esp
  80f828:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = (struct thread_context *) malloc(sizeof(struct thread_context));
  80f82b:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80f832:	e8 4b 4f ff ff       	call   804782 <_Z6mallocj>
  80f837:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80f839:	85 c0                	test   %eax,%eax
  80f83b:	0f 84 1b 01 00 00    	je     80f95c <_Z13thread_createPjPKcPFvjEj+0x13d>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80f841:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80f848:	00 
  80f849:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f850:	00 
  80f851:	89 04 24             	mov    %eax,(%esp)
  80f854:	e8 d8 19 ff ff       	call   801231 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80f859:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80f860:	00 
  80f861:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f864:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f868:	8d 43 08             	lea    0x8(%ebx),%eax
  80f86b:	89 04 24             	mov    %eax,(%esp)
  80f86e:	e8 97 18 ff ff       	call   80110a <_Z7strncpyPcPKcj>
    tc->tc_name[name_size - 1] = 0;
  80f873:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80f877:	a1 5c 11 b4 00       	mov    0xb4115c,%eax
  80f87c:	8d 50 01             	lea    0x1(%eax),%edx
  80f87f:	89 15 5c 11 b4 00    	mov    %edx,0xb4115c
    if (max_tid == (uint32_t)~0)
  80f885:	83 fa ff             	cmp    $0xffffffff,%edx
  80f888:	75 1c                	jne    80f8a6 <_Z13thread_createPjPKcPFvjEj+0x87>
	panic("alloc_tid: no more thread ids");
  80f88a:	c7 44 24 08 c9 67 81 	movl   $0x8167c9,0x8(%esp)
  80f891:	00 
  80f892:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80f899:	00 
  80f89a:	c7 04 24 e7 67 81 00 	movl   $0x8167e7,(%esp)
  80f8a1:	e8 12 11 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80f8a6:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80f8a8:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80f8af:	e8 ce 4e ff ff       	call   804782 <_Z6mallocj>
  80f8b4:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80f8b7:	85 c0                	test   %eax,%eax
  80f8b9:	75 12                	jne    80f8cd <_Z13thread_createPjPKcPFvjEj+0xae>
	free(tc);
  80f8bb:	89 1c 24             	mov    %ebx,(%esp)
  80f8be:	e8 ed 4d ff ff       	call   8046b0 <_Z4freePv>
	return -E_NO_MEM;
  80f8c3:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80f8c8:	e9 94 00 00 00       	jmp    80f961 <_Z13thread_createPjPKcPFvjEj+0x142>
    }

    void *stacktop = (uint8_t*) tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = (uint8_t*) stacktop - 4;
  80f8cd:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80f8d3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80f8da:	00 
  80f8db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f8e2:	00 
  80f8e3:	89 34 24             	mov    %esi,(%esp)
  80f8e6:	e8 46 19 ff ff       	call   801231 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80f8eb:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80f8f2:	00 
  80f8f3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f8fa:	00 
  80f8fb:	8d 43 30             	lea    0x30(%ebx),%eax
  80f8fe:	89 04 24             	mov    %eax,(%esp)
  80f901:	e8 2b 19 ff ff       	call   801231 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80f906:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80f909:	c7 43 30 83 fa 80 00 	movl   $0x80fa83,0x30(%ebx)
    tc->tc_entry = entry;
  80f910:	8b 45 10             	mov    0x10(%ebp),%eax
  80f913:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80f916:	8b 45 14             	mov    0x14(%ebp),%eax
  80f919:	89 43 2c             	mov    %eax,0x2c(%ebx)
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80f91c:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80f923:	83 3d 48 11 b4 00 00 	cmpl   $0x0,0xb41148
  80f92a:	75 0e                	jne    80f93a <_Z13thread_createPjPKcPFvjEj+0x11b>
	tq->tq_first = tc;
  80f92c:	89 1d 48 11 b4 00    	mov    %ebx,0xb41148
	tq->tq_last = tc;
  80f932:	89 1d 4c 11 b4 00    	mov    %ebx,0xb4114c
  80f938:	eb 0e                	jmp    80f948 <_Z13thread_createPjPKcPFvjEj+0x129>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80f93a:	a1 4c 11 b4 00       	mov    0xb4114c,%eax
  80f93f:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80f942:	89 1d 4c 11 b4 00    	mov    %ebx,0xb4114c

    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
  80f948:	b8 00 00 00 00       	mov    $0x0,%eax
    tc->tc_entry = entry;
    tc->tc_arg = arg;

    threadq_push(&thread_queue, tc);

    if (tid)
  80f94d:	85 ff                	test   %edi,%edi
  80f94f:	74 10                	je     80f961 <_Z13thread_createPjPKcPFvjEj+0x142>
	*tid = tc->tc_tid;
  80f951:	8b 03                	mov    (%ebx),%eax
  80f953:	89 07                	mov    %eax,(%edi)
    return 0;
  80f955:	b8 00 00 00 00       	mov    $0x0,%eax
  80f95a:	eb 05                	jmp    80f961 <_Z13thread_createPjPKcPFvjEj+0x142>
int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
    struct thread_context *tc = (struct thread_context *) malloc(sizeof(struct thread_context));
    if (!tc)
	return -E_NO_MEM;
  80f95c:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
    threadq_push(&thread_queue, tc);

    if (tid)
	*tid = tc->tc_tid;
    return 0;
}
  80f961:	83 c4 1c             	add    $0x1c,%esp
  80f964:	5b                   	pop    %ebx
  80f965:	5e                   	pop    %esi
  80f966:	5f                   	pop    %edi
  80f967:	5d                   	pop    %ebp
  80f968:	c3                   	ret    

0080f969 <_Z12thread_yieldv>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80f969:	55                   	push   %ebp
  80f96a:	89 e5                	mov    %esp,%ebp
  80f96c:	53                   	push   %ebx
  80f96d:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80f970:	8b 1d 48 11 b4 00    	mov    0xb41148,%ebx
  80f976:	85 db                	test   %ebx,%ebx
  80f978:	74 69                	je     80f9e3 <_Z12thread_yieldv+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80f97a:	8b 43 64             	mov    0x64(%ebx),%eax
  80f97d:	a3 48 11 b4 00       	mov    %eax,0xb41148
    tc->tc_queue_link = 0;
  80f982:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80f989:	a1 50 11 b4 00       	mov    0xb41150,%eax
  80f98e:	85 c0                	test   %eax,%eax
  80f990:	74 3e                	je     80f9d0 <_Z12thread_yieldv+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80f992:	83 c0 30             	add    $0x30,%eax
  80f995:	89 04 24             	mov    %eax,(%esp)
  80f998:	e8 83 01 00 00       	call   80fb20 <jos_setjmp>
  80f99d:	85 c0                	test   %eax,%eax
  80f99f:	75 42                	jne    80f9e3 <_Z12thread_yieldv+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80f9a1:	a1 50 11 b4 00       	mov    0xb41150,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80f9a6:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80f9ad:	83 3d 48 11 b4 00 00 	cmpl   $0x0,0xb41148
  80f9b4:	75 0c                	jne    80f9c2 <_Z12thread_yieldv+0x59>
	tq->tq_first = tc;
  80f9b6:	a3 48 11 b4 00       	mov    %eax,0xb41148
	tq->tq_last = tc;
  80f9bb:	a3 4c 11 b4 00       	mov    %eax,0xb4114c
  80f9c0:	eb 0e                	jmp    80f9d0 <_Z12thread_yieldv+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80f9c2:	8b 15 4c 11 b4 00    	mov    0xb4114c,%edx
  80f9c8:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80f9cb:	a3 4c 11 b4 00       	mov    %eax,0xb4114c
    }

    cur_tc = next_tc;
  80f9d0:	89 1d 50 11 b4 00    	mov    %ebx,0xb41150
    jos_longjmp(&cur_tc->tc_jb, 1);
  80f9d6:	8d 43 30             	lea    0x30(%ebx),%eax
  80f9d9:	ba 01 00 00 00       	mov    $0x1,%edx
  80f9de:	e8 6d 01 00 00       	call   80fb50 <jos_longjmp>
}
  80f9e3:	83 c4 14             	add    $0x14,%esp
  80f9e6:	5b                   	pop    %ebx
  80f9e7:	5d                   	pop    %ebp
  80f9e8:	c3                   	ret    

0080f9e9 <_Z11thread_haltv>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80f9e9:	55                   	push   %ebp
  80f9ea:	89 e5                	mov    %esp,%ebp
  80f9ec:	56                   	push   %esi
  80f9ed:	53                   	push   %ebx
  80f9ee:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80f9f1:	8b 1d 54 11 b4 00    	mov    0xb41154,%ebx
  80f9f7:	85 db                	test   %ebx,%ebx
  80f9f9:	74 3e                	je     80fa39 <_Z11thread_haltv+0x50>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80f9fb:	8b 43 64             	mov    0x64(%ebx),%eax
  80f9fe:	a3 54 11 b4 00       	mov    %eax,0xb41154
    tc->tc_queue_link = 0;
  80fa03:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80fa0a:	83 7b 60 00          	cmpl   $0x0,0x60(%ebx)
  80fa0e:	7e 16                	jle    80fa26 <_Z11thread_haltv+0x3d>
  80fa10:	be 00 00 00 00       	mov    $0x0,%esi
	tc->tc_onhalt[i](tc->tc_tid);
  80fa15:	8b 03                	mov    (%ebx),%eax
  80fa17:	89 04 24             	mov    %eax,(%esp)
  80fa1a:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80fa1e:	83 c6 01             	add    $0x1,%esi
  80fa21:	3b 73 60             	cmp    0x60(%ebx),%esi
  80fa24:	7c ef                	jl     80fa15 <_Z11thread_haltv+0x2c>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80fa26:	8b 43 04             	mov    0x4(%ebx),%eax
  80fa29:	89 04 24             	mov    %eax,(%esp)
  80fa2c:	e8 7f 4c ff ff       	call   8046b0 <_Z4freePv>
    free(tc);
  80fa31:	89 1c 24             	mov    %ebx,(%esp)
  80fa34:	e8 77 4c ff ff       	call   8046b0 <_Z4freePv>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80fa39:	a1 50 11 b4 00       	mov    0xb41150,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80fa3e:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80fa45:	83 3d 54 11 b4 00 00 	cmpl   $0x0,0xb41154
  80fa4c:	75 0c                	jne    80fa5a <_Z11thread_haltv+0x71>
	tq->tq_first = tc;
  80fa4e:	a3 54 11 b4 00       	mov    %eax,0xb41154
	tq->tq_last = tc;
  80fa53:	a3 58 11 b4 00       	mov    %eax,0xb41158
  80fa58:	eb 0e                	jmp    80fa68 <_Z11thread_haltv+0x7f>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80fa5a:	8b 15 58 11 b4 00    	mov    0xb41158,%edx
  80fa60:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80fa63:	a3 58 11 b4 00       	mov    %eax,0xb41158
    cur_tc = NULL;
  80fa68:	c7 05 50 11 b4 00 00 	movl   $0x0,0xb41150
  80fa6f:	00 00 00 
    thread_yield();
  80fa72:	e8 f2 fe ff ff       	call   80f969 <_Z12thread_yieldv>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80fa77:	e8 20 0f ff ff       	call   80099c <_Z4exitv>
}
  80fa7c:	83 c4 10             	add    $0x10,%esp
  80fa7f:	5b                   	pop    %ebx
  80fa80:	5e                   	pop    %esi
  80fa81:	5d                   	pop    %ebp
  80fa82:	c3                   	ret    

0080fa83 <_ZL12thread_entryv>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80fa83:	55                   	push   %ebp
  80fa84:	89 e5                	mov    %esp,%ebp
  80fa86:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80fa89:	a1 50 11 b4 00       	mov    0xb41150,%eax
  80fa8e:	8b 50 2c             	mov    0x2c(%eax),%edx
  80fa91:	89 14 24             	mov    %edx,(%esp)
  80fa94:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80fa97:	e8 4d ff ff ff       	call   80f9e9 <_Z11thread_haltv>
}
  80fa9c:	c9                   	leave  
  80fa9d:	c3                   	ret    

0080fa9e <_Z11thread_waitPVjjj>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80fa9e:	55                   	push   %ebp
  80fa9f:	89 e5                	mov    %esp,%ebp
  80faa1:	57                   	push   %edi
  80faa2:	56                   	push   %esi
  80faa3:	53                   	push   %ebx
  80faa4:	83 ec 0c             	sub    $0xc,%esp
  80faa7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80faaa:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80faad:	e8 7c 1e ff ff       	call   80192e <_Z13sys_time_msecv>
  80fab2:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80fab4:	a1 50 11 b4 00       	mov    0xb41150,%eax
  80fab9:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80fabc:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
  80fac0:	39 fe                	cmp    %edi,%esi
  80fac2:	72 06                	jb     80faca <_Z11thread_waitPVjjj+0x2c>
  80fac4:	eb 28                	jmp    80faee <_Z11thread_waitPVjjj+0x50>
	if (p < s)
  80fac6:	39 c6                	cmp    %eax,%esi
  80fac8:	77 24                	ja     80faee <_Z11thread_waitPVjjj+0x50>
	    break;
	if (addr && *addr != val)
  80faca:	85 db                	test   %ebx,%ebx
  80facc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80fad0:	74 34                	je     80fb06 <_Z11thread_waitPVjjj+0x68>
  80fad2:	8b 03                	mov    (%ebx),%eax
  80fad4:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80fad7:	75 15                	jne    80faee <_Z11thread_waitPVjjj+0x50>
  80fad9:	eb 2b                	jmp    80fb06 <_Z11thread_waitPVjjj+0x68>
	    break;
	if (cur_tc->tc_wakeup)
	    break;

	thread_yield();
  80fadb:	90                   	nop
  80fadc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80fae0:	e8 84 fe ff ff       	call   80f969 <_Z12thread_yieldv>
	p = sys_time_msec();
  80fae5:	e8 44 1e ff ff       	call   80192e <_Z13sys_time_msecv>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80faea:	39 c7                	cmp    %eax,%edi
  80faec:	77 d8                	ja     80fac6 <_Z11thread_waitPVjjj+0x28>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80faee:	a1 50 11 b4 00       	mov    0xb41150,%eax
  80faf3:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80fafa:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80fafe:	83 c4 0c             	add    $0xc,%esp
  80fb01:	5b                   	pop    %ebx
  80fb02:	5e                   	pop    %esi
  80fb03:	5f                   	pop    %edi
  80fb04:	5d                   	pop    %ebp
  80fb05:	c3                   	ret    
    while (p < msec) {
	if (p < s)
	    break;
	if (addr && *addr != val)
	    break;
	if (cur_tc->tc_wakeup)
  80fb06:	a1 50 11 b4 00       	mov    0xb41150,%eax
  80fb0b:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80fb0f:	84 c0                	test   %al,%al
  80fb11:	74 c8                	je     80fadb <_Z11thread_waitPVjjj+0x3d>
  80fb13:	eb d9                	jmp    80faee <_Z11thread_waitPVjjj+0x50>
	...

0080fb20 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80fb20:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80fb24:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80fb27:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80fb29:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80fb2d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80fb30:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80fb33:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80fb36:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80fb39:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80fb3c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80fb41:	c3                   	ret    
  80fb42:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80fb49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080fb50 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80fb50:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80fb52:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80fb55:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80fb58:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80fb5b:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80fb5e:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80fb61:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80fb63:	ff e1                	jmp    *%ecx
  80fb65:	00 00                	add    %al,(%eax)
	...

0080fb68 <_Z3e2si>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80fb68:	55                   	push   %ebp
  80fb69:	89 e5                	mov    %esp,%ebp
static const char *
get_errlist(int err)
{

	static const char *sys_errlist[ENSRCNAMELOOP+1];
	sys_errlist[EPERM] = "EPERM";     /* Operation not permitted */
  80fb6b:	c7 05 64 11 b4 00 02 	movl   $0x816802,0xb41164
  80fb72:	68 81 00 
	sys_errlist[ENOENT] = "ENOENT";      /* No such file or directory */
  80fb75:	c7 05 68 11 b4 00 08 	movl   $0x816808,0xb41168
  80fb7c:	68 81 00 
	sys_errlist[ESRCH] = "ESRCH";      /* No such process */
  80fb7f:	c7 05 6c 11 b4 00 0f 	movl   $0x81680f,0xb4116c
  80fb86:	68 81 00 
	sys_errlist[EINTR] = "EINTR";      /* Interrupted system call */
  80fb89:	c7 05 70 11 b4 00 15 	movl   $0x816815,0xb41170
  80fb90:	68 81 00 
	sys_errlist[EIO] = "EIO";      /* I/O error */
  80fb93:	c7 05 74 11 b4 00 ce 	movl   $0x816bce,0xb41174
  80fb9a:	6b 81 00 
	sys_errlist[ENXIO] = "ENXIO";      /* No such device or address */
  80fb9d:	c7 05 78 11 b4 00 1b 	movl   $0x81681b,0xb41178
  80fba4:	68 81 00 
	sys_errlist[E2BIG] = "E2BIG";      /* Arg list too long */
  80fba7:	c7 05 7c 11 b4 00 21 	movl   $0x816821,0xb4117c
  80fbae:	68 81 00 
	sys_errlist[ENOEXEC] = "ENOEXEC";      /* Exec format error */
  80fbb1:	c7 05 80 11 b4 00 27 	movl   $0x816827,0xb41180
  80fbb8:	68 81 00 
	sys_errlist[EBADF] = "EBADF";      /* Bad file number */
  80fbbb:	c7 05 84 11 b4 00 2f 	movl   $0x81682f,0xb41184
  80fbc2:	68 81 00 
	sys_errlist[ECHILD] = "ECHILD";      /* No child processes */
  80fbc5:	c7 05 88 11 b4 00 35 	movl   $0x816835,0xb41188
  80fbcc:	68 81 00 
	sys_errlist[EAGAIN] = "EAGAIN";      /* Try again */
	sys_errlist[ENOMEM] = "ENOMEM";      /* Out of memory */
  80fbcf:	c7 05 90 11 b4 00 3c 	movl   $0x81683c,0xb41190
  80fbd6:	68 81 00 
	sys_errlist[EACCES] = "EACCES";      /* Permission denied */
  80fbd9:	c7 05 94 11 b4 00 43 	movl   $0x816843,0xb41194
  80fbe0:	68 81 00 
	sys_errlist[EFAULT] = "EFAULT";      /* Bad address */
  80fbe3:	c7 05 98 11 b4 00 4a 	movl   $0x81684a,0xb41198
  80fbea:	68 81 00 
	sys_errlist[ENOTBLK] = "ENOTBLK";      /* Block device required */
  80fbed:	c7 05 9c 11 b4 00 51 	movl   $0x816851,0xb4119c
  80fbf4:	68 81 00 
	sys_errlist[EBUSY] = "EBUSY";      /* Device or resource busy */
  80fbf7:	c7 05 a0 11 b4 00 59 	movl   $0x816859,0xb411a0
  80fbfe:	68 81 00 
	sys_errlist[EEXIST] = "EEXIST";      /* File exists */
  80fc01:	c7 05 a4 11 b4 00 5f 	movl   $0x81685f,0xb411a4
  80fc08:	68 81 00 
	sys_errlist[EXDEV] = "EXDEV";      /* Cross-device link */
  80fc0b:	c7 05 a8 11 b4 00 66 	movl   $0x816866,0xb411a8
  80fc12:	68 81 00 
	sys_errlist[ENODEV] = "ENODEV";      /* No such device */
  80fc15:	c7 05 ac 11 b4 00 6c 	movl   $0x81686c,0xb411ac
  80fc1c:	68 81 00 
	sys_errlist[ENOTDIR] = "ENOTDIR";      /* Not a directory */
  80fc1f:	c7 05 b0 11 b4 00 73 	movl   $0x816873,0xb411b0
  80fc26:	68 81 00 
	sys_errlist[EISDIR] = "EISDIR";      /* Is a directory */
  80fc29:	c7 05 b4 11 b4 00 7b 	movl   $0x81687b,0xb411b4
  80fc30:	68 81 00 
	sys_errlist[EINVAL] = "EINVAL";      /* Invalid argument */
  80fc33:	c7 05 b8 11 b4 00 82 	movl   $0x816882,0xb411b8
  80fc3a:	68 81 00 
	sys_errlist[ENFILE] = "ENFILE";      /* File table overflow */
  80fc3d:	c7 05 bc 11 b4 00 89 	movl   $0x816889,0xb411bc
  80fc44:	68 81 00 
	sys_errlist[EMFILE] = "EMFILE";      /* Too many open files */
  80fc47:	c7 05 c0 11 b4 00 90 	movl   $0x816890,0xb411c0
  80fc4e:	68 81 00 
	sys_errlist[ENOTTY] = "ENOTTY";      /* Not a typewriter */
  80fc51:	c7 05 c4 11 b4 00 97 	movl   $0x816897,0xb411c4
  80fc58:	68 81 00 
	sys_errlist[ETXTBSY] = "ETXTBSY";      /* Text file busy */
  80fc5b:	c7 05 c8 11 b4 00 9e 	movl   $0x81689e,0xb411c8
  80fc62:	68 81 00 
	sys_errlist[EFBIG] = "EFBIG";      /* File too large */
  80fc65:	c7 05 cc 11 b4 00 a6 	movl   $0x8168a6,0xb411cc
  80fc6c:	68 81 00 
	sys_errlist[ENOSPC] = "ENOSPC";      /* No space left on device */
  80fc6f:	c7 05 d0 11 b4 00 ac 	movl   $0x8168ac,0xb411d0
  80fc76:	68 81 00 
	sys_errlist[ESPIPE] = "ESPIPE";      /* Illegal seek */
  80fc79:	c7 05 d4 11 b4 00 b3 	movl   $0x8168b3,0xb411d4
  80fc80:	68 81 00 
	sys_errlist[EROFS] = "EROFS";      /* Read-only file system */
  80fc83:	c7 05 d8 11 b4 00 ba 	movl   $0x8168ba,0xb411d8
  80fc8a:	68 81 00 
	sys_errlist[EMLINK] = "EMLINK";      /* Too many links */
  80fc8d:	c7 05 dc 11 b4 00 c0 	movl   $0x8168c0,0xb411dc
  80fc94:	68 81 00 
	sys_errlist[EPIPE] = "EPIPE";      /* Broken pipe */
  80fc97:	c7 05 e0 11 b4 00 c7 	movl   $0x8168c7,0xb411e0
  80fc9e:	68 81 00 
	sys_errlist[EDOM] = "EDOM";      /* Math argument out of domain of func */
  80fca1:	c7 05 e4 11 b4 00 cd 	movl   $0x8168cd,0xb411e4
  80fca8:	68 81 00 
	sys_errlist[ERANGE] = "ERANGE";      /* Math result not representable */
  80fcab:	c7 05 e8 11 b4 00 d2 	movl   $0x8168d2,0xb411e8
  80fcb2:	68 81 00 
	sys_errlist[EDEADLK] = "EDEADLK";      /* Resource deadlock would occur */
	sys_errlist[ENAMETOOLONG] = "ENAMETOOLONG";    /* File name too long */
  80fcb5:	c7 05 f0 11 b4 00 d9 	movl   $0x8168d9,0xb411f0
  80fcbc:	68 81 00 
	sys_errlist[ENOLCK] = "ENOLCK";      /* No record locks available */
  80fcbf:	c7 05 f4 11 b4 00 e6 	movl   $0x8168e6,0xb411f4
  80fcc6:	68 81 00 
	sys_errlist[ENOSYS] = "ENOSYS";      /* Function not implemented */
  80fcc9:	c7 05 f8 11 b4 00 ed 	movl   $0x8168ed,0xb411f8
  80fcd0:	68 81 00 
	sys_errlist[ENOTEMPTY] = "ENOTEMPTY";    /* Directory not empty */
  80fcd3:	c7 05 fc 11 b4 00 f4 	movl   $0x8168f4,0xb411fc
  80fcda:	68 81 00 
	sys_errlist[ELOOP] = "ELOOP";      /* Too many symbolic links encountered */
  80fcdd:	c7 05 00 12 b4 00 d6 	movl   $0x816cd6,0xb41200
  80fce4:	6c 81 00 
	sys_errlist[EWOULDBLOCK] = "EWOULDBLOCK"; /* Operation would block */
  80fce7:	c7 05 8c 11 b4 00 fe 	movl   $0x8168fe,0xb4118c
  80fcee:	68 81 00 
	sys_errlist[ENOMSG] = "ENOMSG";      /* No message of desired type */
  80fcf1:	c7 05 08 12 b4 00 0a 	movl   $0x81690a,0xb41208
  80fcf8:	69 81 00 
	sys_errlist[EIDRM] = "EIDRM";      /* Identifier removed */
  80fcfb:	c7 05 0c 12 b4 00 11 	movl   $0x816911,0xb4120c
  80fd02:	69 81 00 
	sys_errlist[ECHRNG] = "ECHRNG";      /* Channel number out of range */
  80fd05:	c7 05 10 12 b4 00 17 	movl   $0x816917,0xb41210
  80fd0c:	69 81 00 
	sys_errlist[EL2NSYNC] = "EL2NSYNC";    /* Level 2 not synchronized */
  80fd0f:	c7 05 14 12 b4 00 1e 	movl   $0x81691e,0xb41214
  80fd16:	69 81 00 
	sys_errlist[EL3HLT] = "EL3HLT";      /* Level 3 halted */
  80fd19:	c7 05 18 12 b4 00 27 	movl   $0x816927,0xb41218
  80fd20:	69 81 00 
	sys_errlist[EL3RST] = "EL3RST";      /* Level 3 reset */
  80fd23:	c7 05 1c 12 b4 00 2e 	movl   $0x81692e,0xb4121c
  80fd2a:	69 81 00 
	sys_errlist[ELNRNG] = "ELNRNG";      /* Link number out of range */
  80fd2d:	c7 05 20 12 b4 00 35 	movl   $0x816935,0xb41220
  80fd34:	69 81 00 
	sys_errlist[EUNATCH] = "EUNATCH";      /* Protocol driver not attached */
  80fd37:	c7 05 24 12 b4 00 3c 	movl   $0x81693c,0xb41224
  80fd3e:	69 81 00 
	sys_errlist[ENOCSI] = "ENOCSI";      /* No CSI structure available */
  80fd41:	c7 05 28 12 b4 00 44 	movl   $0x816944,0xb41228
  80fd48:	69 81 00 
	sys_errlist[EL2HLT] = "EL2HLT";      /* Level 2 halted */
  80fd4b:	c7 05 2c 12 b4 00 4b 	movl   $0x81694b,0xb4122c
  80fd52:	69 81 00 
	sys_errlist[EBADE] = "EBADE";      /* Invalid exchange */
  80fd55:	c7 05 30 12 b4 00 52 	movl   $0x816952,0xb41230
  80fd5c:	69 81 00 
	sys_errlist[EBADR] = "EBADR";      /* Invalid request descriptor */
  80fd5f:	c7 05 34 12 b4 00 58 	movl   $0x816958,0xb41234
  80fd66:	69 81 00 
	sys_errlist[EXFULL] = "EXFULL";      /* Exchange full */
  80fd69:	c7 05 38 12 b4 00 5e 	movl   $0x81695e,0xb41238
  80fd70:	69 81 00 
	sys_errlist[ENOANO] = "ENOANO";      /* No anode */
  80fd73:	c7 05 3c 12 b4 00 65 	movl   $0x816965,0xb4123c
  80fd7a:	69 81 00 
	sys_errlist[EBADRQC] = "EBADRQC";      /* Invalid request code */
  80fd7d:	c7 05 40 12 b4 00 6c 	movl   $0x81696c,0xb41240
  80fd84:	69 81 00 
	sys_errlist[EBADSLT] = "EBADSLT";      /* Invalid slot */
  80fd87:	c7 05 44 12 b4 00 74 	movl   $0x816974,0xb41244
  80fd8e:	69 81 00 

	sys_errlist[EDEADLOCK] = "EDEADLOCK";
  80fd91:	c7 05 ec 11 b4 00 7c 	movl   $0x81697c,0xb411ec
  80fd98:	69 81 00 

	sys_errlist[EBFONT] = "EBFONT";      /* Bad font file format */
  80fd9b:	c7 05 4c 12 b4 00 86 	movl   $0x816986,0xb4124c
  80fda2:	69 81 00 
	sys_errlist[ENOSTR] = "ENOSTR";      /* Device not a stream */
  80fda5:	c7 05 50 12 b4 00 8d 	movl   $0x81698d,0xb41250
  80fdac:	69 81 00 
	sys_errlist[ENODATA] = "ENODATA";      /* No data available */
  80fdaf:	c7 05 54 12 b4 00 94 	movl   $0x816994,0xb41254
  80fdb6:	69 81 00 
	sys_errlist[ETIME] = "ETIME";      /* Timer expired */
  80fdb9:	c7 05 58 12 b4 00 9c 	movl   $0x81699c,0xb41258
  80fdc0:	69 81 00 
	sys_errlist[ENOSR] = "ENOSR";      /* Out of streams resources */
  80fdc3:	c7 05 5c 12 b4 00 a2 	movl   $0x8169a2,0xb4125c
  80fdca:	69 81 00 
	sys_errlist[ENONET] = "ENONET";      /* Machine is not on the network */
  80fdcd:	c7 05 60 12 b4 00 a8 	movl   $0x8169a8,0xb41260
  80fdd4:	69 81 00 
	sys_errlist[ENOPKG] = "ENOPKG";      /* Package not installed */
  80fdd7:	c7 05 64 12 b4 00 af 	movl   $0x8169af,0xb41264
  80fdde:	69 81 00 
	sys_errlist[EREMOTE] = "EREMOTE";      /* Object is remote */
  80fde1:	c7 05 68 12 b4 00 b6 	movl   $0x8169b6,0xb41268
  80fde8:	69 81 00 
	sys_errlist[ENOLINK] = "ENOLINK";      /* Link has been severed */
  80fdeb:	c7 05 6c 12 b4 00 be 	movl   $0x8169be,0xb4126c
  80fdf2:	69 81 00 
	sys_errlist[EADV] = "EADV";      /* Advertise error */
  80fdf5:	c7 05 70 12 b4 00 c6 	movl   $0x8169c6,0xb41270
  80fdfc:	69 81 00 
	sys_errlist[ESRMNT] = "ESRMNT";      /* Srmount error */
  80fdff:	c7 05 74 12 b4 00 cb 	movl   $0x8169cb,0xb41274
  80fe06:	69 81 00 
	sys_errlist[ECOMM] = "ECOMM";      /* Communication error on send */
  80fe09:	c7 05 78 12 b4 00 d2 	movl   $0x8169d2,0xb41278
  80fe10:	69 81 00 
	sys_errlist[EPROTO] = "EPROTO";      /* Protocol error */
  80fe13:	c7 05 7c 12 b4 00 d8 	movl   $0x8169d8,0xb4127c
  80fe1a:	69 81 00 
	sys_errlist[EMULTIHOP] = "EMULTIHOP";    /* Multihop attempted */
  80fe1d:	c7 05 80 12 b4 00 df 	movl   $0x8169df,0xb41280
  80fe24:	69 81 00 
	sys_errlist[EDOTDOT] = "EDOTDOT";      /* RFS specific error */
  80fe27:	c7 05 84 12 b4 00 e9 	movl   $0x8169e9,0xb41284
  80fe2e:	69 81 00 
	sys_errlist[EBADMSG] = "EBADMSG";      /* Not a data message */
  80fe31:	c7 05 88 12 b4 00 f1 	movl   $0x8169f1,0xb41288
  80fe38:	69 81 00 
	sys_errlist[EOVERFLOW] = "EOVERFLOW";    /* Value too large for defined data type */
  80fe3b:	c7 05 8c 12 b4 00 f9 	movl   $0x8169f9,0xb4128c
  80fe42:	69 81 00 
	sys_errlist[ENOTUNIQ] = "ENOTUNIQ";    /* Name not unique on network */
  80fe45:	c7 05 90 12 b4 00 03 	movl   $0x816a03,0xb41290
  80fe4c:	6a 81 00 
	sys_errlist[EBADFD] = "EBADFD";      /* File descriptor in bad state */
  80fe4f:	c7 05 94 12 b4 00 0c 	movl   $0x816a0c,0xb41294
  80fe56:	6a 81 00 
	sys_errlist[EREMCHG] = "EREMCHG";      /* Remote address changed */
  80fe59:	c7 05 98 12 b4 00 13 	movl   $0x816a13,0xb41298
  80fe60:	6a 81 00 
	sys_errlist[ELIBACC] = "ELIBACC";      /* Can not access a needed shared library */
  80fe63:	c7 05 9c 12 b4 00 1b 	movl   $0x816a1b,0xb4129c
  80fe6a:	6a 81 00 
	sys_errlist[ELIBBAD] = "ELIBBAD";      /* Accessing a corrupted shared library */
  80fe6d:	c7 05 a0 12 b4 00 23 	movl   $0x816a23,0xb412a0
  80fe74:	6a 81 00 
	sys_errlist[ELIBSCN] = "ELIBSCN";      /* .lib section in a.out corrupted */
  80fe77:	c7 05 a4 12 b4 00 2b 	movl   $0x816a2b,0xb412a4
  80fe7e:	6a 81 00 
	sys_errlist[ELIBMAX] = "ELIBMAX";      /* Attempting to link in too many shared libraries */
  80fe81:	c7 05 a8 12 b4 00 33 	movl   $0x816a33,0xb412a8
  80fe88:	6a 81 00 
	sys_errlist[ELIBEXEC] = "ELIBEXEC";    /* Cannot exec a shared library directly */
  80fe8b:	c7 05 ac 12 b4 00 3b 	movl   $0x816a3b,0xb412ac
  80fe92:	6a 81 00 
	sys_errlist[EILSEQ] = "EILSEQ";      /* Illegal byte sequence */
  80fe95:	c7 05 b0 12 b4 00 44 	movl   $0x816a44,0xb412b0
  80fe9c:	6a 81 00 
	sys_errlist[ERESTART] = "ERESTART";    /* Interrupted system call should be restarted */
  80fe9f:	c7 05 b4 12 b4 00 4b 	movl   $0x816a4b,0xb412b4
  80fea6:	6a 81 00 
	sys_errlist[ESTRPIPE] = "ESTRPIPE";    /* Streams pipe error */
  80fea9:	c7 05 b8 12 b4 00 54 	movl   $0x816a54,0xb412b8
  80feb0:	6a 81 00 
	sys_errlist[EUSERS] = "EUSERS";      /* Too many users */
  80feb3:	c7 05 bc 12 b4 00 5d 	movl   $0x816a5d,0xb412bc
  80feba:	6a 81 00 
	sys_errlist[ENOTSOCK] = "ENOTSOCK";    /* Socket operation on non-socket */
  80febd:	c7 05 c0 12 b4 00 64 	movl   $0x816a64,0xb412c0
  80fec4:	6a 81 00 
	sys_errlist[EDESTADDRREQ] = "EDESTADDRREQ";    /* Destination address required */
  80fec7:	c7 05 c4 12 b4 00 6d 	movl   $0x816a6d,0xb412c4
  80fece:	6a 81 00 
	sys_errlist[EMSGSIZE] = "EMSGSIZE";    /* Message too long */
  80fed1:	c7 05 c8 12 b4 00 7a 	movl   $0x816a7a,0xb412c8
  80fed8:	6a 81 00 
	sys_errlist[EPROTOTYPE] = "EPROTOTYPE";    /* Protocol wrong type for socket */
  80fedb:	c7 05 cc 12 b4 00 83 	movl   $0x816a83,0xb412cc
  80fee2:	6a 81 00 
	sys_errlist[ENOPROTOOPT] = "ENOPROTOOPT";    /* Protocol not available */
  80fee5:	c7 05 d0 12 b4 00 8e 	movl   $0x816a8e,0xb412d0
  80feec:	6a 81 00 
	sys_errlist[EPROTONOSUPPORT] = "EPROTONOSUPPORT";    /* Protocol not supported */
  80feef:	c7 05 d4 12 b4 00 9a 	movl   $0x816a9a,0xb412d4
  80fef6:	6a 81 00 
	sys_errlist[ESOCKTNOSUPPORT] = "ESOCKTNOSUPPORT";    /* Socket type not supported */
  80fef9:	c7 05 d8 12 b4 00 aa 	movl   $0x816aaa,0xb412d8
  80ff00:	6a 81 00 
	sys_errlist[EOPNOTSUPP] = "EOPNOTSUPP";    /* Operation not supported on transport endpoint */
  80ff03:	c7 05 dc 12 b4 00 ba 	movl   $0x816aba,0xb412dc
  80ff0a:	6a 81 00 
	sys_errlist[EPFNOSUPPORT] = "EPFNOSUPPORT";    /* Protocol family not supported */
  80ff0d:	c7 05 e0 12 b4 00 c5 	movl   $0x816ac5,0xb412e0
  80ff14:	6a 81 00 
	sys_errlist[EAFNOSUPPORT] = "EAFNOSUPPORT";    /* Address family not supported by protocol */
  80ff17:	c7 05 e4 12 b4 00 d2 	movl   $0x816ad2,0xb412e4
  80ff1e:	6a 81 00 
	sys_errlist[EADDRINUSE] = "EADDRINUSE";    /* Address already in use */
  80ff21:	c7 05 e8 12 b4 00 df 	movl   $0x816adf,0xb412e8
  80ff28:	6a 81 00 
	sys_errlist[EADDRNOTAVAIL] = "EADDRNOTAVAIL";    /* Cannot assign requested address */
  80ff2b:	c7 05 ec 12 b4 00 ea 	movl   $0x816aea,0xb412ec
  80ff32:	6a 81 00 
	sys_errlist[ENETDOWN] = "ENETDOWN";  /* Network is down */
  80ff35:	c7 05 f0 12 b4 00 f8 	movl   $0x816af8,0xb412f0
  80ff3c:	6a 81 00 
	sys_errlist[ENETUNREACH] = "ENETUNREACH";  /* Network is unreachable */
  80ff3f:	c7 05 f4 12 b4 00 01 	movl   $0x816b01,0xb412f4
  80ff46:	6b 81 00 
	sys_errlist[ENETRESET] = "ENETRESET";  /* Network dropped connection because of reset */
  80ff49:	c7 05 f8 12 b4 00 0d 	movl   $0x816b0d,0xb412f8
  80ff50:	6b 81 00 
	sys_errlist[ECONNABORTED] = "ECONNABORTED";  /* Software caused connection abort */
  80ff53:	c7 05 fc 12 b4 00 17 	movl   $0x816b17,0xb412fc
  80ff5a:	6b 81 00 
	sys_errlist[ECONNRESET] = "ECONNRESET";  /* Connection reset by peer */
  80ff5d:	c7 05 00 13 b4 00 24 	movl   $0x816b24,0xb41300
  80ff64:	6b 81 00 
	sys_errlist[ENOBUFS] = "ENOBUFS";    /* No buffer space available */
  80ff67:	c7 05 04 13 b4 00 2f 	movl   $0x816b2f,0xb41304
  80ff6e:	6b 81 00 
	sys_errlist[EISCONN] = "EISCONN";    /* Transport endpoint is already connected */
  80ff71:	c7 05 08 13 b4 00 37 	movl   $0x816b37,0xb41308
  80ff78:	6b 81 00 
	sys_errlist[ENOTCONN] = "ENOTCONN";  /* Transport endpoint is not connected */
  80ff7b:	c7 05 0c 13 b4 00 3f 	movl   $0x816b3f,0xb4130c
  80ff82:	6b 81 00 
	sys_errlist[ESHUTDOWN] = "ESHUTDOWN";  /* Cannot send after transport endpoint shutdown */
  80ff85:	c7 05 10 13 b4 00 48 	movl   $0x816b48,0xb41310
  80ff8c:	6b 81 00 
	sys_errlist[ETOOMANYREFS] = "ETOOMANYREFS";  /* Too many references: cannot splice */
  80ff8f:	c7 05 14 13 b4 00 52 	movl   $0x816b52,0xb41314
  80ff96:	6b 81 00 
	sys_errlist[ETIMEDOUT] = "ETIMEDOUT";  /* Connection timed out */
  80ff99:	c7 05 18 13 b4 00 5f 	movl   $0x816b5f,0xb41318
  80ffa0:	6b 81 00 
	sys_errlist[ECONNREFUSED] = "ECONNREFUSED";  /* Connection refused */
  80ffa3:	c7 05 1c 13 b4 00 69 	movl   $0x816b69,0xb4131c
  80ffaa:	6b 81 00 
	sys_errlist[EHOSTDOWN] = "EHOSTDOWN";  /* Host is down */
  80ffad:	c7 05 20 13 b4 00 76 	movl   $0x816b76,0xb41320
  80ffb4:	6b 81 00 
	sys_errlist[EHOSTUNREACH] = "EHOSTUNREACH";  /* No route to host */
  80ffb7:	c7 05 24 13 b4 00 80 	movl   $0x816b80,0xb41324
  80ffbe:	6b 81 00 
	sys_errlist[EALREADY] = "EALREADY";  /* Operation already in progress */
  80ffc1:	c7 05 28 13 b4 00 8d 	movl   $0x816b8d,0xb41328
  80ffc8:	6b 81 00 
	sys_errlist[EINPROGRESS] = "EINPROGRESS";  /* Operation now in progress */
  80ffcb:	c7 05 2c 13 b4 00 96 	movl   $0x816b96,0xb4132c
  80ffd2:	6b 81 00 
	sys_errlist[ESTALE] = "ESTALE";    /* Stale NFS file handle */
  80ffd5:	c7 05 30 13 b4 00 a2 	movl   $0x816ba2,0xb41330
  80ffdc:	6b 81 00 
	sys_errlist[EUCLEAN] = "EUCLEAN";    /* Structure needs cleaning */
  80ffdf:	c7 05 34 13 b4 00 a9 	movl   $0x816ba9,0xb41334
  80ffe6:	6b 81 00 
	sys_errlist[ENOTNAM] = "ENOTNAM";    /* Not a XENIX named type file */
  80ffe9:	c7 05 38 13 b4 00 b1 	movl   $0x816bb1,0xb41338
  80fff0:	6b 81 00 
	sys_errlist[ENAVAIL] = "ENAVAIL";    /* No XENIX semaphores available */
  80fff3:	c7 05 3c 13 b4 00 b9 	movl   $0x816bb9,0xb4133c
  80fffa:	6b 81 00 
	sys_errlist[EISNAM] = "EISNAM";    /* Is a named type file */
  80fffd:	c7 05 40 13 b4 00 c1 	movl   $0x816bc1,0xb41340
  810004:	6b 81 00 
	sys_errlist[EREMOTEIO] = "EREMOTEIO";  /* Remote I/O error */
  810007:	c7 05 44 13 b4 00 c8 	movl   $0x816bc8,0xb41344
  81000e:	6b 81 00 
	sys_errlist[EDQUOT] = "EDQUOT";    /* Quota exceeded */
  810011:	c7 05 48 13 b4 00 d2 	movl   $0x816bd2,0xb41348
  810018:	6b 81 00 

	sys_errlist[ENOMEDIUM] = "ENOMEDIUM";  /* No medium found */
  81001b:	c7 05 4c 13 b4 00 d9 	movl   $0x816bd9,0xb4134c
  810022:	6b 81 00 
	sys_errlist[EMEDIUMTYPE] = "EMEDIUMTYPE";  /* Wrong medium type */
  810025:	c7 05 50 13 b4 00 e3 	movl   $0x816be3,0xb41350
  81002c:	6b 81 00 


	sys_errlist[ENSROK] = "ENSROK";    /* DNS server returned answer with no data */
  81002f:	c7 05 60 11 b4 00 ef 	movl   $0x816bef,0xb41160
  810036:	6b 81 00 
	sys_errlist[ENSRNODATA] = "ENSRNODATA";  /* DNS server returned answer with no data */
  810039:	c7 05 e0 13 b4 00 f6 	movl   $0x816bf6,0xb413e0
  810040:	6b 81 00 
	sys_errlist[ENSRFORMERR] = "ENSRFORMERR"; /* DNS server claims query was misformatted */
  810043:	c7 05 e4 13 b4 00 01 	movl   $0x816c01,0xb413e4
  81004a:	6c 81 00 
	sys_errlist[ENSRSERVFAIL] = "ENSRSERVFAIL"; /* DNS server returned general failure */
  81004d:	c7 05 e8 13 b4 00 0d 	movl   $0x816c0d,0xb413e8
  810054:	6c 81 00 
	sys_errlist[ENSRNOTFOUND] = "ENSRNOTFOUND"; /* Domain name not found */
  810057:	c7 05 ec 13 b4 00 1a 	movl   $0x816c1a,0xb413ec
  81005e:	6c 81 00 
	sys_errlist[ENSRNOTIMP] = "ENSRNOTIMP";  /* DNS server does not implement requested operation */
  810061:	c7 05 f0 13 b4 00 27 	movl   $0x816c27,0xb413f0
  810068:	6c 81 00 
	sys_errlist[ENSRREFUSED] = "ENSRREFUSED"; /* DNS server refused query */
  81006b:	c7 05 f4 13 b4 00 32 	movl   $0x816c32,0xb413f4
  810072:	6c 81 00 
	sys_errlist[ENSRBADQUERY] = "ENSRBADQUERY"; /* Misformatted DNS query */
  810075:	c7 05 f8 13 b4 00 3e 	movl   $0x816c3e,0xb413f8
  81007c:	6c 81 00 
	sys_errlist[ENSRBADNAME] = "ENSRBADNAME"; /* Misformatted domain name */
  81007f:	c7 05 fc 13 b4 00 4b 	movl   $0x816c4b,0xb413fc
  810086:	6c 81 00 
	sys_errlist[ENSRBADFAMILY] = "ENSRBADFAMILY"; /* Unsupported address family */
  810089:	c7 05 00 14 b4 00 57 	movl   $0x816c57,0xb41400
  810090:	6c 81 00 
	sys_errlist[ENSRBADRESP] = "ENSRBADRESP"; /* Misformatted DNS reply */
  810093:	c7 05 04 14 b4 00 65 	movl   $0x816c65,0xb41404
  81009a:	6c 81 00 
	sys_errlist[ENSRCONNREFUSED] = "ENSRCONNREFUSED"; /* Could not contact DNS servers */
  81009d:	c7 05 08 14 b4 00 71 	movl   $0x816c71,0xb41408
  8100a4:	6c 81 00 
	sys_errlist[ENSRTIMEOUT] = "ENSRTIMEOUT"; /* Timeout while contacting DNS servers */
  8100a7:	c7 05 0c 14 b4 00 81 	movl   $0x816c81,0xb4140c
  8100ae:	6c 81 00 
	sys_errlist[ENSROF] = "ENSROF";    /* End of file */
  8100b1:	c7 05 10 14 b4 00 8d 	movl   $0x816c8d,0xb41410
  8100b8:	6c 81 00 
	sys_errlist[ENSRFILE] = "ENSRFILE";  /* Error reading file */
  8100bb:	c7 05 14 14 b4 00 94 	movl   $0x816c94,0xb41414
  8100c2:	6c 81 00 
	sys_errlist[ENSRNOMEM] = "ENSRNOMEM"; /* Out of memory */
  8100c5:	c7 05 18 14 b4 00 9d 	movl   $0x816c9d,0xb41418
  8100cc:	6c 81 00 
	sys_errlist[ENSRDESTRUCTION] = "ENSRDESTRUCTION"; /* Application terminated lookup */
  8100cf:	c7 05 1c 14 b4 00 a7 	movl   $0x816ca7,0xb4141c
  8100d6:	6c 81 00 
	sys_errlist[ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG";  /* Domain name is too long */
  8100d9:	c7 05 20 14 b4 00 b7 	movl   $0x816cb7,0xb41420
  8100e0:	6c 81 00 
	sys_errlist[ENSRCNAMELOOP] = "ENSRCNAMELOOP"; /* Domain name is too long */
  8100e3:	c7 05 24 14 b4 00 ce 	movl   $0x816cce,0xb41424
  8100ea:	6c 81 00 
  8100ed:	8b 45 08             	mov    0x8(%ebp),%eax
  8100f0:	8b 04 85 60 11 b4 00 	mov    0xb41160(,%eax,4),%eax
}

const char *
e2s(int err) {
	return get_errlist(err);
}
  8100f7:	5d                   	pop    %ebp
  8100f8:	c3                   	ret    

008100f9 <_Z6perrorPKc>:
	return sys_errlist[err];
}


void
perror(const char *s) {
  8100f9:	55                   	push   %ebp
  8100fa:	89 e5                	mov    %esp,%ebp
  8100fc:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  8100ff:	a1 00 90 81 00       	mov    0x819000,%eax
  810104:	89 04 24             	mov    %eax,(%esp)
  810107:	e8 5c fa ff ff       	call   80fb68 <_Z3e2si>
  81010c:	89 44 24 08          	mov    %eax,0x8(%esp)
  810110:	8b 45 08             	mov    0x8(%ebp),%eax
  810113:	89 44 24 04          	mov    %eax,0x4(%esp)
  810117:	c7 04 24 dc 6c 81 00 	movl   $0x816cdc,(%esp)
  81011e:	e8 b3 09 ff ff       	call   800ad6 <_Z7cprintfPKcz>
}
  810123:	c9                   	leave  
  810124:	c3                   	ret    
	...

00810130 <_ZL16low_level_outputP5netifP4pbuf>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  810130:	55                   	push   %ebp
  810131:	89 e5                	mov    %esp,%ebp
  810133:	57                   	push   %edi
  810134:	56                   	push   %esi
  810135:	53                   	push   %ebx
  810136:	83 ec 2c             	sub    $0x2c,%esp
  810139:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  81013c:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  810143:	00 
  810144:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  81014b:	10 
  81014c:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  810153:	e8 78 14 ff ff       	call   8015d0 <_Z14sys_page_allociPvi>
    if (r < 0)
  810158:	85 c0                	test   %eax,%eax
  81015a:	79 1c                	jns    810178 <_ZL16low_level_outputP5netifP4pbuf+0x48>
	panic("jif: could not allocate page of memory");
  81015c:	c7 44 24 08 e4 6c 81 	movl   $0x816ce4,0x8(%esp)
  810163:	00 
  810164:	c7 44 24 04 56 00 00 	movl   $0x56,0x4(%esp)
  81016b:	00 
  81016c:	c7 04 24 35 6d 81 00 	movl   $0x816d35,(%esp)
  810173:	e8 40 08 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = (struct jif *) netif->state;
  810178:	8b 45 08             	mov    0x8(%ebp),%eax
  81017b:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  81017e:	85 db                	test   %ebx,%ebx
  810180:	74 7d                	je     8101ff <_ZL16low_level_outputP5netifP4pbuf+0xcf>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  810182:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  810186:	0f b7 d0             	movzwl %ax,%edx
  810189:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  81018f:	7f 1b                	jg     8101ac <_ZL16low_level_outputP5netifP4pbuf+0x7c>

    struct jif *jif;
    jif = (struct jif *) netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
  810191:	be 00 00 00 00       	mov    $0x0,%esi
  810196:	eb 3d                	jmp    8101d5 <_ZL16low_level_outputP5netifP4pbuf+0xa5>
    for (q = p; q != NULL; q = q->next) {
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  810198:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  81019c:	0f b7 d0             	movzwl %ax,%edx
  81019f:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  8101a2:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  8101a8:	7e 2b                	jle    8101d5 <_ZL16low_level_outputP5netifP4pbuf+0xa5>
  8101aa:	eb 05                	jmp    8101b1 <_ZL16low_level_outputP5netifP4pbuf+0x81>

    struct jif *jif;
    jif = (struct jif *) netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
  8101ac:	be 00 00 00 00       	mov    $0x0,%esi
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  8101b1:	89 74 24 10          	mov    %esi,0x10(%esp)
  8101b5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8101b9:	c7 44 24 08 0c 6d 81 	movl   $0x816d0c,0x8(%esp)
  8101c0:	00 
  8101c1:	c7 44 24 04 65 00 00 	movl   $0x65,0x4(%esp)
  8101c8:	00 
  8101c9:	c7 04 24 35 6d 81 00 	movl   $0x816d35,(%esp)
  8101d0:	e8 e3 07 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
	memcpy(&txbuf[txsize], q->payload, q->len);
  8101d5:	0f b7 c0             	movzwl %ax,%eax
  8101d8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8101dc:	8b 43 04             	mov    0x4(%ebx),%eax
  8101df:	89 44 24 04          	mov    %eax,0x4(%esp)
  8101e3:	8d 86 04 00 00 10    	lea    0x10000004(%esi),%eax
  8101e9:	89 04 24             	mov    %eax,(%esp)
  8101ec:	e8 16 11 ff ff       	call   801307 <memcpy>
	txsize += q->len;
  8101f1:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8101f5:	01 c6                	add    %eax,%esi
    jif = (struct jif *) netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8101f7:	8b 1b                	mov    (%ebx),%ebx
  8101f9:	85 db                	test   %ebx,%ebx
  8101fb:	75 9b                	jne    810198 <_ZL16low_level_outputP5netifP4pbuf+0x68>
  8101fd:	eb 05                	jmp    810204 <_ZL16low_level_outputP5netifP4pbuf+0xd4>

    struct jif *jif;
    jif = (struct jif *) netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
  8101ff:	be 00 00 00 00       	mov    $0x0,%esi
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  810204:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  81020a:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  810211:	00 
  810212:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  810219:	10 
  81021a:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  810221:	00 
  810222:	8b 47 04             	mov    0x4(%edi),%eax
  810225:	89 04 24             	mov    %eax,(%esp)
  810228:	e8 62 1d ff ff       	call   801f8f <_Z8ipc_sendijPvi>
    sys_page_unmap(0, (void *)pkt);
  81022d:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  810234:	10 
  810235:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81023c:	e8 4c 14 ff ff       	call   80168d <_Z14sys_page_unmapiPv>

    return ERR_OK;
}
  810241:	b8 00 00 00 00       	mov    $0x0,%eax
  810246:	83 c4 2c             	add    $0x2c,%esp
  810249:	5b                   	pop    %ebx
  81024a:	5e                   	pop    %esi
  81024b:	5f                   	pop    %edi
  81024c:	5d                   	pop    %ebp
  81024d:	c3                   	ret    

0081024e <_ZL10jif_outputP5netifP4pbufP7ip_addr>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  81024e:	55                   	push   %ebp
  81024f:	89 e5                	mov    %esp,%ebp
  810251:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  810254:	8b 45 10             	mov    0x10(%ebp),%eax
  810257:	89 44 24 08          	mov    %eax,0x8(%esp)
  81025b:	8b 45 0c             	mov    0xc(%ebp),%eax
  81025e:	89 44 24 04          	mov    %eax,0x4(%esp)
  810262:	8b 45 08             	mov    0x8(%ebp),%eax
  810265:	89 04 24             	mov    %eax,(%esp)
  810268:	e8 c5 e7 ff ff       	call   80ea32 <etharp_output>
}
  81026d:	c9                   	leave  
  81026e:	c3                   	ret    

0081026f <_Z9jif_inputP5netifPv>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  81026f:	55                   	push   %ebp
  810270:	89 e5                	mov    %esp,%ebp
  810272:	57                   	push   %edi
  810273:	56                   	push   %esi
  810274:	53                   	push   %ebx
  810275:	83 ec 2c             	sub    $0x2c,%esp
  810278:	8b 45 0c             	mov    0xc(%ebp),%eax
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = (struct jif *) netif->state;
  81027b:	8b 55 08             	mov    0x8(%ebp),%edx
  81027e:	8b 52 1c             	mov    0x1c(%edx),%edx
  810281:	89 55 d8             	mov    %edx,-0x28(%ebp)
 *
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  810284:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    s16_t len = pkt->jp_len;
  810287:	0f b7 38             	movzwl (%eax),%edi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  81028a:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  810291:	00 
  810292:	0f b7 c7             	movzwl %di,%eax
  810295:	89 44 24 04          	mov    %eax,0x4(%esp)
  810299:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  8102a0:	e8 80 91 ff ff       	call   809425 <pbuf_alloc>
  8102a5:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  8102a8:	85 c0                	test   %eax,%eax
  8102aa:	0f 84 c2 00 00 00    	je     810372 <_Z9jif_inputP5netifPv+0x103>
  8102b0:	89 c3                	mov    %eax,%ebx
  8102b2:	be 00 00 00 00       	mov    $0x0,%esi
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
	if (bytes > (len - copied))
  8102b7:	0f bf ff             	movswl %di,%edi
  8102ba:	89 7d e0             	mov    %edi,-0x20(%ebp)
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  8102bd:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
	if (bytes > (len - copied))
  8102c1:	8b 7d e0             	mov    -0x20(%ebp),%edi
  8102c4:	29 f7                	sub    %esi,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  8102c6:	39 c7                	cmp    %eax,%edi
  8102c8:	0f 4f f8             	cmovg  %eax,%edi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, (uint8_t*) rxbuf + copied, bytes);
  8102cb:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8102cf:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8102d2:	8d 44 32 04          	lea    0x4(%edx,%esi,1),%eax
  8102d6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8102da:	8b 43 04             	mov    0x4(%ebx),%eax
  8102dd:	89 04 24             	mov    %eax,(%esp)
  8102e0:	e8 22 10 ff ff       	call   801307 <memcpy>
	copied += bytes;
  8102e5:	01 fe                	add    %edi,%esi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  8102e7:	8b 1b                	mov    (%ebx),%ebx
  8102e9:	85 db                	test   %ebx,%ebx
  8102eb:	75 d0                	jne    8102bd <_Z9jif_inputP5netifPv+0x4e>
  8102ed:	eb 63                	jmp    810352 <_Z9jif_inputP5netifPv+0xe3>
    ethhdr = (struct eth_hdr *) p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  8102ef:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8102f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8102f6:	8b 55 08             	mov    0x8(%ebp),%edx
  8102f9:	89 14 24             	mov    %edx,(%esp)
  8102fc:	e8 5d e1 ff ff       	call   80e45e <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  810301:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  810308:	ff 
  810309:	8b 45 dc             	mov    -0x24(%ebp),%eax
  81030c:	89 04 24             	mov    %eax,(%esp)
  81030f:	e8 fc 8d ff ff       	call   809110 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  810314:	8b 55 08             	mov    0x8(%ebp),%edx
  810317:	89 54 24 04          	mov    %edx,0x4(%esp)
  81031b:	8b 45 dc             	mov    -0x24(%ebp),%eax
  81031e:	89 04 24             	mov    %eax,(%esp)
  810321:	ff 52 10             	call   *0x10(%edx)
	break;
  810324:	eb 4c                	jmp    810372 <_Z9jif_inputP5netifPv+0x103>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  810326:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810329:	89 54 24 08          	mov    %edx,0x8(%esp)
  81032d:	8b 55 d8             	mov    -0x28(%ebp),%edx
  810330:	8b 02                	mov    (%edx),%eax
  810332:	89 44 24 04          	mov    %eax,0x4(%esp)
  810336:	8b 45 08             	mov    0x8(%ebp),%eax
  810339:	89 04 24             	mov    %eax,(%esp)
  81033c:	e8 6b e1 ff ff       	call   80e4ac <etharp_arp_input>
	break;
  810341:	eb 2f                	jmp    810372 <_Z9jif_inputP5netifPv+0x103>

    default:
	pbuf_free(p);
  810343:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810346:	89 14 24             	mov    %edx,(%esp)
  810349:	e8 b5 8e ff ff       	call   809203 <pbuf_free>
  81034e:	66 90                	xchg   %ax,%ax
  810350:	eb 20                	jmp    810372 <_Z9jif_inputP5netifPv+0x103>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = (struct eth_hdr *) p->payload;

    switch (htons(ethhdr->type)) {
  810352:	8b 55 dc             	mov    -0x24(%ebp),%edx
  810355:	8b 42 04             	mov    0x4(%edx),%eax
  810358:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81035c:	89 04 24             	mov    %eax,(%esp)
  81035f:	e8 55 c0 ff ff       	call   80c3b9 <htons>
  810364:	66 3d 00 08          	cmp    $0x800,%ax
  810368:	74 85                	je     8102ef <_Z9jif_inputP5netifPv+0x80>
  81036a:	66 3d 06 08          	cmp    $0x806,%ax
  81036e:	75 d3                	jne    810343 <_Z9jif_inputP5netifPv+0xd4>
  810370:	eb b4                	jmp    810326 <_Z9jif_inputP5netifPv+0xb7>
	break;

    default:
	pbuf_free(p);
    }
}
  810372:	83 c4 2c             	add    $0x2c,%esp
  810375:	5b                   	pop    %ebx
  810376:	5e                   	pop    %esi
  810377:	5f                   	pop    %edi
  810378:	5d                   	pop    %ebp
  810379:	c3                   	ret    

0081037a <_Z8jif_initP5netif>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  81037a:	55                   	push   %ebp
  81037b:	89 e5                	mov    %esp,%ebp
  81037d:	83 ec 38             	sub    $0x38,%esp
  810380:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  810383:	89 75 f8             	mov    %esi,-0x8(%ebp)
  810386:	89 7d fc             	mov    %edi,-0x4(%ebp)
  810389:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = (struct jif *) mem_malloc(sizeof(struct jif));
  81038c:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  810393:	e8 ab 87 ff ff       	call   808b43 <mem_malloc>
  810398:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
  81039a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    struct jif *jif;
    envid_t *output_envid; 

    jif = (struct jif *) mem_malloc(sizeof(struct jif));

    if (jif == NULL) {
  81039f:	85 f6                	test   %esi,%esi
  8103a1:	0f 84 8a 00 00 00    	je     810431 <_Z8jif_initP5netif+0xb7>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  8103a7:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  8103aa:	89 73 1c             	mov    %esi,0x1c(%ebx)
    netif->output = jif_output;
  8103ad:	c7 43 14 4e 02 81 00 	movl   $0x81024e,0x14(%ebx)
    netif->linkoutput = low_level_output;
  8103b4:	c7 43 18 30 01 81 00 	movl   $0x810130,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  8103bb:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  8103c2:	00 
  8103c3:	c7 44 24 04 31 50 81 	movl   $0x815031,0x4(%esp)
  8103ca:	00 
  8103cb:	8d 43 2f             	lea    0x2f(%ebx),%eax
  8103ce:	89 04 24             	mov    %eax,(%esp)
  8103d1:	e8 31 0f ff ff       	call   801307 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  8103d6:	8d 43 25             	lea    0x25(%ebx),%eax
  8103d9:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  8103db:	8b 07                	mov    (%edi),%eax
  8103dd:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  8103e0:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  8103e4:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  8103ea:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  8103ee:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  8103f2:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  8103f6:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  8103fa:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  8103fe:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = MACHINE?0x57:0x56;
  810402:	c6 43 2a 57          	movb   $0x57,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  810406:	c7 04 24 2b 44 81 00 	movl   $0x81442b,(%esp)
  81040d:	e8 02 c2 ff ff       	call   80c614 <inet_addr>
  810412:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  810415:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81041c:	00 
  81041d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810420:	89 44 24 04          	mov    %eax,0x4(%esp)
  810424:	89 1c 24             	mov    %ebx,(%esp)
  810427:	e8 cc e3 ff ff       	call   80e7f8 <etharp_query>

    return ERR_OK;
  81042c:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810431:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  810434:	8b 75 f8             	mov    -0x8(%ebp),%esi
  810437:	8b 7d fc             	mov    -0x4(%ebp),%edi
  81043a:	89 ec                	mov    %ebp,%esp
  81043c:	5d                   	pop    %ebp
  81043d:	c3                   	ret    
	...

00810440 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  810440:	55                   	push   %ebp
  810441:	89 e5                	mov    %esp,%ebp
  810443:	56                   	push   %esi
  810444:	53                   	push   %ebx
  810445:	83 ec 30             	sub    $0x30,%esp
  810448:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  81044c:	8b 45 10             	mov    0x10(%ebp),%eax
  81044f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810453:	8b 45 08             	mov    0x8(%ebp),%eax
  810456:	89 04 24             	mov    %eax,(%esp)
  810459:	e8 6f 10 00 00       	call   8114cd <netconn_alloc>
  81045e:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  810460:	85 c0                	test   %eax,%eax
  810462:	0f 84 d6 00 00 00    	je     81053e <netconn_new_with_proto_and_callback+0xfe>
    msg.function = do_newconn;
  810468:	c7 45 e4 c7 13 81 00 	movl   $0x8113c7,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  81046f:	89 f0                	mov    %esi,%eax
  810471:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  810474:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  810477:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  81047a:	89 04 24             	mov    %eax,(%esp)
  81047d:	e8 52 65 ff ff       	call   8069d4 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  810482:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  810486:	0f 84 b2 00 00 00    	je     81053e <netconn_new_with_proto_and_callback+0xfe>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  81048c:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  810490:	74 1c                	je     8104ae <netconn_new_with_proto_and_callback+0x6e>
  810492:	c7 44 24 08 4c 6d 81 	movl   $0x816d4c,0x8(%esp)
  810499:	00 
  81049a:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  8104a1:	00 
  8104a2:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8104a9:	e8 0a 05 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  8104ae:	8b 43 10             	mov    0x10(%ebx),%eax
  8104b1:	83 f8 ff             	cmp    $0xffffffff,%eax
  8104b4:	75 1c                	jne    8104d2 <netconn_new_with_proto_and_callback+0x92>
  8104b6:	c7 44 24 08 15 6e 81 	movl   $0x816e15,0x8(%esp)
  8104bd:	00 
  8104be:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  8104c5:	00 
  8104c6:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8104cd:	e8 e6 04 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  8104d2:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  8104d6:	75 1c                	jne    8104f4 <netconn_new_with_proto_and_callback+0xb4>
  8104d8:	c7 44 24 08 2e 6e 81 	movl   $0x816e2e,0x8(%esp)
  8104df:	00 
  8104e0:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  8104e7:	00 
  8104e8:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8104ef:	e8 c4 04 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  8104f4:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  8104f8:	74 1c                	je     810516 <netconn_new_with_proto_and_callback+0xd6>
  8104fa:	c7 44 24 08 70 6d 81 	movl   $0x816d70,0x8(%esp)
  810501:	00 
  810502:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  810509:	00 
  81050a:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810511:	e8 a2 04 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
      sys_sem_free(conn->op_completed);
  810516:	89 04 24             	mov    %eax,(%esp)
  810519:	e8 83 e9 ff ff       	call   80eea1 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  81051e:	8b 43 14             	mov    0x14(%ebx),%eax
  810521:	89 04 24             	mov    %eax,(%esp)
  810524:	e8 2c ea ff ff       	call   80ef55 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  810529:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81052d:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  810534:	e8 08 89 ff ff       	call   808e41 <memp_free>
      return NULL;
  810539:	bb 00 00 00 00       	mov    $0x0,%ebx
    }
  }
  return conn;
}
  81053e:	89 d8                	mov    %ebx,%eax
  810540:	83 c4 30             	add    $0x30,%esp
  810543:	5b                   	pop    %ebx
  810544:	5e                   	pop    %esi
  810545:	5d                   	pop    %ebp
  810546:	c3                   	ret    

00810547 <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  810547:	55                   	push   %ebp
  810548:	89 e5                	mov    %esp,%ebp
  81054a:	53                   	push   %ebx
  81054b:	83 ec 34             	sub    $0x34,%esp
  81054e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  810551:	85 db                	test   %ebx,%ebx
  810553:	74 24                	je     810579 <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  810555:	c7 45 e4 25 17 81 00 	movl   $0x811725,-0x1c(%ebp)
  msg.msg.conn = conn;
  81055c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  81055f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810562:	89 04 24             	mov    %eax,(%esp)
  810565:	e8 6a 64 ff ff       	call   8069d4 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  81056a:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  810571:	89 1c 24             	mov    %ebx,(%esp)
  810574:	e8 0b 10 00 00       	call   811584 <netconn_free>

  return ERR_OK;
}
  810579:	b8 00 00 00 00       	mov    $0x0,%eax
  81057e:	83 c4 34             	add    $0x34,%esp
  810581:	5b                   	pop    %ebx
  810582:	5d                   	pop    %ebp
  810583:	c3                   	ret    

00810584 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  810584:	55                   	push   %ebp
  810585:	89 e5                	mov    %esp,%ebp
  810587:	83 ec 18             	sub    $0x18,%esp
  81058a:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  81058d:	85 c0                	test   %eax,%eax
  81058f:	75 1c                	jne    8105ad <netconn_type+0x29>
  810591:	c7 44 24 08 43 6e 81 	movl   $0x816e43,0x8(%esp)
  810598:	00 
  810599:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  8105a0:	00 
  8105a1:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8105a8:	e8 0b 04 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  8105ad:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  8105af:	c9                   	leave  
  8105b0:	c3                   	ret    

008105b1 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  8105b1:	55                   	push   %ebp
  8105b2:	89 e5                	mov    %esp,%ebp
  8105b4:	53                   	push   %ebx
  8105b5:	83 ec 34             	sub    $0x34,%esp
  8105b8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8105bb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8105be:	8b 45 10             	mov    0x10(%ebp),%eax
  8105c1:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  8105c5:	85 db                	test   %ebx,%ebx
  8105c7:	75 1c                	jne    8105e5 <netconn_getaddr+0x34>
  8105c9:	c7 44 24 08 5e 6e 81 	movl   $0x816e5e,0x8(%esp)
  8105d0:	00 
  8105d1:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  8105d8:	00 
  8105d9:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8105e0:	e8 d3 03 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  8105e5:	85 d2                	test   %edx,%edx
  8105e7:	75 1c                	jne    810605 <netconn_getaddr+0x54>
  8105e9:	c7 44 24 08 7c 6e 81 	movl   $0x816e7c,0x8(%esp)
  8105f0:	00 
  8105f1:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  8105f8:	00 
  8105f9:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810600:	e8 b3 03 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  810605:	85 c0                	test   %eax,%eax
  810607:	75 1c                	jne    810625 <netconn_getaddr+0x74>
  810609:	c7 44 24 08 9a 6e 81 	movl   $0x816e9a,0x8(%esp)
  810610:	00 
  810611:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  810618:	00 
  810619:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810620:	e8 93 03 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  msg.function = do_getaddr;
  810625:	c7 45 e4 b2 1b 81 00 	movl   $0x811bb2,-0x1c(%ebp)
  msg.msg.conn = conn;
  81062c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  81062f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  810632:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  810635:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  810638:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  81063b:	89 04 24             	mov    %eax,(%esp)
  81063e:	e8 91 63 ff ff       	call   8069d4 <tcpip_apimsg>
  810643:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax

  return conn->err;
}
  810647:	83 c4 34             	add    $0x34,%esp
  81064a:	5b                   	pop    %ebx
  81064b:	5d                   	pop    %ebp
  81064c:	c3                   	ret    

0081064d <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  81064d:	55                   	push   %ebp
  81064e:	89 e5                	mov    %esp,%ebp
  810650:	53                   	push   %ebx
  810651:	83 ec 34             	sub    $0x34,%esp
  810654:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810657:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  81065b:	85 db                	test   %ebx,%ebx
  81065d:	75 1c                	jne    81067b <netconn_bind+0x2e>
  81065f:	c7 44 24 08 b8 6e 81 	movl   $0x816eb8,0x8(%esp)
  810666:	00 
  810667:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  81066e:	00 
  81066f:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810676:	e8 3d 03 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  msg.function = do_bind;
  81067b:	c7 45 e4 d6 17 81 00 	movl   $0x8117d6,-0x1c(%ebp)
  msg.msg.conn = conn;
  810682:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  810685:	8b 55 0c             	mov    0xc(%ebp),%edx
  810688:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  81068b:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  81068f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810692:	89 04 24             	mov    %eax,(%esp)
  810695:	e8 3a 63 ff ff       	call   8069d4 <tcpip_apimsg>
  81069a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  81069e:	83 c4 34             	add    $0x34,%esp
  8106a1:	5b                   	pop    %ebx
  8106a2:	5d                   	pop    %ebp
  8106a3:	c3                   	ret    

008106a4 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  8106a4:	55                   	push   %ebp
  8106a5:	89 e5                	mov    %esp,%ebp
  8106a7:	53                   	push   %ebx
  8106a8:	83 ec 34             	sub    $0x34,%esp
  8106ab:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8106ae:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  8106b2:	85 db                	test   %ebx,%ebx
  8106b4:	75 1c                	jne    8106d2 <netconn_connect+0x2e>
  8106b6:	c7 44 24 08 d3 6e 81 	movl   $0x816ed3,0x8(%esp)
  8106bd:	00 
  8106be:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  8106c5:	00 
  8106c6:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8106cd:	e8 e6 02 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  msg.function = do_connect;
  8106d2:	c7 45 e4 73 18 81 00 	movl   $0x811873,-0x1c(%ebp)
  msg.msg.conn = conn;
  8106d9:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  8106dc:	8b 55 0c             	mov    0xc(%ebp),%edx
  8106df:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  8106e2:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  8106e6:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8106e9:	89 04 24             	mov    %eax,(%esp)
  8106ec:	e8 e3 62 ff ff       	call   8069d4 <tcpip_apimsg>
  8106f1:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  8106f5:	83 c4 34             	add    $0x34,%esp
  8106f8:	5b                   	pop    %ebx
  8106f9:	5d                   	pop    %ebp
  8106fa:	c3                   	ret    

008106fb <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  8106fb:	55                   	push   %ebp
  8106fc:	89 e5                	mov    %esp,%ebp
  8106fe:	53                   	push   %ebx
  8106ff:	83 ec 34             	sub    $0x34,%esp
  810702:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  810705:	85 db                	test   %ebx,%ebx
  810707:	75 1c                	jne    810725 <netconn_disconnect+0x2a>
  810709:	c7 44 24 08 94 6d 81 	movl   $0x816d94,0x8(%esp)
  810710:	00 
  810711:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  810718:	00 
  810719:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810720:	e8 93 02 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  msg.function = do_disconnect;
  810725:	c7 45 e4 39 19 81 00 	movl   $0x811939,-0x1c(%ebp)
  msg.msg.conn = conn;
  81072c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  81072f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810732:	89 04 24             	mov    %eax,(%esp)
  810735:	e8 9a 62 ff ff       	call   8069d4 <tcpip_apimsg>
  81073a:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  81073e:	83 c4 34             	add    $0x34,%esp
  810741:	5b                   	pop    %ebx
  810742:	5d                   	pop    %ebp
  810743:	c3                   	ret    

00810744 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  810744:	55                   	push   %ebp
  810745:	89 e5                	mov    %esp,%ebp
  810747:	53                   	push   %ebx
  810748:	83 ec 34             	sub    $0x34,%esp
  81074b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  81074e:	85 db                	test   %ebx,%ebx
  810750:	75 1c                	jne    81076e <netconn_listen_with_backlog+0x2a>
  810752:	c7 44 24 08 f1 6e 81 	movl   $0x816ef1,0x8(%esp)
  810759:	00 
  81075a:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  810761:	00 
  810762:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810769:	e8 4a 02 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  msg.function = do_listen;
  81076e:	c7 45 e4 70 19 81 00 	movl   $0x811970,-0x1c(%ebp)
  msg.msg.conn = conn;
  810775:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  810778:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  81077b:	89 04 24             	mov    %eax,(%esp)
  81077e:	e8 51 62 ff ff       	call   8069d4 <tcpip_apimsg>
  810783:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  810787:	83 c4 34             	add    $0x34,%esp
  81078a:	5b                   	pop    %ebx
  81078b:	5d                   	pop    %ebp
  81078c:	c3                   	ret    

0081078d <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  81078d:	55                   	push   %ebp
  81078e:	89 e5                	mov    %esp,%ebp
  810790:	53                   	push   %ebx
  810791:	83 ec 24             	sub    $0x24,%esp
  810794:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  810797:	85 db                	test   %ebx,%ebx
  810799:	75 1c                	jne    8107b7 <netconn_accept+0x2a>
  81079b:	c7 44 24 08 0e 6f 81 	movl   $0x816f0e,0x8(%esp)
  8107a2:	00 
  8107a3:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  8107aa:	00 
  8107ab:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8107b2:	e8 01 02 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  8107b7:	8b 43 18             	mov    0x18(%ebx),%eax
  8107ba:	83 f8 ff             	cmp    $0xffffffff,%eax
  8107bd:	75 1c                	jne    8107db <netconn_accept+0x4e>
  8107bf:	c7 44 24 08 b8 6d 81 	movl   $0x816db8,0x8(%esp)
  8107c6:	00 
  8107c7:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  8107ce:	00 
  8107cf:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8107d6:	e8 dd 01 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void **)&newconn, 0);
  8107db:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8107e2:	00 
  8107e3:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8107e6:	89 54 24 04          	mov    %edx,0x4(%esp)
  8107ea:	89 04 24             	mov    %eax,(%esp)
  8107ed:	e8 62 ec ff ff       	call   80f454 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  8107f2:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8107f5:	85 c0                	test   %eax,%eax
  8107f7:	74 15                	je     81080e <netconn_accept+0x81>
  8107f9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810800:	00 
  810801:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  810808:	00 
  810809:	89 1c 24             	mov    %ebx,(%esp)
  81080c:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  81080e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810811:	83 c4 24             	add    $0x24,%esp
  810814:	5b                   	pop    %ebx
  810815:	5d                   	pop    %ebp
  810816:	c3                   	ret    

00810817 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  810817:	55                   	push   %ebp
  810818:	89 e5                	mov    %esp,%ebp
  81081a:	53                   	push   %ebx
  81081b:	83 ec 34             	sub    $0x34,%esp
  81081e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  810821:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  810828:	85 db                	test   %ebx,%ebx
  81082a:	75 1c                	jne    810848 <netconn_recv+0x31>
  81082c:	c7 44 24 08 2b 6f 81 	movl   $0x816f2b,0x8(%esp)
  810833:	00 
  810834:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  81083b:	00 
  81083c:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810843:	e8 70 01 ff ff       	call   8009b8 <_Z6_panicPKciS0_z>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  810848:	8b 53 14             	mov    0x14(%ebx),%edx
  81084b:	83 fa ff             	cmp    $0xffffffff,%edx
  81084e:	75 0e                	jne    81085e <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  810850:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
    return NULL;
  810854:	b8 00 00 00 00       	mov    $0x0,%eax
  810859:	e9 4f 01 00 00       	jmp    8109ad <netconn_recv+0x196>
  }

  if (ERR_IS_FATAL(conn->err)) {
    return NULL;
  81085e:	b8 00 00 00 00       	mov    $0x0,%eax
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
    return NULL;
  }

  if (ERR_IS_FATAL(conn->err)) {
  810863:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  810867:	0f 8c 40 01 00 00    	jl     8109ad <netconn_recv+0x196>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  81086d:	83 3b 10             	cmpl   $0x10,(%ebx)
  810870:	0f 85 ee 00 00 00    	jne    810964 <netconn_recv+0x14d>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  810876:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  81087a:	75 09                	jne    810885 <netconn_recv+0x6e>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  81087c:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
      return NULL;
  810880:	e9 28 01 00 00       	jmp    8109ad <netconn_recv+0x196>
    }

    buf = (struct netbuf *) memp_malloc(MEMP_NETBUF);
  810885:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  81088c:	e8 50 85 ff ff       	call   808de1 <memp_malloc>
  810891:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (buf == NULL) {
  810894:	85 c0                	test   %eax,%eax
  810896:	75 09                	jne    8108a1 <netconn_recv+0x8a>
      conn->err = ERR_MEM;
  810898:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  81089c:	e9 0c 01 00 00       	jmp    8109ad <netconn_recv+0x196>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void **)&p, 0);
  8108a1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8108a8:	00 
  8108a9:	8d 45 f0             	lea    -0x10(%ebp),%eax
  8108ac:	89 44 24 04          	mov    %eax,0x4(%esp)
  8108b0:	8b 43 14             	mov    0x14(%ebx),%eax
  8108b3:	89 04 24             	mov    %eax,(%esp)
  8108b6:	e8 99 eb ff ff       	call   80f454 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  8108bb:	8b 55 f0             	mov    -0x10(%ebp),%edx
      len = p->tot_len;
      SYS_ARCH_DEC(conn->recv_avail, len);
    } else {
      len = 0;
  8108be:	b8 00 00 00 00       	mov    $0x0,%eax
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void **)&p, 0);
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  8108c3:	85 d2                	test   %edx,%edx
  8108c5:	74 08                	je     8108cf <netconn_recv+0xb8>
      len = p->tot_len;
  8108c7:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  8108cb:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  8108cf:	8b 53 2c             	mov    0x2c(%ebx),%edx
  8108d2:	85 d2                	test   %edx,%edx
  8108d4:	74 14                	je     8108ea <netconn_recv+0xd3>
  8108d6:	0f b7 c0             	movzwl %ax,%eax
  8108d9:	89 44 24 08          	mov    %eax,0x8(%esp)
  8108dd:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8108e4:	00 
  8108e5:	89 1c 24             	mov    %ebx,(%esp)
  8108e8:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  8108ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8108ed:	85 c0                	test   %eax,%eax
  8108ef:	75 2b                	jne    81091c <netconn_recv+0x105>
      memp_free(MEMP_NETBUF, buf);
  8108f1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8108f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8108f8:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8108ff:	e8 3d 85 ff ff       	call   808e41 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
        conn->err = ERR_CLSD;
      }
      return NULL;
  810904:	b8 00 00 00 00       	mov    $0x0,%eax

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
      memp_free(MEMP_NETBUF, buf);
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  810909:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  81090d:	0f 85 9a 00 00 00    	jne    8109ad <netconn_recv+0x196>
        conn->err = ERR_CLSD;
  810913:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  810917:	e9 91 00 00 00       	jmp    8109ad <netconn_recv+0x196>
      }
      return NULL;
    }

    buf->p = p;
  81091c:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81091f:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  810921:	8b 45 f4             	mov    -0xc(%ebp),%eax
  810924:	8b 55 f0             	mov    -0x10(%ebp),%edx
  810927:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  81092a:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  810930:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  810937:	c7 45 dc 24 1b 81 00 	movl   $0x811b24,-0x24(%ebp)
    msg.msg.conn = conn;
  81093e:	89 5d e0             	mov    %ebx,-0x20(%ebp)
    if (buf != NULL) {
  810941:	85 c0                	test   %eax,%eax
  810943:	74 0c                	je     810951 <netconn_recv+0x13a>
      msg.msg.msg.r.len = buf->p->tot_len;
  810945:	8b 00                	mov    (%eax),%eax
  810947:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  81094b:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  81094f:	eb 06                	jmp    810957 <netconn_recv+0x140>
    } else {
      msg.msg.msg.r.len = 1;
  810951:	66 c7 45 e4 01 00    	movw   $0x1,-0x1c(%ebp)
    }
    TCPIP_APIMSG(&msg);
  810957:	8d 45 dc             	lea    -0x24(%ebp),%eax
  81095a:	89 04 24             	mov    %eax,(%esp)
  81095d:	e8 72 60 ff ff       	call   8069d4 <tcpip_apimsg>
  810962:	eb 46                	jmp    8109aa <netconn_recv+0x193>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void **)&buf, 0);
  810964:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81096b:	00 
  81096c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  81096f:	89 44 24 04          	mov    %eax,0x4(%esp)
  810973:	89 14 24             	mov    %edx,(%esp)
  810976:	e8 d9 ea ff ff       	call   80f454 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  81097b:	8b 45 f4             	mov    -0xc(%ebp),%eax
  81097e:	85 c0                	test   %eax,%eax
  810980:	74 28                	je     8109aa <netconn_recv+0x193>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  810982:	8b 10                	mov    (%eax),%edx
  810984:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  810988:	66 29 53 20          	sub    %dx,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  81098c:	8b 53 2c             	mov    0x2c(%ebx),%edx
  81098f:	85 d2                	test   %edx,%edx
  810991:	74 17                	je     8109aa <netconn_recv+0x193>
  810993:	8b 00                	mov    (%eax),%eax
  810995:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  810999:	89 44 24 08          	mov    %eax,0x8(%esp)
  81099d:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8109a4:	00 
  8109a5:	89 1c 24             	mov    %ebx,(%esp)
  8109a8:	ff d2                	call   *%edx
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  8109aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  8109ad:	83 c4 34             	add    $0x34,%esp
  8109b0:	5b                   	pop    %ebx
  8109b1:	5d                   	pop    %ebp
  8109b2:	c3                   	ret    

008109b3 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  8109b3:	55                   	push   %ebp
  8109b4:	89 e5                	mov    %esp,%ebp
  8109b6:	53                   	push   %ebx
  8109b7:	83 ec 34             	sub    $0x34,%esp
  8109ba:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  8109bd:	85 db                	test   %ebx,%ebx
  8109bf:	75 1c                	jne    8109dd <netconn_send+0x2a>
  8109c1:	c7 44 24 08 46 6f 81 	movl   $0x816f46,0x8(%esp)
  8109c8:	00 
  8109c9:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  8109d0:	00 
  8109d1:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  8109d8:	e8 db ff fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  8109dd:	c7 45 e4 61 1a 81 00 	movl   $0x811a61,-0x1c(%ebp)
  msg.msg.conn = conn;
  8109e4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  8109e7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8109ea:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  8109ed:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8109f0:	89 04 24             	mov    %eax,(%esp)
  8109f3:	e8 dc 5f ff ff       	call   8069d4 <tcpip_apimsg>
  8109f8:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  8109fc:	83 c4 34             	add    $0x34,%esp
  8109ff:	5b                   	pop    %ebx
  810a00:	5d                   	pop    %ebp
  810a01:	c3                   	ret    

00810a02 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  810a02:	55                   	push   %ebp
  810a03:	89 e5                	mov    %esp,%ebp
  810a05:	83 ec 18             	sub    $0x18,%esp
  810a08:	8b 55 0c             	mov    0xc(%ebp),%edx
  810a0b:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
    buf->addr = addr;
    buf->port = port;
    return netconn_send(conn, buf);
  }
  return ERR_VAL;
  810a0f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  if (buf != NULL) {
  810a14:	85 d2                	test   %edx,%edx
  810a16:	74 19                	je     810a31 <netconn_sendto+0x2f>
    buf->addr = addr;
  810a18:	8b 45 10             	mov    0x10(%ebp),%eax
  810a1b:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  810a1e:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  810a22:	89 54 24 04          	mov    %edx,0x4(%esp)
  810a26:	8b 45 08             	mov    0x8(%ebp),%eax
  810a29:	89 04 24             	mov    %eax,(%esp)
  810a2c:	e8 82 ff ff ff       	call   8109b3 <netconn_send>
  }
  return ERR_VAL;
}
  810a31:	c9                   	leave  
  810a32:	c3                   	ret    

00810a33 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  810a33:	55                   	push   %ebp
  810a34:	89 e5                	mov    %esp,%ebp
  810a36:	53                   	push   %ebx
  810a37:	83 ec 34             	sub    $0x34,%esp
  810a3a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810a3d:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  810a41:	85 db                	test   %ebx,%ebx
  810a43:	75 1c                	jne    810a61 <netconn_write+0x2e>
  810a45:	c7 44 24 08 61 6f 81 	movl   $0x816f61,0x8(%esp)
  810a4c:	00 
  810a4d:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  810a54:	00 
  810a55:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810a5c:	e8 57 ff fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  810a61:	83 3b 10             	cmpl   $0x10,(%ebx)
  810a64:	74 1c                	je     810a82 <netconn_write+0x4f>
  810a66:	c7 44 24 08 dc 6d 81 	movl   $0x816ddc,0x8(%esp)
  810a6d:	00 
  810a6e:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  810a75:	00 
  810a76:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810a7d:	e8 36 ff fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  msg.function = do_write;
  810a82:	c7 45 e4 65 1b 81 00 	movl   $0x811b65,-0x1c(%ebp)
  msg.msg.conn = conn;
  810a89:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  810a8c:	8b 55 0c             	mov    0xc(%ebp),%edx
  810a8f:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  810a92:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  810a95:	8b 45 10             	mov    0x10(%ebp),%eax
  810a98:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  810a9b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810a9e:	89 04 24             	mov    %eax,(%esp)
  810aa1:	e8 2e 5f ff ff       	call   8069d4 <tcpip_apimsg>
  810aa6:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  810aaa:	83 c4 34             	add    $0x34,%esp
  810aad:	5b                   	pop    %ebx
  810aae:	5d                   	pop    %ebp
  810aaf:	c3                   	ret    

00810ab0 <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  810ab0:	55                   	push   %ebp
  810ab1:	89 e5                	mov    %esp,%ebp
  810ab3:	53                   	push   %ebx
  810ab4:	83 ec 34             	sub    $0x34,%esp
  810ab7:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  810aba:	85 db                	test   %ebx,%ebx
  810abc:	75 1c                	jne    810ada <netconn_close+0x2a>
  810abe:	c7 44 24 08 7d 6f 81 	movl   $0x816f7d,0x8(%esp)
  810ac5:	00 
  810ac6:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  810acd:	00 
  810ace:	c7 04 24 fe 6d 81 00 	movl   $0x816dfe,(%esp)
  810ad5:	e8 de fe fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  msg.function = do_close;
  810ada:	c7 45 e4 75 1c 81 00 	movl   $0x811c75,-0x1c(%ebp)
  msg.msg.conn = conn;
  810ae1:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  810ae4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  810ae7:	89 04 24             	mov    %eax,(%esp)
  810aea:	e8 e5 5e ff ff       	call   8069d4 <tcpip_apimsg>
  810aef:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  810af3:	83 c4 34             	add    $0x34,%esp
  810af6:	5b                   	pop    %ebx
  810af7:	5d                   	pop    %ebp
  810af8:	c3                   	ret    
  810af9:	00 00                	add    %al,(%eax)
  810afb:	00 00                	add    %al,(%eax)
  810afd:	00 00                	add    %al,(%eax)
	...

00810b00 <_ZL9setup_tcpP7netconn>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  810b00:	55                   	push   %ebp
  810b01:	89 e5                	mov    %esp,%ebp
  810b03:	53                   	push   %ebx
  810b04:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  810b07:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  810b0a:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b0e:	89 1c 24             	mov    %ebx,(%esp)
  810b11:	e8 7d 98 ff ff       	call   80a393 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  810b16:	c7 44 24 04 de 10 81 	movl   $0x8110de,0x4(%esp)
  810b1d:	00 
  810b1e:	89 1c 24             	mov    %ebx,(%esp)
  810b21:	e8 7b 98 ff ff       	call   80a3a1 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  810b26:	c7 44 24 04 2e 10 81 	movl   $0x81102e,0x4(%esp)
  810b2d:	00 
  810b2e:	89 1c 24             	mov    %ebx,(%esp)
  810b31:	e8 7c 98 ff ff       	call   80a3b2 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  810b36:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  810b3d:	00 
  810b3e:	c7 44 24 04 e0 0f 81 	movl   $0x810fe0,0x4(%esp)
  810b45:	00 
  810b46:	89 1c 24             	mov    %ebx,(%esp)
  810b49:	e8 94 98 ff ff       	call   80a3e2 <tcp_poll>
  tcp_err(pcb, err_tcp);
  810b4e:	c7 44 24 04 a7 0d 81 	movl   $0x810da7,0x4(%esp)
  810b55:	00 
  810b56:	89 1c 24             	mov    %ebx,(%esp)
  810b59:	e8 65 98 ff ff       	call   80a3c3 <tcp_err>
}
  810b5e:	83 c4 14             	add    $0x14,%esp
  810b61:	5b                   	pop    %ebx
  810b62:	5d                   	pop    %ebp
  810b63:	c3                   	ret    

00810b64 <_ZL12do_connectedPvP7tcp_pcba>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  810b64:	55                   	push   %ebp
  810b65:	89 e5                	mov    %esp,%ebp
  810b67:	53                   	push   %ebx
  810b68:	83 ec 14             	sub    $0x14,%esp
  810b6b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810b6e:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *) arg;

  if (conn == NULL) {
    return ERR_VAL;
  810b72:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax

  LWIP_UNUSED_ARG(pcb);

  conn = (struct netconn *) arg;

  if (conn == NULL) {
  810b77:	85 db                	test   %ebx,%ebx
  810b79:	74 2a                	je     810ba5 <_ZL12do_connectedPvP7tcp_pcba+0x41>
    return ERR_VAL;
  }

  conn->err = err;
  810b7b:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  810b7e:	83 3b 10             	cmpl   $0x10,(%ebx)
  810b81:	75 0b                	jne    810b8e <_ZL12do_connectedPvP7tcp_pcba+0x2a>
  810b83:	84 d2                	test   %dl,%dl
  810b85:	75 07                	jne    810b8e <_ZL12do_connectedPvP7tcp_pcba+0x2a>
    setup_tcp(conn);
  810b87:	89 d8                	mov    %ebx,%eax
  810b89:	e8 72 ff ff ff       	call   810b00 <_ZL9setup_tcpP7netconn>
  }
  conn->state = NETCONN_NONE;
  810b8e:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  810b95:	8b 43 10             	mov    0x10(%ebx),%eax
  810b98:	89 04 24             	mov    %eax,(%esp)
  810b9b:	e8 ff e5 ff ff       	call   80f19f <sys_sem_signal>
  return ERR_OK;
  810ba0:	b8 00 00 00 00       	mov    $0x0,%eax
}
  810ba5:	83 c4 14             	add    $0x14,%esp
  810ba8:	5b                   	pop    %ebx
  810ba9:	5d                   	pop    %ebp
  810baa:	c3                   	ret    

00810bab <_ZL17do_close_internalP7netconn>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  810bab:	55                   	push   %ebp
  810bac:	89 e5                	mov    %esp,%ebp
  810bae:	53                   	push   %ebx
  810baf:	83 ec 14             	sub    $0x14,%esp
  810bb2:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  810bb4:	85 c0                	test   %eax,%eax
  810bb6:	75 1c                	jne    810bd4 <_ZL17do_close_internalP7netconn+0x29>
  810bb8:	c7 44 24 08 54 6f 81 	movl   $0x816f54,0x8(%esp)
  810bbf:	00 
  810bc0:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  810bc7:	00 
  810bc8:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810bcf:	e8 e4 fd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  810bd4:	83 38 10             	cmpl   $0x10,(%eax)
  810bd7:	74 1c                	je     810bf5 <_ZL17do_close_internalP7netconn+0x4a>
  810bd9:	c7 44 24 08 b0 6f 81 	movl   $0x816fb0,0x8(%esp)
  810be0:	00 
  810be1:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  810be8:	00 
  810be9:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810bf0:	e8 c3 fd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  810bf5:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  810bf9:	74 1c                	je     810c17 <_ZL17do_close_internalP7netconn+0x6c>
  810bfb:	c7 44 24 08 7c 70 81 	movl   $0x81707c,0x8(%esp)
  810c02:	00 
  810c03:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  810c0a:	00 
  810c0b:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810c12:	e8 a1 fd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  810c17:	8b 40 08             	mov    0x8(%eax),%eax
  810c1a:	85 c0                	test   %eax,%eax
  810c1c:	75 1c                	jne    810c3a <_ZL17do_close_internalP7netconn+0x8f>
  810c1e:	c7 44 24 08 ce 6f 81 	movl   $0x816fce,0x8(%esp)
  810c25:	00 
  810c26:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  810c2d:	00 
  810c2e:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810c35:	e8 7e fd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  810c3a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810c41:	00 
  810c42:	89 04 24             	mov    %eax,(%esp)
  810c45:	e8 49 97 ff ff       	call   80a393 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  810c4a:	8b 43 08             	mov    0x8(%ebx),%eax
  810c4d:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  810c51:	75 12                	jne    810c65 <_ZL17do_close_internalP7netconn+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  810c53:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810c5a:	00 
  810c5b:	89 04 24             	mov    %eax,(%esp)
  810c5e:	e8 71 97 ff ff       	call   80a3d4 <tcp_accept>
  810c63:	eb 64                	jmp    810cc9 <_ZL17do_close_internalP7netconn+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  810c65:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810c6c:	00 
  810c6d:	89 04 24             	mov    %eax,(%esp)
  810c70:	e8 2c 97 ff ff       	call   80a3a1 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  810c75:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810c7c:	00 
  810c7d:	8b 43 08             	mov    0x8(%ebx),%eax
  810c80:	89 04 24             	mov    %eax,(%esp)
  810c83:	e8 4c 97 ff ff       	call   80a3d4 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  810c88:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810c8f:	00 
  810c90:	8b 43 08             	mov    0x8(%ebx),%eax
  810c93:	89 04 24             	mov    %eax,(%esp)
  810c96:	e8 17 97 ff ff       	call   80a3b2 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  810c9b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  810ca2:	00 
  810ca3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810caa:	00 
  810cab:	8b 43 08             	mov    0x8(%ebx),%eax
  810cae:	89 04 24             	mov    %eax,(%esp)
  810cb1:	e8 2c 97 ff ff       	call   80a3e2 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  810cb6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810cbd:	00 
  810cbe:	8b 43 08             	mov    0x8(%ebx),%eax
  810cc1:	89 04 24             	mov    %eax,(%esp)
  810cc4:	e8 fa 96 ff ff       	call   80a3c3 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  810cc9:	8b 43 08             	mov    0x8(%ebx),%eax
  810ccc:	89 04 24             	mov    %eax,(%esp)
  810ccf:	e8 1f 9e ff ff       	call   80aaf3 <tcp_close>
  if (err == ERR_OK) {
  810cd4:	84 c0                	test   %al,%al
  810cd6:	75 57                	jne    810d2f <_ZL17do_close_internalP7netconn+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  810cd8:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  810cdf:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  810ce6:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  810cea:	8b 43 2c             	mov    0x2c(%ebx),%eax
  810ced:	85 c0                	test   %eax,%eax
  810cef:	74 31                	je     810d22 <_ZL17do_close_internalP7netconn+0x177>
  810cf1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810cf8:	00 
  810cf9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810d00:	00 
  810d01:	89 1c 24             	mov    %ebx,(%esp)
  810d04:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  810d06:	8b 43 2c             	mov    0x2c(%ebx),%eax
  810d09:	85 c0                	test   %eax,%eax
  810d0b:	74 15                	je     810d22 <_ZL17do_close_internalP7netconn+0x177>
  810d0d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810d14:	00 
  810d15:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  810d1c:	00 
  810d1d:	89 1c 24             	mov    %ebx,(%esp)
  810d20:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  810d22:	8b 43 10             	mov    0x10(%ebx),%eax
  810d25:	89 04 24             	mov    %eax,(%esp)
  810d28:	e8 72 e4 ff ff       	call   80f19f <sys_sem_signal>
  810d2d:	eb 72                	jmp    810da1 <_ZL17do_close_internalP7netconn+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  810d2f:	8b 43 08             	mov    0x8(%ebx),%eax
  810d32:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  810d36:	75 1c                	jne    810d54 <_ZL17do_close_internalP7netconn+0x1a9>
  810d38:	c7 44 24 08 a0 70 81 	movl   $0x8170a0,0x8(%esp)
  810d3f:	00 
  810d40:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  810d47:	00 
  810d48:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810d4f:	e8 64 fc fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  810d54:	c7 44 24 04 2e 10 81 	movl   $0x81102e,0x4(%esp)
  810d5b:	00 
  810d5c:	89 04 24             	mov    %eax,(%esp)
  810d5f:	e8 4e 96 ff ff       	call   80a3b2 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  810d64:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  810d6b:	00 
  810d6c:	c7 44 24 04 e0 0f 81 	movl   $0x810fe0,0x4(%esp)
  810d73:	00 
  810d74:	8b 43 08             	mov    0x8(%ebx),%eax
  810d77:	89 04 24             	mov    %eax,(%esp)
  810d7a:	e8 63 96 ff ff       	call   80a3e2 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  810d7f:	c7 44 24 04 a7 0d 81 	movl   $0x810da7,0x4(%esp)
  810d86:	00 
  810d87:	8b 43 08             	mov    0x8(%ebx),%eax
  810d8a:	89 04 24             	mov    %eax,(%esp)
  810d8d:	e8 31 96 ff ff       	call   80a3c3 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  810d92:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  810d96:	8b 43 08             	mov    0x8(%ebx),%eax
  810d99:	89 04 24             	mov    %eax,(%esp)
  810d9c:	e8 f2 95 ff ff       	call   80a393 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  810da1:	83 c4 14             	add    $0x14,%esp
  810da4:	5b                   	pop    %ebx
  810da5:	5d                   	pop    %ebp
  810da6:	c3                   	ret    

00810da7 <_ZL7err_tcpPva>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  810da7:	55                   	push   %ebp
  810da8:	89 e5                	mov    %esp,%ebp
  810daa:	53                   	push   %ebx
  810dab:	83 ec 14             	sub    $0x14,%esp
  810dae:	8b 5d 08             	mov    0x8(%ebp),%ebx
  810db1:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = (struct netconn *) arg;
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  810db5:	85 db                	test   %ebx,%ebx
  810db7:	75 1c                	jne    810dd5 <_ZL7err_tcpPva+0x2e>
  810db9:	c7 44 24 08 e1 6f 81 	movl   $0x816fe1,0x8(%esp)
  810dc0:	00 
  810dc1:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  810dc8:	00 
  810dc9:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810dd0:	e8 e3 fb fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  conn->pcb.tcp = NULL;
  810dd5:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  810ddc:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  810ddf:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  810de3:	74 2f                	je     810e14 <_ZL7err_tcpPva+0x6d>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  810de5:	8b 43 2c             	mov    0x2c(%ebx),%eax
  810de8:	85 c0                	test   %eax,%eax
  810dea:	74 15                	je     810e01 <_ZL7err_tcpPva+0x5a>
  810dec:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810df3:	00 
  810df4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810dfb:	00 
  810dfc:	89 1c 24             	mov    %ebx,(%esp)
  810dff:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  810e01:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810e08:	00 
  810e09:	8b 43 14             	mov    0x14(%ebx),%eax
  810e0c:	89 04 24             	mov    %eax,(%esp)
  810e0f:	e8 fe e5 ff ff       	call   80f412 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  810e14:	8b 43 10             	mov    0x10(%ebx),%eax
  810e17:	83 f8 ff             	cmp    $0xffffffff,%eax
  810e1a:	74 15                	je     810e31 <_ZL7err_tcpPva+0x8a>
  810e1c:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  810e20:	75 0f                	jne    810e31 <_ZL7err_tcpPva+0x8a>
    conn->state = NETCONN_NONE;
  810e22:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  810e29:	89 04 24             	mov    %eax,(%esp)
  810e2c:	e8 6e e3 ff ff       	call   80f19f <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  810e31:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  810e35:	74 2f                	je     810e66 <_ZL7err_tcpPva+0xbf>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  810e37:	8b 43 2c             	mov    0x2c(%ebx),%eax
  810e3a:	85 c0                	test   %eax,%eax
  810e3c:	74 15                	je     810e53 <_ZL7err_tcpPva+0xac>
  810e3e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  810e45:	00 
  810e46:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810e4d:	00 
  810e4e:	89 1c 24             	mov    %ebx,(%esp)
  810e51:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  810e53:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  810e5a:	00 
  810e5b:	8b 43 18             	mov    0x18(%ebx),%eax
  810e5e:	89 04 24             	mov    %eax,(%esp)
  810e61:	e8 ac e5 ff ff       	call   80f412 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  810e66:	8b 43 04             	mov    0x4(%ebx),%eax
  810e69:	83 f8 01             	cmp    $0x1,%eax
  810e6c:	74 05                	je     810e73 <_ZL7err_tcpPva+0xcc>
  810e6e:	83 f8 04             	cmp    $0x4,%eax
  810e71:	75 12                	jne    810e85 <_ZL7err_tcpPva+0xde>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  810e73:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  810e7a:	8b 43 10             	mov    0x10(%ebx),%eax
  810e7d:	89 04 24             	mov    %eax,(%esp)
  810e80:	e8 1a e3 ff ff       	call   80f19f <sys_sem_signal>
  }
}
  810e85:	83 c4 14             	add    $0x14,%esp
  810e88:	5b                   	pop    %ebx
  810e89:	5d                   	pop    %ebp
  810e8a:	c3                   	ret    

00810e8b <_ZL12do_writemoreP7netconn>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  810e8b:	55                   	push   %ebp
  810e8c:	89 e5                	mov    %esp,%ebp
  810e8e:	57                   	push   %edi
  810e8f:	56                   	push   %esi
  810e90:	53                   	push   %ebx
  810e91:	83 ec 1c             	sub    $0x1c,%esp
  810e94:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  810e96:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  810e9a:	74 1c                	je     810eb8 <_ZL12do_writemoreP7netconn+0x2d>
  810e9c:	c7 44 24 08 ee 6f 81 	movl   $0x816fee,0x8(%esp)
  810ea3:	00 
  810ea4:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  810eab:	00 
  810eac:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810eb3:	e8 00 fb fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  810eb8:	8b 40 24             	mov    0x24(%eax),%eax
  810ebb:	8b 53 28             	mov    0x28(%ebx),%edx
  810ebe:	89 d1                	mov    %edx,%ecx
  810ec0:	03 48 04             	add    0x4(%eax),%ecx
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  810ec3:	8b 70 08             	mov    0x8(%eax),%esi
  810ec6:	89 f7                	mov    %esi,%edi
  810ec8:	29 d7                	sub    %edx,%edi
    len = 0xffff;
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  810eca:	66 29 d6             	sub    %dx,%si
  810ecd:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  810ed3:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  810ed8:	0f 4f f2             	cmovg  %edx,%esi
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  810edb:	8b 53 08             	mov    0x8(%ebx),%edx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  810ede:	0f b7 7a 6e          	movzwl 0x6e(%edx),%edi
  810ee2:	66 39 fe             	cmp    %di,%si
  810ee5:	0f 47 f7             	cmova  %edi,%esi
  810ee8:	0f b7 f6             	movzwl %si,%esi
  810eeb:	0f b6 40 0c          	movzbl 0xc(%eax),%eax
  810eef:	89 44 24 0c          	mov    %eax,0xc(%esp)
  810ef3:	89 74 24 08          	mov    %esi,0x8(%esp)
  810ef7:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  810efb:	89 14 24             	mov    %edx,(%esp)
  810efe:	e8 3a be ff ff       	call   80cd3d <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  810f03:	89 f2                	mov    %esi,%edx
  810f05:	03 53 28             	add    0x28(%ebx),%edx
  810f08:	8b 4b 24             	mov    0x24(%ebx),%ecx
  810f0b:	3b 51 08             	cmp    0x8(%ecx),%edx
  810f0e:	7e 1c                	jle    810f2c <_ZL12do_writemoreP7netconn+0xa1>
  810f10:	c7 44 24 08 0b 70 81 	movl   $0x81700b,0x8(%esp)
  810f17:	00 
  810f18:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  810f1f:	00 
  810f20:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  810f27:	e8 8c fa fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  if (err == ERR_OK) {
  810f2c:	84 c0                	test   %al,%al
  810f2e:	75 6f                	jne    810f9f <_ZL12do_writemoreP7netconn+0x114>
    conn->write_offset += len;
  810f30:	89 53 28             	mov    %edx,0x28(%ebx)
do_writemore(struct netconn *conn)
{
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;
  810f33:	bf 00 00 00 00       	mov    $0x0,%edi

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  810f38:	3b 51 08             	cmp    0x8(%ecx),%edx
  810f3b:	75 13                	jne    810f50 <_ZL12do_writemoreP7netconn+0xc5>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  810f3d:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  810f44:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  if (err == ERR_OK) {
    conn->write_offset += len;
    if (conn->write_offset == conn->write_msg->msg.w.len) {
      /* everything was written */
      write_finished = 1;
  810f4b:	bf 01 00 00 00       	mov    $0x1,%edi
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  810f50:	8b 43 08             	mov    0x8(%ebx),%eax
  810f53:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  810f57:	74 12                	je     810f6b <_ZL12do_writemoreP7netconn+0xe0>
  810f59:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  810f5d:	75 0c                	jne    810f6b <_ZL12do_writemoreP7netconn+0xe0>
  810f5f:	8b 50 74             	mov    0x74(%eax),%edx
  810f62:	85 d2                	test   %edx,%edx
  810f64:	74 74                	je     810fda <_ZL12do_writemoreP7netconn+0x14f>
  810f66:	83 3a 00             	cmpl   $0x0,(%edx)
  810f69:	74 6f                	je     810fda <_ZL12do_writemoreP7netconn+0x14f>
  810f6b:	89 04 24             	mov    %eax,(%esp)
  810f6e:	e8 82 be ff ff       	call   80cdf5 <tcp_output>
    conn->err = err;
  810f73:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  810f76:	84 c0                	test   %al,%al
  810f78:	75 3b                	jne    810fb5 <_ZL12do_writemoreP7netconn+0x12a>
  810f7a:	8b 43 08             	mov    0x8(%ebx),%eax
  810f7d:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  810f83:	77 30                	ja     810fb5 <_ZL12do_writemoreP7netconn+0x12a>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  810f85:	8b 43 2c             	mov    0x2c(%ebx),%eax
  810f88:	85 c0                	test   %eax,%eax
  810f8a:	74 29                	je     810fb5 <_ZL12do_writemoreP7netconn+0x12a>
  810f8c:	89 74 24 08          	mov    %esi,0x8(%esp)
  810f90:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  810f97:	00 
  810f98:	89 1c 24             	mov    %ebx,(%esp)
  810f9b:	ff d0                	call   *%eax
  810f9d:	eb 16                	jmp    810fb5 <_ZL12do_writemoreP7netconn+0x12a>
    }
  } else if (err == ERR_MEM) {
  810f9f:	3c ff                	cmp    $0xff,%al
  810fa1:	75 0d                	jne    810fb0 <_ZL12do_writemoreP7netconn+0x125>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  810fa3:	8b 43 08             	mov    0x8(%ebx),%eax
  810fa6:	89 04 24             	mov    %eax,(%esp)
  810fa9:	e8 47 be ff ff       	call   80cdf5 <tcp_output>
  810fae:	eb 1d                	jmp    810fcd <_ZL12do_writemoreP7netconn+0x142>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  810fb0:	88 43 0c             	mov    %al,0xc(%ebx)
  810fb3:	eb 06                	jmp    810fbb <_ZL12do_writemoreP7netconn+0x130>
    write_finished = 1;
  }

  if (write_finished) {
  810fb5:	89 f8                	mov    %edi,%eax
  810fb7:	84 c0                	test   %al,%al
  810fb9:	74 12                	je     810fcd <_ZL12do_writemoreP7netconn+0x142>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  810fbb:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  810fc2:	8b 43 10             	mov    0x10(%ebx),%eax
  810fc5:	89 04 24             	mov    %eax,(%esp)
  810fc8:	e8 d2 e1 ff ff       	call   80f19f <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  810fcd:	b8 00 00 00 00       	mov    $0x0,%eax
  810fd2:	83 c4 1c             	add    $0x1c,%esp
  810fd5:	5b                   	pop    %ebx
  810fd6:	5e                   	pop    %esi
  810fd7:	5f                   	pop    %edi
  810fd8:	5d                   	pop    %ebp
  810fd9:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  810fda:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  810fde:	eb 9a                	jmp    810f7a <_ZL12do_writemoreP7netconn+0xef>

00810fe0 <_ZL8poll_tcpPvP7tcp_pcb>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  810fe0:	55                   	push   %ebp
  810fe1:	89 e5                	mov    %esp,%ebp
  810fe3:	83 ec 18             	sub    $0x18,%esp
  810fe6:	8b 45 08             	mov    0x8(%ebp),%eax
  struct netconn *conn = (struct netconn *) arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  810fe9:	85 c0                	test   %eax,%eax
  810feb:	75 1c                	jne    811009 <_ZL8poll_tcpPvP7tcp_pcb+0x29>
  810fed:	c7 44 24 08 e1 6f 81 	movl   $0x816fe1,0x8(%esp)
  810ff4:	00 
  810ff5:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  810ffc:	00 
  810ffd:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811004:	e8 af f9 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  if (conn->state == NETCONN_WRITE) {
  811009:	8b 50 04             	mov    0x4(%eax),%edx
  81100c:	83 fa 01             	cmp    $0x1,%edx
  81100f:	75 07                	jne    811018 <_ZL8poll_tcpPvP7tcp_pcb+0x38>
    do_writemore(conn);
  811011:	e8 75 fe ff ff       	call   810e8b <_ZL12do_writemoreP7netconn>
  811016:	eb 0f                	jmp    811027 <_ZL8poll_tcpPvP7tcp_pcb+0x47>
  } else if (conn->state == NETCONN_CLOSE) {
  811018:	83 fa 04             	cmp    $0x4,%edx
  81101b:	90                   	nop
  81101c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  811020:	75 05                	jne    811027 <_ZL8poll_tcpPvP7tcp_pcb+0x47>
    do_close_internal(conn);
  811022:	e8 84 fb ff ff       	call   810bab <_ZL17do_close_internalP7netconn>
  }

  return ERR_OK;
}
  811027:	b8 00 00 00 00       	mov    $0x0,%eax
  81102c:	c9                   	leave  
  81102d:	c3                   	ret    

0081102e <_ZL8sent_tcpPvP7tcp_pcbt>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  81102e:	55                   	push   %ebp
  81102f:	89 e5                	mov    %esp,%ebp
  811031:	83 ec 18             	sub    $0x18,%esp
  811034:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  811037:	89 75 fc             	mov    %esi,-0x4(%ebp)
  81103a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  81103d:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = (struct netconn *) arg;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  811041:	85 db                	test   %ebx,%ebx
  811043:	75 1c                	jne    811061 <_ZL8sent_tcpPvP7tcp_pcbt+0x33>
  811045:	c7 44 24 08 e1 6f 81 	movl   $0x816fe1,0x8(%esp)
  81104c:	00 
  81104d:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  811054:	00 
  811055:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  81105c:	e8 57 f9 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  if (conn->state == NETCONN_WRITE) {
  811061:	8b 43 04             	mov    0x4(%ebx),%eax
  811064:	83 f8 01             	cmp    $0x1,%eax
  811067:	75 2b                	jne    811094 <_ZL8sent_tcpPvP7tcp_pcbt+0x66>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  811069:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  81106d:	75 1c                	jne    81108b <_ZL8sent_tcpPvP7tcp_pcbt+0x5d>
  81106f:	c7 44 24 08 29 70 81 	movl   $0x817029,0x8(%esp)
  811076:	00 
  811077:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  81107e:	00 
  81107f:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811086:	e8 2d f9 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
    do_writemore(conn);
  81108b:	89 d8                	mov    %ebx,%eax
  81108d:	e8 f9 fd ff ff       	call   810e8b <_ZL12do_writemoreP7netconn>
  811092:	eb 11                	jmp    8110a5 <_ZL8sent_tcpPvP7tcp_pcbt+0x77>
  } else if (conn->state == NETCONN_CLOSE) {
  811094:	83 f8 04             	cmp    $0x4,%eax
  811097:	75 0c                	jne    8110a5 <_ZL8sent_tcpPvP7tcp_pcbt+0x77>
    do_close_internal(conn);
  811099:	89 d8                	mov    %ebx,%eax
  81109b:	90                   	nop
  81109c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8110a0:	e8 06 fb ff ff       	call   810bab <_ZL17do_close_internalP7netconn>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  8110a5:	8b 43 08             	mov    0x8(%ebx),%eax
  8110a8:	85 c0                	test   %eax,%eax
  8110aa:	74 23                	je     8110cf <_ZL8sent_tcpPvP7tcp_pcbt+0xa1>
  8110ac:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  8110b2:	76 1b                	jbe    8110cf <_ZL8sent_tcpPvP7tcp_pcbt+0xa1>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  8110b4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8110b7:	85 c0                	test   %eax,%eax
  8110b9:	74 14                	je     8110cf <_ZL8sent_tcpPvP7tcp_pcbt+0xa1>
  8110bb:	0f b7 f6             	movzwl %si,%esi
  8110be:	89 74 24 08          	mov    %esi,0x8(%esp)
  8110c2:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8110c9:	00 
  8110ca:	89 1c 24             	mov    %ebx,(%esp)
  8110cd:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  8110cf:	b8 00 00 00 00       	mov    $0x0,%eax
  8110d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8110d7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8110da:	89 ec                	mov    %ebp,%esp
  8110dc:	5d                   	pop    %ebp
  8110dd:	c3                   	ret    

008110de <_ZL8recv_tcpPvP7tcp_pcbP4pbufa>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  8110de:	55                   	push   %ebp
  8110df:	89 e5                	mov    %esp,%ebp
  8110e1:	83 ec 18             	sub    $0x18,%esp
  8110e4:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8110e7:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8110ea:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8110ed:	8b 45 0c             	mov    0xc(%ebp),%eax
  8110f0:	8b 75 10             	mov    0x10(%ebp),%esi
  8110f3:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  8110f7:	85 c0                	test   %eax,%eax
  8110f9:	75 1c                	jne    811117 <_ZL8recv_tcpPvP7tcp_pcbP4pbufa+0x39>
  8110fb:	c7 44 24 08 c4 70 81 	movl   $0x8170c4,0x8(%esp)
  811102:	00 
  811103:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  81110a:	00 
  81110b:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811112:	e8 a1 f8 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  811117:	85 db                	test   %ebx,%ebx
  811119:	75 1c                	jne    811137 <_ZL8recv_tcpPvP7tcp_pcbP4pbufa+0x59>
  81111b:	c7 44 24 08 e8 70 81 	movl   $0x8170e8,0x8(%esp)
  811122:	00 
  811123:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  81112a:	00 
  81112b:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811132:	e8 81 f8 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  conn = (struct netconn *) arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  811137:	39 43 08             	cmp    %eax,0x8(%ebx)
  81113a:	74 1c                	je     811158 <_ZL8recv_tcpPvP7tcp_pcbP4pbufa+0x7a>
  81113c:	c7 44 24 08 3f 70 81 	movl   $0x81703f,0x8(%esp)
  811143:	00 
  811144:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  81114b:	00 
  81114c:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811153:	e8 60 f8 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  811158:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  conn = (struct netconn *) arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  81115d:	85 db                	test   %ebx,%ebx
  81115f:	74 4a                	je     8111ab <_ZL8recv_tcpPvP7tcp_pcbP4pbufa+0xcd>
  811161:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  811165:	74 44                	je     8111ab <_ZL8recv_tcpPvP7tcp_pcbP4pbufa+0xcd>
    return ERR_VAL;
  }

  conn->err = err;
  811167:	88 4b 0c             	mov    %cl,0xc(%ebx)
  if (p != NULL) {
    len = p->tot_len;
    SYS_ARCH_INC(conn->recv_avail, len);
  } else {
    len = 0;
  81116a:	b8 00 00 00 00       	mov    $0x0,%eax
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
    return ERR_VAL;
  }

  conn->err = err;
  if (p != NULL) {
  81116f:	85 f6                	test   %esi,%esi
  811171:	74 08                	je     81117b <_ZL8recv_tcpPvP7tcp_pcbP4pbufa+0x9d>
    len = p->tot_len;
  811173:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  811177:	66 01 43 20          	add    %ax,0x20(%ebx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  81117b:	8b 53 2c             	mov    0x2c(%ebx),%edx
  81117e:	85 d2                	test   %edx,%edx
  811180:	74 14                	je     811196 <_ZL8recv_tcpPvP7tcp_pcbP4pbufa+0xb8>
  811182:	0f b7 c0             	movzwl %ax,%eax
  811185:	89 44 24 08          	mov    %eax,0x8(%esp)
  811189:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811190:	00 
  811191:	89 1c 24             	mov    %ebx,(%esp)
  811194:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  811196:	89 74 24 04          	mov    %esi,0x4(%esp)
  81119a:	8b 43 14             	mov    0x14(%ebx),%eax
  81119d:	89 04 24             	mov    %eax,(%esp)
  8111a0:	e8 a5 e1 ff ff       	call   80f34a <sys_mbox_trypost>
    return ERR_MEM;
  8111a5:	3c 01                	cmp    $0x1,%al
  8111a7:	19 c0                	sbb    %eax,%eax
  8111a9:	f7 d0                	not    %eax
  }

  return ERR_OK;
}
  8111ab:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8111ae:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8111b1:	89 ec                	mov    %ebp,%esp
  8111b3:	5d                   	pop    %ebp
  8111b4:	c3                   	ret    

008111b5 <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  8111b5:	55                   	push   %ebp
  8111b6:	89 e5                	mov    %esp,%ebp
  8111b8:	83 ec 38             	sub    $0x38,%esp
  8111bb:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8111be:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8111c1:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8111c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8111c7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8111ca:	8b 7d 10             	mov    0x10(%ebp),%edi
  8111cd:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  8111d1:	66 89 55 e2          	mov    %dx,-0x1e(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  8111d5:	85 c0                	test   %eax,%eax
  8111d7:	75 1c                	jne    8111f5 <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x40>
  8111d9:	c7 44 24 08 08 71 81 	movl   $0x817108,0x8(%esp)
  8111e0:	00 
  8111e1:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  8111e8:	00 
  8111e9:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  8111f0:	e8 c3 f7 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  8111f5:	85 db                	test   %ebx,%ebx
  8111f7:	75 1c                	jne    811215 <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x60>
  8111f9:	c7 44 24 08 2c 71 81 	movl   $0x81712c,0x8(%esp)
  811200:	00 
  811201:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  811208:	00 
  811209:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811210:	e8 a3 f7 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  conn = (struct netconn *) arg;
  811215:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  811218:	39 43 08             	cmp    %eax,0x8(%ebx)
  81121b:	74 1c                	je     811239 <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x84>
  81121d:	c7 44 24 08 5d 70 81 	movl   $0x81705d,0x8(%esp)
  811224:	00 
  811225:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  81122c:	00 
  81122d:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811234:	e8 7f f7 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  811239:	85 db                	test   %ebx,%ebx
  81123b:	74 06                	je     811243 <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x8e>
  81123d:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  811241:	75 0a                	jne    81124d <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x98>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  811243:	89 3c 24             	mov    %edi,(%esp)
  811246:	e8 b8 7f ff ff       	call   809203 <pbuf_free>
    return;
  81124b:	eb 71                	jmp    8112be <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x109>
  }

  buf = (struct netbuf *) memp_malloc(MEMP_NETBUF);
  81124d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  811254:	e8 88 7b ff ff       	call   808de1 <memp_malloc>
  811259:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  81125b:	85 c0                	test   %eax,%eax
  81125d:	75 0a                	jne    811269 <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0xb4>
    pbuf_free(p);
  81125f:	89 3c 24             	mov    %edi,(%esp)
  811262:	e8 9c 7f ff ff       	call   809203 <pbuf_free>
    return;
  811267:	eb 55                	jmp    8112be <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x109>
  } else {
    buf->p = p;
  811269:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  81126b:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  81126e:	8b 45 14             	mov    0x14(%ebp),%eax
  811271:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  811274:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  811278:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  81127c:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  811280:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811283:	66 01 42 20          	add    %ax,0x20(%edx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  811287:	8b 43 2c             	mov    0x2c(%ebx),%eax
  81128a:	85 c0                	test   %eax,%eax
  81128c:	74 15                	je     8112a3 <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0xee>
  81128e:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  811292:	89 54 24 08          	mov    %edx,0x8(%esp)
  811296:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81129d:	00 
  81129e:	89 1c 24             	mov    %ebx,(%esp)
  8112a1:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  8112a3:	89 74 24 04          	mov    %esi,0x4(%esp)
  8112a7:	8b 43 14             	mov    0x14(%ebx),%eax
  8112aa:	89 04 24             	mov    %eax,(%esp)
  8112ad:	e8 98 e0 ff ff       	call   80f34a <sys_mbox_trypost>
  8112b2:	84 c0                	test   %al,%al
  8112b4:	74 08                	je     8112be <_ZL8recv_udpPvP7udp_pcbP4pbufP7ip_addrt+0x109>
    netbuf_delete(buf);
  8112b6:	89 34 24             	mov    %esi,(%esp)
  8112b9:	e8 36 58 ff ff       	call   806af4 <netbuf_delete>
    return;
  }
}
  8112be:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8112c1:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8112c4:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8112c7:	89 ec                	mov    %ebp,%esp
  8112c9:	5d                   	pop    %ebp
  8112ca:	c3                   	ret    

008112cb <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  8112cb:	55                   	push   %ebp
  8112cc:	89 e5                	mov    %esp,%ebp
  8112ce:	83 ec 38             	sub    $0x38,%esp
  8112d1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8112d4:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8112d7:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8112da:	8b 75 08             	mov    0x8(%ebp),%esi
  8112dd:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = (struct netconn *)arg;
  8112e0:	89 75 e4             	mov    %esi,-0x1c(%ebp)
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  8112e3:	85 f6                	test   %esi,%esi
  8112e5:	0f 84 b3 00 00 00    	je     81139e <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xd3>
  8112eb:	83 7e 14 ff          	cmpl   $0xffffffff,0x14(%esi)
  8112ef:	0f 84 a9 00 00 00    	je     81139e <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xd3>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  8112f5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8112fc:	00 
  8112fd:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  811301:	89 44 24 04          	mov    %eax,0x4(%esp)
  811305:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  81130c:	e8 14 81 ff ff       	call   809425 <pbuf_alloc>
  811311:	89 c3                	mov    %eax,%ebx
    if(q != NULL) {
  811313:	85 c0                	test   %eax,%eax
  811315:	0f 84 83 00 00 00    	je     81139e <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xd3>
      if (pbuf_copy(q, p) != ERR_OK) {
  81131b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81131f:	89 04 24             	mov    %eax,(%esp)
  811322:	e8 58 85 ff ff       	call   80987f <pbuf_copy>
  811327:	84 c0                	test   %al,%al
  811329:	0f 84 81 00 00 00    	je     8113b0 <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xe5>
        pbuf_free(q);
  81132f:	89 1c 24             	mov    %ebx,(%esp)
  811332:	e8 cc 7e ff ff       	call   809203 <pbuf_free>
  811337:	eb 65                	jmp    81139e <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xd3>
    }

    if(q != NULL) {
      buf =  (struct netbuf *) memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  811339:	89 1c 24             	mov    %ebx,(%esp)
  81133c:	e8 c2 7e ff ff       	call   809203 <pbuf_free>
        return 0;
  811341:	eb 5b                	jmp    81139e <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xd3>
      }

      buf->p = q;
  811343:	89 1f                	mov    %ebx,(%edi)
      buf->ptr = q;
  811345:	89 5f 04             	mov    %ebx,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  811348:	8b 43 04             	mov    0x4(%ebx),%eax
  81134b:	83 c0 0c             	add    $0xc,%eax
  81134e:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  811351:	8b 45 0c             	mov    0xc(%ebp),%eax
  811354:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  811358:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  81135c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  811360:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811363:	66 01 42 20          	add    %ax,0x20(%edx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  811367:	8b 46 2c             	mov    0x2c(%esi),%eax
  81136a:	85 c0                	test   %eax,%eax
  81136c:	74 15                	je     811383 <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xb8>
  81136e:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  811372:	89 54 24 08          	mov    %edx,0x8(%esp)
  811376:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81137d:	00 
  81137e:	89 34 24             	mov    %esi,(%esp)
  811381:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  811383:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811387:	8b 46 14             	mov    0x14(%esi),%eax
  81138a:	89 04 24             	mov    %eax,(%esp)
  81138d:	e8 b8 df ff ff       	call   80f34a <sys_mbox_trypost>
  811392:	84 c0                	test   %al,%al
  811394:	74 08                	je     81139e <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0xd3>
        netbuf_delete(buf);
  811396:	89 3c 24             	mov    %edi,(%esp)
  811399:	e8 56 57 ff ff       	call   806af4 <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  81139e:	b8 00 00 00 00       	mov    $0x0,%eax
  8113a3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8113a6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8113a9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8113ac:	89 ec                	mov    %ebp,%esp
  8113ae:	5d                   	pop    %ebp
  8113af:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf =  (struct netbuf *) memp_malloc(MEMP_NETBUF);
  8113b0:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8113b7:	e8 25 7a ff ff       	call   808de1 <memp_malloc>
  8113bc:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  8113be:	85 c0                	test   %eax,%eax
  8113c0:	75 81                	jne    811343 <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0x78>
  8113c2:	e9 72 ff ff ff       	jmp    811339 <_ZL8recv_rawPvP7raw_pcbP4pbufP7ip_addr+0x6e>

008113c7 <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  8113c7:	55                   	push   %ebp
  8113c8:	89 e5                	mov    %esp,%ebp
  8113ca:	83 ec 18             	sub    $0x18,%esp
  8113cd:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8113d0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8113d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  8113d6:	8b 03                	mov    (%ebx),%eax
  8113d8:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  8113dc:	0f 85 d4 00 00 00    	jne    8114b6 <do_newconn+0xef>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  8113e2:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  8113e6:	8b 33                	mov    (%ebx),%esi
  8113e8:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  8113ec:	74 1c                	je     81140a <do_newconn+0x43>
  8113ee:	c7 44 24 08 4c 71 81 	movl   $0x81714c,0x8(%esp)
  8113f5:	00 
  8113f6:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  8113fd:	00 
  8113fe:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  811405:	e8 ae f5 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  81140a:	8b 06                	mov    (%esi),%eax
  81140c:	25 f0 00 00 00       	and    $0xf0,%eax
  811411:	83 f8 20             	cmp    $0x20,%eax
  811414:	74 44                	je     81145a <do_newconn+0x93>
  811416:	83 f8 40             	cmp    $0x40,%eax
  811419:	74 0b                	je     811426 <do_newconn+0x5f>
  81141b:	83 f8 10             	cmp    $0x10,%eax
  81141e:	0f 85 8e 00 00 00    	jne    8114b2 <do_newconn+0xeb>
  811424:	eb 6f                	jmp    811495 <do_newconn+0xce>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  811426:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  81142a:	89 04 24             	mov    %eax,(%esp)
  81142d:	e8 0b 26 00 00       	call   813a3d <raw_new>
  811432:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  811435:	8b 03                	mov    (%ebx),%eax
  811437:	8b 50 08             	mov    0x8(%eax),%edx
  81143a:	85 d2                	test   %edx,%edx
  81143c:	75 06                	jne    811444 <do_newconn+0x7d>
       msg->conn->err = ERR_MEM;
  81143e:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  811442:	eb 72                	jmp    8114b6 <do_newconn+0xef>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  811444:	89 44 24 08          	mov    %eax,0x8(%esp)
  811448:	c7 44 24 04 cb 12 81 	movl   $0x8112cb,0x4(%esp)
  81144f:	00 
  811450:	89 14 24             	mov    %edx,(%esp)
  811453:	e8 5a 24 00 00       	call   8138b2 <raw_recv>
  811458:	eb 5c                	jmp    8114b6 <do_newconn+0xef>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  81145a:	e8 9b ca ff ff       	call   80defa <udp_new>
  81145f:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  811462:	8b 03                	mov    (%ebx),%eax
  811464:	8b 50 08             	mov    0x8(%eax),%edx
  811467:	85 d2                	test   %edx,%edx
  811469:	75 06                	jne    811471 <do_newconn+0xaa>
       msg->conn->err = ERR_MEM;
  81146b:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  81146f:	eb 45                	jmp    8114b6 <do_newconn+0xef>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  811471:	83 38 22             	cmpl   $0x22,(%eax)
  811474:	75 04                	jne    81147a <do_newconn+0xb3>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  811476:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  81147a:	8b 03                	mov    (%ebx),%eax
  81147c:	89 44 24 08          	mov    %eax,0x8(%esp)
  811480:	c7 44 24 04 b5 11 81 	movl   $0x8111b5,0x4(%esp)
  811487:	00 
  811488:	8b 40 08             	mov    0x8(%eax),%eax
  81148b:	89 04 24             	mov    %eax,(%esp)
  81148e:	e8 07 ca ff ff       	call   80de9a <udp_recv>
  811493:	eb 21                	jmp    8114b6 <do_newconn+0xef>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  811495:	e8 87 99 ff ff       	call   80ae21 <tcp_new>
  81149a:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  81149d:	8b 03                	mov    (%ebx),%eax
  81149f:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  8114a3:	75 06                	jne    8114ab <do_newconn+0xe4>
       msg->conn->err = ERR_MEM;
  8114a5:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  8114a9:	eb 0b                	jmp    8114b6 <do_newconn+0xef>
       break;
     }
     setup_tcp(msg->conn);
  8114ab:	e8 50 f6 ff ff       	call   810b00 <_ZL9setup_tcpP7netconn>
  8114b0:	eb 04                	jmp    8114b6 <do_newconn+0xef>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  8114b2:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  8114b6:	8b 03                	mov    (%ebx),%eax
  8114b8:	8b 40 10             	mov    0x10(%eax),%eax
  8114bb:	89 04 24             	mov    %eax,(%esp)
  8114be:	e8 dc dc ff ff       	call   80f19f <sys_sem_signal>
}
  8114c3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8114c6:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8114c9:	89 ec                	mov    %ebp,%esp
  8114cb:	5d                   	pop    %ebp
  8114cc:	c3                   	ret    

008114cd <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  8114cd:	55                   	push   %ebp
  8114ce:	89 e5                	mov    %esp,%ebp
  8114d0:	53                   	push   %ebx
  8114d1:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = (struct netconn *) memp_malloc(MEMP_NETCONN);
  8114d4:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  8114db:	e8 01 79 ff ff       	call   808de1 <memp_malloc>
  8114e0:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  8114e2:	85 c0                	test   %eax,%eax
  8114e4:	0f 84 92 00 00 00    	je     81157c <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  8114ea:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  8114ee:	8b 45 08             	mov    0x8(%ebp),%eax
  8114f1:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  8114f3:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  8114fa:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811501:	e8 d8 d8 ff ff       	call   80edde <sys_sem_new>
  811506:	89 43 10             	mov    %eax,0x10(%ebx)
  811509:	83 f8 ff             	cmp    $0xffffffff,%eax
  81150c:	75 17                	jne    811525 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  81150e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811512:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  811519:	e8 23 79 ff ff       	call   808e41 <memp_free>
    return NULL;
  81151e:	bb 00 00 00 00       	mov    $0x0,%ebx
  811523:	eb 57                	jmp    81157c <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  811525:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  81152c:	e8 0b db ff ff       	call   80f03c <sys_mbox_new>
  811531:	89 43 14             	mov    %eax,0x14(%ebx)
  811534:	83 f8 ff             	cmp    $0xffffffff,%eax
  811537:	75 22                	jne    81155b <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  811539:	8b 43 10             	mov    0x10(%ebx),%eax
  81153c:	89 04 24             	mov    %eax,(%esp)
  81153f:	e8 5d d9 ff ff       	call   80eea1 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  811544:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811548:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  81154f:	e8 ed 78 ff ff       	call   808e41 <memp_free>
    return NULL;
  811554:	bb 00 00 00 00       	mov    $0x0,%ebx
  811559:	eb 21                	jmp    81157c <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  81155b:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  811562:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  811569:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  811570:	8b 45 0c             	mov    0xc(%ebp),%eax
  811573:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  811576:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  81157c:	89 d8                	mov    %ebx,%eax
  81157e:	83 c4 14             	add    $0x14,%esp
  811581:	5b                   	pop    %ebx
  811582:	5d                   	pop    %ebp
  811583:	c3                   	ret    

00811584 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  811584:	55                   	push   %ebp
  811585:	89 e5                	mov    %esp,%ebp
  811587:	56                   	push   %esi
  811588:	53                   	push   %ebx
  811589:	83 ec 20             	sub    $0x20,%esp
  81158c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  81158f:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  811593:	74 1c                	je     8115b1 <netconn_free+0x2d>
  811595:	c7 44 24 08 6c 71 81 	movl   $0x81716c,0x8(%esp)
  81159c:	00 
  81159d:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  8115a4:	00 
  8115a5:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  8115ac:	e8 07 f4 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  8115b1:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  8115b4:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  8115b8:	75 23                	jne    8115dd <netconn_free+0x59>
  8115ba:	eb 47                	jmp    811603 <netconn_free+0x7f>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  8115bc:	83 3b 10             	cmpl   $0x10,(%ebx)
  8115bf:	75 11                	jne    8115d2 <netconn_free+0x4e>
        if(mem != NULL) {
  8115c1:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8115c4:	85 c0                	test   %eax,%eax
  8115c6:	74 15                	je     8115dd <netconn_free+0x59>
          pbuf_free((struct pbuf *)mem);
  8115c8:	89 04 24             	mov    %eax,(%esp)
  8115cb:	e8 33 7c ff ff       	call   809203 <pbuf_free>
  8115d0:	eb 0b                	jmp    8115dd <netconn_free+0x59>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  8115d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8115d5:	89 04 24             	mov    %eax,(%esp)
  8115d8:	e8 17 55 ff ff       	call   806af4 <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  8115dd:	89 74 24 04          	mov    %esi,0x4(%esp)
  8115e1:	8b 43 14             	mov    0x14(%ebx),%eax
  8115e4:	89 04 24             	mov    %eax,(%esp)
  8115e7:	e8 71 df ff ff       	call   80f55d <sys_arch_mbox_tryfetch>
  8115ec:	83 f8 ff             	cmp    $0xffffffff,%eax
  8115ef:	75 cb                	jne    8115bc <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  8115f1:	8b 43 14             	mov    0x14(%ebx),%eax
  8115f4:	89 04 24             	mov    %eax,(%esp)
  8115f7:	e8 59 d9 ff ff       	call   80ef55 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  8115fc:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  811603:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  811606:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  81160a:	75 0d                	jne    811619 <netconn_free+0x95>
  81160c:	eb 31                	jmp    81163f <netconn_free+0xbb>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  81160e:	8b 45 f4             	mov    -0xc(%ebp),%eax
  811611:	89 04 24             	mov    %eax,(%esp)
  811614:	e8 2e ef ff ff       	call   810547 <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  811619:	89 74 24 04          	mov    %esi,0x4(%esp)
  81161d:	8b 43 18             	mov    0x18(%ebx),%eax
  811620:	89 04 24             	mov    %eax,(%esp)
  811623:	e8 35 df ff ff       	call   80f55d <sys_arch_mbox_tryfetch>
  811628:	83 f8 ff             	cmp    $0xffffffff,%eax
  81162b:	75 e1                	jne    81160e <netconn_free+0x8a>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  81162d:	8b 43 18             	mov    0x18(%ebx),%eax
  811630:	89 04 24             	mov    %eax,(%esp)
  811633:	e8 1d d9 ff ff       	call   80ef55 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  811638:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  81163f:	8b 43 10             	mov    0x10(%ebx),%eax
  811642:	89 04 24             	mov    %eax,(%esp)
  811645:	e8 57 d8 ff ff       	call   80eea1 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  81164a:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  811651:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811655:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  81165c:	e8 e0 77 ff ff       	call   808e41 <memp_free>
}
  811661:	83 c4 20             	add    $0x20,%esp
  811664:	5b                   	pop    %ebx
  811665:	5e                   	pop    %esi
  811666:	5d                   	pop    %ebp
  811667:	c3                   	ret    

00811668 <_ZL15accept_functionPvP7tcp_pcba>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  811668:	55                   	push   %ebp
  811669:	89 e5                	mov    %esp,%ebp
  81166b:	83 ec 28             	sub    $0x28,%esp
  81166e:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  811671:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811674:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811677:	8b 5d 08             	mov    0x8(%ebp),%ebx
  81167a:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  81167e:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  811682:	75 1c                	jne    8116a0 <_ZL15accept_functionPvP7tcp_pcba+0x38>
  811684:	c7 44 24 08 9c 71 81 	movl   $0x81719c,0x8(%esp)
  81168b:	00 
  81168c:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  811693:	00 
  811694:	c7 04 24 99 6f 81 00 	movl   $0x816f99,(%esp)
  81169b:	e8 18 f3 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  8116a0:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8116a3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8116a7:	8b 03                	mov    (%ebx),%eax
  8116a9:	89 04 24             	mov    %eax,(%esp)
  8116ac:	e8 1c fe ff ff       	call   8114cd <netconn_alloc>
  8116b1:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
    return ERR_MEM;
  8116b3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  if (newconn == NULL) {
  8116b8:	85 f6                	test   %esi,%esi
  8116ba:	74 5c                	je     811718 <_ZL15accept_functionPvP7tcp_pcba+0xb0>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  8116bc:	8b 45 0c             	mov    0xc(%ebp),%eax
  8116bf:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  8116c2:	89 f0                	mov    %esi,%eax
  8116c4:	e8 37 f4 ff ff       	call   810b00 <_ZL9setup_tcpP7netconn>
  newconn->err = err;
  8116c9:	89 f8                	mov    %edi,%eax
  8116cb:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  8116ce:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8116d1:	85 c0                	test   %eax,%eax
  8116d3:	74 15                	je     8116ea <_ZL15accept_functionPvP7tcp_pcba+0x82>
  8116d5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8116dc:	00 
  8116dd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8116e4:	00 
  8116e5:	89 1c 24             	mov    %ebx,(%esp)
  8116e8:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  8116ea:	89 74 24 04          	mov    %esi,0x4(%esp)
  8116ee:	8b 43 18             	mov    0x18(%ebx),%eax
  8116f1:	89 04 24             	mov    %eax,(%esp)
  8116f4:	e8 51 dc ff ff       	call   80f34a <sys_mbox_trypost>
  8116f9:	84 c0                	test   %al,%al
  8116fb:	74 16                	je     811713 <_ZL15accept_functionPvP7tcp_pcba+0xab>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  8116fd:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  811704:	89 34 24             	mov    %esi,(%esp)
  811707:	e8 78 fe ff ff       	call   811584 <netconn_free>
    return ERR_MEM;
  81170c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  811711:	eb 05                	jmp    811718 <_ZL15accept_functionPvP7tcp_pcba+0xb0>
  }
  return ERR_OK;
  811713:	b8 00 00 00 00       	mov    $0x0,%eax
}
  811718:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  81171b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  81171e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  811721:	89 ec                	mov    %ebp,%esp
  811723:	5d                   	pop    %ebp
  811724:	c3                   	ret    

00811725 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  811725:	55                   	push   %ebp
  811726:	89 e5                	mov    %esp,%ebp
  811728:	53                   	push   %ebx
  811729:	83 ec 14             	sub    $0x14,%esp
  81172c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  81172f:	8b 03                	mov    (%ebx),%eax
  811731:	8b 48 08             	mov    0x8(%eax),%ecx
  811734:	85 c9                	test   %ecx,%ecx
  811736:	74 4a                	je     811782 <do_delconn+0x5d>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  811738:	8b 10                	mov    (%eax),%edx
  81173a:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  811740:	83 fa 20             	cmp    $0x20,%edx
  811743:	74 17                	je     81175c <do_delconn+0x37>
  811745:	83 fa 40             	cmp    $0x40,%edx
  811748:	74 08                	je     811752 <do_delconn+0x2d>
  81174a:	83 fa 10             	cmp    $0x10,%edx
  81174d:	75 33                	jne    811782 <do_delconn+0x5d>
  81174f:	90                   	nop
  811750:	eb 20                	jmp    811772 <do_delconn+0x4d>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  811752:	89 0c 24             	mov    %ecx,(%esp)
  811755:	e8 97 22 00 00       	call   8139f1 <raw_remove>
      break;
  81175a:	eb 26                	jmp    811782 <do_delconn+0x5d>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  81175c:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  811763:	8b 03                	mov    (%ebx),%eax
  811765:	8b 40 08             	mov    0x8(%eax),%eax
  811768:	89 04 24             	mov    %eax,(%esp)
  81176b:	e8 3e c7 ff ff       	call   80deae <udp_remove>
      break;
  811770:	eb 10                	jmp    811782 <do_delconn+0x5d>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  811772:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  811779:	8b 03                	mov    (%ebx),%eax
  81177b:	e8 2b f4 ff ff       	call   810bab <_ZL17do_close_internalP7netconn>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  811780:	eb 4e                	jmp    8117d0 <do_delconn+0xab>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  811782:	8b 13                	mov    (%ebx),%edx
  811784:	8b 42 2c             	mov    0x2c(%edx),%eax
  811787:	85 c0                	test   %eax,%eax
  811789:	74 33                	je     8117be <do_delconn+0x99>
  81178b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811792:	00 
  811793:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81179a:	00 
  81179b:	89 14 24             	mov    %edx,(%esp)
  81179e:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  8117a0:	8b 13                	mov    (%ebx),%edx
  8117a2:	8b 42 2c             	mov    0x2c(%edx),%eax
  8117a5:	85 c0                	test   %eax,%eax
  8117a7:	74 15                	je     8117be <do_delconn+0x99>
  8117a9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8117b0:	00 
  8117b1:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  8117b8:	00 
  8117b9:	89 14 24             	mov    %edx,(%esp)
  8117bc:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  8117be:	8b 03                	mov    (%ebx),%eax
  8117c0:	8b 40 10             	mov    0x10(%eax),%eax
  8117c3:	83 f8 ff             	cmp    $0xffffffff,%eax
  8117c6:	74 08                	je     8117d0 <do_delconn+0xab>
    sys_sem_signal(msg->conn->op_completed);
  8117c8:	89 04 24             	mov    %eax,(%esp)
  8117cb:	e8 cf d9 ff ff       	call   80f19f <sys_sem_signal>
  }
}
  8117d0:	83 c4 14             	add    $0x14,%esp
  8117d3:	5b                   	pop    %ebx
  8117d4:	5d                   	pop    %ebp
  8117d5:	c3                   	ret    

008117d6 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  8117d6:	55                   	push   %ebp
  8117d7:	89 e5                	mov    %esp,%ebp
  8117d9:	83 ec 18             	sub    $0x18,%esp
  8117dc:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8117df:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8117e2:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  8117e5:	8b 1e                	mov    (%esi),%ebx
  8117e7:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  8117eb:	7c 6f                	jl     81185c <do_bind+0x86>
    if (msg->conn->pcb.tcp != NULL) {
  8117ed:	8b 53 08             	mov    0x8(%ebx),%edx
  8117f0:	85 d2                	test   %edx,%edx
  8117f2:	74 64                	je     811858 <do_bind+0x82>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  8117f4:	8b 03                	mov    (%ebx),%eax
  8117f6:	25 f0 00 00 00       	and    $0xf0,%eax
  8117fb:	83 f8 20             	cmp    $0x20,%eax
  8117fe:	74 20                	je     811820 <do_bind+0x4a>
  811800:	83 f8 40             	cmp    $0x40,%eax
  811803:	74 07                	je     81180c <do_bind+0x36>
  811805:	83 f8 10             	cmp    $0x10,%eax
  811808:	75 52                	jne    81185c <do_bind+0x86>
  81180a:	eb 30                	jmp    81183c <do_bind+0x66>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  81180c:	8b 46 04             	mov    0x4(%esi),%eax
  81180f:	89 44 24 04          	mov    %eax,0x4(%esp)
  811813:	89 14 24             	mov    %edx,(%esp)
  811816:	e8 5c 20 00 00       	call   813877 <raw_bind>
  81181b:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  81181e:	eb 3c                	jmp    81185c <do_bind+0x86>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  811820:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811824:	89 44 24 08          	mov    %eax,0x8(%esp)
  811828:	8b 46 04             	mov    0x4(%esi),%eax
  81182b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81182f:	89 14 24             	mov    %edx,(%esp)
  811832:	e8 bd c2 ff ff       	call   80daf4 <udp_bind>
  811837:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  81183a:	eb 20                	jmp    81185c <do_bind+0x86>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  81183c:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811840:	89 44 24 08          	mov    %eax,0x8(%esp)
  811844:	8b 46 04             	mov    0x4(%esi),%eax
  811847:	89 44 24 04          	mov    %eax,0x4(%esp)
  81184b:	89 14 24             	mov    %edx,(%esp)
  81184e:	e8 93 86 ff ff       	call   809ee6 <tcp_bind>
  811853:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  811856:	eb 04                	jmp    81185c <do_bind+0x86>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  811858:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  81185c:	8b 06                	mov    (%esi),%eax
  81185e:	8b 40 10             	mov    0x10(%eax),%eax
  811861:	89 04 24             	mov    %eax,(%esp)
  811864:	e8 36 d9 ff ff       	call   80f19f <sys_sem_signal>
}
  811869:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  81186c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  81186f:	89 ec                	mov    %ebp,%esp
  811871:	5d                   	pop    %ebp
  811872:	c3                   	ret    

00811873 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  811873:	55                   	push   %ebp
  811874:	89 e5                	mov    %esp,%ebp
  811876:	56                   	push   %esi
  811877:	53                   	push   %ebx
  811878:	83 ec 10             	sub    $0x10,%esp
  81187b:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  81187e:	8b 1e                	mov    (%esi),%ebx
  811880:	8b 53 08             	mov    0x8(%ebx),%edx
  811883:	85 d2                	test   %edx,%edx
  811885:	75 10                	jne    811897 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  811887:	8b 43 10             	mov    0x10(%ebx),%eax
  81188a:	89 04 24             	mov    %eax,(%esp)
  81188d:	e8 0d d9 ff ff       	call   80f19f <sys_sem_signal>
    return;
  811892:	e9 9b 00 00 00       	jmp    811932 <do_connect+0xbf>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  811897:	8b 03                	mov    (%ebx),%eax
  811899:	25 f0 00 00 00       	and    $0xf0,%eax
  81189e:	83 f8 20             	cmp    $0x20,%eax
  8118a1:	74 31                	je     8118d4 <do_connect+0x61>
  8118a3:	83 f8 40             	cmp    $0x40,%eax
  8118a6:	74 0b                	je     8118b3 <do_connect+0x40>
  8118a8:	83 f8 10             	cmp    $0x10,%eax
  8118ab:	0f 85 81 00 00 00    	jne    811932 <do_connect+0xbf>
  8118b1:	eb 4a                	jmp    8118fd <do_connect+0x8a>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  8118b3:	8b 46 04             	mov    0x4(%esi),%eax
  8118b6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118ba:	89 14 24             	mov    %edx,(%esp)
  8118bd:	e8 d2 1f 00 00       	call   813894 <raw_connect>
  8118c2:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  8118c5:	8b 06                	mov    (%esi),%eax
  8118c7:	8b 40 10             	mov    0x10(%eax),%eax
  8118ca:	89 04 24             	mov    %eax,(%esp)
  8118cd:	e8 cd d8 ff ff       	call   80f19f <sys_sem_signal>
    break;
  8118d2:	eb 5e                	jmp    811932 <do_connect+0xbf>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  8118d4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8118d8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8118dc:	8b 46 04             	mov    0x4(%esi),%eax
  8118df:	89 44 24 04          	mov    %eax,0x4(%esp)
  8118e3:	89 14 24             	mov    %edx,(%esp)
  8118e6:	e8 0c c5 ff ff       	call   80ddf7 <udp_connect>
  8118eb:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  8118ee:	8b 06                	mov    (%esi),%eax
  8118f0:	8b 40 10             	mov    0x10(%eax),%eax
  8118f3:	89 04 24             	mov    %eax,(%esp)
  8118f6:	e8 a4 d8 ff ff       	call   80f19f <sys_sem_signal>
    break;
  8118fb:	eb 35                	jmp    811932 <do_connect+0xbf>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  8118fd:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  811904:	8b 06                	mov    (%esi),%eax
  811906:	e8 f5 f1 ff ff       	call   810b00 <_ZL9setup_tcpP7netconn>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
                                 do_connected);
  81190b:	8b 1e                	mov    (%esi),%ebx
  81190d:	c7 44 24 0c 64 0b 81 	movl   $0x810b64,0xc(%esp)
  811914:	00 
  811915:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811919:	89 44 24 08          	mov    %eax,0x8(%esp)
  81191d:	8b 46 04             	mov    0x4(%esi),%eax
  811920:	89 44 24 04          	mov    %eax,0x4(%esp)
  811924:	8b 43 08             	mov    0x8(%ebx),%eax
  811927:	89 04 24             	mov    %eax,(%esp)
  81192a:	e8 3a 95 ff ff       	call   80ae69 <tcp_connect>
  81192f:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  811932:	83 c4 10             	add    $0x10,%esp
  811935:	5b                   	pop    %ebx
  811936:	5e                   	pop    %esi
  811937:	5d                   	pop    %ebp
  811938:	c3                   	ret    

00811939 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  811939:	55                   	push   %ebp
  81193a:	89 e5                	mov    %esp,%ebp
  81193c:	53                   	push   %ebx
  81193d:	83 ec 14             	sub    $0x14,%esp
  811940:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  811943:	8b 03                	mov    (%ebx),%eax
  811945:	8b 10                	mov    (%eax),%edx
  811947:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  81194d:	83 fa 20             	cmp    $0x20,%edx
  811950:	75 0b                	jne    81195d <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  811952:	8b 40 08             	mov    0x8(%eax),%eax
  811955:	89 04 24             	mov    %eax,(%esp)
  811958:	e8 22 c5 ff ff       	call   80de7f <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  81195d:	8b 03                	mov    (%ebx),%eax
  81195f:	8b 40 10             	mov    0x10(%eax),%eax
  811962:	89 04 24             	mov    %eax,(%esp)
  811965:	e8 35 d8 ff ff       	call   80f19f <sys_sem_signal>
}
  81196a:	83 c4 14             	add    $0x14,%esp
  81196d:	5b                   	pop    %ebx
  81196e:	5d                   	pop    %ebp
  81196f:	c3                   	ret    

00811970 <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  811970:	55                   	push   %ebp
  811971:	89 e5                	mov    %esp,%ebp
  811973:	83 ec 28             	sub    $0x28,%esp
  811976:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  811979:	89 75 f8             	mov    %esi,-0x8(%ebp)
  81197c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  81197f:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  811982:	8b 03                	mov    (%ebx),%eax
  811984:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  811988:	0f 8c b9 00 00 00    	jl     811a47 <do_listen+0xd7>
    if (msg->conn->pcb.tcp != NULL) {
  81198e:	8b 50 08             	mov    0x8(%eax),%edx
  811991:	85 d2                	test   %edx,%edx
  811993:	0f 84 ae 00 00 00    	je     811a47 <do_listen+0xd7>
      if (msg->conn->type == NETCONN_TCP) {
  811999:	83 38 10             	cmpl   $0x10,(%eax)
  81199c:	0f 85 a5 00 00 00    	jne    811a47 <do_listen+0xd7>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  8119a2:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  8119a6:	0f 85 97 00 00 00    	jne    811a43 <do_listen+0xd3>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  8119ac:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  8119b3:	00 
  8119b4:	89 14 24             	mov    %edx,(%esp)
  8119b7:	e8 f6 86 ff ff       	call   80a0b2 <tcp_listen_with_backlog>
  8119bc:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  8119be:	85 c0                	test   %eax,%eax
  8119c0:	75 08                	jne    8119ca <do_listen+0x5a>
            msg->conn->err = ERR_MEM;
  8119c2:	8b 03                	mov    (%ebx),%eax
  8119c4:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  8119c8:	eb 7d                	jmp    811a47 <do_listen+0xd7>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  8119ca:	8b 03                	mov    (%ebx),%eax
  8119cc:	8b 40 14             	mov    0x14(%eax),%eax
  8119cf:	83 f8 ff             	cmp    $0xffffffff,%eax
  8119d2:	74 11                	je     8119e5 <do_listen+0x75>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  8119d4:	89 04 24             	mov    %eax,(%esp)
  8119d7:	e8 79 d5 ff ff       	call   80ef55 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  8119dc:	8b 03                	mov    (%ebx),%eax
  8119de:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  8119e5:	8b 3b                	mov    (%ebx),%edi
  8119e7:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  8119eb:	75 1a                	jne    811a07 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  8119ed:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8119f4:	e8 43 d6 ff ff       	call   80f03c <sys_mbox_new>
  8119f9:	89 47 18             	mov    %eax,0x18(%edi)
  8119fc:	83 f8 ff             	cmp    $0xffffffff,%eax
  8119ff:	75 06                	jne    811a07 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  811a01:	8b 03                	mov    (%ebx),%eax
  811a03:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  811a07:	8b 03                	mov    (%ebx),%eax
  811a09:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  811a0d:	75 38                	jne    811a47 <do_listen+0xd7>
              msg->conn->state = NETCONN_LISTEN;
  811a0f:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  811a16:	8b 03                	mov    (%ebx),%eax
  811a18:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  811a1b:	8b 03                	mov    (%ebx),%eax
  811a1d:	89 44 24 04          	mov    %eax,0x4(%esp)
  811a21:	8b 40 08             	mov    0x8(%eax),%eax
  811a24:	89 04 24             	mov    %eax,(%esp)
  811a27:	e8 67 89 ff ff       	call   80a393 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  811a2c:	c7 44 24 04 68 16 81 	movl   $0x811668,0x4(%esp)
  811a33:	00 
  811a34:	8b 03                	mov    (%ebx),%eax
  811a36:	8b 40 08             	mov    0x8(%eax),%eax
  811a39:	89 04 24             	mov    %eax,(%esp)
  811a3c:	e8 93 89 ff ff       	call   80a3d4 <tcp_accept>
  811a41:	eb 04                	jmp    811a47 <do_listen+0xd7>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  811a43:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  811a47:	8b 03                	mov    (%ebx),%eax
  811a49:	8b 40 10             	mov    0x10(%eax),%eax
  811a4c:	89 04 24             	mov    %eax,(%esp)
  811a4f:	e8 4b d7 ff ff       	call   80f19f <sys_sem_signal>
}
  811a54:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  811a57:	8b 75 f8             	mov    -0x8(%ebp),%esi
  811a5a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  811a5d:	89 ec                	mov    %ebp,%esp
  811a5f:	5d                   	pop    %ebp
  811a60:	c3                   	ret    

00811a61 <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  811a61:	55                   	push   %ebp
  811a62:	89 e5                	mov    %esp,%ebp
  811a64:	83 ec 28             	sub    $0x28,%esp
  811a67:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  811a6a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811a6d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811a70:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  811a73:	8b 1e                	mov    (%esi),%ebx
  811a75:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  811a79:	0f 8c 8b 00 00 00    	jl     811b0a <do_send+0xa9>
    if (msg->conn->pcb.tcp != NULL) {
  811a7f:	8b 43 08             	mov    0x8(%ebx),%eax
  811a82:	85 c0                	test   %eax,%eax
  811a84:	0f 84 80 00 00 00    	je     811b0a <do_send+0xa9>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  811a8a:	8b 13                	mov    (%ebx),%edx
  811a8c:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  811a92:	83 fa 20             	cmp    $0x20,%edx
  811a95:	74 39                	je     811ad0 <do_send+0x6f>
  811a97:	83 fa 40             	cmp    $0x40,%edx
  811a9a:	75 6e                	jne    811b0a <do_send+0xa9>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  811a9c:	8b 56 04             	mov    0x4(%esi),%edx
  811a9f:	8b 4a 08             	mov    0x8(%edx),%ecx
  811aa2:	85 c9                	test   %ecx,%ecx
  811aa4:	75 13                	jne    811ab9 <do_send+0x58>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  811aa6:	8b 12                	mov    (%edx),%edx
  811aa8:	89 54 24 04          	mov    %edx,0x4(%esp)
  811aac:	89 04 24             	mov    %eax,(%esp)
  811aaf:	e8 1c 1f 00 00       	call   8139d0 <raw_send>
  811ab4:	88 43 0c             	mov    %al,0xc(%ebx)
  811ab7:	eb 51                	jmp    811b0a <do_send+0xa9>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  811ab9:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811abd:	8b 12                	mov    (%edx),%edx
  811abf:	89 54 24 04          	mov    %edx,0x4(%esp)
  811ac3:	89 04 24             	mov    %eax,(%esp)
  811ac6:	e8 fb 1d 00 00       	call   8138c6 <raw_sendto>
  811acb:	88 43 0c             	mov    %al,0xc(%ebx)
  811ace:	eb 3a                	jmp    811b0a <do_send+0xa9>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  811ad0:	8b 56 04             	mov    0x4(%esi),%edx
  811ad3:	8b 4a 08             	mov    0x8(%edx),%ecx
  811ad6:	85 c9                	test   %ecx,%ecx
  811ad8:	75 13                	jne    811aed <do_send+0x8c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  811ada:	8b 12                	mov    (%edx),%edx
  811adc:	89 54 24 04          	mov    %edx,0x4(%esp)
  811ae0:	89 04 24             	mov    %eax,(%esp)
  811ae3:	e8 e6 c2 ff ff       	call   80ddce <udp_send>
  811ae8:	88 43 0c             	mov    %al,0xc(%ebx)
  811aeb:	eb 1d                	jmp    811b0a <do_send+0xa9>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  811aed:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  811af1:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  811af5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  811af9:	8b 12                	mov    (%edx),%edx
  811afb:	89 54 24 04          	mov    %edx,0x4(%esp)
  811aff:	89 04 24             	mov    %eax,(%esp)
  811b02:	e8 76 c2 ff ff       	call   80dd7d <udp_sendto>
  811b07:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  811b0a:	8b 06                	mov    (%esi),%eax
  811b0c:	8b 40 10             	mov    0x10(%eax),%eax
  811b0f:	89 04 24             	mov    %eax,(%esp)
  811b12:	e8 88 d6 ff ff       	call   80f19f <sys_sem_signal>
}
  811b17:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  811b1a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  811b1d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  811b20:	89 ec                	mov    %ebp,%esp
  811b22:	5d                   	pop    %ebp
  811b23:	c3                   	ret    

00811b24 <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  811b24:	55                   	push   %ebp
  811b25:	89 e5                	mov    %esp,%ebp
  811b27:	53                   	push   %ebx
  811b28:	83 ec 14             	sub    $0x14,%esp
  811b2b:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  811b2e:	8b 03                	mov    (%ebx),%eax
  811b30:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  811b34:	7c 1c                	jl     811b52 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  811b36:	8b 50 08             	mov    0x8(%eax),%edx
  811b39:	85 d2                	test   %edx,%edx
  811b3b:	74 15                	je     811b52 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  811b3d:	83 38 10             	cmpl   $0x10,(%eax)
  811b40:	75 10                	jne    811b52 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  811b42:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  811b46:	89 44 24 04          	mov    %eax,0x4(%esp)
  811b4a:	89 14 24             	mov    %edx,(%esp)
  811b4d:	e8 68 86 ff ff       	call   80a1ba <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  811b52:	8b 03                	mov    (%ebx),%eax
  811b54:	8b 40 10             	mov    0x10(%eax),%eax
  811b57:	89 04 24             	mov    %eax,(%esp)
  811b5a:	e8 40 d6 ff ff       	call   80f19f <sys_sem_signal>
}
  811b5f:	83 c4 14             	add    $0x14,%esp
  811b62:	5b                   	pop    %ebx
  811b63:	5d                   	pop    %ebp
  811b64:	c3                   	ret    

00811b65 <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  811b65:	55                   	push   %ebp
  811b66:	89 e5                	mov    %esp,%ebp
  811b68:	83 ec 18             	sub    $0x18,%esp
  811b6b:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  811b6e:	8b 02                	mov    (%edx),%eax
  811b70:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  811b74:	7c 2d                	jl     811ba3 <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  811b76:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  811b7a:	74 23                	je     811b9f <do_write+0x3a>
  811b7c:	83 38 10             	cmpl   $0x10,(%eax)
  811b7f:	75 1e                	jne    811b9f <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  811b81:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  811b88:	8b 02                	mov    (%edx),%eax
  811b8a:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  811b8d:	8b 02                	mov    (%edx),%eax
  811b8f:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  811b96:	8b 02                	mov    (%edx),%eax
  811b98:	e8 ee f2 ff ff       	call   810e8b <_ZL12do_writemoreP7netconn>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  811b9d:	eb 11                	jmp    811bb0 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  811b9f:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  811ba3:	8b 02                	mov    (%edx),%eax
  811ba5:	8b 40 10             	mov    0x10(%eax),%eax
  811ba8:	89 04 24             	mov    %eax,(%esp)
  811bab:	e8 ef d5 ff ff       	call   80f19f <sys_sem_signal>
}
  811bb0:	c9                   	leave  
  811bb1:	c3                   	ret    

00811bb2 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  811bb2:	55                   	push   %ebp
  811bb3:	89 e5                	mov    %esp,%ebp
  811bb5:	53                   	push   %ebx
  811bb6:	83 ec 14             	sub    $0x14,%esp
  811bb9:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  811bbc:	8b 08                	mov    (%eax),%ecx
  811bbe:	8b 51 08             	mov    0x8(%ecx),%edx
  811bc1:	85 d2                	test   %edx,%edx
  811bc3:	0f 84 95 00 00 00    	je     811c5e <do_getaddr+0xac>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  811bc9:	8b 48 04             	mov    0x4(%eax),%ecx
  811bcc:	8d 5a 04             	lea    0x4(%edx),%ebx
  811bcf:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  811bd3:	0f 44 d3             	cmove  %ebx,%edx
  811bd6:	8b 12                	mov    (%edx),%edx
  811bd8:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  811bda:	8b 08                	mov    (%eax),%ecx
  811bdc:	8b 11                	mov    (%ecx),%edx
  811bde:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  811be4:	83 fa 20             	cmp    $0x20,%edx
  811be7:	74 27                	je     811c10 <do_getaddr+0x5e>
  811be9:	83 fa 40             	cmp    $0x40,%edx
  811bec:	74 07                	je     811bf5 <do_getaddr+0x43>
  811bee:	83 fa 10             	cmp    $0x10,%edx
  811bf1:	75 6f                	jne    811c62 <do_getaddr+0xb0>
  811bf3:	eb 4b                	jmp    811c40 <do_getaddr+0x8e>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  811bf5:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  811bf9:	74 0f                	je     811c0a <do_getaddr+0x58>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  811bfb:	8b 50 08             	mov    0x8(%eax),%edx
  811bfe:	8b 49 08             	mov    0x8(%ecx),%ecx
  811c01:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  811c05:	66 89 0a             	mov    %cx,(%edx)
  811c08:	eb 58                	jmp    811c62 <do_getaddr+0xb0>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  811c0a:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  811c0e:	eb 52                	jmp    811c62 <do_getaddr+0xb0>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  811c10:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  811c14:	74 0f                	je     811c25 <do_getaddr+0x73>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  811c16:	8b 50 08             	mov    0x8(%eax),%edx
  811c19:	8b 49 08             	mov    0x8(%ecx),%ecx
  811c1c:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  811c20:	66 89 0a             	mov    %cx,(%edx)
  811c23:	eb 3d                	jmp    811c62 <do_getaddr+0xb0>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  811c25:	8b 51 08             	mov    0x8(%ecx),%edx
  811c28:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  811c2c:	75 06                	jne    811c34 <do_getaddr+0x82>
          msg->conn->err = ERR_CONN;
  811c2e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  811c32:	eb 2e                	jmp    811c62 <do_getaddr+0xb0>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  811c34:	8b 48 08             	mov    0x8(%eax),%ecx
  811c37:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  811c3b:	66 89 11             	mov    %dx,(%ecx)
  811c3e:	eb 22                	jmp    811c62 <do_getaddr+0xb0>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  811c40:	8b 50 08             	mov    0x8(%eax),%edx
  811c43:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  811c47:	74 09                	je     811c52 <do_getaddr+0xa0>
  811c49:	8b 49 08             	mov    0x8(%ecx),%ecx
  811c4c:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  811c50:	eb 07                	jmp    811c59 <do_getaddr+0xa7>
  811c52:	8b 49 08             	mov    0x8(%ecx),%ecx
  811c55:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  811c59:	66 89 0a             	mov    %cx,(%edx)
      break;
  811c5c:	eb 04                	jmp    811c62 <do_getaddr+0xb0>
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  811c5e:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  811c62:	8b 00                	mov    (%eax),%eax
  811c64:	8b 40 10             	mov    0x10(%eax),%eax
  811c67:	89 04 24             	mov    %eax,(%esp)
  811c6a:	e8 30 d5 ff ff       	call   80f19f <sys_sem_signal>
}
  811c6f:	83 c4 14             	add    $0x14,%esp
  811c72:	5b                   	pop    %ebx
  811c73:	5d                   	pop    %ebp
  811c74:	c3                   	ret    

00811c75 <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  811c75:	55                   	push   %ebp
  811c76:	89 e5                	mov    %esp,%ebp
  811c78:	83 ec 18             	sub    $0x18,%esp
  811c7b:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  811c7e:	8b 02                	mov    (%edx),%eax
  811c80:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  811c84:	74 15                	je     811c9b <do_close+0x26>
  811c86:	83 38 10             	cmpl   $0x10,(%eax)
  811c89:	75 10                	jne    811c9b <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  811c8b:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  811c92:	8b 02                	mov    (%edx),%eax
  811c94:	e8 12 ef ff ff       	call   810bab <_ZL17do_close_internalP7netconn>
  811c99:	eb 11                	jmp    811cac <do_close+0x37>
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  811c9b:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  811c9f:	8b 02                	mov    (%edx),%eax
  811ca1:	8b 40 10             	mov    0x10(%eax),%eax
  811ca4:	89 04 24             	mov    %eax,(%esp)
  811ca7:	e8 f3 d4 ff ff       	call   80f19f <sys_sem_signal>
  }
}
  811cac:	c9                   	leave  
  811cad:	c3                   	ret    
	...

00811cb0 <_ZL12tcp_parseoptP7tcp_pcb>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  811cb0:	55                   	push   %ebp
  811cb1:	89 e5                	mov    %esp,%ebp
  811cb3:	57                   	push   %edi
  811cb4:	56                   	push   %esi
  811cb5:	53                   	push   %ebx
  811cb6:	83 ec 1c             	sub    $0x1c,%esp
  811cb9:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  811cbb:	a1 30 14 b4 00       	mov    0xb41430,%eax
  811cc0:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  811cc3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  811cc7:	89 04 24             	mov    %eax,(%esp)
  811cca:	e8 f7 a6 ff ff       	call   80c3c6 <ntohs>
  811ccf:	0f b7 c0             	movzwl %ax,%eax
  811cd2:	c1 f8 0c             	sar    $0xc,%eax
  811cd5:	bb 00 00 00 00       	mov    $0x0,%ebx
  811cda:	83 f8 05             	cmp    $0x5,%eax
  811cdd:	7f 51                	jg     811d30 <_ZL12tcp_parseoptP7tcp_pcb+0x80>
  811cdf:	eb 74                	jmp    811d55 <_ZL12tcp_parseoptP7tcp_pcb+0xa5>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  811ce1:	0f b6 d3             	movzbl %bl,%edx
  811ce4:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  811ce8:	84 c0                	test   %al,%al
  811cea:	74 69                	je     811d55 <_ZL12tcp_parseoptP7tcp_pcb+0xa5>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  811cec:	3c 01                	cmp    $0x1,%al
  811cee:	75 05                	jne    811cf5 <_ZL12tcp_parseoptP7tcp_pcb+0x45>
        ++c;
  811cf0:	83 c3 01             	add    $0x1,%ebx
  811cf3:	eb 3b                	jmp    811d30 <_ZL12tcp_parseoptP7tcp_pcb+0x80>
        /* NOP option. */
      } else if (opt == 0x02 &&
  811cf5:	3c 02                	cmp    $0x2,%al
  811cf7:	75 2c                	jne    811d25 <_ZL12tcp_parseoptP7tcp_pcb+0x75>
  811cf9:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  811cfe:	75 25                	jne    811d25 <_ZL12tcp_parseoptP7tcp_pcb+0x75>
        opts[c + 1] == 0x04) {
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  811d00:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  811d05:	c1 e0 08             	shl    $0x8,%eax
  811d08:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  811d0d:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  811d0f:	8d 50 ff             	lea    -0x1(%eax),%edx
  811d12:	66 81 fa b4 05       	cmp    $0x5b4,%dx
  811d17:	ba b4 05 00 00       	mov    $0x5b4,%edx
  811d1c:	0f 43 c2             	cmovae %edx,%eax
  811d1f:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  811d23:	eb 30                	jmp    811d55 <_ZL12tcp_parseoptP7tcp_pcb+0xa5>
      } else {
        if (opts[c + 1] == 0) {
  811d25:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  811d2a:	84 c0                	test   %al,%al
  811d2c:	74 27                	je     811d55 <_ZL12tcp_parseoptP7tcp_pcb+0xa5>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  811d2e:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  811d30:	a1 30 14 b4 00       	mov    0xb41430,%eax
  811d35:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  811d39:	89 04 24             	mov    %eax,(%esp)
  811d3c:	e8 85 a6 ff ff       	call   80c3c6 <ntohs>
  811d41:	0f b6 d3             	movzbl %bl,%edx
  811d44:	0f b7 c0             	movzwl %ax,%eax
  811d47:	c1 f8 0c             	sar    $0xc,%eax
  811d4a:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  811d51:	39 c2                	cmp    %eax,%edx
  811d53:	7c 8c                	jl     811ce1 <_ZL12tcp_parseoptP7tcp_pcb+0x31>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  811d55:	83 c4 1c             	add    $0x1c,%esp
  811d58:	5b                   	pop    %ebx
  811d59:	5e                   	pop    %esi
  811d5a:	5f                   	pop    %edi
  811d5b:	5d                   	pop    %ebp
  811d5c:	c3                   	ret    

00811d5d <_ZL11tcp_receiveP7tcp_pcb>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  811d5d:	55                   	push   %ebp
  811d5e:	89 e5                	mov    %esp,%ebp
  811d60:	57                   	push   %edi
  811d61:	56                   	push   %esi
  811d62:	53                   	push   %ebx
  811d63:	83 ec 2c             	sub    $0x2c,%esp
  811d66:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  811d68:	f6 05 3c 14 b4 00 10 	testb  $0x10,0xb4143c
  811d6f:	0f 84 5e 04 00 00    	je     8121d3 <_ZL11tcp_receiveP7tcp_pcb+0x476>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  811d75:	0f b7 70 5c          	movzwl 0x5c(%eax),%esi
  811d79:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  811d7c:	a1 34 14 b4 00       	mov    0xb41434,%eax
  811d81:	39 c2                	cmp    %eax,%edx
  811d83:	78 26                	js     811dab <_ZL11tcp_receiveP7tcp_pcb+0x4e>
  811d85:	39 c2                	cmp    %eax,%edx
  811d87:	75 0b                	jne    811d94 <_ZL11tcp_receiveP7tcp_pcb+0x37>
  811d89:	8b 0d 38 14 b4 00    	mov    0xb41438,%ecx
  811d8f:	39 4b 64             	cmp    %ecx,0x64(%ebx)
  811d92:	78 17                	js     811dab <_ZL11tcp_receiveP7tcp_pcb+0x4e>
  811d94:	8b 3d 38 14 b4 00    	mov    0xb41438,%edi
  811d9a:	39 7b 64             	cmp    %edi,0x64(%ebx)
  811d9d:	75 3a                	jne    811dd9 <_ZL11tcp_receiveP7tcp_pcb+0x7c>
  811d9f:	8b 0d 30 14 b4 00    	mov    0xb41430,%ecx
  811da5:	66 3b 71 0e          	cmp    0xe(%ecx),%si
  811da9:	73 2e                	jae    811dd9 <_ZL11tcp_receiveP7tcp_pcb+0x7c>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
      pcb->snd_wnd = tcphdr->wnd;
  811dab:	8b 0d 30 14 b4 00    	mov    0xb41430,%ecx
  811db1:	0f b7 49 0e          	movzwl 0xe(%ecx),%ecx
  811db5:	66 89 4b 5c          	mov    %cx,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  811db9:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  811dbc:	a1 38 14 b4 00       	mov    0xb41438,%eax
  811dc1:	89 43 64             	mov    %eax,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  811dc4:	66 85 c9             	test   %cx,%cx
  811dc7:	74 10                	je     811dd9 <_ZL11tcp_receiveP7tcp_pcb+0x7c>
  811dc9:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  811dd0:	74 07                	je     811dd9 <_ZL11tcp_receiveP7tcp_pcb+0x7c>
          pcb->persist_backoff = 0;
  811dd2:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  811dd9:	8b 4b 48             	mov    0x48(%ebx),%ecx
  811ddc:	a1 38 14 b4 00       	mov    0xb41438,%eax
  811de1:	39 c1                	cmp    %eax,%ecx
  811de3:	0f 85 a8 00 00 00    	jne    811e91 <_ZL11tcp_receiveP7tcp_pcb+0x134>
      pcb->acked = 0;
  811de9:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  811def:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  811df3:	03 43 60             	add    0x60(%ebx),%eax
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  811df6:	0f b7 f6             	movzwl %si,%esi
  811df9:	8d 14 16             	lea    (%esi,%edx,1),%edx
    }

    if (pcb->lastack == ackno) {
      pcb->acked = 0;

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  811dfc:	39 d0                	cmp    %edx,%eax
  811dfe:	0f 85 d1 02 00 00    	jne    8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
        ++pcb->dupacks;
  811e04:	0f b6 43 4c          	movzbl 0x4c(%ebx),%eax
  811e08:	83 c0 01             	add    $0x1,%eax
  811e0b:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  811e0e:	3c 02                	cmp    $0x2,%al
  811e10:	0f 86 bf 02 00 00    	jbe    8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
  811e16:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  811e1a:	0f 84 b5 02 00 00    	je     8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
          if (!(pcb->flags & TF_INFR)) {
  811e20:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  811e24:	75 50                	jne    811e76 <_ZL11tcp_receiveP7tcp_pcb+0x119>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  811e26:	89 1c 24             	mov    %ebx,(%esp)
  811e29:	e8 18 b6 ff ff       	call   80d446 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  811e2e:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  811e32:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  811e36:	66 39 d0             	cmp    %dx,%ax
  811e39:	76 09                	jbe    811e44 <_ZL11tcp_receiveP7tcp_pcb+0xe7>
              pcb->ssthresh = pcb->snd_wnd / 2;
  811e3b:	66 d1 ea             	shr    %dx
  811e3e:	66 89 53 50          	mov    %dx,0x50(%ebx)
  811e42:	eb 07                	jmp    811e4b <_ZL11tcp_receiveP7tcp_pcb+0xee>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  811e44:	66 d1 e8             	shr    %ax
  811e47:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  811e4b:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  811e4f:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  811e53:	0f b7 d0             	movzwl %ax,%edx
  811e56:	01 d2                	add    %edx,%edx
  811e58:	39 d1                	cmp    %edx,%ecx
  811e5a:	7d 07                	jge    811e63 <_ZL11tcp_receiveP7tcp_pcb+0x106>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  811e5c:	8d 14 00             	lea    (%eax,%eax,1),%edx
  811e5f:	66 89 53 50          	mov    %dx,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  811e63:	6b c0 03             	imul   $0x3,%eax,%eax
  811e66:	03 43 50             	add    0x50(%ebx),%eax
  811e69:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  811e6d:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  811e71:	e9 5f 02 00 00       	jmp    8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  811e76:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  811e7a:	89 d0                	mov    %edx,%eax
  811e7c:	03 43 34             	add    0x34(%ebx),%eax
  811e7f:	66 39 c2             	cmp    %ax,%dx
  811e82:	0f 83 4d 02 00 00    	jae    8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
              pcb->cwnd += pcb->mss;
  811e88:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  811e8c:	e9 44 02 00 00       	jmp    8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  811e91:	89 ca                	mov    %ecx,%edx
  811e93:	f7 d2                	not    %edx
  811e95:	01 c2                	add    %eax,%edx
  811e97:	0f 88 a8 01 00 00    	js     812045 <_ZL11tcp_receiveP7tcp_pcb+0x2e8>
  811e9d:	89 c2                	mov    %eax,%edx
  811e9f:	2b 53 58             	sub    0x58(%ebx),%edx
  811ea2:	85 d2                	test   %edx,%edx
  811ea4:	0f 8f 9b 01 00 00    	jg     812045 <_ZL11tcp_receiveP7tcp_pcb+0x2e8>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  811eaa:	0f b6 53 20          	movzbl 0x20(%ebx),%edx
  811eae:	f6 c2 04             	test   $0x4,%dl
  811eb1:	74 0e                	je     811ec1 <_ZL11tcp_receiveP7tcp_pcb+0x164>
        pcb->flags &= ~TF_INFR;
  811eb3:	83 e2 fb             	and    $0xfffffffb,%edx
  811eb6:	88 53 20             	mov    %dl,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  811eb9:	0f b7 53 50          	movzwl 0x50(%ebx),%edx
  811ebd:	66 89 53 4e          	mov    %dx,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  811ec1:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  811ec5:	0f bf 53 40          	movswl 0x40(%ebx),%edx
  811ec9:	c1 fa 03             	sar    $0x3,%edx
  811ecc:	66 03 53 42          	add    0x42(%ebx),%dx
  811ed0:	66 89 53 44          	mov    %dx,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  811ed4:	89 c2                	mov    %eax,%edx
  811ed6:	66 29 ca             	sub    %cx,%dx
  811ed9:	66 89 53 6c          	mov    %dx,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  811edd:	66 01 53 6e          	add    %dx,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  811ee1:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  811ee5:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  811ee8:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  811eec:	0f 8e ac 00 00 00    	jle    811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>
        if (pcb->cwnd < pcb->ssthresh) {
  811ef2:	0f b7 4b 4e          	movzwl 0x4e(%ebx),%ecx
  811ef6:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  811efa:	73 17                	jae    811f13 <_ZL11tcp_receiveP7tcp_pcb+0x1b6>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  811efc:	89 c8                	mov    %ecx,%eax
  811efe:	03 43 34             	add    0x34(%ebx),%eax
  811f01:	66 39 c1             	cmp    %ax,%cx
  811f04:	0f 83 94 00 00 00    	jae    811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>
            pcb->cwnd += pcb->mss;
  811f0a:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  811f0e:	e9 8b 00 00 00       	jmp    811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  811f13:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  811f17:	0f af c0             	imul   %eax,%eax
  811f1a:	0f b7 f1             	movzwl %cx,%esi
  811f1d:	89 c2                	mov    %eax,%edx
  811f1f:	c1 fa 1f             	sar    $0x1f,%edx
  811f22:	f7 fe                	idiv   %esi
  811f24:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  811f27:	66 39 c1             	cmp    %ax,%cx
  811f2a:	73 72                	jae    811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>
            pcb->cwnd = new_cwnd;
  811f2c:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  811f30:	eb 6c                	jmp    811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>

        next = pcb->unacked;
        pcb->unacked = pcb->unacked->next;

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  811f32:	c7 44 24 08 c8 71 81 	movl   $0x8171c8,0x8(%esp)
  811f39:	00 
  811f3a:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  811f41:	00 
  811f42:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  811f49:	e8 6a ea fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  811f4e:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  811f52:	8b 46 04             	mov    0x4(%esi),%eax
  811f55:	89 04 24             	mov    %eax,(%esp)
  811f58:	e8 74 77 ff ff       	call   8096d1 <pbuf_clen>
  811f5d:	0f b6 c0             	movzbl %al,%eax
  811f60:	66 29 c7             	sub    %ax,%di
  811f63:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  811f67:	89 34 24             	mov    %esi,(%esp)
  811f6a:	e8 5d 83 ff ff       	call   80a2cc <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  811f6f:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  811f74:	74 28                	je     811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  811f76:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  811f7a:	75 22                	jne    811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>
  811f7c:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  811f80:	75 1c                	jne    811f9e <_ZL11tcp_receiveP7tcp_pcb+0x241>
  811f82:	c7 44 24 08 f0 71 81 	movl   $0x8171f0,0x8(%esp)
  811f89:	00 
  811f8a:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  811f91:	00 
  811f92:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  811f99:	e8 1a ea fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  811f9e:	8b 43 78             	mov    0x78(%ebx),%eax
  811fa1:	85 c0                	test   %eax,%eax
  811fa3:	0f 84 85 00 00 00    	je     81202e <_ZL11tcp_receiveP7tcp_pcb+0x2d1>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  811fa9:	8b 40 10             	mov    0x10(%eax),%eax
  811fac:	8b 40 04             	mov    0x4(%eax),%eax
  811faf:	89 04 24             	mov    %eax,(%esp)
  811fb2:	e8 82 a6 ff ff       	call   80c639 <ntohl>
  811fb7:	89 c6                	mov    %eax,%esi
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  811fb9:	8b 43 78             	mov    0x78(%ebx),%eax
  811fbc:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  811fc0:	8b 40 10             	mov    0x10(%eax),%eax
  811fc3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  811fc7:	89 04 24             	mov    %eax,(%esp)
  811fca:	e8 f7 a3 ff ff       	call   80c3c6 <ntohs>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  811fcf:	ba 01 00 00 00       	mov    $0x1,%edx
  811fd4:	a8 01                	test   $0x1,%al
  811fd6:	75 1b                	jne    811ff3 <_ZL11tcp_receiveP7tcp_pcb+0x296>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  811fd8:	8b 43 78             	mov    0x78(%ebx),%eax
  811fdb:	8b 40 10             	mov    0x10(%eax),%eax
  811fde:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  811fe2:	89 04 24             	mov    %eax,(%esp)
  811fe5:	e8 dc a3 ff ff       	call   80c3c6 <ntohs>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  811fea:	83 e0 02             	and    $0x2,%eax
  811fed:	0f 95 c2             	setne  %dl
  811ff0:	0f b6 d2             	movzbl %dl,%edx
  811ff3:	2b 35 38 14 b4 00    	sub    0xb41438,%esi
  811ff9:	8d 3c 3a             	lea    (%edx,%edi,1),%edi
  811ffc:	01 fe                	add    %edi,%esi
  811ffe:	85 f6                	test   %esi,%esi
  812000:	0f 8f d7 09 00 00    	jg     8129dd <_ZL11tcp_receiveP7tcp_pcb+0xc80>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  812006:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  812009:	8b 06                	mov    (%esi),%eax
  81200b:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81200e:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  812012:	8b 46 04             	mov    0x4(%esi),%eax
  812015:	89 04 24             	mov    %eax,(%esp)
  812018:	e8 b4 76 ff ff       	call   8096d1 <pbuf_clen>
  81201d:	0f b6 c0             	movzbl %al,%eax
  812020:	66 39 c7             	cmp    %ax,%di
  812023:	0f 83 25 ff ff ff    	jae    811f4e <_ZL11tcp_receiveP7tcp_pcb+0x1f1>
  812029:	e9 04 ff ff ff       	jmp    811f32 <_ZL11tcp_receiveP7tcp_pcb+0x1d5>
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
        pcb->rtime = -1;
  81202e:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  812034:	eb 06                	jmp    81203c <_ZL11tcp_receiveP7tcp_pcb+0x2df>
      else
        pcb->rtime = 0;
  812036:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

      pcb->polltmr = 0;
  81203c:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
  812040:	e9 90 00 00 00       	jmp    8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  812045:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  81204b:	e9 85 00 00 00       	jmp    8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
      pcb->unsent = pcb->unsent->next;
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  812050:	c7 44 24 08 c8 71 81 	movl   $0x8171c8,0x8(%esp)
  812057:	00 
  812058:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  81205f:	00 
  812060:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812067:	e8 4c e9 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  81206c:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  812070:	8b 46 04             	mov    0x4(%esi),%eax
  812073:	89 04 24             	mov    %eax,(%esp)
  812076:	e8 56 76 ff ff       	call   8096d1 <pbuf_clen>
  81207b:	0f b6 c0             	movzbl %al,%eax
  81207e:	66 29 c7             	sub    %ax,%di
  812081:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  812085:	89 34 24             	mov    %esi,(%esp)
  812088:	e8 3f 82 ff ff       	call   80a2cc <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  81208d:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  812092:	74 29                	je     8120bd <_ZL11tcp_receiveP7tcp_pcb+0x360>
        LWIP_ASSERT("tcp_receive: valid queue length",
  812094:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  812098:	75 23                	jne    8120bd <_ZL11tcp_receiveP7tcp_pcb+0x360>
  81209a:	8b 43 74             	mov    0x74(%ebx),%eax
  81209d:	85 c0                	test   %eax,%eax
  81209f:	75 23                	jne    8120c4 <_ZL11tcp_receiveP7tcp_pcb+0x367>
  8120a1:	c7 44 24 08 f0 71 81 	movl   $0x8171f0,0x8(%esp)
  8120a8:	00 
  8120a9:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  8120b0:	00 
  8120b1:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  8120b8:	e8 fb e8 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  8120bd:	8b 43 74             	mov    0x74(%ebx),%eax
  8120c0:	85 c0                	test   %eax,%eax
  8120c2:	74 11                	je     8120d5 <_ZL11tcp_receiveP7tcp_pcb+0x378>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  8120c4:	8b 40 10             	mov    0x10(%eax),%eax
  8120c7:	8b 40 04             	mov    0x4(%eax),%eax
  8120ca:	89 04 24             	mov    %eax,(%esp)
  8120cd:	e8 08 a3 ff ff       	call   80c3da <htonl>
  8120d2:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  8120d5:	8b 43 74             	mov    0x74(%ebx),%eax
  8120d8:	85 c0                	test   %eax,%eax
  8120da:	0f 84 0c 09 00 00    	je     8129ec <_ZL11tcp_receiveP7tcp_pcb+0xc8f>
  8120e0:	8b 35 38 14 b4 00    	mov    0xb41438,%esi
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  8120e6:	8b 40 10             	mov    0x10(%eax),%eax
  8120e9:	8b 40 04             	mov    0x4(%eax),%eax
  8120ec:	89 04 24             	mov    %eax,(%esp)
  8120ef:	e8 45 a5 ff ff       	call   80c639 <ntohl>
  8120f4:	89 c7                	mov    %eax,%edi
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  8120f6:	8b 43 74             	mov    0x74(%ebx),%eax
  8120f9:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  8120fd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  812100:	8b 40 10             	mov    0x10(%eax),%eax
  812103:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812107:	89 04 24             	mov    %eax,(%esp)
  81210a:	e8 b7 a2 ff ff       	call   80c3c6 <ntohs>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81210f:	ba 01 00 00 00       	mov    $0x1,%edx
  812114:	a8 01                	test   $0x1,%al
  812116:	75 1b                	jne    812133 <_ZL11tcp_receiveP7tcp_pcb+0x3d6>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  812118:	8b 43 74             	mov    0x74(%ebx),%eax
  81211b:	8b 40 10             	mov    0x10(%eax),%eax
  81211e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812122:	89 04 24             	mov    %eax,(%esp)
  812125:	e8 9c a2 ff ff       	call   80c3c6 <ntohs>
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  81212a:	83 e0 02             	and    $0x2,%eax
  81212d:	0f 95 c2             	setne  %dl
  812130:	0f b6 d2             	movzbl %dl,%edx
  812133:	29 fe                	sub    %edi,%esi
  812135:	03 55 e4             	add    -0x1c(%ebp),%edx
  812138:	39 d6                	cmp    %edx,%esi
  81213a:	0f 88 ac 08 00 00    	js     8129ec <_ZL11tcp_receiveP7tcp_pcb+0xc8f>
  812140:	a1 38 14 b4 00       	mov    0xb41438,%eax
  812145:	2b 43 58             	sub    0x58(%ebx),%eax
  812148:	85 c0                	test   %eax,%eax
  81214a:	0f 8f 9c 08 00 00    	jg     8129ec <_ZL11tcp_receiveP7tcp_pcb+0xc8f>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  812150:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  812153:	8b 06                	mov    (%esi),%eax
  812155:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  812158:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  81215c:	8b 46 04             	mov    0x4(%esi),%eax
  81215f:	89 04 24             	mov    %eax,(%esp)
  812162:	e8 6a 75 ff ff       	call   8096d1 <pbuf_clen>
  812167:	0f b6 c0             	movzbl %al,%eax
  81216a:	66 39 c7             	cmp    %ax,%di
  81216d:	0f 83 f9 fe ff ff    	jae    81206c <_ZL11tcp_receiveP7tcp_pcb+0x30f>
  812173:	e9 d8 fe ff ff       	jmp    812050 <_ZL11tcp_receiveP7tcp_pcb+0x2f3>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  812178:	8b 0d 38 14 b4 00    	mov    0xb41438,%ecx
  81217e:	39 4b 3c             	cmp    %ecx,0x3c(%ebx)
  812181:	79 50                	jns    8121d3 <_ZL11tcp_receiveP7tcp_pcb+0x476>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  812183:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
      /* diff between this shouldn't exceed 32K since this are tcp timer ticks
         and a round-trip shouldn't be that long... */
      m = (s16_t)(tcp_ticks - pcb->rttest);
  812187:	8b 0d d0 a3 b3 00    	mov    0xb3a3d0,%ecx
  81218d:	66 29 c1             	sub    %ax,%cx
  812190:	89 c8                	mov    %ecx,%eax

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  812192:	0f bf ca             	movswl %dx,%ecx
  812195:	c1 f9 03             	sar    $0x3,%ecx
  812198:	66 29 c8             	sub    %cx,%ax
      pcb->sa += m;
  81219b:	8d 14 10             	lea    (%eax,%edx,1),%edx
  81219e:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
        m = -m;
  8121a2:	89 c1                	mov    %eax,%ecx
  8121a4:	f7 d9                	neg    %ecx
  8121a6:	66 85 c0             	test   %ax,%ax
  8121a9:	0f 48 c1             	cmovs  %ecx,%eax
      }
      m = m - (pcb->sv >> 2);
  8121ac:	0f b7 4b 42          	movzwl 0x42(%ebx),%ecx
  8121b0:	0f bf f1             	movswl %cx,%esi
  8121b3:	c1 fe 02             	sar    $0x2,%esi
  8121b6:	66 29 f1             	sub    %si,%cx
      pcb->sv += m;
  8121b9:	8d 04 01             	lea    (%ecx,%eax,1),%eax
  8121bc:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  8121c0:	0f bf d2             	movswl %dx,%edx
  8121c3:	c1 fa 03             	sar    $0x3,%edx
  8121c6:	01 d0                	add    %edx,%eax
  8121c8:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  8121cc:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  8121d3:	0f b7 0d 3e 14 b4 00 	movzwl 0xb4143e,%ecx
  8121da:	66 85 c9             	test   %cx,%cx
  8121dd:	0f 84 b9 07 00 00    	je     81299c <_ZL11tcp_receiveP7tcp_pcb+0xc3f>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  8121e3:	8b 53 24             	mov    0x24(%ebx),%edx
  8121e6:	a1 34 14 b4 00       	mov    0xb41434,%eax
  8121eb:	89 c6                	mov    %eax,%esi
  8121ed:	f7 d6                	not    %esi
  8121ef:	01 d6                	add    %edx,%esi
  8121f1:	0f 88 3c 01 00 00    	js     812333 <_ZL11tcp_receiveP7tcp_pcb+0x5d6>
  8121f7:	8d 7a 01             	lea    0x1(%edx),%edi
  8121fa:	29 c7                	sub    %eax,%edi
  8121fc:	0f b7 f1             	movzwl %cx,%esi
  8121ff:	89 f9                	mov    %edi,%ecx
  812201:	29 f1                	sub    %esi,%ecx
  812203:	85 c9                	test   %ecx,%ecx
  812205:	0f 8f 28 01 00 00    	jg     812333 <_ZL11tcp_receiveP7tcp_pcb+0x5d6>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  81220b:	8b 35 44 14 b4 00    	mov    0xb41444,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  812211:	85 f6                	test   %esi,%esi
  812213:	75 1c                	jne    812231 <_ZL11tcp_receiveP7tcp_pcb+0x4d4>
  812215:	c7 44 24 08 4b 73 81 	movl   $0x81734b,0x8(%esp)
  81221c:	00 
  81221d:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  812224:	00 
  812225:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  81222c:	e8 87 e7 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  812231:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  812233:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  812239:	7e 1c                	jle    812257 <_ZL11tcp_receiveP7tcp_pcb+0x4fa>
  81223b:	c7 44 24 08 5b 73 81 	movl   $0x81735b,0x8(%esp)
  812242:	00 
  812243:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  81224a:	00 
  81224b:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812252:	e8 61 e7 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
      if (inseg.p->len < off) {
  812257:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  81225b:	39 c2                	cmp    %eax,%edx
  81225d:	7e 71                	jle    8122d0 <_ZL11tcp_receiveP7tcp_pcb+0x573>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  81225f:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  812263:	0f b7 f9             	movzwl %cx,%edi
  812266:	39 fa                	cmp    %edi,%edx
  812268:	7e 1c                	jle    812286 <_ZL11tcp_receiveP7tcp_pcb+0x529>
  81226a:	c7 44 24 08 6a 73 81 	movl   $0x81736a,0x8(%esp)
  812271:	00 
  812272:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  812279:	00 
  81227a:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812281:	e8 32 e7 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  812286:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  812289:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  81228b:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  81228f:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  812295:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  812297:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  81229b:	39 d0                	cmp    %edx,%eax
  81229d:	7c ea                	jl     812289 <_ZL11tcp_receiveP7tcp_pcb+0x52c>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  81229f:	f7 da                	neg    %edx
  8122a1:	0f bf c2             	movswl %dx,%eax
  8122a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8122a8:	89 34 24             	mov    %esi,(%esp)
  8122ab:	e8 60 6e ff ff       	call   809110 <pbuf_header>
  8122b0:	84 c0                	test   %al,%al
  8122b2:	74 4d                	je     812301 <_ZL11tcp_receiveP7tcp_pcb+0x5a4>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  8122b4:	c7 44 24 08 7a 73 81 	movl   $0x81737a,0x8(%esp)
  8122bb:	00 
  8122bc:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  8122c3:	00 
  8122c4:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  8122cb:	e8 e8 e6 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  8122d0:	89 d0                	mov    %edx,%eax
  8122d2:	f7 d8                	neg    %eax
  8122d4:	98                   	cwtl   
  8122d5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8122d9:	89 34 24             	mov    %esi,(%esp)
  8122dc:	e8 2f 6e ff ff       	call   809110 <pbuf_header>
  8122e1:	84 c0                	test   %al,%al
  8122e3:	74 1c                	je     812301 <_ZL11tcp_receiveP7tcp_pcb+0x5a4>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  8122e5:	c7 44 24 08 7a 73 81 	movl   $0x81737a,0x8(%esp)
  8122ec:	00 
  8122ed:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  8122f4:	00 
  8122f5:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  8122fc:	e8 b7 e6 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  812301:	8b 46 04             	mov    0x4(%esi),%eax
  812304:	a3 48 14 b4 00       	mov    %eax,0xb41448
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  812309:	8b 43 24             	mov    0x24(%ebx),%eax
  81230c:	8b 15 34 14 b4 00    	mov    0xb41434,%edx
  812312:	66 03 15 4c 14 b4 00 	add    0xb4144c,%dx
  812319:	66 29 c2             	sub    %ax,%dx
  81231c:	66 89 15 4c 14 b4 00 	mov    %dx,0xb4144c
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  812323:	a3 34 14 b4 00       	mov    %eax,0xb41434
  812328:	8b 15 50 14 b4 00    	mov    0xb41450,%edx
  81232e:	89 42 04             	mov    %eax,0x4(%edx)
  812331:	eb 10                	jmp    812343 <_ZL11tcp_receiveP7tcp_pcb+0x5e6>
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  812333:	39 d0                	cmp    %edx,%eax
  812335:	79 1c                	jns    812353 <_ZL11tcp_receiveP7tcp_pcb+0x5f6>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  812337:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81233b:	89 1c 24             	mov    %ebx,(%esp)
  81233e:	e8 b2 aa ff ff       	call   80cdf5 <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  812343:	a1 34 14 b4 00       	mov    0xb41434,%eax
  812348:	8b 53 24             	mov    0x24(%ebx),%edx
  81234b:	39 d0                	cmp    %edx,%eax
  81234d:	0f 88 36 06 00 00    	js     812989 <_ZL11tcp_receiveP7tcp_pcb+0xc2c>
  812353:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  812357:	89 c6                	mov    %eax,%esi
  812359:	29 ce                	sub    %ecx,%esi
  81235b:	8d 4e 01             	lea    0x1(%esi),%ecx
  81235e:	29 d1                	sub    %edx,%ecx
  812360:	85 c9                	test   %ecx,%ecx
  812362:	0f 8f 21 06 00 00    	jg     812989 <_ZL11tcp_receiveP7tcp_pcb+0xc2c>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  812368:	39 d0                	cmp    %edx,%eax
  81236a:	0f 85 6e 03 00 00    	jne    8126de <_ZL11tcp_receiveP7tcp_pcb+0x981>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  812370:	8b 53 7c             	mov    0x7c(%ebx),%edx
  812373:	85 d2                	test   %edx,%edx
  812375:	0f 84 86 00 00 00    	je     812401 <_ZL11tcp_receiveP7tcp_pcb+0x6a4>
  81237b:	8b 4a 10             	mov    0x10(%edx),%ecx
  81237e:	8b 49 04             	mov    0x4(%ecx),%ecx
  812381:	0f b7 35 4c 14 b4 00 	movzwl 0xb4144c,%esi
  812388:	89 cf                	mov    %ecx,%edi
  81238a:	29 f7                	sub    %esi,%edi
  81238c:	89 fe                	mov    %edi,%esi
  81238e:	29 c6                	sub    %eax,%esi
  812390:	85 f6                	test   %esi,%esi
  812392:	7f 6d                	jg     812401 <_ZL11tcp_receiveP7tcp_pcb+0x6a4>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  812394:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  812399:	74 20                	je     8123bb <_ZL11tcp_receiveP7tcp_pcb+0x65e>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  81239b:	66 29 c1             	sub    %ax,%cx
  81239e:	66 89 0d 4c 14 b4 00 	mov    %cx,0xb4144c
            pbuf_realloc(inseg.p, inseg.len);
  8123a5:	0f b7 c9             	movzwl %cx,%ecx
  8123a8:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  8123ac:	a1 44 14 b4 00       	mov    0xb41444,%eax
  8123b1:	89 04 24             	mov    %eax,(%esp)
  8123b4:	e8 26 6f ff ff       	call   8092df <pbuf_realloc>
  8123b9:	eb 46                	jmp    812401 <_ZL11tcp_receiveP7tcp_pcb+0x6a4>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  8123bb:	a1 50 14 b4 00       	mov    0xb41450,%eax
  8123c0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8123c4:	89 04 24             	mov    %eax,(%esp)
  8123c7:	e8 fa 9f ff ff       	call   80c3c6 <ntohs>
  8123cc:	89 c6                	mov    %eax,%esi
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
  8123ce:	8b 43 7c             	mov    0x7c(%ebx),%eax
  8123d1:	8b 40 10             	mov    0x10(%eax),%eax
  8123d4:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8123d8:	89 04 24             	mov    %eax,(%esp)
  8123db:	e8 e6 9f ff ff       	call   80c3c6 <ntohs>
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
            pbuf_realloc(inseg.p, inseg.len);
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  8123e0:	31 c6                	xor    %eax,%esi
  8123e2:	66 f7 c6 03 00       	test   $0x3,%si
  8123e7:	75 18                	jne    812401 <_ZL11tcp_receiveP7tcp_pcb+0x6a4>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  8123e9:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  8123ec:	8b 10                	mov    (%eax),%edx
  8123ee:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  8123f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8123f5:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  8123fc:	e8 40 6a ff ff       	call   808e41 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  812401:	0f b7 35 4c 14 b4 00 	movzwl 0xb4144c,%esi
  812408:	a1 50 14 b4 00       	mov    0xb41450,%eax
  81240d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812411:	89 04 24             	mov    %eax,(%esp)
  812414:	e8 ad 9f ff ff       	call   80c3c6 <ntohs>
  812419:	ba 01 00 00 00       	mov    $0x1,%edx
  81241e:	a8 01                	test   $0x1,%al
  812420:	75 1a                	jne    81243c <_ZL11tcp_receiveP7tcp_pcb+0x6df>
  812422:	a1 50 14 b4 00       	mov    0xb41450,%eax
  812427:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81242b:	89 04 24             	mov    %eax,(%esp)
  81242e:	e8 93 9f ff ff       	call   80c3c6 <ntohs>
  812433:	83 e0 02             	and    $0x2,%eax
  812436:	0f 95 c2             	setne  %dl
  812439:	0f b6 d2             	movzbl %dl,%edx
  81243c:	8d 34 32             	lea    (%edx,%esi,1),%esi
  81243f:	66 89 35 3e 14 b4 00 	mov    %si,0xb4143e

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  812446:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  81244a:	74 06                	je     812452 <_ZL11tcp_receiveP7tcp_pcb+0x6f5>
          pcb->rcv_nxt += tcplen;
  81244c:	0f b7 c6             	movzwl %si,%eax
  81244f:	01 43 24             	add    %eax,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  812452:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
  812456:	66 39 c6             	cmp    %ax,%si
  812459:	76 08                	jbe    812463 <_ZL11tcp_receiveP7tcp_pcb+0x706>
          pcb->rcv_wnd = 0;
  81245b:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  812461:	eb 07                	jmp    81246a <_ZL11tcp_receiveP7tcp_pcb+0x70d>
        } else {
          pcb->rcv_wnd -= tcplen;
  812463:	66 29 f0             	sub    %si,%ax
  812466:	66 89 43 28          	mov    %ax,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81246a:	0f b7 43 2a          	movzwl 0x2a(%ebx),%eax
  81246e:	66 39 c6             	cmp    %ax,%si
  812471:	76 08                	jbe    81247b <_ZL11tcp_receiveP7tcp_pcb+0x71e>
          pcb->rcv_ann_wnd = 0;
  812473:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  812479:	eb 07                	jmp    812482 <_ZL11tcp_receiveP7tcp_pcb+0x725>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  81247b:	66 29 f0             	sub    %si,%ax
  81247e:	66 89 43 2a          	mov    %ax,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  812482:	a1 44 14 b4 00       	mov    0xb41444,%eax
  812487:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  81248c:	74 0f                	je     81249d <_ZL11tcp_receiveP7tcp_pcb+0x740>
          recv_data = inseg.p;
  81248e:	a3 54 14 b4 00       	mov    %eax,0xb41454
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  812493:	c7 05 44 14 b4 00 00 	movl   $0x0,0xb41444
  81249a:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  81249d:	a1 50 14 b4 00       	mov    0xb41450,%eax
  8124a2:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8124a6:	89 04 24             	mov    %eax,(%esp)
  8124a9:	e8 18 9f ff ff       	call   80c3c6 <ntohs>
  8124ae:	89 de                	mov    %ebx,%esi
  8124b0:	a8 01                	test   $0x1,%al
  8124b2:	0f 84 b3 01 00 00    	je     81266b <_ZL11tcp_receiveP7tcp_pcb+0x90e>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  8124b8:	c6 05 58 14 b4 00 20 	movb   $0x20,0xb41458
  8124bf:	89 de                	mov    %ebx,%esi
  8124c1:	e9 a5 01 00 00       	jmp    81266b <_ZL11tcp_receiveP7tcp_pcb+0x90e>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  8124c6:	8b 43 10             	mov    0x10(%ebx),%eax
  8124c9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8124cd:	89 04 24             	mov    %eax,(%esp)
  8124d0:	e8 f1 9e ff ff       	call   80c3c6 <ntohs>
  8124d5:	83 e0 02             	and    $0x2,%eax
  8124d8:	0f 95 c2             	setne  %dl
  8124db:	0f b6 d2             	movzbl %dl,%edx
  8124de:	8d 3c 3a             	lea    (%edx,%edi,1),%edi
  8124e1:	03 7d e4             	add    -0x1c(%ebp),%edi
  8124e4:	89 7e 24             	mov    %edi,0x24(%esi)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  8124e7:	0f b7 46 28          	movzwl 0x28(%esi),%eax
  8124eb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8124ee:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  8124f2:	8b 43 10             	mov    0x10(%ebx),%eax
  8124f5:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8124f9:	89 04 24             	mov    %eax,(%esp)
  8124fc:	e8 c5 9e ff ff       	call   80c3c6 <ntohs>
  812501:	ba 01 00 00 00       	mov    $0x1,%edx
  812506:	a8 01                	test   $0x1,%al
  812508:	75 18                	jne    812522 <_ZL11tcp_receiveP7tcp_pcb+0x7c5>
  81250a:	8b 43 10             	mov    0x10(%ebx),%eax
  81250d:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812511:	89 04 24             	mov    %eax,(%esp)
  812514:	e8 ad 9e ff ff       	call   80c3c6 <ntohs>
  812519:	83 e0 02             	and    $0x2,%eax
  81251c:	0f 95 c2             	setne  %dl
  81251f:	0f b6 d2             	movzbl %dl,%edx
  812522:	01 fa                	add    %edi,%edx
  812524:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  812527:	7d 08                	jge    812531 <_ZL11tcp_receiveP7tcp_pcb+0x7d4>
            pcb->rcv_wnd = 0;
  812529:	66 c7 46 28 00 00    	movw   $0x0,0x28(%esi)
  81252f:	eb 47                	jmp    812578 <_ZL11tcp_receiveP7tcp_pcb+0x81b>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  812531:	0f b7 7e 28          	movzwl 0x28(%esi),%edi
  812535:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  812539:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  81253d:	8b 43 10             	mov    0x10(%ebx),%eax
  812540:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812544:	89 04 24             	mov    %eax,(%esp)
  812547:	e8 7a 9e ff ff       	call   80c3c6 <ntohs>
  81254c:	ba 01 00 00 00       	mov    $0x1,%edx
  812551:	a8 01                	test   $0x1,%al
  812553:	75 18                	jne    81256d <_ZL11tcp_receiveP7tcp_pcb+0x810>
  812555:	8b 43 10             	mov    0x10(%ebx),%eax
  812558:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81255c:	89 04 24             	mov    %eax,(%esp)
  81255f:	e8 62 9e ff ff       	call   80c3c6 <ntohs>
  812564:	83 e0 02             	and    $0x2,%eax
  812567:	0f 95 c2             	setne  %dl
  81256a:	0f b6 d2             	movzbl %dl,%edx
  81256d:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  812571:	66 29 d7             	sub    %dx,%di
  812574:	66 89 7e 28          	mov    %di,0x28(%esi)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  812578:	0f b7 4e 2a          	movzwl 0x2a(%esi),%ecx
  81257c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  81257f:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  812583:	8b 43 10             	mov    0x10(%ebx),%eax
  812586:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81258a:	89 04 24             	mov    %eax,(%esp)
  81258d:	e8 34 9e ff ff       	call   80c3c6 <ntohs>
  812592:	ba 01 00 00 00       	mov    $0x1,%edx
  812597:	a8 01                	test   $0x1,%al
  812599:	75 18                	jne    8125b3 <_ZL11tcp_receiveP7tcp_pcb+0x856>
  81259b:	8b 43 10             	mov    0x10(%ebx),%eax
  81259e:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8125a2:	89 04 24             	mov    %eax,(%esp)
  8125a5:	e8 1c 9e ff ff       	call   80c3c6 <ntohs>
  8125aa:	83 e0 02             	and    $0x2,%eax
  8125ad:	0f 95 c2             	setne  %dl
  8125b0:	0f b6 d2             	movzbl %dl,%edx
  8125b3:	01 fa                	add    %edi,%edx
  8125b5:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8125b8:	7d 08                	jge    8125c2 <_ZL11tcp_receiveP7tcp_pcb+0x865>
            pcb->rcv_ann_wnd = 0;
  8125ba:	66 c7 46 2a 00 00    	movw   $0x0,0x2a(%esi)
  8125c0:	eb 47                	jmp    812609 <_ZL11tcp_receiveP7tcp_pcb+0x8ac>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  8125c2:	0f b7 7e 2a          	movzwl 0x2a(%esi),%edi
  8125c6:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  8125ca:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  8125ce:	8b 43 10             	mov    0x10(%ebx),%eax
  8125d1:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8125d5:	89 04 24             	mov    %eax,(%esp)
  8125d8:	e8 e9 9d ff ff       	call   80c3c6 <ntohs>
  8125dd:	ba 01 00 00 00       	mov    $0x1,%edx
  8125e2:	a8 01                	test   $0x1,%al
  8125e4:	75 18                	jne    8125fe <_ZL11tcp_receiveP7tcp_pcb+0x8a1>
  8125e6:	8b 43 10             	mov    0x10(%ebx),%eax
  8125e9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8125ed:	89 04 24             	mov    %eax,(%esp)
  8125f0:	e8 d1 9d ff ff       	call   80c3c6 <ntohs>
  8125f5:	83 e0 02             	and    $0x2,%eax
  8125f8:	0f 95 c2             	setne  %dl
  8125fb:	0f b6 d2             	movzbl %dl,%edx
  8125fe:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  812602:	66 29 d7             	sub    %dx,%di
  812605:	66 89 7e 2a          	mov    %di,0x2a(%esi)
          }

          if (cseg->p->tot_len > 0) {
  812609:	8b 43 04             	mov    0x4(%ebx),%eax
  81260c:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  812611:	74 24                	je     812637 <_ZL11tcp_receiveP7tcp_pcb+0x8da>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  812613:	8b 15 54 14 b4 00    	mov    0xb41454,%edx
  812619:	85 d2                	test   %edx,%edx
  81261b:	74 0e                	je     81262b <_ZL11tcp_receiveP7tcp_pcb+0x8ce>
              pbuf_cat(recv_data, cseg->p);
  81261d:	89 44 24 04          	mov    %eax,0x4(%esp)
  812621:	89 14 24             	mov    %edx,(%esp)
  812624:	e8 d3 70 ff ff       	call   8096fc <pbuf_cat>
  812629:	eb 05                	jmp    812630 <_ZL11tcp_receiveP7tcp_pcb+0x8d3>
            } else {
              recv_data = cseg->p;
  81262b:	a3 54 14 b4 00       	mov    %eax,0xb41454
            }
            cseg->p = NULL;
  812630:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  812637:	8b 43 10             	mov    0x10(%ebx),%eax
  81263a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81263e:	89 04 24             	mov    %eax,(%esp)
  812641:	e8 80 9d ff ff       	call   80c3c6 <ntohs>
  812646:	a8 01                	test   $0x1,%al
  812648:	74 14                	je     81265e <_ZL11tcp_receiveP7tcp_pcb+0x901>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  81264a:	c6 05 58 14 b4 00 20 	movb   $0x20,0xb41458
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  812651:	83 7e 10 04          	cmpl   $0x4,0x10(%esi)
  812655:	75 07                	jne    81265e <_ZL11tcp_receiveP7tcp_pcb+0x901>
              pcb->state = CLOSE_WAIT;
  812657:	c7 46 10 07 00 00 00 	movl   $0x7,0x10(%esi)
            } 
          }


          pcb->ooseq = cseg->next;
  81265e:	8b 03                	mov    (%ebx),%eax
  812660:	89 46 7c             	mov    %eax,0x7c(%esi)
          tcp_seg_free(cseg);
  812663:	89 1c 24             	mov    %ebx,(%esp)
  812666:	e8 61 7c ff ff       	call   80a2cc <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  81266b:	8b 5e 7c             	mov    0x7c(%esi),%ebx
  81266e:	85 db                	test   %ebx,%ebx
  812670:	0f 84 86 03 00 00    	je     8129fc <_ZL11tcp_receiveP7tcp_pcb+0xc9f>
  812676:	8b 43 10             	mov    0x10(%ebx),%eax
  812679:	8b 50 04             	mov    0x4(%eax),%edx
  81267c:	3b 56 24             	cmp    0x24(%esi),%edx
  81267f:	0f 85 77 03 00 00    	jne    8129fc <_ZL11tcp_receiveP7tcp_pcb+0xc9f>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  812685:	89 15 34 14 b4 00    	mov    %edx,0xb41434

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  81268b:	8b 56 24             	mov    0x24(%esi),%edx
  81268e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  812691:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  812695:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812699:	89 04 24             	mov    %eax,(%esp)
  81269c:	e8 25 9d ff ff       	call   80c3c6 <ntohs>
  8126a1:	ba 01 00 00 00       	mov    $0x1,%edx
  8126a6:	a8 01                	test   $0x1,%al
  8126a8:	0f 85 30 fe ff ff    	jne    8124de <_ZL11tcp_receiveP7tcp_pcb+0x781>
  8126ae:	e9 13 fe ff ff       	jmp    8124c6 <_ZL11tcp_receiveP7tcp_pcb+0x769>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  8126b3:	83 e0 fe             	and    $0xfffffffe,%eax
  8126b6:	83 c8 02             	or     $0x2,%eax
  8126b9:	88 43 20             	mov    %al,0x20(%ebx)
  8126bc:	89 1c 24             	mov    %ebx,(%esp)
  8126bf:	e8 31 a7 ff ff       	call   80cdf5 <tcp_output>
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  8126c4:	b8 01 00 00 00       	mov    $0x1,%eax
  8126c9:	e9 07 03 00 00       	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  8126ce:	83 c8 01             	or     $0x1,%eax
  8126d1:	88 43 20             	mov    %al,0x20(%ebx)
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
        accepted_inseq = 1; 
  8126d4:	b8 01 00 00 00       	mov    $0x1,%eax
  8126d9:	e9 f7 02 00 00       	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
        /* Acknowledge the segment(s). */
        tcp_ack(pcb);

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  8126de:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8126e2:	89 1c 24             	mov    %ebx,(%esp)
  8126e5:	e8 0b a7 ff ff       	call   80cdf5 <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  8126ea:	8b 4b 7c             	mov    0x7c(%ebx),%ecx
  8126ed:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8126f0:	85 c9                	test   %ecx,%ecx
  8126f2:	74 22                	je     812716 <_ZL11tcp_receiveP7tcp_pcb+0x9b9>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  8126f4:	8b 41 10             	mov    0x10(%ecx),%eax
  8126f7:	8b 40 04             	mov    0x4(%eax),%eax
  8126fa:	8b 15 34 14 b4 00    	mov    0xb41434,%edx
  812700:	39 d0                	cmp    %edx,%eax
  812702:	74 2b                	je     81272f <_ZL11tcp_receiveP7tcp_pcb+0x9d2>
  812704:	bf 00 00 00 00       	mov    $0x0,%edi
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  812709:	8d 72 01             	lea    0x1(%edx),%esi
  81270c:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  81270f:	89 f3                	mov    %esi,%ebx
  812711:	e9 cd 00 00 00       	jmp    8127e3 <_ZL11tcp_receiveP7tcp_pcb+0xa86>
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
          pcb->ooseq = tcp_seg_copy(&inseg);
  812716:	c7 04 24 40 14 b4 00 	movl   $0xb41440,(%esp)
  81271d:	e8 2e 7c ff ff       	call   80a350 <tcp_seg_copy>
  812722:	89 43 7c             	mov    %eax,0x7c(%ebx)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  812725:	b8 00 00 00 00       	mov    $0x0,%eax
  81272a:	e9 a6 02 00 00       	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  81272f:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  812732:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  812739:	eb 06                	jmp    812741 <_ZL11tcp_receiveP7tcp_pcb+0x9e4>
  81273b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  81273e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  812741:	b8 00 00 00 00       	mov    $0x0,%eax
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  812746:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  81274a:	66 39 3d 4c 14 b4 00 	cmp    %di,0xb4144c
  812751:	0f 86 7e 02 00 00    	jbe    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  812757:	c7 04 24 40 14 b4 00 	movl   $0xb41440,(%esp)
  81275e:	e8 ed 7b ff ff       	call   80a350 <tcp_seg_copy>
  812763:	89 c7                	mov    %eax,%edi
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  812765:	b8 00 00 00 00       	mov    $0x0,%eax
              if (inseg.len > next->len) {
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
  81276a:	85 ff                	test   %edi,%edi
  81276c:	0f 84 63 02 00 00    	je     8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                  cseg->next = next->next;
  812772:	8b 06                	mov    (%esi),%eax
  812774:	89 07                	mov    %eax,(%edi)
                  if (prev != NULL) {
  812776:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  81277a:	74 07                	je     812783 <_ZL11tcp_receiveP7tcp_pcb+0xa26>
                    prev->next = cseg;
  81277c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  81277f:	89 38                	mov    %edi,(%eax)
  812781:	eb 03                	jmp    812786 <_ZL11tcp_receiveP7tcp_pcb+0xa29>
                  } else {
                    pcb->ooseq = cseg;
  812783:	89 7b 7c             	mov    %edi,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  812786:	89 34 24             	mov    %esi,(%esp)
  812789:	e8 3e 7b ff ff       	call   80a2cc <tcp_seg_free>
                  if (cseg->next != NULL) {
  81278e:	8b 0f                	mov    (%edi),%ecx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  812790:	b8 00 00 00 00       	mov    $0x0,%eax
                    prev->next = cseg;
                  } else {
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
  812795:	85 c9                	test   %ecx,%ecx
  812797:	0f 84 38 02 00 00    	je     8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  81279d:	8b 15 34 14 b4 00    	mov    0xb41434,%edx
  8127a3:	8b 41 10             	mov    0x10(%ecx),%eax
  8127a6:	8b 48 04             	mov    0x4(%eax),%ecx
  8127a9:	0f b7 5f 0c          	movzwl 0xc(%edi),%ebx
  8127ad:	29 cb                	sub    %ecx,%ebx
  8127af:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  8127b1:	b8 00 00 00 00       	mov    $0x0,%eax
                    pcb->ooseq = cseg;
                  }
                  tcp_seg_free(next);
                  if (cseg->next != NULL) {
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  8127b6:	85 db                	test   %ebx,%ebx
  8127b8:	0f 8e 17 02 00 00    	jle    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  8127be:	89 c8                	mov    %ecx,%eax
  8127c0:	66 29 d0             	sub    %dx,%ax
  8127c3:	66 89 47 0c          	mov    %ax,0xc(%edi)
                      pbuf_realloc(cseg->p, cseg->len);
  8127c7:	0f b7 c0             	movzwl %ax,%eax
  8127ca:	89 44 24 04          	mov    %eax,0x4(%esp)
  8127ce:	8b 47 04             	mov    0x4(%edi),%eax
  8127d1:	89 04 24             	mov    %eax,(%esp)
  8127d4:	e8 06 6b ff ff       	call   8092df <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  8127d9:	b8 00 00 00 00       	mov    $0x0,%eax
  8127de:	e9 f2 01 00 00       	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  8127e3:	85 ff                	test   %edi,%edi
  8127e5:	75 62                	jne    812849 <_ZL11tcp_receiveP7tcp_pcb+0xaec>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  8127e7:	39 c2                	cmp    %eax,%edx
  8127e9:	0f 89 0d 01 00 00    	jns    8128fc <_ZL11tcp_receiveP7tcp_pcb+0xb9f>
  8127ef:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  8127f2:	8b 5d e0             	mov    -0x20(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  8127f5:	0f b7 0d 4c 14 b4 00 	movzwl 0xb4144c,%ecx
  8127fc:	01 d1                	add    %edx,%ecx
  8127fe:	29 c1                	sub    %eax,%ecx
  812800:	85 c9                	test   %ecx,%ecx
  812802:	7e 1d                	jle    812821 <_ZL11tcp_receiveP7tcp_pcb+0xac4>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  812804:	66 29 d0             	sub    %dx,%ax
  812807:	66 a3 4c 14 b4 00    	mov    %ax,0xb4144c
                    pbuf_realloc(inseg.p, inseg.len);
  81280d:	0f b7 c0             	movzwl %ax,%eax
  812810:	89 44 24 04          	mov    %eax,0x4(%esp)
  812814:	a1 44 14 b4 00       	mov    0xb41444,%eax
  812819:	89 04 24             	mov    %eax,(%esp)
  81281c:	e8 be 6a ff ff       	call   8092df <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  812821:	c7 04 24 40 14 b4 00 	movl   $0xb41440,(%esp)
  812828:	e8 23 7b ff ff       	call   80a350 <tcp_seg_copy>
  81282d:	89 c2                	mov    %eax,%edx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81282f:	b8 00 00 00 00       	mov    $0x0,%eax
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
                    pbuf_realloc(inseg.p, inseg.len);
                  }
                  cseg = tcp_seg_copy(&inseg);
                  if (cseg != NULL) {
  812834:	85 d2                	test   %edx,%edx
  812836:	0f 84 99 01 00 00    	je     8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                    cseg->next = next;
  81283c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  81283f:	89 0a                	mov    %ecx,(%edx)
                    pcb->ooseq = cseg;
  812841:	89 53 7c             	mov    %edx,0x7c(%ebx)
  812844:	e9 8c 01 00 00       	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  812849:	8b 77 10             	mov    0x10(%edi),%esi
  81284c:	8b 76 04             	mov    0x4(%esi),%esi
  81284f:	f7 d6                	not    %esi
  812851:	01 d6                	add    %edx,%esi
  812853:	0f 88 a3 00 00 00    	js     8128fc <_ZL11tcp_receiveP7tcp_pcb+0xb9f>
  812859:	89 de                	mov    %ebx,%esi
  81285b:	29 c6                	sub    %eax,%esi
  81285d:	85 f6                	test   %esi,%esi
  81285f:	0f 8f 97 00 00 00    	jg     8128fc <_ZL11tcp_receiveP7tcp_pcb+0xb9f>
  812865:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  812868:	0f b7 0d 4c 14 b4 00 	movzwl 0xb4144c,%ecx
  81286f:	01 d1                	add    %edx,%ecx
  812871:	29 c1                	sub    %eax,%ecx
  812873:	85 c9                	test   %ecx,%ecx
  812875:	7e 1d                	jle    812894 <_ZL11tcp_receiveP7tcp_pcb+0xb37>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  812877:	66 29 d0             	sub    %dx,%ax
  81287a:	66 a3 4c 14 b4 00    	mov    %ax,0xb4144c
                  pbuf_realloc(inseg.p, inseg.len);
  812880:	0f b7 c0             	movzwl %ax,%eax
  812883:	89 44 24 04          	mov    %eax,0x4(%esp)
  812887:	a1 44 14 b4 00       	mov    0xb41444,%eax
  81288c:	89 04 24             	mov    %eax,(%esp)
  81288f:	e8 4b 6a ff ff       	call   8092df <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  812894:	c7 04 24 40 14 b4 00 	movl   $0xb41440,(%esp)
  81289b:	e8 b0 7a ff ff       	call   80a350 <tcp_seg_copy>
  8128a0:	89 c2                	mov    %eax,%edx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  8128a2:	b8 00 00 00 00       	mov    $0x0,%eax
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
                  pbuf_realloc(inseg.p, inseg.len);
                }

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
  8128a7:	85 d2                	test   %edx,%edx
  8128a9:	0f 84 26 01 00 00    	je     8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                  cseg->next = next;
  8128af:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  8128b2:	89 32                	mov    %esi,(%edx)
                  prev->next = cseg;
  8128b4:	89 17                	mov    %edx,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  8128b6:	8b 47 10             	mov    0x10(%edi),%eax
  8128b9:	8b 50 04             	mov    0x4(%eax),%edx
  8128bc:	8b 0d 34 14 b4 00    	mov    0xb41434,%ecx
  8128c2:	0f b7 5f 0c          	movzwl 0xc(%edi),%ebx
  8128c6:	29 cb                	sub    %ecx,%ebx
  8128c8:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  8128ca:	b8 00 00 00 00       	mov    $0x0,%eax

                cseg = tcp_seg_copy(&inseg);
                if (cseg != NULL) {
                  cseg->next = next;
                  prev->next = cseg;
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  8128cf:	85 db                	test   %ebx,%ebx
  8128d1:	0f 8e fe 00 00 00    	jle    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  8128d7:	89 c8                	mov    %ecx,%eax
  8128d9:	66 29 d0             	sub    %dx,%ax
  8128dc:	66 89 47 0c          	mov    %ax,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  8128e0:	0f b7 c0             	movzwl %ax,%eax
  8128e3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8128e7:	8b 47 04             	mov    0x4(%edi),%eax
  8128ea:	89 04 24             	mov    %eax,(%esp)
  8128ed:	e8 ed 69 ff ff       	call   8092df <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  8128f2:	b8 00 00 00 00       	mov    $0x0,%eax
  8128f7:	e9 d9 00 00 00       	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  8128fc:	8b 31                	mov    (%ecx),%esi
  8128fe:	85 f6                	test   %esi,%esi
  812900:	75 70                	jne    812972 <_ZL11tcp_receiveP7tcp_pcb+0xc15>
  812902:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  812905:	29 c2                	sub    %eax,%edx
  812907:	85 d2                	test   %edx,%edx
  812909:	0f 8e c1 00 00 00    	jle    8129d0 <_ZL11tcp_receiveP7tcp_pcb+0xc73>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  81290f:	c7 04 24 40 14 b4 00 	movl   $0xb41440,(%esp)
  812916:	e8 35 7a ff ff       	call   80a350 <tcp_seg_copy>
  81291b:	89 c2                	mov    %eax,%edx
  81291d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  812920:	89 07                	mov    %eax,(%edi)
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  812922:	b8 00 00 00 00       	mov    $0x0,%eax
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
  812927:	85 d2                	test   %edx,%edx
  812929:	0f 84 a6 00 00 00    	je     8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  81292f:	8b 47 10             	mov    0x10(%edi),%eax
  812932:	8b 50 04             	mov    0x4(%eax),%edx
  812935:	8b 0d 34 14 b4 00    	mov    0xb41434,%ecx
  81293b:	0f b7 5f 0c          	movzwl 0xc(%edi),%ebx
  81293f:	29 cb                	sub    %ecx,%ebx
  812941:	01 d3                	add    %edx,%ebx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  812943:	b8 00 00 00 00       	mov    $0x0,%eax
                 of the list. */
              if (next->next == NULL &&
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
                if (next->next != NULL) {
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  812948:	85 db                	test   %ebx,%ebx
  81294a:	0f 8e 85 00 00 00    	jle    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  812950:	89 c8                	mov    %ecx,%eax
  812952:	66 29 d0             	sub    %dx,%ax
  812955:	66 89 47 0c          	mov    %ax,0xc(%edi)
                    pbuf_realloc(next->p, next->len);
  812959:	0f b7 c0             	movzwl %ax,%eax
  81295c:	89 44 24 04          	mov    %eax,0x4(%esp)
  812960:	8b 47 04             	mov    0x4(%edi),%eax
  812963:	89 04 24             	mov    %eax,(%esp)
  812966:	e8 74 69 ff ff       	call   8092df <pbuf_realloc>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  81296b:	b8 00 00 00 00       	mov    $0x0,%eax
  812970:	eb 63                	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  812972:	8b 46 10             	mov    0x10(%esi),%eax
  812975:	8b 40 04             	mov    0x4(%eax),%eax
  812978:	39 d0                	cmp    %edx,%eax
  81297a:	0f 84 bb fd ff ff    	je     81273b <_ZL11tcp_receiveP7tcp_pcb+0x9de>
  812980:	89 cf                	mov    %ecx,%edi
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  812982:	89 f1                	mov    %esi,%ecx
  812984:	e9 5a fe ff ff       	jmp    8127e3 <_ZL11tcp_receiveP7tcp_pcb+0xa86>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  812989:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81298d:	89 1c 24             	mov    %ebx,(%esp)
  812990:	e8 60 a4 ff ff       	call   80cdf5 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  812995:	b8 00 00 00 00       	mov    $0x0,%eax
  81299a:	eb 39                	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  81299c:	8b 15 34 14 b4 00    	mov    0xb41434,%edx
  8129a2:	8b 43 24             	mov    0x24(%ebx),%eax
  8129a5:	39 c2                	cmp    %eax,%edx
  8129a7:	78 14                	js     8129bd <_ZL11tcp_receiveP7tcp_pcb+0xc60>
  8129a9:	83 c2 01             	add    $0x1,%edx
  8129ac:	29 c2                	sub    %eax,%edx
  8129ae:	0f b7 43 28          	movzwl 0x28(%ebx),%eax
  8129b2:	29 c2                	sub    %eax,%edx
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  8129b4:	b8 00 00 00 00       	mov    $0x0,%eax
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  8129b9:	85 d2                	test   %edx,%edx
  8129bb:	7e 18                	jle    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
      tcp_ack_now(pcb);
  8129bd:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8129c1:	89 1c 24             	mov    %ebx,(%esp)
  8129c4:	e8 2c a4 ff ff       	call   80cdf5 <tcp_output>
  struct pbuf *p;
  s32_t off;
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;
  8129c9:	b8 00 00 00 00       	mov    $0x0,%eax
  8129ce:	eb 05                	jmp    8129d5 <_ZL11tcp_receiveP7tcp_pcb+0xc78>
  8129d0:	b8 00 00 00 00       	mov    $0x0,%eax
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
      tcp_ack_now(pcb);
    }
  }
  return accepted_inseq;
}
  8129d5:	83 c4 2c             	add    $0x2c,%esp
  8129d8:	5b                   	pop    %ebx
  8129d9:	5e                   	pop    %esi
  8129da:	5f                   	pop    %edi
  8129db:	5d                   	pop    %ebp
  8129dc:	c3                   	ret    
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  8129dd:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8129e1:	0f 85 4f f6 ff ff    	jne    812036 <_ZL11tcp_receiveP7tcp_pcb+0x2d9>
  8129e7:	e9 42 f6 ff ff       	jmp    81202e <_ZL11tcp_receiveP7tcp_pcb+0x2d1>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  8129ec:	8b 43 38             	mov    0x38(%ebx),%eax
  8129ef:	85 c0                	test   %eax,%eax
  8129f1:	0f 85 81 f7 ff ff    	jne    812178 <_ZL11tcp_receiveP7tcp_pcb+0x41b>
  8129f7:	e9 d7 f7 ff ff       	jmp    8121d3 <_ZL11tcp_receiveP7tcp_pcb+0x476>
  8129fc:	89 f3                	mov    %esi,%ebx
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  8129fe:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  812a02:	a8 01                	test   $0x1,%al
  812a04:	0f 84 c4 fc ff ff    	je     8126ce <_ZL11tcp_receiveP7tcp_pcb+0x971>
  812a0a:	e9 a4 fc ff ff       	jmp    8126b3 <_ZL11tcp_receiveP7tcp_pcb+0x956>

00812a0f <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  812a0f:	55                   	push   %ebp
  812a10:	89 e5                	mov    %esp,%ebp
  812a12:	57                   	push   %edi
  812a13:	56                   	push   %esi
  812a14:	53                   	push   %ebx
  812a15:	83 ec 4c             	sub    $0x4c,%esp
  812a18:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = (struct ip_hdr *)p->payload;
  812a1b:	8b 5e 04             	mov    0x4(%esi),%ebx
  812a1e:	89 1d 2c 14 b4 00    	mov    %ebx,0xb4142c
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  812a24:	0f b7 03             	movzwl (%ebx),%eax
  812a27:	89 04 24             	mov    %eax,(%esp)
  812a2a:	e8 97 99 ff ff       	call   80c3c6 <ntohs>
  812a2f:	c1 e8 06             	shr    $0x6,%eax
  812a32:	83 e0 3c             	and    $0x3c,%eax
  812a35:	01 c3                	add    %eax,%ebx
  812a37:	89 1d 30 14 b4 00    	mov    %ebx,0xb41430
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  812a3d:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  812a42:	0f b7 00             	movzwl (%eax),%eax
  812a45:	89 04 24             	mov    %eax,(%esp)
  812a48:	e8 79 99 ff ff       	call   80c3c6 <ntohs>
  812a4d:	c1 e8 06             	shr    $0x6,%eax
  812a50:	83 e0 3c             	and    $0x3c,%eax
  812a53:	f7 d8                	neg    %eax
  812a55:	98                   	cwtl   
  812a56:	89 44 24 04          	mov    %eax,0x4(%esp)
  812a5a:	89 34 24             	mov    %esi,(%esp)
  812a5d:	e8 ae 66 ff ff       	call   809110 <pbuf_header>
  812a62:	84 c0                	test   %al,%al
  812a64:	75 07                	jne    812a6d <tcp_input+0x5e>
  812a66:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  812a6b:	77 0d                	ja     812a7a <tcp_input+0x6b>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  812a6d:	89 34 24             	mov    %esi,(%esp)
  812a70:	e8 8e 67 ff ff       	call   809203 <pbuf_free>
    return;
  812a75:	e9 4c 0d 00 00       	jmp    8137c6 <tcp_input+0xdb7>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  812a7a:	8b 45 0c             	mov    0xc(%ebp),%eax
  812a7d:	89 44 24 04          	mov    %eax,0x4(%esp)
  812a81:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  812a86:	83 c0 10             	add    $0x10,%eax
  812a89:	89 04 24             	mov    %eax,(%esp)
  812a8c:	e8 4f 85 ff ff       	call   80afe0 <ip_addr_isbroadcast>
  812a91:	84 c0                	test   %al,%al
  812a93:	75 2c                	jne    812ac1 <tcp_input+0xb2>
  812a95:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  812a9a:	8b 78 10             	mov    0x10(%eax),%edi
      ip_addr_ismulticast(&(iphdr->dest))) {
  812a9d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  812aa4:	e8 90 9b ff ff       	call   80c639 <ntohl>
  812aa9:	89 c3                	mov    %eax,%ebx
  812aab:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  812ab2:	e8 82 9b ff ff       	call   80c639 <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  812ab7:	21 fb                	and    %edi,%ebx
  812ab9:	39 c3                	cmp    %eax,%ebx
  812abb:	0f 85 2e 0c 00 00    	jne    8136ef <tcp_input+0xce0>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  812ac1:	89 34 24             	mov    %esi,(%esp)
  812ac4:	e8 3a 67 ff ff       	call   809203 <pbuf_free>
    return;
  812ac9:	e9 f8 0c 00 00       	jmp    8137c6 <tcp_input+0xdb7>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  812ace:	89 34 24             	mov    %esi,(%esp)
  812ad1:	e8 2d 67 ff ff       	call   809203 <pbuf_free>
    return;
  812ad6:	e9 eb 0c 00 00       	jmp    8137c6 <tcp_input+0xdb7>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  812adb:	a1 30 14 b4 00       	mov    0xb41430,%eax
  812ae0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812ae4:	89 04 24             	mov    %eax,(%esp)
  812ae7:	e8 da 98 ff ff       	call   80c3c6 <ntohs>
  812aec:	0f b7 c0             	movzwl %ax,%eax
  if(pbuf_header(p, -(hdrlen * 4))){
  812aef:	c1 e8 0c             	shr    $0xc,%eax
  812af2:	f7 d8                	neg    %eax
  812af4:	c1 e0 02             	shl    $0x2,%eax
  812af7:	98                   	cwtl   
  812af8:	89 44 24 04          	mov    %eax,0x4(%esp)
  812afc:	89 34 24             	mov    %esi,(%esp)
  812aff:	e8 0c 66 ff ff       	call   809110 <pbuf_header>
  812b04:	84 c0                	test   %al,%al
  812b06:	74 0d                	je     812b15 <tcp_input+0x106>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  812b08:	89 34 24             	mov    %esi,(%esp)
  812b0b:	e8 f3 66 ff ff       	call   809203 <pbuf_free>
    return;
  812b10:	e9 b1 0c 00 00       	jmp    8137c6 <tcp_input+0xdb7>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  812b15:	8b 1d 30 14 b4 00    	mov    0xb41430,%ebx
  812b1b:	0f b7 03             	movzwl (%ebx),%eax
  812b1e:	89 04 24             	mov    %eax,(%esp)
  812b21:	e8 a0 98 ff ff       	call   80c3c6 <ntohs>
  812b26:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  812b29:	8b 1d 30 14 b4 00    	mov    0xb41430,%ebx
  812b2f:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  812b33:	89 04 24             	mov    %eax,(%esp)
  812b36:	e8 8b 98 ff ff       	call   80c3c6 <ntohs>
  812b3b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  812b3f:	8b 1d 30 14 b4 00    	mov    0xb41430,%ebx
  812b45:	8b 43 04             	mov    0x4(%ebx),%eax
  812b48:	89 04 24             	mov    %eax,(%esp)
  812b4b:	e8 e9 9a ff ff       	call   80c639 <ntohl>
  812b50:	89 43 04             	mov    %eax,0x4(%ebx)
  812b53:	a3 34 14 b4 00       	mov    %eax,0xb41434
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  812b58:	8b 1d 30 14 b4 00    	mov    0xb41430,%ebx
  812b5e:	8b 43 08             	mov    0x8(%ebx),%eax
  812b61:	89 04 24             	mov    %eax,(%esp)
  812b64:	e8 d0 9a ff ff       	call   80c639 <ntohl>
  812b69:	89 43 08             	mov    %eax,0x8(%ebx)
  812b6c:	a3 38 14 b4 00       	mov    %eax,0xb41438
  tcphdr->wnd = ntohs(tcphdr->wnd);
  812b71:	8b 1d 30 14 b4 00    	mov    0xb41430,%ebx
  812b77:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  812b7b:	89 04 24             	mov    %eax,(%esp)
  812b7e:	e8 43 98 ff ff       	call   80c3c6 <ntohs>
  812b83:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  812b87:	a1 30 14 b4 00       	mov    0xb41430,%eax
  812b8c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  812b90:	89 04 24             	mov    %eax,(%esp)
  812b93:	e8 2e 98 ff ff       	call   80c3c6 <ntohs>
  812b98:	83 e0 3f             	and    $0x3f,%eax
  812b9b:	a2 3c 14 b4 00       	mov    %al,0xb4143c
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  812ba0:	0f b6 c0             	movzbl %al,%eax
  812ba3:	89 45 c8             	mov    %eax,-0x38(%ebp)
  812ba6:	a8 03                	test   $0x3,%al
  812ba8:	0f 95 c0             	setne  %al
  812bab:	0f b6 c0             	movzbl %al,%eax
  812bae:	66 03 46 08          	add    0x8(%esi),%ax
  812bb2:	66 89 45 ce          	mov    %ax,-0x32(%ebp)
  812bb6:	66 a3 3e 14 b4 00    	mov    %ax,0xb4143e
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  812bbc:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
  812bc1:	89 45 d0             	mov    %eax,-0x30(%ebp)
  812bc4:	85 c0                	test   %eax,%eax
  812bc6:	0f 84 2c 01 00 00    	je     812cf8 <tcp_input+0x2e9>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  812bcc:	8b 40 10             	mov    0x10(%eax),%eax
  812bcf:	85 c0                	test   %eax,%eax
  812bd1:	74 16                	je     812be9 <tcp_input+0x1da>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  812bd3:	83 f8 0a             	cmp    $0xa,%eax
  812bd6:	74 32                	je     812c0a <tcp_input+0x1fb>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  812bd8:	83 f8 01             	cmp    $0x1,%eax
  812bdb:	75 6a                	jne    812c47 <tcp_input+0x238>
  812bdd:	8d 76 00             	lea    0x0(%esi),%esi
  812be0:	eb 49                	jmp    812c2b <tcp_input+0x21c>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  812be2:	8b 50 10             	mov    0x10(%eax),%edx
  812be5:	85 d2                	test   %edx,%edx
  812be7:	75 1c                	jne    812c05 <tcp_input+0x1f6>
  812be9:	c7 44 24 08 10 72 81 	movl   $0x817210,0x8(%esp)
  812bf0:	00 
  812bf1:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  812bf8:	00 
  812bf9:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812c00:	e8 b3 dd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  812c05:	83 fa 0a             	cmp    $0xa,%edx
  812c08:	75 1c                	jne    812c26 <tcp_input+0x217>
  812c0a:	c7 44 24 08 38 72 81 	movl   $0x817238,0x8(%esp)
  812c11:	00 
  812c12:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  812c19:	00 
  812c1a:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812c21:	e8 92 dd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  812c26:	83 fa 01             	cmp    $0x1,%edx
  812c29:	75 37                	jne    812c62 <tcp_input+0x253>
  812c2b:	c7 44 24 08 64 72 81 	movl   $0x817264,0x8(%esp)
  812c32:	00 
  812c33:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  812c3a:	00 
  812c3b:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812c42:	e8 71 dd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
    if (pcb->remote_port == tcphdr->src &&
  812c47:	8b 3d 30 14 b4 00    	mov    0xb41430,%edi
  812c4d:	0f b7 0f             	movzwl (%edi),%ecx
  812c50:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  812c55:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  812c58:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);

  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;
  812c5b:	ba 00 00 00 00       	mov    $0x0,%edx
  812c60:	eb 04                	jmp    812c66 <tcp_input+0x257>

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  812c62:	89 da                	mov    %ebx,%edx
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  812c64:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  812c66:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  812c6a:	75 77                	jne    812ce3 <tcp_input+0x2d4>
  812c6c:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  812c70:	66 39 43 1c          	cmp    %ax,0x1c(%ebx)
  812c74:	75 6d                	jne    812ce3 <tcp_input+0x2d4>
  812c76:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  812c79:	8b 40 0c             	mov    0xc(%eax),%eax
  812c7c:	39 43 04             	cmp    %eax,0x4(%ebx)
  812c7f:	75 62                	jne    812ce3 <tcp_input+0x2d4>
  812c81:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  812c84:	8b 40 10             	mov    0x10(%eax),%eax
  812c87:	39 03                	cmp    %eax,(%ebx)
  812c89:	75 58                	jne    812ce3 <tcp_input+0x2d4>
  812c8b:	89 d8                	mov    %ebx,%eax
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  812c8d:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  812c90:	39 d9                	cmp    %ebx,%ecx
  812c92:	75 1c                	jne    812cb0 <tcp_input+0x2a1>
  812c94:	c7 44 24 08 8c 72 81 	movl   $0x81728c,0x8(%esp)
  812c9b:	00 
  812c9c:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  812ca3:	00 
  812ca4:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812cab:	e8 08 dd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
      if (prev != NULL) {
  812cb0:	85 d2                	test   %edx,%edx
  812cb2:	74 3c                	je     812cf0 <tcp_input+0x2e1>
        prev->next = pcb->next;
  812cb4:	89 4a 0c             	mov    %ecx,0xc(%edx)
        pcb->next = tcp_active_pcbs;
  812cb7:	8b 55 d0             	mov    -0x30(%ebp),%edx
  812cba:	89 53 0c             	mov    %edx,0xc(%ebx)
        tcp_active_pcbs = pcb;
  812cbd:	89 1d dc a3 b3 00    	mov    %ebx,0xb3a3dc
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  812cc3:	39 da                	cmp    %ebx,%edx
  812cc5:	75 29                	jne    812cf0 <tcp_input+0x2e1>
  812cc7:	c7 44 24 08 b8 72 81 	movl   $0x8172b8,0x8(%esp)
  812cce:	00 
  812ccf:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  812cd6:	00 
  812cd7:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812cde:	e8 d5 dc fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  812ce3:	8b 43 0c             	mov    0xc(%ebx),%eax
  812ce6:	85 c0                	test   %eax,%eax
  812ce8:	0f 85 f4 fe ff ff    	jne    812be2 <tcp_input+0x1d3>
  812cee:	eb 08                	jmp    812cf8 <tcp_input+0x2e9>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  812cf0:	85 c0                	test   %eax,%eax
  812cf2:	0f 85 98 02 00 00    	jne    812f90 <tcp_input+0x581>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  812cf8:	8b 1d e0 a3 b3 00    	mov    0xb3a3e0,%ebx
  812cfe:	85 db                	test   %ebx,%ebx
  812d00:	0f 84 a1 00 00 00    	je     812da7 <tcp_input+0x398>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  812d06:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  812d0a:	74 24                	je     812d30 <tcp_input+0x321>
  812d0c:	eb 06                	jmp    812d14 <tcp_input+0x305>
  812d0e:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  812d12:	74 2b                	je     812d3f <tcp_input+0x330>
  812d14:	c7 44 24 08 e4 72 81 	movl   $0x8172e4,0x8(%esp)
  812d1b:	00 
  812d1c:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  812d23:	00 
  812d24:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  812d2b:	e8 88 dc fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
      if (pcb->remote_port == tcphdr->src &&
  812d30:	8b 15 30 14 b4 00    	mov    0xb41430,%edx
  812d36:	0f b7 02             	movzwl (%edx),%eax
  812d39:	8b 0d 2c 14 b4 00    	mov    0xb4142c,%ecx
  812d3f:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  812d43:	75 57                	jne    812d9c <tcp_input+0x38d>
  812d45:	0f b7 7a 02          	movzwl 0x2(%edx),%edi
  812d49:	66 39 7b 1c          	cmp    %di,0x1c(%ebx)
  812d4d:	75 4d                	jne    812d9c <tcp_input+0x38d>
  812d4f:	8b 79 0c             	mov    0xc(%ecx),%edi
  812d52:	39 7b 04             	cmp    %edi,0x4(%ebx)
  812d55:	75 45                	jne    812d9c <tcp_input+0x38d>
  812d57:	8b 79 10             	mov    0x10(%ecx),%edi
  812d5a:	39 3b                	cmp    %edi,(%ebx)
  812d5c:	75 3e                	jne    812d9c <tcp_input+0x38d>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  812d5e:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  812d62:	03 05 34 14 b4 00    	add    0xb41434,%eax
  812d68:	89 c2                	mov    %eax,%edx
  812d6a:	2b 53 24             	sub    0x24(%ebx),%edx
  812d6d:	85 d2                	test   %edx,%edx
  812d6f:	7e 03                	jle    812d74 <tcp_input+0x365>
    pcb->rcv_nxt = seqno + tcplen;
  812d71:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  812d74:	66 83 7d ce 00       	cmpw   $0x0,-0x32(%ebp)
  812d79:	74 0c                	je     812d87 <tcp_input+0x378>
    tcp_ack_now(pcb);
  812d7b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  812d7f:	89 1c 24             	mov    %ebx,(%esp)
  812d82:	e8 6e a0 ff ff       	call   80cdf5 <tcp_output>
  }
  return tcp_output(pcb);
  812d87:	89 1c 24             	mov    %ebx,(%esp)
  812d8a:	e8 66 a0 ff ff       	call   80cdf5 <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  812d8f:	89 34 24             	mov    %esi,(%esp)
  812d92:	e8 6c 64 ff ff       	call   809203 <pbuf_free>
        return;
  812d97:	e9 2a 0a 00 00       	jmp    8137c6 <tcp_input+0xdb7>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  812d9c:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  812d9f:	85 db                	test   %ebx,%ebx
  812da1:	0f 85 67 ff ff ff    	jne    812d0e <tcp_input+0x2ff>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  812da7:	a1 d8 a3 b3 00       	mov    0xb3a3d8,%eax
  812dac:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  812daf:	85 c0                	test   %eax,%eax
  812db1:	0f 84 d1 01 00 00    	je     812f88 <tcp_input+0x579>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  812db7:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  812dbc:	8b 0d 30 14 b4 00    	mov    0xb41430,%ecx
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  812dc2:	8b 7d d4             	mov    -0x2c(%ebp),%edi
      }
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
  812dc5:	ba 00 00 00 00       	mov    $0x0,%edx
  812dca:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  812dcd:	89 c3                	mov    %eax,%ebx
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  812dcf:	85 ff                	test   %edi,%edi
  812dd1:	74 0f                	je     812de2 <tcp_input+0x3d3>
  812dd3:	8b 07                	mov    (%edi),%eax
  812dd5:	85 c0                	test   %eax,%eax
  812dd7:	74 09                	je     812de2 <tcp_input+0x3d3>
  812dd9:	3b 43 10             	cmp    0x10(%ebx),%eax
  812ddc:	0f 85 93 01 00 00    	jne    812f75 <tcp_input+0x566>
  812de2:	0f b7 41 02          	movzwl 0x2(%ecx),%eax
  812de6:	66 39 47 1c          	cmp    %ax,0x1c(%edi)
  812dea:	0f 85 85 01 00 00    	jne    812f75 <tcp_input+0x566>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
        lpcb->local_port == tcphdr->dest) {
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  812df0:	85 d2                	test   %edx,%edx
  812df2:	74 12                	je     812e06 <tcp_input+0x3f7>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  812df4:	8b 47 0c             	mov    0xc(%edi),%eax
  812df7:	89 42 0c             	mov    %eax,0xc(%edx)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  812dfa:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  812dfd:	89 57 0c             	mov    %edx,0xc(%edi)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  812e00:	89 3d d8 a3 b3 00    	mov    %edi,0xb3a3d8
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  812e06:	f6 45 c8 10          	testb  $0x10,-0x38(%ebp)
  812e0a:	74 45                	je     812e51 <tcp_input+0x442>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  812e0c:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  812e11:	0f b7 11             	movzwl (%ecx),%edx
  812e14:	89 54 24 14          	mov    %edx,0x14(%esp)
  812e18:	0f b7 51 02          	movzwl 0x2(%ecx),%edx
  812e1c:	89 54 24 10          	mov    %edx,0x10(%esp)
  812e20:	8d 50 0c             	lea    0xc(%eax),%edx
  812e23:	89 54 24 0c          	mov    %edx,0xc(%esp)
  812e27:	83 c0 10             	add    $0x10,%eax
  812e2a:	89 44 24 08          	mov    %eax,0x8(%esp)
  812e2e:	0f b7 45 ce          	movzwl -0x32(%ebp),%eax
  812e32:	03 05 34 14 b4 00    	add    0xb41434,%eax
  812e38:	89 44 24 04          	mov    %eax,0x4(%esp)
  812e3c:	a1 38 14 b4 00       	mov    0xb41438,%eax
  812e41:	83 c0 01             	add    $0x1,%eax
  812e44:	89 04 24             	mov    %eax,(%esp)
  812e47:	e8 44 a4 ff ff       	call   80d290 <tcp_rst>
  812e4c:	e9 17 01 00 00       	jmp    812f68 <tcp_input+0x559>
  } else if (flags & TCP_SYN) {
  812e51:	f6 45 c8 02          	testb  $0x2,-0x38(%ebp)
  812e55:	0f 84 0d 01 00 00    	je     812f68 <tcp_input+0x559>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  812e5b:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  812e5f:	89 04 24             	mov    %eax,(%esp)
  812e62:	e8 2c 7e ff ff       	call   80ac93 <tcp_alloc>
  812e67:	89 c3                	mov    %eax,%ebx
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  812e69:	85 c0                	test   %eax,%eax
  812e6b:	0f 84 f7 00 00 00    	je     812f68 <tcp_input+0x559>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  812e71:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  812e76:	ba 00 00 00 00       	mov    $0x0,%edx
  812e7b:	83 f8 f0             	cmp    $0xfffffff0,%eax
  812e7e:	74 03                	je     812e83 <tcp_input+0x474>
  812e80:	8b 50 10             	mov    0x10(%eax),%edx
  812e83:	89 13                	mov    %edx,(%ebx)
    npcb->local_port = pcb->local_port;
  812e85:	0f b7 57 1c          	movzwl 0x1c(%edi),%edx
  812e89:	66 89 53 1c          	mov    %dx,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  812e8d:	ba 00 00 00 00       	mov    $0x0,%edx
  812e92:	83 f8 f4             	cmp    $0xfffffff4,%eax
  812e95:	74 03                	je     812e9a <tcp_input+0x48b>
  812e97:	8b 50 0c             	mov    0xc(%eax),%edx
  812e9a:	89 53 04             	mov    %edx,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  812e9d:	8b 15 30 14 b4 00    	mov    0xb41430,%edx
  812ea3:	0f b7 02             	movzwl (%edx),%eax
  812ea6:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  812eaa:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  812eb1:	a1 34 14 b4 00       	mov    0xb41434,%eax
  812eb6:	8d 48 01             	lea    0x1(%eax),%ecx
  812eb9:	89 4b 24             	mov    %ecx,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  812ebc:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  812ec0:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  812ec4:	66 89 53 50          	mov    %dx,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  812ec8:	83 e8 01             	sub    $0x1,%eax
  812ecb:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  812ece:	8b 47 18             	mov    0x18(%edi),%eax
  812ed1:	89 43 18             	mov    %eax,0x18(%ebx)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  812ed4:	8b 47 20             	mov    0x20(%edi),%eax
  812ed7:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  812edd:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  812ee1:	66 25 99 01          	and    $0x199,%ax
  812ee5:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  812ee9:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
  812eee:	89 43 0c             	mov    %eax,0xc(%ebx)
  812ef1:	89 1d dc a3 b3 00    	mov    %ebx,0xb3a3dc
  812ef7:	e8 21 39 ff ff       	call   80681d <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  812efc:	89 d8                	mov    %ebx,%eax
  812efe:	e8 ad ed ff ff       	call   811cb0 <_ZL12tcp_parseoptP7tcp_pcb>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  812f03:	8d 43 04             	lea    0x4(%ebx),%eax
  812f06:	89 44 24 04          	mov    %eax,0x4(%esp)
  812f0a:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  812f0e:	89 04 24             	mov    %eax,(%esp)
  812f11:	e8 1f 7f ff ff       	call   80ae35 <tcp_eff_send_mss>
  812f16:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  812f1a:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  812f21:	e8 b4 94 ff ff       	call   80c3da <htonl>
  812f26:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  812f29:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  812f30:	00 
  812f31:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  812f34:	89 44 24 14          	mov    %eax,0x14(%esp)
  812f38:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  812f3f:	00 
  812f40:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  812f47:	00 
  812f48:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  812f4f:	00 
  812f50:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  812f57:	00 
  812f58:	89 1c 24             	mov    %ebx,(%esp)
  812f5b:	e8 f0 96 ff ff       	call   80c650 <tcp_enqueue>
    return tcp_output(npcb);
  812f60:	89 1c 24             	mov    %ebx,(%esp)
  812f63:	e8 8d 9e ff ff       	call   80cdf5 <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  812f68:	89 34 24             	mov    %esi,(%esp)
  812f6b:	e8 93 62 ff ff       	call   809203 <pbuf_free>
        return;
  812f70:	e9 51 08 00 00       	jmp    8137c6 <tcp_input+0xdb7>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  812f75:	8b 47 0c             	mov    0xc(%edi),%eax
  812f78:	85 c0                	test   %eax,%eax
  812f7a:	74 09                	je     812f85 <tcp_input+0x576>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
  812f7c:	89 fa                	mov    %edi,%edx
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  812f7e:	89 c7                	mov    %eax,%edi
  812f80:	e9 4a fe ff ff       	jmp    812dcf <tcp_input+0x3c0>
  812f85:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  812f88:	85 db                	test   %ebx,%ebx
  812f8a:	0f 84 f7 06 00 00    	je     813687 <tcp_input+0xc78>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  812f90:	c7 05 40 14 b4 00 00 	movl   $0x0,0xb41440
  812f97:	00 00 00 
    inseg.len = p->tot_len;
  812f9a:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  812f9e:	66 a3 4c 14 b4 00    	mov    %ax,0xb4144c
    inseg.dataptr = p->payload;
  812fa4:	8b 46 04             	mov    0x4(%esi),%eax
  812fa7:	a3 48 14 b4 00       	mov    %eax,0xb41448
    inseg.p = p;
  812fac:	89 35 44 14 b4 00    	mov    %esi,0xb41444
    inseg.tcphdr = tcphdr;
  812fb2:	a1 30 14 b4 00       	mov    0xb41430,%eax
  812fb7:	a3 50 14 b4 00       	mov    %eax,0xb41450

    recv_data = NULL;
  812fbc:	c7 05 54 14 b4 00 00 	movl   $0x0,0xb41454
  812fc3:	00 00 00 
    recv_flags = 0;
  812fc6:	c6 05 58 14 b4 00 00 	movb   $0x0,0xb41458

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  812fcd:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  812fd3:	85 c0                	test   %eax,%eax
  812fd5:	74 49                	je     813020 <tcp_input+0x611>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  812fd7:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  812fdd:	85 d2                	test   %edx,%edx
  812fdf:	74 1e                	je     812fff <tcp_input+0x5f0>
  812fe1:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  812fe8:	00 
  812fe9:	89 44 24 08          	mov    %eax,0x8(%esp)
  812fed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  812ff1:	8b 43 18             	mov    0x18(%ebx),%eax
  812ff4:	89 04 24             	mov    %eax,(%esp)
  812ff7:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  812ff9:	84 c0                	test   %al,%al
  812ffb:	74 0a                	je     813007 <tcp_input+0x5f8>
  812ffd:	eb 14                	jmp    813013 <tcp_input+0x604>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  812fff:	89 04 24             	mov    %eax,(%esp)
  813002:	e8 fc 61 ff ff       	call   809203 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  813007:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  81300e:	00 00 00 
  813011:	eb 0d                	jmp    813020 <tcp_input+0x611>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  813013:	89 34 24             	mov    %esi,(%esp)
  813016:	e8 e8 61 ff ff       	call   809203 <pbuf_free>
        return;
  81301b:	e9 a6 07 00 00       	jmp    8137c6 <tcp_input+0xdb7>
      }
    }

    tcp_input_pcb = pcb;
  813020:	89 1d 28 14 b4 00    	mov    %ebx,0xb41428
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  813026:	0f b6 05 3c 14 b4 00 	movzbl 0xb4143c,%eax
  81302d:	a8 04                	test   $0x4,%al
  81302f:	74 68                	je     813099 <tcp_input+0x68a>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  813031:	8b 43 10             	mov    0x10(%ebx),%eax
  813034:	83 f8 02             	cmp    $0x2,%eax
  813037:	75 0e                	jne    813047 <tcp_input+0x638>
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  813039:	8b 3d 38 14 b4 00    	mov    0xb41438,%edi
  81303f:	39 7b 54             	cmp    %edi,0x54(%ebx)
  813042:	0f 94 c2             	sete   %dl
  813045:	eb 1a                	jmp    813061 <tcp_input+0x652>
    if (pcb->state == SYN_SENT) {
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  813047:	8b 15 34 14 b4 00    	mov    0xb41434,%edx
  81304d:	2b 53 24             	sub    0x24(%ebx),%edx
  813050:	0f 88 61 07 00 00    	js     8137b7 <tcp_input+0xda8>
  813056:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  81305a:	29 ca                	sub    %ecx,%edx
 */
static err_t
tcp_process(struct tcp_pcb *pcb)
{
  struct tcp_seg *rseg;
  u8_t acceptable = 0;
  81305c:	85 d2                	test   %edx,%edx
  81305e:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  813061:	84 d2                	test   %dl,%dl
  813063:	0f 84 4e 07 00 00    	je     8137b7 <tcp_input+0xda8>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  813069:	85 c0                	test   %eax,%eax
  81306b:	75 1c                	jne    813089 <tcp_input+0x67a>
  81306d:	c7 44 24 08 14 73 81 	movl   $0x817314,0x8(%esp)
  813074:	00 
  813075:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  81307c:	00 
  81307d:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  813084:	e8 2f d9 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
      recv_flags = TF_RESET;
  813089:	c6 05 58 14 b4 00 08 	movb   $0x8,0xb41458
      pcb->flags &= ~TF_ACK_DELAY;
  813090:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  813094:	e9 1e 07 00 00       	jmp    8137b7 <tcp_input+0xda8>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  813099:	8b 15 d0 a3 b3 00    	mov    0xb3a3d0,%edx
  81309f:	89 53 2c             	mov    %edx,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  8130a2:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  8130a9:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  8130ad:	0f 87 72 04 00 00    	ja     813525 <tcp_input+0xb16>
  8130b3:	8b 53 10             	mov    0x10(%ebx),%edx
  8130b6:	ff 24 95 b8 73 81 00 	jmp    *0x8173b8(,%edx,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  8130bd:	83 e0 12             	and    $0x12,%eax
  8130c0:	83 f8 12             	cmp    $0x12,%eax
  8130c3:	75 20                	jne    8130e5 <tcp_input+0x6d6>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  8130c5:	8b 43 78             	mov    0x78(%ebx),%eax
  8130c8:	8b 40 10             	mov    0x10(%eax),%eax
  8130cb:	8b 40 04             	mov    0x4(%eax),%eax
  8130ce:	89 04 24             	mov    %eax,(%esp)
  8130d1:	e8 63 95 ff ff       	call   80c639 <ntohl>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  8130d6:	83 c0 01             	add    $0x1,%eax
  8130d9:	3b 05 38 14 b4 00    	cmp    0xb41438,%eax
  8130df:	0f 84 43 06 00 00    	je     813728 <tcp_input+0xd19>
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  8130e5:	f6 05 3c 14 b4 00 10 	testb  $0x10,0xb4143c
  8130ec:	0f 84 c5 06 00 00    	je     8137b7 <tcp_input+0xda8>
  8130f2:	eb 78                	jmp    81316c <tcp_input+0x75d>
      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  8130f4:	c7 44 24 08 8d 73 81 	movl   $0x81738d,0x8(%esp)
  8130fb:	00 
  8130fc:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  813103:	00 
  813104:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  81310b:	e8 a8 d8 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
      --pcb->snd_queuelen;
  813110:	83 e8 01             	sub    $0x1,%eax
  813113:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  813117:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  81311a:	8b 10                	mov    (%eax),%edx
  81311c:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81311f:	85 d2                	test   %edx,%edx
  813121:	75 08                	jne    81312b <tcp_input+0x71c>
        pcb->rtime = -1;
  813123:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  813129:	eb 0a                	jmp    813135 <tcp_input+0x726>
      else {
        pcb->rtime = 0;
  81312b:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  813131:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  813135:	89 04 24             	mov    %eax,(%esp)
  813138:	e8 8f 71 ff ff       	call   80a2cc <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  81313d:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  813143:	85 c0                	test   %eax,%eax
  813145:	74 14                	je     81315b <tcp_input+0x74c>
  813147:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81314e:	00 
  81314f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  813153:	8b 53 18             	mov    0x18(%ebx),%edx
  813156:	89 14 24             	mov    %edx,(%esp)
  813159:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  81315b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81315f:	89 1c 24             	mov    %ebx,(%esp)
  813162:	e8 8e 9c ff ff       	call   80cdf5 <tcp_output>
  813167:	e9 4b 06 00 00       	jmp    8137b7 <tcp_input+0xda8>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81316c:	8b 15 30 14 b4 00    	mov    0xb41430,%edx
  813172:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  813177:	0f b7 0a             	movzwl (%edx),%ecx
  81317a:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  81317e:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  813182:	89 54 24 10          	mov    %edx,0x10(%esp)
  813186:	8d 50 0c             	lea    0xc(%eax),%edx
  813189:	89 54 24 0c          	mov    %edx,0xc(%esp)
  81318d:	83 c0 10             	add    $0x10,%eax
  813190:	89 44 24 08          	mov    %eax,0x8(%esp)
  813194:	0f b7 05 3e 14 b4 00 	movzwl 0xb4143e,%eax
  81319b:	03 05 34 14 b4 00    	add    0xb41434,%eax
  8131a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8131a5:	a1 38 14 b4 00       	mov    0xb41438,%eax
  8131aa:	89 04 24             	mov    %eax,(%esp)
  8131ad:	e8 de a0 ff ff       	call   80d290 <tcp_rst>
  8131b2:	e9 00 06 00 00       	jmp    8137b7 <tcp_input+0xda8>
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  8131b7:	83 e0 14             	and    $0x14,%eax
  8131ba:	83 f8 10             	cmp    $0x10,%eax
  8131bd:	0f 85 f4 05 00 00    	jne    8137b7 <tcp_input+0xda8>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  8131c3:	a1 38 14 b4 00       	mov    0xb41438,%eax
  8131c8:	8b 53 48             	mov    0x48(%ebx),%edx
  8131cb:	f7 d2                	not    %edx
  8131cd:	01 c2                	add    %eax,%edx
  8131cf:	0f 88 b7 00 00 00    	js     81328c <tcp_input+0x87d>
  8131d5:	89 c2                	mov    %eax,%edx
  8131d7:	2b 53 54             	sub    0x54(%ebx),%edx
  8131da:	85 d2                	test   %edx,%edx
  8131dc:	0f 8f aa 00 00 00    	jg     81328c <tcp_input+0x87d>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  8131e2:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  8131e9:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  8131ef:	85 c0                	test   %eax,%eax
  8131f1:	75 1c                	jne    81320f <tcp_input+0x800>
  8131f3:	c7 44 24 08 a3 73 81 	movl   $0x8173a3,0x8(%esp)
  8131fa:	00 
  8131fb:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  813202:	00 
  813203:	c7 04 24 34 73 81 00 	movl   $0x817334,(%esp)
  81320a:	e8 a9 d7 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  81320f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  813216:	00 
  813217:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81321b:	8b 53 18             	mov    0x18(%ebx),%edx
  81321e:	89 14 24             	mov    %edx,(%esp)
  813221:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  813223:	84 c0                	test   %al,%al
  813225:	74 17                	je     81323e <tcp_input+0x82f>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  813227:	89 1c 24             	mov    %ebx,(%esp)
  81322a:	e8 3f 73 ff ff       	call   80a56e <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  81322f:	c7 05 28 14 b4 00 00 	movl   $0x0,0xb41428
  813236:	00 00 00 
  813239:	e9 25 04 00 00       	jmp    813663 <tcp_input+0xc54>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  81323e:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  813242:	89 d8                	mov    %ebx,%eax
  813244:	e8 14 eb ff ff       	call   811d5d <_ZL11tcp_receiveP7tcp_pcb>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  813249:	66 83 fe 01          	cmp    $0x1,%si
  81324d:	75 08                	jne    813257 <tcp_input+0x848>
  81324f:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  813253:	01 d2                	add    %edx,%edx
  813255:	eb 04                	jmp    81325b <tcp_input+0x84c>
  813257:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  81325b:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  81325f:	f6 05 3c 14 b4 00 01 	testb  $0x1,0xb4143c
  813266:	0f 84 4b 05 00 00    	je     8137b7 <tcp_input+0xda8>
  81326c:	84 c0                	test   %al,%al
  81326e:	0f 84 43 05 00 00    	je     8137b7 <tcp_input+0xda8>
          tcp_ack_now(pcb);
  813274:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  813278:	89 1c 24             	mov    %ebx,(%esp)
  81327b:	e8 75 9b ff ff       	call   80cdf5 <tcp_output>
          pcb->state = CLOSE_WAIT;
  813280:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  813287:	e9 2b 05 00 00       	jmp    8137b7 <tcp_input+0xda8>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  81328c:	8b 0d 30 14 b4 00    	mov    0xb41430,%ecx
  813292:	8b 15 2c 14 b4 00    	mov    0xb4142c,%edx
  813298:	0f b7 31             	movzwl (%ecx),%esi
  81329b:	89 74 24 14          	mov    %esi,0x14(%esp)
  81329f:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  8132a3:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  8132a7:	8d 4a 0c             	lea    0xc(%edx),%ecx
  8132aa:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  8132ae:	83 c2 10             	add    $0x10,%edx
  8132b1:	89 54 24 08          	mov    %edx,0x8(%esp)
  8132b5:	0f b7 15 3e 14 b4 00 	movzwl 0xb4143e,%edx
  8132bc:	03 15 34 14 b4 00    	add    0xb41434,%edx
  8132c2:	89 54 24 04          	mov    %edx,0x4(%esp)
  8132c6:	89 04 24             	mov    %eax,(%esp)
  8132c9:	e8 c2 9f ff ff       	call   80d290 <tcp_rst>
  8132ce:	e9 e4 04 00 00       	jmp    8137b7 <tcp_input+0xda8>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  8132d3:	89 d8                	mov    %ebx,%eax
  8132d5:	e8 83 ea ff ff       	call   811d5d <_ZL11tcp_receiveP7tcp_pcb>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  8132da:	f6 05 3c 14 b4 00 01 	testb  $0x1,0xb4143c
  8132e1:	0f 84 d0 04 00 00    	je     8137b7 <tcp_input+0xda8>
  8132e7:	84 c0                	test   %al,%al
  8132e9:	0f 84 c8 04 00 00    	je     8137b7 <tcp_input+0xda8>
      tcp_ack_now(pcb);
  8132ef:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8132f3:	89 1c 24             	mov    %ebx,(%esp)
  8132f6:	e8 fa 9a ff ff       	call   80cdf5 <tcp_output>
      pcb->state = CLOSE_WAIT;
  8132fb:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  813302:	e9 b0 04 00 00       	jmp    8137b7 <tcp_input+0xda8>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  813307:	89 d8                	mov    %ebx,%eax
  813309:	e8 4f ea ff ff       	call   811d5d <_ZL11tcp_receiveP7tcp_pcb>
    if (flags & TCP_FIN) {
  81330e:	0f b6 05 3c 14 b4 00 	movzbl 0xb4143c,%eax
  813315:	a8 01                	test   $0x1,%al
  813317:	0f 84 9a 00 00 00    	je     8133b7 <tcp_input+0x9a8>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81331d:	a8 10                	test   $0x10,%al
  81331f:	74 7e                	je     81339f <tcp_input+0x990>
  813321:	a1 38 14 b4 00       	mov    0xb41438,%eax
  813326:	39 43 54             	cmp    %eax,0x54(%ebx)
  813329:	75 74                	jne    81339f <tcp_input+0x990>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  81332b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81332f:	89 1c 24             	mov    %ebx,(%esp)
  813332:	e8 be 9a ff ff       	call   80cdf5 <tcp_output>
        tcp_pcb_purge(pcb);
  813337:	89 1c 24             	mov    %ebx,(%esp)
  81333a:	e8 ba 70 ff ff       	call   80a3f9 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  81333f:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
  813344:	39 c3                	cmp    %eax,%ebx
  813346:	75 0a                	jne    813352 <tcp_input+0x943>
  813348:	8b 43 0c             	mov    0xc(%ebx),%eax
  81334b:	a3 dc a3 b3 00       	mov    %eax,0xb3a3dc
  813350:	eb 2e                	jmp    813380 <tcp_input+0x971>
  813352:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  813357:	eb 1e                	jmp    813377 <tcp_input+0x968>
  813359:	8b 50 0c             	mov    0xc(%eax),%edx
  81335c:	85 d2                	test   %edx,%edx
  81335e:	74 11                	je     813371 <tcp_input+0x962>
  813360:	39 d3                	cmp    %edx,%ebx
  813362:	75 11                	jne    813375 <tcp_input+0x966>
  813364:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  813369:	8b 53 0c             	mov    0xc(%ebx),%edx
  81336c:	89 50 0c             	mov    %edx,0xc(%eax)
  81336f:	eb 0f                	jmp    813380 <tcp_input+0x971>
  813371:	89 d0                	mov    %edx,%eax
  813373:	eb 02                	jmp    813377 <tcp_input+0x968>
  813375:	89 d0                	mov    %edx,%eax
  813377:	85 c0                	test   %eax,%eax
  813379:	75 de                	jne    813359 <tcp_input+0x94a>
  81337b:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
        pcb->state = TIME_WAIT;
  813380:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  813387:	a1 e0 a3 b3 00       	mov    0xb3a3e0,%eax
  81338c:	89 43 0c             	mov    %eax,0xc(%ebx)
  81338f:	89 1d e0 a3 b3 00    	mov    %ebx,0xb3a3e0
  813395:	e8 83 34 ff ff       	call   80681d <tcp_timer_needed>
  81339a:	e9 18 04 00 00       	jmp    8137b7 <tcp_input+0xda8>
      } else {
        tcp_ack_now(pcb);
  81339f:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8133a3:	89 1c 24             	mov    %ebx,(%esp)
  8133a6:	e8 4a 9a ff ff       	call   80cdf5 <tcp_output>
        pcb->state = CLOSING;
  8133ab:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  8133b2:	e9 00 04 00 00       	jmp    8137b7 <tcp_input+0xda8>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8133b7:	a8 10                	test   $0x10,%al
  8133b9:	0f 84 f8 03 00 00    	je     8137b7 <tcp_input+0xda8>
  8133bf:	8b 15 38 14 b4 00    	mov    0xb41438,%edx
  8133c5:	39 53 54             	cmp    %edx,0x54(%ebx)
  8133c8:	0f 85 e9 03 00 00    	jne    8137b7 <tcp_input+0xda8>
      pcb->state = FIN_WAIT_2;
  8133ce:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  8133d5:	e9 dd 03 00 00       	jmp    8137b7 <tcp_input+0xda8>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  8133da:	89 d8                	mov    %ebx,%eax
  8133dc:	e8 7c e9 ff ff       	call   811d5d <_ZL11tcp_receiveP7tcp_pcb>
    if (flags & TCP_FIN) {
  8133e1:	f6 05 3c 14 b4 00 01 	testb  $0x1,0xb4143c
  8133e8:	0f 84 c9 03 00 00    	je     8137b7 <tcp_input+0xda8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8133ee:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8133f2:	89 1c 24             	mov    %ebx,(%esp)
  8133f5:	e8 fb 99 ff ff       	call   80cdf5 <tcp_output>
      tcp_pcb_purge(pcb);
  8133fa:	89 1c 24             	mov    %ebx,(%esp)
  8133fd:	e8 f7 6f ff ff       	call   80a3f9 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  813402:	8b 15 dc a3 b3 00    	mov    0xb3a3dc,%edx
  813408:	39 d3                	cmp    %edx,%ebx
  81340a:	75 0a                	jne    813416 <tcp_input+0xa07>
  81340c:	8b 43 0c             	mov    0xc(%ebx),%eax
  81340f:	a3 dc a3 b3 00       	mov    %eax,0xb3a3dc
  813414:	eb 2d                	jmp    813443 <tcp_input+0xa34>
  813416:	89 15 e4 a3 b3 00    	mov    %edx,0xb3a3e4
  81341c:	89 d1                	mov    %edx,%ecx
  81341e:	85 d2                	test   %edx,%edx
  813420:	75 06                	jne    813428 <tcp_input+0xa19>
  813422:	eb 1f                	jmp    813443 <tcp_input+0xa34>
  813424:	89 c1                	mov    %eax,%ecx
  813426:	89 c2                	mov    %eax,%edx
  813428:	8b 42 0c             	mov    0xc(%edx),%eax
  81342b:	85 c0                	test   %eax,%eax
  81342d:	0f 84 6f 03 00 00    	je     8137a2 <tcp_input+0xd93>
  813433:	39 c3                	cmp    %eax,%ebx
  813435:	75 ed                	jne    813424 <tcp_input+0xa15>
  813437:	89 0d e4 a3 b3 00    	mov    %ecx,0xb3a3e4
  81343d:	8b 43 0c             	mov    0xc(%ebx),%eax
  813440:	89 42 0c             	mov    %eax,0xc(%edx)
      pcb->state = TIME_WAIT;
  813443:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81344a:	a1 e0 a3 b3 00       	mov    0xb3a3e0,%eax
  81344f:	89 43 0c             	mov    %eax,0xc(%ebx)
  813452:	89 1d e0 a3 b3 00    	mov    %ebx,0xb3a3e0
  813458:	e8 c0 33 ff ff       	call   80681d <tcp_timer_needed>
  81345d:	e9 55 03 00 00       	jmp    8137b7 <tcp_input+0xda8>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  813462:	89 d8                	mov    %ebx,%eax
  813464:	e8 f4 e8 ff ff       	call   811d5d <_ZL11tcp_receiveP7tcp_pcb>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  813469:	f6 05 3c 14 b4 00 10 	testb  $0x10,0xb4143c
  813470:	0f 84 41 03 00 00    	je     8137b7 <tcp_input+0xda8>
  813476:	8b 3d 38 14 b4 00    	mov    0xb41438,%edi
  81347c:	39 7b 54             	cmp    %edi,0x54(%ebx)
  81347f:	0f 85 32 03 00 00    	jne    8137b7 <tcp_input+0xda8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  813485:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  813489:	89 1c 24             	mov    %ebx,(%esp)
  81348c:	e8 64 99 ff ff       	call   80cdf5 <tcp_output>
      tcp_pcb_purge(pcb);
  813491:	89 1c 24             	mov    %ebx,(%esp)
  813494:	e8 60 6f ff ff       	call   80a3f9 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  813499:	a1 dc a3 b3 00       	mov    0xb3a3dc,%eax
  81349e:	39 c3                	cmp    %eax,%ebx
  8134a0:	75 0a                	jne    8134ac <tcp_input+0xa9d>
  8134a2:	8b 43 0c             	mov    0xc(%ebx),%eax
  8134a5:	a3 dc a3 b3 00       	mov    %eax,0xb3a3dc
  8134aa:	eb 2c                	jmp    8134d8 <tcp_input+0xac9>
  8134ac:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  8134b1:	89 c1                	mov    %eax,%ecx
  8134b3:	85 c0                	test   %eax,%eax
  8134b5:	75 06                	jne    8134bd <tcp_input+0xaae>
  8134b7:	eb 1f                	jmp    8134d8 <tcp_input+0xac9>
  8134b9:	89 d1                	mov    %edx,%ecx
  8134bb:	89 d0                	mov    %edx,%eax
  8134bd:	8b 50 0c             	mov    0xc(%eax),%edx
  8134c0:	85 d2                	test   %edx,%edx
  8134c2:	0f 84 e4 02 00 00    	je     8137ac <tcp_input+0xd9d>
  8134c8:	39 d3                	cmp    %edx,%ebx
  8134ca:	75 ed                	jne    8134b9 <tcp_input+0xaaa>
  8134cc:	89 0d e4 a3 b3 00    	mov    %ecx,0xb3a3e4
  8134d2:	8b 53 0c             	mov    0xc(%ebx),%edx
  8134d5:	89 50 0c             	mov    %edx,0xc(%eax)
      pcb->state = TIME_WAIT;
  8134d8:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  8134df:	a1 e0 a3 b3 00       	mov    0xb3a3e0,%eax
  8134e4:	89 43 0c             	mov    %eax,0xc(%ebx)
  8134e7:	89 1d e0 a3 b3 00    	mov    %ebx,0xb3a3e0
  8134ed:	e8 2b 33 ff ff       	call   80681d <tcp_timer_needed>
  8134f2:	e9 c0 02 00 00       	jmp    8137b7 <tcp_input+0xda8>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  8134f7:	89 d8                	mov    %ebx,%eax
  8134f9:	e8 5f e8 ff ff       	call   811d5d <_ZL11tcp_receiveP7tcp_pcb>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8134fe:	f6 05 3c 14 b4 00 10 	testb  $0x10,0xb4143c
  813505:	0f 84 ac 02 00 00    	je     8137b7 <tcp_input+0xda8>
  81350b:	a1 38 14 b4 00       	mov    0xb41438,%eax
  813510:	39 43 54             	cmp    %eax,0x54(%ebx)
  813513:	0f 85 9e 02 00 00    	jne    8137b7 <tcp_input+0xda8>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  813519:	c6 05 58 14 b4 00 10 	movb   $0x10,0xb41458
  813520:	e9 92 02 00 00       	jmp    8137b7 <tcp_input+0xda8>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  813525:	c7 05 28 14 b4 00 00 	movl   $0x0,0xb41428
  81352c:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  81352f:	0f b6 05 58 14 b4 00 	movzbl 0xb41458,%eax
  813536:	a8 08                	test   $0x8,%al
  813538:	74 3f                	je     813579 <tcp_input+0xb6a>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  81353a:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  813540:	85 c0                	test   %eax,%eax
  813542:	74 10                	je     813554 <tcp_input+0xb45>
  813544:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  81354b:	ff 
  81354c:	8b 53 18             	mov    0x18(%ebx),%edx
  81354f:	89 14 24             	mov    %edx,(%esp)
  813552:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  813554:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  813558:	c7 04 24 dc a3 b3 00 	movl   $0xb3a3dc,(%esp)
  81355f:	e8 0e 6f ff ff       	call   80a472 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  813564:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  813568:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  81356f:	e8 cd 58 ff ff       	call   808e41 <memp_free>
  813574:	e9 ea 00 00 00       	jmp    813663 <tcp_input+0xc54>
      } else if (recv_flags & TF_CLOSED) {
  813579:	a8 10                	test   $0x10,%al
  81357b:	74 25                	je     8135a2 <tcp_input+0xb93>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81357d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  813581:	c7 04 24 dc a3 b3 00 	movl   $0xb3a3dc,(%esp)
  813588:	e8 e5 6e ff ff       	call   80a472 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  81358d:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  813591:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  813598:	e8 a4 58 ff ff       	call   808e41 <memp_free>
  81359d:	e9 c1 00 00 00       	jmp    813663 <tcp_input+0xc54>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  8135a2:	0f b7 53 6c          	movzwl 0x6c(%ebx),%edx
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
        memp_free(MEMP_TCP_PCB, pcb);
      } else {
        err = ERR_OK;
  8135a6:	b8 00 00 00 00       	mov    $0x0,%eax
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  8135ab:	66 85 d2             	test   %dx,%dx
  8135ae:	74 1d                	je     8135cd <tcp_input+0xbbe>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  8135b0:	8b 8b 84 00 00 00    	mov    0x84(%ebx),%ecx
  8135b6:	85 c9                	test   %ecx,%ecx
  8135b8:	74 13                	je     8135cd <tcp_input+0xbbe>
  8135ba:	0f b7 d2             	movzwl %dx,%edx
  8135bd:	89 54 24 08          	mov    %edx,0x8(%esp)
  8135c1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8135c5:	8b 43 18             	mov    0x18(%ebx),%eax
  8135c8:	89 04 24             	mov    %eax,(%esp)
  8135cb:	ff d1                	call   *%ecx
        }
      
        if (recv_data != NULL) {
  8135cd:	8b 15 54 14 b4 00    	mov    0xb41454,%edx
  8135d3:	85 d2                	test   %edx,%edx
  8135d5:	74 51                	je     813628 <tcp_input+0xc19>
          if(flags & TCP_PSH) {
  8135d7:	f6 05 3c 14 b4 00 08 	testb  $0x8,0xb4143c
  8135de:	74 04                	je     8135e4 <tcp_input+0xbd5>
            recv_data->flags |= PBUF_FLAG_PUSH;
  8135e0:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  8135e4:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  8135ea:	85 c0                	test   %eax,%eax
  8135ec:	74 1e                	je     81360c <tcp_input+0xbfd>
  8135ee:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8135f5:	00 
  8135f6:	89 54 24 08          	mov    %edx,0x8(%esp)
  8135fa:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8135fe:	8b 53 18             	mov    0x18(%ebx),%edx
  813601:	89 14 24             	mov    %edx,(%esp)
  813604:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  813606:	84 c0                	test   %al,%al
  813608:	75 12                	jne    81361c <tcp_input+0xc0d>
  81360a:	eb 1c                	jmp    813628 <tcp_input+0xc19>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  81360c:	89 14 24             	mov    %edx,(%esp)
  81360f:	90                   	nop
  813610:	e8 ee 5b ff ff       	call   809203 <pbuf_free>
  813615:	b8 00 00 00 00       	mov    $0x0,%eax
  81361a:	eb 0c                	jmp    813628 <tcp_input+0xc19>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  81361c:	8b 15 54 14 b4 00    	mov    0xb41454,%edx
  813622:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  813628:	f6 05 58 14 b4 00 20 	testb  $0x20,0xb41458
  81362f:	74 26                	je     813657 <tcp_input+0xc48>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  813631:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  813637:	85 c0                	test   %eax,%eax
  813639:	74 20                	je     81365b <tcp_input+0xc4c>
  81363b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  813642:	00 
  813643:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81364a:	00 
  81364b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  81364f:	8b 53 18             	mov    0x18(%ebx),%edx
  813652:	89 14 24             	mov    %edx,(%esp)
  813655:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  813657:	84 c0                	test   %al,%al
  813659:	75 08                	jne    813663 <tcp_input+0xc54>
          tcp_output(pcb);
  81365b:	89 1c 24             	mov    %ebx,(%esp)
  81365e:	e8 92 97 ff ff       	call   80cdf5 <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  813663:	a1 44 14 b4 00       	mov    0xb41444,%eax
  813668:	85 c0                	test   %eax,%eax
  81366a:	0f 84 56 01 00 00    	je     8137c6 <tcp_input+0xdb7>
    {
      pbuf_free(inseg.p);
  813670:	89 04 24             	mov    %eax,(%esp)
  813673:	e8 8b 5b ff ff       	call   809203 <pbuf_free>
      inseg.p = NULL;
  813678:	c7 05 44 14 b4 00 00 	movl   $0x0,0xb41444
  81367f:	00 00 00 
  813682:	e9 3f 01 00 00       	jmp    8137c6 <tcp_input+0xdb7>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  813687:	a1 30 14 b4 00       	mov    0xb41430,%eax
  81368c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  813690:	89 04 24             	mov    %eax,(%esp)
  813693:	e8 2e 8d ff ff       	call   80c3c6 <ntohs>
  813698:	a8 04                	test   $0x4,%al
  81369a:	75 46                	jne    8136e2 <tcp_input+0xcd3>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81369c:	8b 15 30 14 b4 00    	mov    0xb41430,%edx
  8136a2:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  8136a7:	0f b7 0a             	movzwl (%edx),%ecx
  8136aa:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  8136ae:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  8136b2:	89 54 24 10          	mov    %edx,0x10(%esp)
  8136b6:	8d 50 0c             	lea    0xc(%eax),%edx
  8136b9:	89 54 24 0c          	mov    %edx,0xc(%esp)
  8136bd:	83 c0 10             	add    $0x10,%eax
  8136c0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8136c4:	0f b7 05 3e 14 b4 00 	movzwl 0xb4143e,%eax
  8136cb:	03 05 34 14 b4 00    	add    0xb41434,%eax
  8136d1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8136d5:	a1 38 14 b4 00       	mov    0xb41438,%eax
  8136da:	89 04 24             	mov    %eax,(%esp)
  8136dd:	e8 ae 9b ff ff       	call   80d290 <tcp_rst>
    }
    pbuf_free(p);
  8136e2:	89 34 24             	mov    %esi,(%esp)
  8136e5:	e8 19 5b ff ff       	call   809203 <pbuf_free>
  8136ea:	e9 d7 00 00 00       	jmp    8137c6 <tcp_input+0xdb7>

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
      IP_PROTO_TCP, p->tot_len) != 0) {
  8136ef:	a1 2c 14 b4 00       	mov    0xb4142c,%eax
  8136f4:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  8136f8:	89 54 24 10          	mov    %edx,0x10(%esp)
  8136fc:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  813703:	00 
  813704:	8d 50 10             	lea    0x10(%eax),%edx
  813707:	89 54 24 08          	mov    %edx,0x8(%esp)
  81370b:	83 c0 0c             	add    $0xc,%eax
  81370e:	89 44 24 04          	mov    %eax,0x4(%esp)
  813712:	89 34 24             	mov    %esi,(%esp)
  813715:	e8 23 89 ff ff       	call   80c03d <inet_chksum_pseudo>
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  81371a:	66 85 c0             	test   %ax,%ax
  81371d:	0f 84 b8 f3 ff ff    	je     812adb <tcp_input+0xcc>
  813723:	e9 a6 f3 ff ff       	jmp    812ace <tcp_input+0xbf>
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  813728:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  81372d:	a1 34 14 b4 00       	mov    0xb41434,%eax
  813732:	8d 50 01             	lea    0x1(%eax),%edx
  813735:	89 53 24             	mov    %edx,0x24(%ebx)
      pcb->lastack = ackno;
  813738:	8b 15 38 14 b4 00    	mov    0xb41438,%edx
  81373e:	89 53 48             	mov    %edx,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  813741:	8b 15 30 14 b4 00    	mov    0xb41430,%edx
  813747:	0f b7 52 0e          	movzwl 0xe(%edx),%edx
  81374b:	66 89 53 5c          	mov    %dx,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  81374f:	83 e8 01             	sub    $0x1,%eax
  813752:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  813755:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81375c:	89 d8                	mov    %ebx,%eax
  81375e:	e8 4d e5 ff ff       	call   811cb0 <_ZL12tcp_parseoptP7tcp_pcb>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  813763:	8d 43 04             	lea    0x4(%ebx),%eax
  813766:	89 44 24 04          	mov    %eax,0x4(%esp)
  81376a:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  81376e:	89 04 24             	mov    %eax,(%esp)
  813771:	e8 bf 76 ff ff       	call   80ae35 <tcp_eff_send_mss>
  813776:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  81377a:	6b d0 0a             	imul   $0xa,%eax,%edx
  81377d:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  813781:	8d 14 00             	lea    (%eax,%eax,1),%edx
  813784:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  813789:	0f 44 c2             	cmove  %edx,%eax
  81378c:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  813790:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  813794:	66 85 c0             	test   %ax,%ax
  813797:	0f 85 73 f9 ff ff    	jne    813110 <tcp_input+0x701>
  81379d:	e9 52 f9 ff ff       	jmp    8130f4 <tcp_input+0x6e5>
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  8137a2:	a3 e4 a3 b3 00       	mov    %eax,0xb3a3e4
  8137a7:	e9 97 fc ff ff       	jmp    813443 <tcp_input+0xa34>
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  8137ac:	89 15 e4 a3 b3 00    	mov    %edx,0xb3a3e4
  8137b2:	e9 21 fd ff ff       	jmp    8134d8 <tcp_input+0xac9>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  8137b7:	c7 05 28 14 b4 00 00 	movl   $0x0,0xb41428
  8137be:	00 00 00 
  8137c1:	e9 69 fd ff ff       	jmp    81352f <tcp_input+0xb20>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  8137c6:	83 c4 4c             	add    $0x4c,%esp
  8137c9:	5b                   	pop    %ebx
  8137ca:	5e                   	pop    %esi
  8137cb:	5f                   	pop    %edi
  8137cc:	5d                   	pop    %ebp
  8137cd:	c3                   	ret    
	...

008137d0 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  8137d0:	55                   	push   %ebp
  8137d1:	89 e5                	mov    %esp,%ebp
  8137d3:	57                   	push   %edi
  8137d4:	56                   	push   %esi
  8137d5:	53                   	push   %ebx
  8137d6:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *) p->payload;
  8137d9:	8b 45 08             	mov    0x8(%ebp),%eax
  8137dc:	8b 40 04             	mov    0x4(%eax),%eax
  8137df:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  proto = IPH_PROTO(iphdr);
  8137e2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  8137e6:	89 04 24             	mov    %eax,(%esp)
  8137e9:	e8 d8 8b ff ff       	call   80c3c6 <ntohs>
  8137ee:	0f b6 f8             	movzbl %al,%edi

  prev = NULL;
  pcb = raw_pcbs;
  8137f1:	8b 1d 5c 14 b4 00    	mov    0xb4145c,%ebx
raw_input(struct pbuf *p, struct netif *inp)
{
  struct raw_pcb *pcb, *prev;
  struct ip_hdr *iphdr;
  s16_t proto;
  u8_t eaten = 0;
  8137f7:	b8 00 00 00 00       	mov    $0x0,%eax

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  8137fc:	85 db                	test   %ebx,%ebx
  8137fe:	74 6f                	je     81386f <raw_input+0x9f>
  LWIP_UNUSED_ARG(inp);

  iphdr = (struct ip_hdr *) p->payload;
  proto = IPH_PROTO(iphdr);

  prev = NULL;
  813800:	be 00 00 00 00       	mov    $0x0,%esi
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  813805:	0f bf ff             	movswl %di,%edi
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  813808:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  81380b:	83 c2 0c             	add    $0xc,%edx
  81380e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  813811:	eb 04                	jmp    813817 <raw_input+0x47>

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  813813:	89 de                	mov    %ebx,%esi
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  813815:	89 c3                	mov    %eax,%ebx
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  813817:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  81381b:	39 f8                	cmp    %edi,%eax
  81381d:	75 49                	jne    813868 <raw_input+0x98>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  81381f:	8b 43 14             	mov    0x14(%ebx),%eax
  813822:	85 c0                	test   %eax,%eax
  813824:	74 42                	je     813868 <raw_input+0x98>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  813826:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  813829:	89 54 24 0c          	mov    %edx,0xc(%esp)
  81382d:	8b 55 08             	mov    0x8(%ebp),%edx
  813830:	89 54 24 08          	mov    %edx,0x8(%esp)
  813834:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  813838:	8b 53 18             	mov    0x18(%ebx),%edx
  81383b:	89 14 24             	mov    %edx,(%esp)
  81383e:	ff d0                	call   *%eax
  813840:	84 c0                	test   %al,%al
  813842:	74 24                	je     813868 <raw_input+0x98>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  813844:	b8 01 00 00 00       	mov    $0x1,%eax
  813849:	85 f6                	test   %esi,%esi
  81384b:	74 22                	je     81386f <raw_input+0x9f>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  81384d:	8b 43 0c             	mov    0xc(%ebx),%eax
  813850:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  813853:	a1 5c 14 b4 00       	mov    0xb4145c,%eax
  813858:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  81385b:	89 1d 5c 14 b4 00    	mov    %ebx,0xb4145c
  813861:	b8 01 00 00 00       	mov    $0x1,%eax
  813866:	eb 07                	jmp    81386f <raw_input+0x9f>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  813868:	8b 43 0c             	mov    0xc(%ebx),%eax

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  81386b:	85 c0                	test   %eax,%eax
  81386d:	75 a4                	jne    813813 <raw_input+0x43>
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  81386f:	83 c4 2c             	add    $0x2c,%esp
  813872:	5b                   	pop    %ebx
  813873:	5e                   	pop    %esi
  813874:	5f                   	pop    %edi
  813875:	5d                   	pop    %ebp
  813876:	c3                   	ret    

00813877 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  813877:	55                   	push   %ebp
  813878:	89 e5                	mov    %esp,%ebp
  81387a:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  81387d:	b8 00 00 00 00       	mov    $0x0,%eax
  813882:	85 d2                	test   %edx,%edx
  813884:	74 02                	je     813888 <raw_bind+0x11>
  813886:	8b 02                	mov    (%edx),%eax
  813888:	8b 55 08             	mov    0x8(%ebp),%edx
  81388b:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  81388d:	b8 00 00 00 00       	mov    $0x0,%eax
  813892:	5d                   	pop    %ebp
  813893:	c3                   	ret    

00813894 <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  813894:	55                   	push   %ebp
  813895:	89 e5                	mov    %esp,%ebp
  813897:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  81389a:	b8 00 00 00 00       	mov    $0x0,%eax
  81389f:	85 d2                	test   %edx,%edx
  8138a1:	74 02                	je     8138a5 <raw_connect+0x11>
  8138a3:	8b 02                	mov    (%edx),%eax
  8138a5:	8b 55 08             	mov    0x8(%ebp),%edx
  8138a8:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  8138ab:	b8 00 00 00 00       	mov    $0x0,%eax
  8138b0:	5d                   	pop    %ebp
  8138b1:	c3                   	ret    

008138b2 <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  8138b2:	55                   	push   %ebp
  8138b3:	89 e5                	mov    %esp,%ebp
  8138b5:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  8138b8:	8b 55 0c             	mov    0xc(%ebp),%edx
  8138bb:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  8138be:	8b 55 10             	mov    0x10(%ebp),%edx
  8138c1:	89 50 18             	mov    %edx,0x18(%eax)
}
  8138c4:	5d                   	pop    %ebp
  8138c5:	c3                   	ret    

008138c6 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  8138c6:	55                   	push   %ebp
  8138c7:	89 e5                	mov    %esp,%ebp
  8138c9:	57                   	push   %edi
  8138ca:	56                   	push   %esi
  8138cb:	53                   	push   %ebx
  8138cc:	83 ec 3c             	sub    $0x3c,%esp
  8138cf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8138d2:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  8138d5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8138dc:	00 
  8138dd:	89 3c 24             	mov    %edi,(%esp)
  8138e0:	e8 2b 58 ff ff       	call   809110 <pbuf_header>
  8138e5:	84 c0                	test   %al,%al
  8138e7:	74 38                	je     813921 <raw_sendto+0x5b>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  8138e9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8138f0:	00 
  8138f1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8138f8:	00 
  8138f9:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  813900:	e8 20 5b ff ff       	call   809425 <pbuf_alloc>
  813905:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
  813907:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  81390b:	85 c0                	test   %eax,%eax
  81390d:	0f 84 b1 00 00 00    	je     8139c4 <raw_sendto+0xfe>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  813913:	89 7c 24 04          	mov    %edi,0x4(%esp)
  813917:	89 04 24             	mov    %eax,(%esp)
  81391a:	e8 86 5e ff ff       	call   8097a5 <pbuf_chain>
  81391f:	eb 32                	jmp    813953 <raw_sendto+0x8d>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  813921:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  813928:	ff 
  813929:	89 3c 24             	mov    %edi,(%esp)
  81392c:	e8 df 57 ff ff       	call   809110 <pbuf_header>
  813931:	84 c0                	test   %al,%al
  813933:	74 1c                	je     813951 <raw_sendto+0x8b>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  813935:	c7 44 24 08 e0 73 81 	movl   $0x8173e0,0x8(%esp)
  81393c:	00 
  81393d:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  813944:	00 
  813945:	c7 04 24 06 74 81 00 	movl   $0x817406,(%esp)
  81394c:	e8 67 d0 fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
    pbuf_chain(q, p);
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
  813951:	89 fe                	mov    %edi,%esi
      LWIP_ASSERT("Can't restore header we just removed!", 0);
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  813953:	8b 45 10             	mov    0x10(%ebp),%eax
  813956:	89 04 24             	mov    %eax,(%esp)
  813959:	e8 c2 76 ff ff       	call   80b020 <ip_route>
  81395e:	85 c0                	test   %eax,%eax
  813960:	75 16                	jne    813978 <raw_sendto+0xb2>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
      pbuf_free(q);
    }
    return ERR_RTE;
  813962:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  813966:	39 fe                	cmp    %edi,%esi
  813968:	74 5a                	je     8139c4 <raw_sendto+0xfe>
      pbuf_free(q);
  81396a:	89 34 24             	mov    %esi,(%esp)
  81396d:	e8 91 58 ff ff       	call   809203 <pbuf_free>
    }
    return ERR_RTE;
  813972:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  813976:	eb 4c                	jmp    8139c4 <raw_sendto+0xfe>
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  813978:	89 da                	mov    %ebx,%edx
  81397a:	85 db                	test   %ebx,%ebx
  81397c:	74 05                	je     813983 <raw_sendto+0xbd>
  81397e:	83 3b 00             	cmpl   $0x0,(%ebx)
  813981:	75 03                	jne    813986 <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  813983:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  813986:	89 44 24 18          	mov    %eax,0x18(%esp)
  81398a:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  81398e:	89 44 24 14          	mov    %eax,0x14(%esp)
  813992:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  813996:	89 44 24 10          	mov    %eax,0x10(%esp)
  81399a:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  81399e:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8139a2:	8b 45 10             	mov    0x10(%ebp),%eax
  8139a5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8139a9:	89 54 24 04          	mov    %edx,0x4(%esp)
  8139ad:	89 34 24             	mov    %esi,(%esp)
  8139b0:	e8 84 79 ff ff       	call   80b339 <ip_output_if>
  8139b5:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  8139b8:	39 fe                	cmp    %edi,%esi
  8139ba:	74 08                	je     8139c4 <raw_sendto+0xfe>
    /* free the header */
    pbuf_free(q);
  8139bc:	89 34 24             	mov    %esi,(%esp)
  8139bf:	e8 3f 58 ff ff       	call   809203 <pbuf_free>
  }
  return err;
}
  8139c4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  8139c8:	83 c4 3c             	add    $0x3c,%esp
  8139cb:	5b                   	pop    %ebx
  8139cc:	5e                   	pop    %esi
  8139cd:	5f                   	pop    %edi
  8139ce:	5d                   	pop    %ebp
  8139cf:	c3                   	ret    

008139d0 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  8139d0:	55                   	push   %ebp
  8139d1:	89 e5                	mov    %esp,%ebp
  8139d3:	83 ec 18             	sub    $0x18,%esp
  8139d6:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  8139d9:	8d 50 04             	lea    0x4(%eax),%edx
  8139dc:	89 54 24 08          	mov    %edx,0x8(%esp)
  8139e0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8139e3:	89 54 24 04          	mov    %edx,0x4(%esp)
  8139e7:	89 04 24             	mov    %eax,(%esp)
  8139ea:	e8 d7 fe ff ff       	call   8138c6 <raw_sendto>
}
  8139ef:	c9                   	leave  
  8139f0:	c3                   	ret    

008139f1 <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  8139f1:	55                   	push   %ebp
  8139f2:	89 e5                	mov    %esp,%ebp
  8139f4:	83 ec 18             	sub    $0x18,%esp
  8139f7:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  8139fa:	8b 15 5c 14 b4 00    	mov    0xb4145c,%edx
  813a00:	39 ca                	cmp    %ecx,%edx
  813a02:	74 06                	je     813a0a <raw_remove+0x19>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  813a04:	85 d2                	test   %edx,%edx
  813a06:	75 0e                	jne    813a16 <raw_remove+0x25>
  813a08:	eb 21                	jmp    813a2b <raw_remove+0x3a>
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  813a0a:	8b 42 0c             	mov    0xc(%edx),%eax
  813a0d:	a3 5c 14 b4 00       	mov    %eax,0xb4145c
  813a12:	eb 17                	jmp    813a2b <raw_remove+0x3a>
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  813a14:	89 c2                	mov    %eax,%edx
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  813a16:	8b 42 0c             	mov    0xc(%edx),%eax
  813a19:	85 c0                	test   %eax,%eax
  813a1b:	74 0e                	je     813a2b <raw_remove+0x3a>
  813a1d:	39 c1                	cmp    %eax,%ecx
  813a1f:	75 f3                	jne    813a14 <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  813a21:	8b 41 0c             	mov    0xc(%ecx),%eax
  813a24:	89 42 0c             	mov    %eax,0xc(%edx)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  813a27:	85 c0                	test   %eax,%eax
  813a29:	75 e9                	jne    813a14 <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  813a2b:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  813a2f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  813a36:	e8 06 54 ff ff       	call   808e41 <memp_free>
}
  813a3b:	c9                   	leave  
  813a3c:	c3                   	ret    

00813a3d <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  813a3d:	55                   	push   %ebp
  813a3e:	89 e5                	mov    %esp,%ebp
  813a40:	83 ec 18             	sub    $0x18,%esp
  813a43:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  813a46:	89 75 fc             	mov    %esi,-0x4(%ebp)
  813a49:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = (struct raw_pcb *) memp_malloc(MEMP_RAW_PCB);
  813a4d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  813a54:	e8 88 53 ff ff       	call   808de1 <memp_malloc>
  813a59:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  813a5b:	85 c0                	test   %eax,%eax
  813a5d:	74 2f                	je     813a8e <raw_new+0x51>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  813a5f:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  813a66:	00 
  813a67:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  813a6e:	00 
  813a6f:	89 04 24             	mov    %eax,(%esp)
  813a72:	e8 ba d7 fe ff       	call   801231 <memset>
    pcb->protocol = proto;
  813a77:	89 f0                	mov    %esi,%eax
  813a79:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  813a7c:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  813a80:	a1 5c 14 b4 00       	mov    0xb4145c,%eax
  813a85:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  813a88:	89 1d 5c 14 b4 00    	mov    %ebx,0xb4145c
  }
  return pcb;
}
  813a8e:	89 d8                	mov    %ebx,%eax
  813a90:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  813a93:	8b 75 fc             	mov    -0x4(%ebp),%esi
  813a96:	89 ec                	mov    %ebp,%esp
  813a98:	5d                   	pop    %ebp
  813a99:	c3                   	ret    
  813a9a:	00 00                	add    %al,(%eax)
  813a9c:	00 00                	add    %al,(%eax)
	...

00813aa0 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  813aa0:	55                   	push   %ebp
  813aa1:	89 e5                	mov    %esp,%ebp
  813aa3:	83 ec 48             	sub    $0x48,%esp
  813aa6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  813aa9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  813aac:	89 7d fc             	mov    %edi,-0x4(%ebp)
  813aaf:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = (struct ip_hdr *) p->payload;
  813ab2:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  813ab5:	0f b7 06             	movzwl (%esi),%eax
  813ab8:	89 04 24             	mov    %eax,(%esp)
  813abb:	e8 06 89 ff ff       	call   80c3c6 <ntohs>
  813ac0:	c1 e8 06             	shr    $0x6,%eax
  813ac3:	83 e0 3c             	and    $0x3c,%eax
  813ac6:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  813aca:	89 c7                	mov    %eax,%edi
  813acc:	f7 df                	neg    %edi
  813ace:	0f bf ff             	movswl %di,%edi
  813ad1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  813ad5:	89 1c 24             	mov    %ebx,(%esp)
  813ad8:	e8 33 56 ff ff       	call   809110 <pbuf_header>
  813add:	84 c0                	test   %al,%al
  813adf:	0f 85 e4 02 00 00    	jne    813dc9 <icmp_input+0x329>
  813ae5:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  813aea:	0f 86 d9 02 00 00    	jbe    813dc9 <icmp_input+0x329>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: short ICMP (%"U16_F" bytes) received\n", p->tot_len));
    goto lenerr;
  }

  type = *((u8_t *)p->payload);
  813af0:	8b 43 04             	mov    0x4(%ebx),%eax
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  813af3:	80 38 08             	cmpb   $0x8,(%eax)
  813af6:	0f 85 c3 02 00 00    	jne    813dbf <icmp_input+0x31f>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  813afc:	8b 45 0c             	mov    0xc(%ebp),%eax
  813aff:	89 44 24 04          	mov    %eax,0x4(%esp)
  813b03:	8d 46 10             	lea    0x10(%esi),%eax
  813b06:	89 04 24             	mov    %eax,(%esp)
  813b09:	e8 d2 74 ff ff       	call   80afe0 <ip_addr_isbroadcast>
  813b0e:	84 c0                	test   %al,%al
  813b10:	75 2f                	jne    813b41 <icmp_input+0xa1>
  813b12:	8b 56 10             	mov    0x10(%esi),%edx
  813b15:	89 55 e0             	mov    %edx,-0x20(%ebp)
  813b18:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  813b1f:	e8 15 8b ff ff       	call   80c639 <ntohl>
  813b24:	89 45 dc             	mov    %eax,-0x24(%ebp)
  813b27:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  813b2e:	e8 06 8b ff ff       	call   80c639 <ntohl>
  813b33:	8b 55 dc             	mov    -0x24(%ebp),%edx
  813b36:	23 55 e0             	and    -0x20(%ebp),%edx
  813b39:	39 c2                	cmp    %eax,%edx
  813b3b:	0f 85 a1 02 00 00    	jne    813de2 <icmp_input+0x342>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  813b41:	89 1c 24             	mov    %ebx,(%esp)
  813b44:	e8 ba 56 ff ff       	call   809203 <pbuf_free>
      return;
  813b49:	e9 a0 02 00 00       	jmp    813dee <icmp_input+0x34e>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  813b4e:	89 1c 24             	mov    %ebx,(%esp)
  813b51:	e8 2f 87 ff ff       	call   80c285 <inet_chksum_pbuf>
  813b56:	66 85 c0             	test   %ax,%ax
  813b59:	74 0d                	je     813b68 <icmp_input+0xc8>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  813b5b:	89 1c 24             	mov    %ebx,(%esp)
  813b5e:	e8 a0 56 ff ff       	call   809203 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  813b63:	e9 86 02 00 00       	jmp    813dee <icmp_input+0x34e>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  813b68:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  813b6f:	00 
  813b70:	89 1c 24             	mov    %ebx,(%esp)
  813b73:	e8 98 55 ff ff       	call   809110 <pbuf_header>
  813b78:	84 c0                	test   %al,%al
  813b7a:	0f 84 f0 00 00 00    	je     813c70 <icmp_input+0x1d0>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  813b80:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  813b84:	89 44 24 04          	mov    %eax,0x4(%esp)
  813b88:	89 1c 24             	mov    %ebx,(%esp)
  813b8b:	e8 80 55 ff ff       	call   809110 <pbuf_header>
  813b90:	84 c0                	test   %al,%al
  813b92:	74 1c                	je     813bb0 <icmp_input+0x110>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  813b94:	c7 44 24 08 1c 74 81 	movl   $0x81741c,0x8(%esp)
  813b9b:	00 
  813b9c:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  813ba3:	00 
  813ba4:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813bab:	e8 08 ce fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  813bb0:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  813bb7:	00 
  813bb8:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  813bbc:	89 44 24 04          	mov    %eax,0x4(%esp)
  813bc0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  813bc7:	e8 59 58 ff ff       	call   809425 <pbuf_alloc>
  813bcc:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  813bcf:	85 c0                	test   %eax,%eax
  813bd1:	0f 84 fc 01 00 00    	je     813dd3 <icmp_input+0x333>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  813bd7:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  813bdb:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  813bdf:	83 c0 08             	add    $0x8,%eax
  813be2:	39 c2                	cmp    %eax,%edx
  813be4:	73 1c                	jae    813c02 <icmp_input+0x162>
  813be6:	c7 44 24 08 50 74 81 	movl   $0x817450,0x8(%esp)
  813bed:	00 
  813bee:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  813bf5:	00 
  813bf6:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813bfd:	e8 b6 cd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  813c02:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  813c06:	8b 45 e0             	mov    -0x20(%ebp),%eax
  813c09:	89 04 24             	mov    %eax,(%esp)
  813c0c:	e8 6e 5c ff ff       	call   80987f <pbuf_copy>
  813c11:	84 c0                	test   %al,%al
  813c13:	74 1c                	je     813c31 <icmp_input+0x191>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  813c15:	c7 44 24 08 88 74 81 	movl   $0x817488,0x8(%esp)
  813c1c:	00 
  813c1d:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  813c24:	00 
  813c25:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813c2c:	e8 87 cd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
        goto memerr;
      }
      iphdr = (struct ip_hdr *) r->payload;
  813c31:	8b 55 e0             	mov    -0x20(%ebp),%edx
  813c34:	8b 72 04             	mov    0x4(%edx),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  813c37:	89 7c 24 04          	mov    %edi,0x4(%esp)
  813c3b:	89 14 24             	mov    %edx,(%esp)
  813c3e:	e8 cd 54 ff ff       	call   809110 <pbuf_header>
  813c43:	84 c0                	test   %al,%al
  813c45:	74 1c                	je     813c63 <icmp_input+0x1c3>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  813c47:	c7 44 24 08 b0 74 81 	movl   $0x8174b0,0x8(%esp)
  813c4e:	00 
  813c4f:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  813c56:	00 
  813c57:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813c5e:	e8 55 cd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  813c63:	89 1c 24             	mov    %ebx,(%esp)
  813c66:	e8 98 55 ff ff       	call   809203 <pbuf_free>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
  813c6b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  813c6e:	eb 30                	jmp    813ca0 <icmp_input+0x200>
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  813c70:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  813c77:	ff 
  813c78:	89 1c 24             	mov    %ebx,(%esp)
  813c7b:	e8 90 54 ff ff       	call   809110 <pbuf_header>
  813c80:	84 c0                	test   %al,%al
  813c82:	74 1c                	je     813ca0 <icmp_input+0x200>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  813c84:	c7 44 24 08 b0 74 81 	movl   $0x8174b0,0x8(%esp)
  813c8b:	00 
  813c8c:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  813c93:	00 
  813c94:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813c9b:	e8 18 cd fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = (struct icmp_echo_hdr *) p->payload;
  813ca0:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  813ca3:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  813ca6:	8b 56 10             	mov    0x10(%esi),%edx
  813ca9:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  813cac:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  813caf:	0f b7 07             	movzwl (%edi),%eax
  813cb2:	89 04 24             	mov    %eax,(%esp)
  813cb5:	e8 0c 87 ff ff       	call   80c3c6 <ntohs>
  813cba:	0f b6 c0             	movzbl %al,%eax
  813cbd:	89 04 24             	mov    %eax,(%esp)
  813cc0:	e8 f4 86 ff ff       	call   80c3b9 <htons>
  813cc5:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  813cc8:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  813ccc:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  813cd0:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  813cd7:	e8 dd 86 ff ff       	call   80c3b9 <htons>
  813cdc:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  813ce0:	72 22                	jb     813d04 <icmp_input+0x264>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  813ce2:	0f b7 57 02          	movzwl 0x2(%edi),%edx
  813ce6:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  813cea:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  813cf1:	e8 c3 86 ff ff       	call   80c3b9 <htons>
  813cf6:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  813cfa:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  813cfe:	66 89 47 02          	mov    %ax,0x2(%edi)
  813d02:	eb 1c                	jmp    813d20 <icmp_input+0x280>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  813d04:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  813d08:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  813d0c:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  813d13:	e8 a1 86 ff ff       	call   80c3b9 <htons>
  813d18:	66 03 45 e0          	add    -0x20(%ebp),%ax
  813d1c:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  813d20:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  813d24:	89 04 24             	mov    %eax,(%esp)
  813d27:	e8 9a 86 ff ff       	call   80c3c6 <ntohs>
  813d2c:	66 0d 00 ff          	or     $0xff00,%ax
  813d30:	0f b7 c0             	movzwl %ax,%eax
  813d33:	89 04 24             	mov    %eax,(%esp)
  813d36:	e8 7e 86 ff ff       	call   80c3b9 <htons>
  813d3b:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  813d3f:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  813d45:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  813d4c:	00 
  813d4d:	89 34 24             	mov    %esi,(%esp)
  813d50:	e8 1a 85 ff ff       	call   80c26f <inet_chksum>
  813d55:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  813d59:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  813d5d:	89 44 24 04          	mov    %eax,0x4(%esp)
  813d61:	89 1c 24             	mov    %ebx,(%esp)
  813d64:	e8 a7 53 ff ff       	call   809110 <pbuf_header>
  813d69:	84 c0                	test   %al,%al
  813d6b:	74 1c                	je     813d89 <icmp_input+0x2e9>
      LWIP_ASSERT("Can't move over header in packet", 0);
  813d6d:	c7 44 24 08 44 64 81 	movl   $0x816444,0x8(%esp)
  813d74:	00 
  813d75:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  813d7c:	00 
  813d7d:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813d84:	e8 2f cc fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
                   ICMP_TTL, 0, IP_PROTO_ICMP, inp);
  813d89:	8b 55 0c             	mov    0xc(%ebp),%edx
  813d8c:	89 54 24 18          	mov    %edx,0x18(%esp)
  813d90:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  813d97:	00 
  813d98:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  813d9f:	00 
  813da0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  813da7:	00 
  813da8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  813daf:	00 
  813db0:	83 c6 0c             	add    $0xc,%esi
  813db3:	89 74 24 04          	mov    %esi,0x4(%esp)
  813db7:	89 1c 24             	mov    %ebx,(%esp)
  813dba:	e8 7a 75 ff ff       	call   80b339 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  813dbf:	89 1c 24             	mov    %ebx,(%esp)
  813dc2:	e8 3c 54 ff ff       	call   809203 <pbuf_free>
  return;
  813dc7:	eb 25                	jmp    813dee <icmp_input+0x34e>
lenerr:
  pbuf_free(p);
  813dc9:	89 1c 24             	mov    %ebx,(%esp)
  813dcc:	e8 32 54 ff ff       	call   809203 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  813dd1:	eb 1b                	jmp    813dee <icmp_input+0x34e>
memerr:
  pbuf_free(p);
  813dd3:	89 1c 24             	mov    %ebx,(%esp)
  813dd6:	e8 28 54 ff ff       	call   809203 <pbuf_free>
  813ddb:	90                   	nop
  813ddc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  813de0:	eb 0c                	jmp    813dee <icmp_input+0x34e>
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
      return;
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  813de2:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  813de7:	76 e0                	jbe    813dc9 <icmp_input+0x329>
  813de9:	e9 60 fd ff ff       	jmp    813b4e <icmp_input+0xae>
memerr:
  pbuf_free(p);
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  813dee:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  813df1:	8b 75 f8             	mov    -0x8(%ebp),%esi
  813df4:	8b 7d fc             	mov    -0x4(%ebp),%edi
  813df7:	89 ec                	mov    %ebp,%esp
  813df9:	5d                   	pop    %ebp
  813dfa:	c3                   	ret    

00813dfb <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  813dfb:	55                   	push   %ebp
  813dfc:	89 e5                	mov    %esp,%ebp
  813dfe:	57                   	push   %edi
  813dff:	56                   	push   %esi
  813e00:	53                   	push   %ebx
  813e01:	83 ec 3c             	sub    $0x3c,%esp
  813e04:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  813e07:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  813e0e:	00 
  813e0f:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  813e16:	00 
  813e17:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  813e1e:	e8 02 56 ff ff       	call   809425 <pbuf_alloc>
  813e23:	89 c3                	mov    %eax,%ebx
  if (q == NULL) {
  813e25:	85 c0                	test   %eax,%eax
  813e27:	0f 84 d8 00 00 00    	je     813f05 <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  813e2d:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  813e32:	77 1c                	ja     813e50 <icmp_dest_unreach+0x55>
  813e34:	c7 44 24 08 e4 74 81 	movl   $0x8174e4,0x8(%esp)
  813e3b:	00 
  813e3c:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  813e43:	00 
  813e44:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813e4b:	e8 68 cb fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *) p->payload;
  813e50:	8b 47 04             	mov    0x4(%edi),%eax
  813e53:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = (struct icmp_dur_hdr *) q->payload;
  813e56:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  813e59:	0f b7 06             	movzwl (%esi),%eax
  813e5c:	89 04 24             	mov    %eax,(%esp)
  813e5f:	e8 62 85 ff ff       	call   80c3c6 <ntohs>
  813e64:	0f b6 c0             	movzbl %al,%eax
  813e67:	80 cc 03             	or     $0x3,%ah
  813e6a:	89 04 24             	mov    %eax,(%esp)
  813e6d:	e8 47 85 ff ff       	call   80c3b9 <htons>
  813e72:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  813e75:	0f b7 c0             	movzwl %ax,%eax
  813e78:	89 04 24             	mov    %eax,(%esp)
  813e7b:	e8 46 85 ff ff       	call   80c3c6 <ntohs>
  813e80:	b0 00                	mov    $0x0,%al
  813e82:	66 0b 45 0c          	or     0xc(%ebp),%ax
  813e86:	0f b7 c0             	movzwl %ax,%eax
  813e89:	89 04 24             	mov    %eax,(%esp)
  813e8c:	e8 28 85 ff ff       	call   80c3b9 <htons>
  813e91:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
  813e94:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  813e9b:	00 
  813e9c:	8b 47 04             	mov    0x4(%edi),%eax
  813e9f:	89 44 24 04          	mov    %eax,0x4(%esp)

  idur = (struct icmp_dur_hdr *) q->payload;
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  ICMPH_CODE_SET(idur, t);

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  813ea3:	8b 43 04             	mov    0x4(%ebx),%eax
  813ea6:	83 c0 08             	add    $0x8,%eax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
  813ea9:	89 04 24             	mov    %eax,(%esp)
  813eac:	e8 56 d4 fe ff       	call   801307 <memcpy>

  /* calculate checksum */
  idur->chksum = 0;
  813eb1:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  813eb7:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  813ebb:	89 44 24 04          	mov    %eax,0x4(%esp)
  813ebf:	89 34 24             	mov    %esi,(%esp)
  813ec2:	e8 a8 83 ff ff       	call   80c26f <inet_chksum>
  813ec7:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  813ecb:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  813ed2:	00 
  813ed3:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  813eda:	00 
  813edb:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  813ee2:	00 
  813ee3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  813ee6:	83 c0 0c             	add    $0xc,%eax
  813ee9:	89 44 24 08          	mov    %eax,0x8(%esp)
  813eed:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  813ef4:	00 
  813ef5:	89 1c 24             	mov    %ebx,(%esp)
  813ef8:	e8 ec 75 ff ff       	call   80b4e9 <ip_output>
  pbuf_free(q);
  813efd:	89 1c 24             	mov    %ebx,(%esp)
  813f00:	e8 fe 52 ff ff       	call   809203 <pbuf_free>
}
  813f05:	83 c4 3c             	add    $0x3c,%esp
  813f08:	5b                   	pop    %ebx
  813f09:	5e                   	pop    %esi
  813f0a:	5f                   	pop    %edi
  813f0b:	5d                   	pop    %ebp
  813f0c:	c3                   	ret    

00813f0d <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  813f0d:	55                   	push   %ebp
  813f0e:	89 e5                	mov    %esp,%ebp
  813f10:	57                   	push   %edi
  813f11:	56                   	push   %esi
  813f12:	53                   	push   %ebx
  813f13:	83 ec 3c             	sub    $0x3c,%esp
  813f16:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
                 PBUF_RAM);
  813f19:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  813f20:	00 
  813f21:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  813f28:	00 
  813f29:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  813f30:	e8 f0 54 ff ff       	call   809425 <pbuf_alloc>
  813f35:	89 c3                	mov    %eax,%ebx
  if (q == NULL) {
  813f37:	85 c0                	test   %eax,%eax
  813f39:	0f 84 d8 00 00 00    	je     814017 <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  813f3f:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  813f44:	77 1c                	ja     813f62 <icmp_time_exceeded+0x55>
  813f46:	c7 44 24 08 e4 74 81 	movl   $0x8174e4,0x8(%esp)
  813f4d:	00 
  813f4e:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  813f55:	00 
  813f56:	c7 04 24 10 75 81 00 	movl   $0x817510,(%esp)
  813f5d:	e8 56 ca fe ff       	call   8009b8 <_Z6_panicPKciS0_z>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = (struct ip_hdr *) p->payload;
  813f62:	8b 47 04             	mov    0x4(%edi),%eax
  813f65:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = (struct icmp_te_hdr *) q->payload;
  813f68:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  813f6b:	0f b7 06             	movzwl (%esi),%eax
  813f6e:	89 04 24             	mov    %eax,(%esp)
  813f71:	e8 50 84 ff ff       	call   80c3c6 <ntohs>
  813f76:	0f b6 c0             	movzbl %al,%eax
  813f79:	80 cc 0b             	or     $0xb,%ah
  813f7c:	89 04 24             	mov    %eax,(%esp)
  813f7f:	e8 35 84 ff ff       	call   80c3b9 <htons>
  813f84:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  813f87:	0f b7 c0             	movzwl %ax,%eax
  813f8a:	89 04 24             	mov    %eax,(%esp)
  813f8d:	e8 34 84 ff ff       	call   80c3c6 <ntohs>
  813f92:	b0 00                	mov    $0x0,%al
  813f94:	66 0b 45 0c          	or     0xc(%ebp),%ax
  813f98:	0f b7 c0             	movzwl %ax,%eax
  813f9b:	89 04 24             	mov    %eax,(%esp)
  813f9e:	e8 16 84 ff ff       	call   80c3b9 <htons>
  813fa3:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
  813fa6:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  813fad:	00 
  813fae:	8b 47 04             	mov    0x4(%edi),%eax
  813fb1:	89 44 24 04          	mov    %eax,0x4(%esp)
  tehdr = (struct icmp_te_hdr *) q->payload;
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  ICMPH_CODE_SET(tehdr, t);

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  813fb5:	8b 43 04             	mov    0x4(%ebx),%eax
  813fb8:	83 c0 08             	add    $0x8,%eax
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);
  813fbb:	89 04 24             	mov    %eax,(%esp)
  813fbe:	e8 44 d3 fe ff       	call   801307 <memcpy>

  /* calculate checksum */
  tehdr->chksum = 0;
  813fc3:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  813fc9:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  813fcd:	89 44 24 04          	mov    %eax,0x4(%esp)
  813fd1:	89 34 24             	mov    %esi,(%esp)
  813fd4:	e8 96 82 ff ff       	call   80c26f <inet_chksum>
  813fd9:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  813fdd:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  813fe4:	00 
  813fe5:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  813fec:	00 
  813fed:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  813ff4:	00 
  813ff5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  813ff8:	83 c0 0c             	add    $0xc,%eax
  813ffb:	89 44 24 08          	mov    %eax,0x8(%esp)
  813fff:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  814006:	00 
  814007:	89 1c 24             	mov    %ebx,(%esp)
  81400a:	e8 da 74 ff ff       	call   80b4e9 <ip_output>
  pbuf_free(q);
  81400f:	89 1c 24             	mov    %ebx,(%esp)
  814012:	e8 ec 51 ff ff       	call   809203 <pbuf_free>
}
  814017:	83 c4 3c             	add    $0x3c,%esp
  81401a:	5b                   	pop    %ebx
  81401b:	5e                   	pop    %esi
  81401c:	5f                   	pop    %edi
  81401d:	5d                   	pop    %ebp
  81401e:	c3                   	ret    
	...

00814020 <__udivdi3>:
  814020:	55                   	push   %ebp
  814021:	89 e5                	mov    %esp,%ebp
  814023:	57                   	push   %edi
  814024:	56                   	push   %esi
  814025:	83 ec 20             	sub    $0x20,%esp
  814028:	8b 45 14             	mov    0x14(%ebp),%eax
  81402b:	8b 75 08             	mov    0x8(%ebp),%esi
  81402e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  814031:	8b 7d 0c             	mov    0xc(%ebp),%edi
  814034:	85 c0                	test   %eax,%eax
  814036:	89 75 e8             	mov    %esi,-0x18(%ebp)
  814039:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  81403c:	75 3a                	jne    814078 <__udivdi3+0x58>
  81403e:	39 f9                	cmp    %edi,%ecx
  814040:	77 66                	ja     8140a8 <__udivdi3+0x88>
  814042:	85 c9                	test   %ecx,%ecx
  814044:	75 0b                	jne    814051 <__udivdi3+0x31>
  814046:	b8 01 00 00 00       	mov    $0x1,%eax
  81404b:	31 d2                	xor    %edx,%edx
  81404d:	f7 f1                	div    %ecx
  81404f:	89 c1                	mov    %eax,%ecx
  814051:	89 f8                	mov    %edi,%eax
  814053:	31 d2                	xor    %edx,%edx
  814055:	f7 f1                	div    %ecx
  814057:	89 c7                	mov    %eax,%edi
  814059:	89 f0                	mov    %esi,%eax
  81405b:	f7 f1                	div    %ecx
  81405d:	89 fa                	mov    %edi,%edx
  81405f:	89 c6                	mov    %eax,%esi
  814061:	89 75 f0             	mov    %esi,-0x10(%ebp)
  814064:	89 55 f4             	mov    %edx,-0xc(%ebp)
  814067:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81406a:	8b 55 f4             	mov    -0xc(%ebp),%edx
  81406d:	83 c4 20             	add    $0x20,%esp
  814070:	5e                   	pop    %esi
  814071:	5f                   	pop    %edi
  814072:	5d                   	pop    %ebp
  814073:	c3                   	ret    
  814074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  814078:	31 d2                	xor    %edx,%edx
  81407a:	31 f6                	xor    %esi,%esi
  81407c:	39 f8                	cmp    %edi,%eax
  81407e:	77 e1                	ja     814061 <__udivdi3+0x41>
  814080:	0f bd d0             	bsr    %eax,%edx
  814083:	83 f2 1f             	xor    $0x1f,%edx
  814086:	89 55 ec             	mov    %edx,-0x14(%ebp)
  814089:	75 2d                	jne    8140b8 <__udivdi3+0x98>
  81408b:	8b 4d e8             	mov    -0x18(%ebp),%ecx
  81408e:	39 4d f0             	cmp    %ecx,-0x10(%ebp)
  814091:	76 06                	jbe    814099 <__udivdi3+0x79>
  814093:	39 f8                	cmp    %edi,%eax
  814095:	89 f2                	mov    %esi,%edx
  814097:	73 c8                	jae    814061 <__udivdi3+0x41>
  814099:	31 d2                	xor    %edx,%edx
  81409b:	be 01 00 00 00       	mov    $0x1,%esi
  8140a0:	eb bf                	jmp    814061 <__udivdi3+0x41>
  8140a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8140a8:	89 f0                	mov    %esi,%eax
  8140aa:	89 fa                	mov    %edi,%edx
  8140ac:	f7 f1                	div    %ecx
  8140ae:	31 d2                	xor    %edx,%edx
  8140b0:	89 c6                	mov    %eax,%esi
  8140b2:	eb ad                	jmp    814061 <__udivdi3+0x41>
  8140b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8140b8:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8140bc:	89 c2                	mov    %eax,%edx
  8140be:	b8 20 00 00 00       	mov    $0x20,%eax
  8140c3:	8b 75 f0             	mov    -0x10(%ebp),%esi
  8140c6:	2b 45 ec             	sub    -0x14(%ebp),%eax
  8140c9:	d3 e2                	shl    %cl,%edx
  8140cb:	89 c1                	mov    %eax,%ecx
  8140cd:	d3 ee                	shr    %cl,%esi
  8140cf:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8140d3:	09 d6                	or     %edx,%esi
  8140d5:	89 fa                	mov    %edi,%edx
  8140d7:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  8140da:	8b 75 f0             	mov    -0x10(%ebp),%esi
  8140dd:	d3 e6                	shl    %cl,%esi
  8140df:	89 c1                	mov    %eax,%ecx
  8140e1:	d3 ea                	shr    %cl,%edx
  8140e3:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8140e7:	89 75 f0             	mov    %esi,-0x10(%ebp)
  8140ea:	8b 75 e8             	mov    -0x18(%ebp),%esi
  8140ed:	d3 e7                	shl    %cl,%edi
  8140ef:	89 c1                	mov    %eax,%ecx
  8140f1:	d3 ee                	shr    %cl,%esi
  8140f3:	09 fe                	or     %edi,%esi
  8140f5:	89 f0                	mov    %esi,%eax
  8140f7:	f7 75 e4             	divl   -0x1c(%ebp)
  8140fa:	89 d7                	mov    %edx,%edi
  8140fc:	89 c6                	mov    %eax,%esi
  8140fe:	f7 65 f0             	mull   -0x10(%ebp)
  814101:	39 d7                	cmp    %edx,%edi
  814103:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  814106:	72 12                	jb     81411a <__udivdi3+0xfa>
  814108:	8b 55 e8             	mov    -0x18(%ebp),%edx
  81410b:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  81410f:	d3 e2                	shl    %cl,%edx
  814111:	39 c2                	cmp    %eax,%edx
  814113:	73 08                	jae    81411d <__udivdi3+0xfd>
  814115:	3b 7d e4             	cmp    -0x1c(%ebp),%edi
  814118:	75 03                	jne    81411d <__udivdi3+0xfd>
  81411a:	83 ee 01             	sub    $0x1,%esi
  81411d:	31 d2                	xor    %edx,%edx
  81411f:	e9 3d ff ff ff       	jmp    814061 <__udivdi3+0x41>
	...

00814130 <__umoddi3>:
  814130:	55                   	push   %ebp
  814131:	89 e5                	mov    %esp,%ebp
  814133:	57                   	push   %edi
  814134:	56                   	push   %esi
  814135:	83 ec 20             	sub    $0x20,%esp
  814138:	8b 7d 14             	mov    0x14(%ebp),%edi
  81413b:	8b 45 08             	mov    0x8(%ebp),%eax
  81413e:	8b 4d 10             	mov    0x10(%ebp),%ecx
  814141:	8b 75 0c             	mov    0xc(%ebp),%esi
  814144:	85 ff                	test   %edi,%edi
  814146:	89 45 e8             	mov    %eax,-0x18(%ebp)
  814149:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  81414c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  81414f:	89 f2                	mov    %esi,%edx
  814151:	75 15                	jne    814168 <__umoddi3+0x38>
  814153:	39 f1                	cmp    %esi,%ecx
  814155:	76 41                	jbe    814198 <__umoddi3+0x68>
  814157:	f7 f1                	div    %ecx
  814159:	89 d0                	mov    %edx,%eax
  81415b:	31 d2                	xor    %edx,%edx
  81415d:	83 c4 20             	add    $0x20,%esp
  814160:	5e                   	pop    %esi
  814161:	5f                   	pop    %edi
  814162:	5d                   	pop    %ebp
  814163:	c3                   	ret    
  814164:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  814168:	39 f7                	cmp    %esi,%edi
  81416a:	77 4c                	ja     8141b8 <__umoddi3+0x88>
  81416c:	0f bd c7             	bsr    %edi,%eax
  81416f:	83 f0 1f             	xor    $0x1f,%eax
  814172:	89 45 ec             	mov    %eax,-0x14(%ebp)
  814175:	75 51                	jne    8141c8 <__umoddi3+0x98>
  814177:	3b 4d f0             	cmp    -0x10(%ebp),%ecx
  81417a:	0f 87 e8 00 00 00    	ja     814268 <__umoddi3+0x138>
  814180:	89 f2                	mov    %esi,%edx
  814182:	8b 75 f0             	mov    -0x10(%ebp),%esi
  814185:	29 ce                	sub    %ecx,%esi
  814187:	19 fa                	sbb    %edi,%edx
  814189:	89 75 f0             	mov    %esi,-0x10(%ebp)
  81418c:	8b 45 f0             	mov    -0x10(%ebp),%eax
  81418f:	83 c4 20             	add    $0x20,%esp
  814192:	5e                   	pop    %esi
  814193:	5f                   	pop    %edi
  814194:	5d                   	pop    %ebp
  814195:	c3                   	ret    
  814196:	66 90                	xchg   %ax,%ax
  814198:	85 c9                	test   %ecx,%ecx
  81419a:	75 0b                	jne    8141a7 <__umoddi3+0x77>
  81419c:	b8 01 00 00 00       	mov    $0x1,%eax
  8141a1:	31 d2                	xor    %edx,%edx
  8141a3:	f7 f1                	div    %ecx
  8141a5:	89 c1                	mov    %eax,%ecx
  8141a7:	89 f0                	mov    %esi,%eax
  8141a9:	31 d2                	xor    %edx,%edx
  8141ab:	f7 f1                	div    %ecx
  8141ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8141b0:	eb a5                	jmp    814157 <__umoddi3+0x27>
  8141b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8141b8:	89 f2                	mov    %esi,%edx
  8141ba:	83 c4 20             	add    $0x20,%esp
  8141bd:	5e                   	pop    %esi
  8141be:	5f                   	pop    %edi
  8141bf:	5d                   	pop    %ebp
  8141c0:	c3                   	ret    
  8141c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8141c8:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8141cc:	89 f2                	mov    %esi,%edx
  8141ce:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8141d1:	c7 45 f0 20 00 00 00 	movl   $0x20,-0x10(%ebp)
  8141d8:	29 45 f0             	sub    %eax,-0x10(%ebp)
  8141db:	d3 e7                	shl    %cl,%edi
  8141dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8141e0:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8141e4:	d3 e8                	shr    %cl,%eax
  8141e6:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  8141ea:	09 f8                	or     %edi,%eax
  8141ec:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8141ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8141f2:	d3 e0                	shl    %cl,%eax
  8141f4:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  8141f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8141fb:	8b 45 e8             	mov    -0x18(%ebp),%eax
  8141fe:	d3 ea                	shr    %cl,%edx
  814200:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  814204:	d3 e6                	shl    %cl,%esi
  814206:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  81420a:	d3 e8                	shr    %cl,%eax
  81420c:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  814210:	09 f0                	or     %esi,%eax
  814212:	8b 75 e8             	mov    -0x18(%ebp),%esi
  814215:	f7 75 e4             	divl   -0x1c(%ebp)
  814218:	d3 e6                	shl    %cl,%esi
  81421a:	89 75 e8             	mov    %esi,-0x18(%ebp)
  81421d:	89 d6                	mov    %edx,%esi
  81421f:	f7 65 f4             	mull   -0xc(%ebp)
  814222:	89 d7                	mov    %edx,%edi
  814224:	89 c2                	mov    %eax,%edx
  814226:	39 fe                	cmp    %edi,%esi
  814228:	89 f9                	mov    %edi,%ecx
  81422a:	72 30                	jb     81425c <__umoddi3+0x12c>
  81422c:	39 45 e8             	cmp    %eax,-0x18(%ebp)
  81422f:	72 27                	jb     814258 <__umoddi3+0x128>
  814231:	8b 45 e8             	mov    -0x18(%ebp),%eax
  814234:	29 d0                	sub    %edx,%eax
  814236:	19 ce                	sbb    %ecx,%esi
  814238:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  81423c:	89 f2                	mov    %esi,%edx
  81423e:	d3 e8                	shr    %cl,%eax
  814240:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  814244:	d3 e2                	shl    %cl,%edx
  814246:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  81424a:	09 d0                	or     %edx,%eax
  81424c:	89 f2                	mov    %esi,%edx
  81424e:	d3 ea                	shr    %cl,%edx
  814250:	83 c4 20             	add    $0x20,%esp
  814253:	5e                   	pop    %esi
  814254:	5f                   	pop    %edi
  814255:	5d                   	pop    %ebp
  814256:	c3                   	ret    
  814257:	90                   	nop
  814258:	39 fe                	cmp    %edi,%esi
  81425a:	75 d5                	jne    814231 <__umoddi3+0x101>
  81425c:	89 f9                	mov    %edi,%ecx
  81425e:	89 c2                	mov    %eax,%edx
  814260:	2b 55 f4             	sub    -0xc(%ebp),%edx
  814263:	1b 4d e4             	sbb    -0x1c(%ebp),%ecx
  814266:	eb c9                	jmp    814231 <__umoddi3+0x101>
  814268:	39 f7                	cmp    %esi,%edi
  81426a:	0f 82 10 ff ff ff    	jb     814180 <__umoddi3+0x50>
  814270:	e9 17 ff ff ff       	jmp    81418c <__umoddi3+0x5c>
